<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lucene.Net</name>
    </assembly>
    <members>
        <member name="T:Lucene.Net.Analysis.Analyzer">
            <summary>
            An <see cref="T:Lucene.Net.Analysis.Analyzer"/> builds <see cref="T:Lucene.Net.Analysis.TokenStream"/>s, which analyze text.  It thus represents a
            policy for extracting index terms from text.
            <para/>
            In order to define what analysis is done, subclasses must define their
            <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> in <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/>.
            The components are then reused in each call to <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>.
            <para/>
            Simple example:
            <code>
            Analyzer analyzer = Analyzer.NewAnonymous(createComponents: (fieldName, reader) => 
            {
                Tokenizer source = new FooTokenizer(reader);
                TokenStream filter = new FooFilter(source);
                filter = new BarFilter(filter);
                return new TokenStreamComponents(source, filter);
            });
            </code>
            For more examples, see the <see cref="N:Lucene.Net.Analysis"/> namespace documentation.
            <para/>
            For some concrete implementations bundled with Lucene, look in the analysis modules:
            <list type="bullet">
              <item><description>Common:
                  Analyzers for indexing content in different languages and domains.</description></item>
              <item><description>ICU:
                  Exposes functionality from ICU to Apache Lucene.</description></item>
              <item><description>Kuromoji:
                  Morphological analyzer for Japanese text.</description></item>
              <item><description>Morfologik:
                  Dictionary-driven lemmatization for the Polish language.</description></item>
              <item><description>Phonetic:
                  Analysis for indexing phonetic signatures (for sounds-alike search).</description></item>
              <item><description>Smart Chinese:
                  Analyzer for Simplified Chinese, which indexes words.</description></item>
              <item><description>Stempel:
                  Algorithmic Stemmer for the Polish Language.</description></item>
              <item><description>UIMA:
                  Analysis integration with Apache UIMA.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.#ctor">
            <summary>
            Create a new <see cref="T:Lucene.Net.Analysis.Analyzer"/>, reusing the same set of components per-thread
            across calls to <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.#ctor(Lucene.Net.Analysis.ReuseStrategy)">
            <summary>
            Expert: create a new Analyzer with a custom <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/>.
            <para/>
            NOTE: if you just want to reuse on a per-field basis, its easier to
            use a subclass of <see cref="T:Lucene.Net.Analysis.AnalyzerWrapper"/> such as
            <c>Lucene.Net.Analysis.Common.Miscellaneous.PerFieldAnalyzerWrapper</c>
            instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.NewAnonymous(System.Func{System.String,System.IO.TextReader,Lucene.Net.Analysis.TokenStreamComponents})">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/>
            method through the <paramref name="createComponents"/> parameter.
            Simple example: 
            <code>
                var analyzer = Analyzer.NewAnonymous(createComponents: (fieldName, reader) => 
                {
                    Tokenizer source = new FooTokenizer(reader);
                    TokenStream filter = new FooFilter(source);
                    filter = new BarFilter(filter);
                    return new TokenStreamComponents(source, filter);
                });
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="createComponents">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/> 
            method. It accepts a <see cref="T:System.String"/> fieldName and a <see cref="T:System.IO.TextReader"/> reader and 
            returns the <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for this analyzer.
            </param>
            <returns> A new <see cref="T:Lucene.Net.Analysis.Analyzer.AnonymousAnalyzer"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.NewAnonymous(System.Func{System.String,System.IO.TextReader,Lucene.Net.Analysis.TokenStreamComponents},Lucene.Net.Analysis.ReuseStrategy)">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/>
            method through the <paramref name="createComponents"/> parameter and allows the use of a <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/>.
            Simple example: 
            <code>
                var analyzer = Analyzer.NewAnonymous(createComponents: (fieldName, reader) => 
                {
                    Tokenizer source = new FooTokenizer(reader);
                    TokenStream filter = new FooFilter(source);
                    filter = new BarFilter(filter);
                    return new TokenStreamComponents(source, filter);
                }, reuseStrategy);
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="createComponents">
            An delegate method that represents (is called by) the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/> 
            method. It accepts a <see cref="T:System.String"/> fieldName and a <see cref="T:System.IO.TextReader"/> reader and 
            returns the <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for this analyzer.
            </param>
            <param name="reuseStrategy">A custom <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/> instance.</param>
            <returns> A new <see cref="T:Lucene.Net.Analysis.Analyzer.AnonymousAnalyzer"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.NewAnonymous(System.Func{System.String,System.IO.TextReader,Lucene.Net.Analysis.TokenStreamComponents},System.Func{System.String,System.IO.TextReader,System.IO.TextReader})">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/>
            method through the <paramref name="createComponents"/> parameter and the body of the <see cref="M:Lucene.Net.Analysis.Analyzer.InitReader(System.String,System.IO.TextReader)"/>
            method through the <paramref name="initReader"/> parameter.
            Simple example: 
            <code>
                var analyzer = Analyzer.NewAnonymous(createComponents: (fieldName, reader) => 
                {
                    Tokenizer source = new FooTokenizer(reader);
                    TokenStream filter = new FooFilter(source);
                    filter = new BarFilter(filter);
                    return new TokenStreamComponents(source, filter);
                }, initReader: (fieldName, reader) => 
                {
                    return new HTMLStripCharFilter(reader);
                });
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="createComponents">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/> 
            method. It accepts a <see cref="T:System.String"/> fieldName and a <see cref="T:System.IO.TextReader"/> reader and 
            returns the <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for this analyzer.
            </param>
            <param name="initReader">A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Analysis.Analyzer.InitReader(System.String,System.IO.TextReader)"/>
            method. It accepts a <see cref="T:System.String"/> fieldName and a <see cref="T:System.IO.TextReader"/> reader and 
            returns the <see cref="T:System.IO.TextReader"/> that can be modified or wrapped by the <paramref name="initReader"/> method.</param>
            <returns> A new <see cref="T:Lucene.Net.Analysis.Analyzer.AnonymousAnalyzer"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.NewAnonymous(System.Func{System.String,System.IO.TextReader,Lucene.Net.Analysis.TokenStreamComponents},System.Func{System.String,System.IO.TextReader,System.IO.TextReader},Lucene.Net.Analysis.ReuseStrategy)">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/>
            method through the <paramref name="createComponents"/> parameter, the body of the <see cref="M:Lucene.Net.Analysis.Analyzer.InitReader(System.String,System.IO.TextReader)"/>
            method through the <paramref name="initReader"/> parameter, and allows the use of a <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/>.
            Simple example: 
            <code>
                var analyzer = Analyzer.NewAnonymous(createComponents: (fieldName, reader) => 
                {
                    Tokenizer source = new FooTokenizer(reader);
                    TokenStream filter = new FooFilter(source);
                    filter = new BarFilter(filter);
                    return new TokenStreamComponents(source, filter);
                }, initReader: (fieldName, reader) => 
                {
                    return new HTMLStripCharFilter(reader);
                }, reuseStrategy);
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="createComponents">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/> 
            method. It accepts a <see cref="T:System.String"/> fieldName and a <see cref="T:System.IO.TextReader"/> reader and 
            returns the <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for this analyzer.
            </param>
            <param name="initReader">A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Analysis.Analyzer.InitReader(System.String,System.IO.TextReader)"/>
            method. It accepts a <see cref="T:System.String"/> fieldName and a <see cref="T:System.IO.TextReader"/> reader and 
            returns the <see cref="T:System.IO.TextReader"/> that can be modified or wrapped by the <paramref name="initReader"/> method.</param>
            <param name="reuseStrategy">A custom <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/> instance.</param>
            <returns> A new <see cref="T:Lucene.Net.Analysis.Analyzer.AnonymousAnalyzer"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> instance for this analyzer.
            </summary>
            <param name="fieldName">
                     the name of the fields content passed to the
                     <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> sink as a reader </param>
            <param name="reader">
                     the reader passed to the <see cref="T:Lucene.Net.Analysis.Tokenizer"/> constructor </param>
            <returns> the <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for this analyzer. </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Analysis.TokenStream"/> suitable for <paramref name="fieldName"/>, tokenizing
            the contents of <c>text</c>.
            <para/>
            This method uses <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/> to obtain an
            instance of <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/>. It returns the sink of the
            components and stores the components internally. Subsequent calls to this
            method will reuse the previously stored components after resetting them
            through <see cref="M:Lucene.Net.Analysis.TokenStreamComponents.SetReader(System.IO.TextReader)"/>.
            <para/>
            <b>NOTE:</b> After calling this method, the consumer must follow the
            workflow described in <see cref="T:Lucene.Net.Analysis.TokenStream"/> to properly consume its contents.
            See the <see cref="N:Lucene.Net.Analysis"/> namespace documentation for
            some examples demonstrating this.
            </summary>
            <param name="fieldName"> the name of the field the created <see cref="T:Lucene.Net.Analysis.TokenStream"/> is used for </param>
            <param name="reader"> the reader the streams source reads from </param>
            <returns> <see cref="T:Lucene.Net.Analysis.TokenStream"/> for iterating the analyzed content of <see cref="T:System.IO.TextReader"/> </returns>
            <exception cref="T:System.ObjectDisposedException"> if the Analyzer is disposed. </exception>
            <exception cref="T:System.IO.IOException"> if an i/o error occurs (may rarely happen for strings). </exception>
            <seealso cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.String)"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.String)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Analysis.TokenStream"/> suitable for <paramref name="fieldName"/>, tokenizing
            the contents of <paramref name="text"/>.
            <para/>
            This method uses <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/> to obtain an
            instance of <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/>. It returns the sink of the
            components and stores the components internally. Subsequent calls to this
            method will reuse the previously stored components after resetting them
            through <see cref="M:Lucene.Net.Analysis.TokenStreamComponents.SetReader(System.IO.TextReader)"/>.
            <para/>
            <b>NOTE:</b> After calling this method, the consumer must follow the 
            workflow described in <see cref="T:Lucene.Net.Analysis.TokenStream"/> to properly consume its contents.
            See the <see cref="N:Lucene.Net.Analysis"/> namespace documentation for
            some examples demonstrating this.
            </summary>
            <param name="fieldName">the name of the field the created <see cref="T:Lucene.Net.Analysis.TokenStream"/> is used for</param>
            <param name="text">the <see cref="T:System.String"/> the streams source reads from </param>
            <returns><see cref="T:Lucene.Net.Analysis.TokenStream"/> for iterating the analyzed content of <c>reader</c></returns>
            <exception cref="T:System.ObjectDisposedException"> if the Analyzer is disposed. </exception>
            <exception cref="T:System.IO.IOException"> if an i/o error occurs (may rarely happen for strings). </exception>
            <seealso cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.InitReader(System.String,System.IO.TextReader)">
            <summary>
            Override this if you want to add a <see cref="T:Lucene.Net.Analysis.CharFilter"/> chain.
            <para/>
            The default implementation returns <paramref name="reader"/>
            unchanged.
            </summary>
            <param name="fieldName"> <see cref="T:Lucene.Net.Index.IIndexableField"/> name being indexed </param>
            <param name="reader"> original <see cref="T:System.IO.TextReader"/> </param>
            <returns> reader, optionally decorated with <see cref="T:Lucene.Net.Analysis.CharFilter"/>(s) </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetPositionIncrementGap(System.String)">
            <summary>
            Invoked before indexing a <see cref="T:Lucene.Net.Index.IIndexableField"/> instance if
            terms have already been added to that field.  This allows custom
            analyzers to place an automatic position increment gap between
            <see cref="T:Lucene.Net.Index.IIndexableField"/> instances using the same field name.  The default value
            position increment gap is 0.  With a 0 position increment gap and
            the typical default token position increment of 1, all terms in a field,
            including across <see cref="T:Lucene.Net.Index.IIndexableField"/> instances, are in successive positions, allowing
            exact <see cref="T:Lucene.Net.Search.PhraseQuery"/> matches, for instance, across <see cref="T:Lucene.Net.Index.IIndexableField"/> instance boundaries.
            </summary>
            <param name="fieldName"> <see cref="T:Lucene.Net.Index.IIndexableField"/> name being indexed. </param>
            <returns> position increment gap, added to the next token emitted from <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>.
                    this value must be <c>&gt;= 0</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetOffsetGap(System.String)">
            <summary>
            Just like <see cref="M:Lucene.Net.Analysis.Analyzer.GetPositionIncrementGap(System.String)"/>, except for
            <see cref="T:Lucene.Net.Analysis.Token"/> offsets instead.  By default this returns 1.
            this method is only called if the field
            produced at least one token for indexing.
            </summary>
            <param name="fieldName"> the field just indexed </param>
            <returns> offset gap, added to the next token emitted from <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>.
                    this value must be <c>&gt;= 0</c>. </returns>
        </member>
        <member name="P:Lucene.Net.Analysis.Analyzer.Strategy">
            <summary>
            Returns the used <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.Dispose">
            <summary>
            Frees persistent resources used by this <see cref="T:Lucene.Net.Analysis.Analyzer"/> 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.Dispose(System.Boolean)">
            <summary>
            Frees persistent resources used by this <see cref="T:Lucene.Net.Analysis.Analyzer"/> 
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Analyzer.GLOBAL_REUSE_STRATEGY">
            <summary>
            A predefined <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/>  that reuses the same components for
            every field.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Analyzer.GlobalReuseStrategy">
            <summary>
            Implementation of <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/> that reuses the same components for
            every field. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GlobalReuseStrategy.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass constructors, typically implicit.) </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Analyzer.PER_FIELD_REUSE_STRATEGY">
            <summary>
            A predefined <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/> that reuses components per-field by
            maintaining a Map of <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> per field name.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Analyzer.PerFieldReuseStrategy">
            <summary>
            Implementation of <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/> that reuses components per-field by
            maintaining a Map of <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> per field name.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.PerFieldReuseStrategy.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass constructors, typically implicit.)
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Analyzer.AnonymousAnalyzer">
            <summary>
            LUCENENET specific helper class to mimick Java's ability to create anonymous classes.
            Clearly, the design of <see cref="T:Lucene.Net.Analysis.Analyzer"/> took this feature of Java into consideration.
            Since it doesn't exist in .NET, we can use a delegate method to call the constructor of
            this concrete instance to fake it (by calling an overload of 
            <see cref="M:Lucene.Net.Analysis.Analyzer.NewAnonymous(System.Func{System.String,System.IO.TextReader,Lucene.Net.Analysis.TokenStreamComponents})"/>).
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenStreamComponents">
            <summary>
            This class encapsulates the outer components of a token stream. It provides
            access to the source (<see cref="T:Lucene.Net.Analysis.Tokenizer"/>) and the outer end (sink), an
            instance of <see cref="T:Lucene.Net.Analysis.TokenFilter"/> which also serves as the
            <see cref="T:Lucene.Net.Analysis.TokenStream"/> returned by
            <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenStreamComponents.m_source">
            <summary>
            Original source of the tokens.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenStreamComponents.m_sink">
            <summary>
            Sink tokenstream, such as the outer tokenfilter decorating
            the chain. This can be the source if there are no filters.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenStreamComponents.reusableStringReader">
            <summary>
            Internal cache only used by <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.String)"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamComponents.#ctor(Lucene.Net.Analysis.Tokenizer,Lucene.Net.Analysis.TokenStream)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> instance.
            </summary>
            <param name="source">
                     the analyzer's tokenizer </param>
            <param name="result">
                     the analyzer's resulting token stream </param>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamComponents.#ctor(Lucene.Net.Analysis.Tokenizer)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> instance.
            </summary>
            <param name="source">
                     the analyzer's tokenizer </param>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamComponents.SetReader(System.IO.TextReader)">
            <summary>
            Resets the encapsulated components with the given reader. If the components
            cannot be reset, an Exception should be thrown.
            </summary>
            <param name="reader">
                     a reader to reset the source component </param>
            <exception cref="T:System.IO.IOException">
                      if the component's reset method throws an <seealso cref="T:System.IO.IOException"/> </exception>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenStreamComponents.TokenStream">
            <summary>
            Returns the sink <see cref="T:Lucene.Net.Analysis.TokenStream"/>
            </summary>
            <returns> the sink <see cref="T:Lucene.Net.Analysis.TokenStream"/> </returns>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenStreamComponents.Tokenizer">
            <summary>
            Returns the component's <see cref="T:Lucene.Net.Analysis.Tokenizer"/>
            </summary>
            <returns> Component's <see cref="T:Lucene.Net.Analysis.Tokenizer"/> </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.ReuseStrategy">
            <summary>
            Strategy defining how <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> are reused per call to
            <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.ReuseStrategy.GetReusableComponents(Lucene.Net.Analysis.Analyzer,System.String)">
            <summary>
            Gets the reusable <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for the field with the given name.
            </summary>
            <param name="analyzer"> <see cref="T:Lucene.Net.Analysis.Analyzer"/> from which to get the reused components. Use
                   <see cref="M:Lucene.Net.Analysis.ReuseStrategy.GetStoredValue(Lucene.Net.Analysis.Analyzer)"/> and <see cref="M:Lucene.Net.Analysis.ReuseStrategy.SetStoredValue(Lucene.Net.Analysis.Analyzer,System.Object)"/>
                   to access the data on the <see cref="T:Lucene.Net.Analysis.Analyzer"/>. </param>
            <param name="fieldName"> Name of the field whose reusable <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/>
                   are to be retrieved </param>
            <returns> Reusable <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for the field, or <c>null</c>
                    if there was no previous components for the field </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.ReuseStrategy.SetReusableComponents(Lucene.Net.Analysis.Analyzer,System.String,Lucene.Net.Analysis.TokenStreamComponents)">
            <summary>
            Stores the given <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> as the reusable components for the
            field with the give name.
            </summary>
            <param name="analyzer"> Analyzer </param>
            <param name="fieldName"> Name of the field whose <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> are being set </param>
            <param name="components"> <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> which are to be reused for the field </param>
        </member>
        <member name="M:Lucene.Net.Analysis.ReuseStrategy.GetStoredValue(Lucene.Net.Analysis.Analyzer)">
            <summary>
            Returns the currently stored value.
            </summary>
            <returns> Currently stored value or <c>null</c> if no value is stored </returns>
            <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Analysis.Analyzer"/> is closed. </exception>
        </member>
        <member name="M:Lucene.Net.Analysis.ReuseStrategy.SetStoredValue(Lucene.Net.Analysis.Analyzer,System.Object)">
            <summary>
            Sets the stored value.
            </summary>
            <param name="analyzer"> Analyzer </param>
            <param name="storedValue"> Value to store </param>
            <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Analysis.Analyzer"/> is closed. </exception>
        </member>
        <member name="T:Lucene.Net.Analysis.AnalyzerWrapper">
            <summary>
            Extension to <see cref="T:Lucene.Net.Analysis.Analyzer"/> suitable for <see cref="T:Lucene.Net.Analysis.Analyzer"/>s which wrap
            other <see cref="T:Lucene.Net.Analysis.Analyzer"/>s.
            <para/>
            <see cref="M:Lucene.Net.Analysis.AnalyzerWrapper.GetWrappedAnalyzer(System.String)"/> allows the <see cref="T:Lucene.Net.Analysis.Analyzer"/>
            to wrap multiple <see cref="T:Lucene.Net.Analysis.Analyzer"/>s which are selected on a per field basis.
            <para/>
            <see cref="M:Lucene.Net.Analysis.AnalyzerWrapper.WrapComponents(System.String,Lucene.Net.Analysis.TokenStreamComponents)"/> allows the
            <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> of the wrapped <see cref="T:Lucene.Net.Analysis.Analyzer"/> to then be wrapped
            (such as adding a new <see cref="T:Lucene.Net.Analysis.TokenFilter"/> to form new <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.#ctor">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Analysis.AnalyzerWrapper"/>.  Since the <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/> of
            the wrapped <see cref="T:Lucene.Net.Analysis.Analyzer"/>s are unknown, <see cref="F:Lucene.Net.Analysis.Analyzer.PER_FIELD_REUSE_STRATEGY"/> is assumed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.#ctor(Lucene.Net.Analysis.ReuseStrategy)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Analysis.AnalyzerWrapper"/> with the given reuse strategy.
            <para/>If you want to wrap a single delegate <see cref="T:Lucene.Net.Analysis.Analyzer"/> you can probably
            reuse its strategy when instantiating this subclass:
            <c>base(innerAnalyzer.Strategy)</c>.
            <para/>If you choose different analyzers per field, use
            <see cref="F:Lucene.Net.Analysis.Analyzer.PER_FIELD_REUSE_STRATEGY"/>.
            </summary>
            <seealso cref="P:Lucene.Net.Analysis.Analyzer.Strategy"/>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.GetWrappedAnalyzer(System.String)">
            <summary>
            Retrieves the wrapped <see cref="T:Lucene.Net.Analysis.Analyzer"/> appropriate for analyzing the field with
            the given name
            </summary>
            <param name="fieldName"> Name of the field which is to be analyzed </param>
            <returns> <see cref="T:Lucene.Net.Analysis.Analyzer"/> for the field with the given name.  Assumed to be non-null </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.WrapComponents(System.String,Lucene.Net.Analysis.TokenStreamComponents)">
            <summary>
            Wraps / alters the given <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/>, taken from the wrapped
            <see cref="T:Lucene.Net.Analysis.Analyzer"/>, to form new components. It is through this method that new
            <see cref="T:Lucene.Net.Analysis.TokenFilter"/>s can be added by <see cref="T:Lucene.Net.Analysis.AnalyzerWrapper"/>s. By default, the given
            components are returned.
            </summary>
            <param name="fieldName">
                     Name of the field which is to be analyzed </param>
            <param name="components">
                     <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> taken from the wrapped <see cref="T:Lucene.Net.Analysis.Analyzer"/> </param>
            <returns> Wrapped / altered <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.WrapReader(System.String,System.IO.TextReader)">
            <summary>
            Wraps / alters the given <see cref="T:System.IO.TextReader"/>. Through this method <see cref="T:Lucene.Net.Analysis.AnalyzerWrapper"/>s can
            implement <see cref="M:Lucene.Net.Analysis.AnalyzerWrapper.InitReader(System.String,System.IO.TextReader)"/>. By default, the given reader
            is returned.
            </summary>
            <param name="fieldName">
                     name of the field which is to be analyzed </param>
            <param name="reader">
                     the reader to wrap </param>
            <returns> the wrapped reader </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.CachingTokenFilter">
             <summary>
             This class can be used if the token attributes of a <see cref="T:Lucene.Net.Analysis.TokenStream"/>
             are intended to be consumed more than once. It caches
             all token attribute states locally in a List.
            
             <para/><see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/> implements the optional method
             <see cref="M:Lucene.Net.Analysis.TokenStream.Reset"/>, which repositions the
             stream to the first <see cref="T:Lucene.Net.Analysis.Token"/>.
             </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CachingTokenFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/> around <paramref name="input"/>,
            caching its token attributes, which can be replayed again
            after a call to <see cref="M:Lucene.Net.Analysis.CachingTokenFilter.Reset"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CachingTokenFilter.Reset">
            <summary>
            Rewinds the iterator to the beginning of the cached list.
            <para/>
            Note that this does not call <see cref="M:Lucene.Net.Analysis.CachingTokenFilter.Reset"/> on the wrapped tokenstream ever, even
            the first time. You should <see cref="M:Lucene.Net.Analysis.CachingTokenFilter.Reset"/> the inner tokenstream before wrapping
            it with <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.CharFilter">
            <summary>
            Subclasses of <see cref="T:Lucene.Net.Analysis.CharFilter"/> can be chained to filter a <see cref="T:System.IO.TextReader"/>
            They can be used as <see cref="T:System.IO.TextReader"/> with additional offset
            correction. <see cref="T:Lucene.Net.Analysis.Tokenizer"/>s will automatically use <see cref="M:Lucene.Net.Analysis.CharFilter.CorrectOffset(System.Int32)"/>
            if a <see cref="T:Lucene.Net.Analysis.CharFilter"/> subclass is used.
            <para/>
            This class is abstract: at a minimum you must implement <see cref="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)"/>,
            transforming the input in some way from <see cref="F:Lucene.Net.Analysis.CharFilter.m_input"/>, and <seealso cref="M:Lucene.Net.Analysis.CharFilter.Correct(System.Int32)"/>
            to adjust the offsets to match the originals.
            <para/>
            You can optionally provide more efficient implementations of additional methods
            like <see cref="M:System.IO.TextReader.Read"/>, but this is not required.
            <para/>
            For examples and integration with <see cref="T:Lucene.Net.Analysis.Analyzer"/>, see the
            <see cref="N:Lucene.Net.Analysis"/> namespace documentation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.CharFilter.m_input">
            <summary>
            The underlying character-input stream.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.#ctor(System.IO.TextReader)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Analysis.CharFilter"/> wrapping the provided reader. </summary>
            <param name="input"> a <see cref="T:System.IO.TextReader"/>, can also be a <see cref="T:Lucene.Net.Analysis.CharFilter"/> for chaining. </param>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.Dispose(System.Boolean)">
            <summary>
            Closes the underlying input stream.
            <para/>
            <b>NOTE:</b>
            The default implementation closes the input <see cref="T:System.IO.TextReader"/>, so
            be sure to call <c>base.Dispose(disposing)</c> when overriding this method.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.Correct(System.Int32)">
            <summary>
            Subclasses override to correct the current offset.
            </summary>
            <param name="currentOff"> current offset </param>
            <returns> corrected offset </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.CorrectOffset(System.Int32)">
            <summary>
            Chains the corrected offset through the input
            <see cref="T:Lucene.Net.Analysis.CharFilter"/>(s).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.Skip(System.Int32)">
            <summary>
            Skips characters. This method will block until some characters are available, an I/O error occurs, or the end of the stream is reached.
            
            LUCENENET specific. Moved here from the Reader class (in Java) so it can be overridden to provide reader buffering.
            </summary>
            <param name="n">The number of characters to skip</param>
            <returns>The number of characters actually skipped</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.Reset">
            <summary>
            LUCENENET specific. Moved here from the Reader class (in Java) so it can be overridden to provide reader buffering.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Lucene.Net.Analysis.CharFilter.IsReady">
            <summary>
            Tells whether this stream is ready to be read.
            <para/>
            True if the next <see cref="M:System.IO.TextReader.Read"/> is guaranteed not to block for input, false otherwise. Note 
            that returning false does not guarantee that the next read will block.
            <para/>
            LUCENENET specific. Moved here from the Reader class (in Java) so it can be overridden to provide reader buffering.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.CharFilter.IsMarkSupported">
            <summary>
            Tells whether this stream supports the <see cref="M:Lucene.Net.Analysis.CharFilter.Mark(System.Int32)"/> operation. The default implementation always 
            returns false. Subclasses should override this method.
            <para/>
            LUCENENET specific. Moved here from the Reader class (in Java) so it can be overridden to provide reader buffering.
            </summary>
            <returns>true if and only if this stream supports the mark operation.</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.Mark(System.Int32)">
            <summary>
            Marks the present position in the stream. Subsequent calls to <see cref="M:Lucene.Net.Analysis.CharFilter.Reset"/> will attempt to 
            reposition the stream to this point. Not all character-input streams support the <see cref="M:Lucene.Net.Analysis.CharFilter.Mark(System.Int32)"/> operation.
            <para/>
            LUCENENET specific. Moved here from the Reader class (in Java) so it can be overridden to provide reader buffering.
            </summary>
            <param name="readAheadLimit">Limit on the number of characters that may be read while still preserving the mark. After 
            reading this many characters, attempting to reset the stream may fail.</param>
        </member>
        <member name="T:Lucene.Net.Analysis.NumericTokenStream">
             <summary>
             <b>Expert:</b> this class provides a <see cref="T:Lucene.Net.Analysis.TokenStream"/>
             for indexing numeric values that can be used by <see cref="T:Lucene.Net.Search.NumericRangeQuery"/>
             or <see cref="T:Lucene.Net.Search.NumericRangeFilter"/>.
            
             <para/>Note that for simple usage, <see cref="T:Lucene.Net.Documents.Int32Field"/>, <see cref="T:Lucene.Net.Documents.Int64Field"/>, 
             <see cref="T:Lucene.Net.Documents.SingleField"/> or <see cref="T:Lucene.Net.Documents.DoubleField"/> is
             recommended.  These fields disable norms and
             term freqs, as they are not usually needed during
             searching.  If you need to change these settings, you
             should use this class.
            
             <para/>Here's an example usage, for an <see cref="T:System.Int32"/> field:
            
             <code>
                 IndexableFieldType fieldType = new IndexableFieldType(TextField.TYPE_NOT_STORED)
                 {
                     OmitNorms = true,
                     IndexOptions = IndexOptions.DOCS_ONLY
                 };
                 Field field = new Field(name, new NumericTokenStream(precisionStep).SetInt32Value(value), fieldType);
                 document.Add(field);
             </code>
            
             <para/>For optimal performance, re-use the <see cref="T:Lucene.Net.Analysis.TokenStream"/> and <see cref="T:Lucene.Net.Documents.Field"/> instance
             for more than one document:
            
             <code>
                 NumericTokenStream stream = new NumericTokenStream(precisionStep);
                 IndexableFieldType fieldType = new IndexableFieldType(TextField.TYPE_NOT_STORED)
                 {
                     OmitNorms = true,
                     IndexOptions = IndexOptions.DOCS_ONLY
                 };
                 Field field = new Field(name, stream, fieldType);
                 Document document = new Document();
                 document.Add(field);
            
                 for(all documents) 
                 {
                     stream.SetInt32Value(value)
                     writer.AddDocument(document);
                 }
             </code>
            
             <para>this stream is not intended to be used in analyzers;
             it's more for iterating the different precisions during
             indexing a specific numeric value.</para>
            
             <para><b>NOTE</b>: as token streams are only consumed once
             the document is added to the index, if you index more
             than one numeric field, use a separate <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>
             instance for each.</para>
            
             <para>See <see cref="T:Lucene.Net.Search.NumericRangeQuery"/> for more details on the
             <c>precisionStep</c> parameter as well as how numeric fields work under the hood.
             </para>
            
             @since 2.9
             </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.NumericTokenStream.TOKEN_TYPE_FULL_PREC">
            <summary>
            The full precision token gets this token type assigned. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.NumericTokenStream.TOKEN_TYPE_LOWER_PREC">
            <summary>
            The lower precision tokens gets this token type assigned. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute">
            <summary>
            <b>Expert:</b> Use this attribute to get the details of the currently generated token.
            @lucene.experimental
            @since 4.0
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.Shift">
            <summary>
            Returns current shift value, undefined before first token </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.RawValue">
            <summary>
            Returns current token's raw value as <see cref="T:System.Int64"/> with all <see cref="P:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.Shift"/> applied, undefined before first token </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.ValueSize">
            <summary>
            Returns value size in bits (32 for <see cref="T:System.Single"/>, <see cref="T:System.Int32"/>; 64 for <see cref="T:System.Double"/>, <see cref="T:System.Int64"/>) </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.Init(System.Int64,System.Int32,System.Int32,System.Int32)">
            <summary>
            <em>Don't call this method!</em>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.IncShift">
            <summary>
            <em>Don't call this method!</em>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.NumericTokenStream.NumericTermAttribute">
            <summary>
            Implementation of <see cref="T:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute"/>.
            @lucene.internal
            @since 4.0
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.NumericTermAttribute.#ctor">
            <summary>
            Creates, but does not yet initialize this attribute instance
            </summary>
            <seealso cref="M:Lucene.Net.Analysis.NumericTokenStream.NumericTermAttribute.Init(System.Int64,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.#ctor">
            <summary>
            Creates a token stream for numeric values using the default <seealso cref="F:Lucene.Net.Analysis.NumericTokenStream.precisionStep"/>
            <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4). The stream is not yet initialized,
            before using set a value using the various Set<em>???</em>Value() methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.#ctor(System.Int32)">
            <summary>
            Creates a token stream for numeric values with the specified
            <paramref name="precisionStep"/>. The stream is not yet initialized,
            before using set a value using the various Set<em>???</em>Value() methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory,System.Int32)">
            <summary>
            Expert: Creates a token stream for numeric values with the specified
            <paramref name="precisionStep"/> using the given
            <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/>.
            The stream is not yet initialized,
            before using set a value using the various Set<em>???</em>Value() methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.SetInt64Value(System.Int64)">
            <summary>
            Initializes the token stream with the supplied <see cref="T:System.Int64"/> value. 
            <para/>
            NOTE: This was setLongValue() in Lucene
            </summary>
            <param name="value"> the value, for which this <see cref="T:Lucene.Net.Analysis.TokenStream"/> should enumerate tokens. </param>
            <returns> this instance, because of this you can use it the following way:
            <code>new Field(name, new NumericTokenStream(precisionStep).SetInt64Value(value))</code> </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.SetInt32Value(System.Int32)">
            <summary>
            Initializes the token stream with the supplied <see cref="T:System.Int32"/> value.
            <para/>
            NOTE: This was setIntValue() in Lucene
            </summary>
            <param name="value"> the value, for which this <see cref="T:Lucene.Net.Analysis.TokenStream"/> should enumerate tokens. </param>
            <returns> this instance, because of this you can use it the following way:
            <code>new Field(name, new NumericTokenStream(precisionStep).SetInt32Value(value))</code> </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.SetDoubleValue(System.Double)">
            <summary>
            Initializes the token stream with the supplied <see cref="T:System.Double"/> value. </summary>
            <param name="value"> the value, for which this <see cref="T:Lucene.Net.Analysis.TokenStream"/> should enumerate tokens. </param>
            <returns> this instance, because of this you can use it the following way:
            <code>new Field(name, new NumericTokenStream(precisionStep).SetDoubleValue(value))</code> </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.SetSingleValue(System.Single)">
            <summary>
            Initializes the token stream with the supplied <see cref="T:System.Single"/> value. 
            <para/>
            NOTE: This was setFloatValue() in Lucene
            </summary>
            <param name="value"> the value, for which this <see cref="T:Lucene.Net.Analysis.TokenStream"/> should enumerate tokens. </param>
            <returns> this instance, because of this you can use it the following way:
            <code>new Field(name, new NumericTokenStream(precisionStep).SetSingleValue(value))</code> </returns>
        </member>
        <member name="P:Lucene.Net.Analysis.NumericTokenStream.PrecisionStep">
            <summary>
            Returns the precision step. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.ReusableStringReader">
            <summary>
            Internal class to enable reuse of the string reader by <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.String)"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Token">
             <summary>
             A <see cref="T:Lucene.Net.Analysis.Token"/> is an occurrence of a term from the text of a field.  It consists of
             a term's text, the start and end offset of the term in the text of the field,
             and a type string.
             <para/>
             The start and end offsets permit applications to re-associate a token with
             its source text, e.g., to display highlighted query terms in a document
             browser, or to show matching text fragments in a KWIC (KeyWord In Context)
             display, etc.
             <para/>
             The type is a string, assigned by a lexical analyzer
             (a.k.a. tokenizer), naming the lexical or syntactic class that the token
             belongs to.  For example an end of sentence marker token might be implemented
             with type "eos".  The default token type is "word".
             <para/>
             A Token can optionally have metadata (a.k.a. payload) in the form of a variable
             length byte array. Use <see cref="M:Lucene.Net.Index.DocsAndPositionsEnum.GetPayload"/> to retrieve the
             payloads from the index.
            
             <para/><para/>
            
             <para/><b>NOTE:</b> As of 2.9, Token implements all <see cref="T:Lucene.Net.Util.IAttribute"/> interfaces
             that are part of core Lucene and can be found in the <see cref="N:Lucene.Net.Analysis.TokenAttributes"/> namespace.
             Even though it is not necessary to use <see cref="T:Lucene.Net.Analysis.Token"/> anymore, with the new <see cref="T:Lucene.Net.Analysis.TokenStream"/> API it can
             be used as convenience class that implements all <see cref="T:Lucene.Net.Util.IAttribute"/>s, which is especially useful
             to easily switch from the old to the new <see cref="T:Lucene.Net.Analysis.TokenStream"/> API.
            
             <para/><para/>
            
             <para><see cref="T:Lucene.Net.Analysis.Tokenizer"/>s and <see cref="T:Lucene.Net.Analysis.TokenFilter"/>s should try to re-use a <see cref="T:Lucene.Net.Analysis.Token"/>
             instance when possible for best performance, by
             implementing the <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/> API.
             Failing that, to create a new <see cref="T:Lucene.Net.Analysis.Token"/> you should first use
             one of the constructors that starts with null text.  To load
             the token from a char[] use <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.CopyBuffer(System.Char[],System.Int32,System.Int32)"/>.
             To load from a <see cref="T:System.String"/> use <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetEmpty"/> followed by 
             <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.String)"/> or <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.String,System.Int32,System.Int32)"/>.
             Alternatively you can get the <see cref="T:Lucene.Net.Analysis.Token"/>'s termBuffer by calling either <see cref="P:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Buffer"/>,
             if you know that your text is shorter than the capacity of the termBuffer
             or <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.ResizeBuffer(System.Int32)"/>, if there is any possibility
             that you may need to grow the buffer. Fill in the characters of your term into this
             buffer, with <see cref="M:System.String.ToCharArray(System.Int32,System.Int32)"/> if loading from a string,
             or with <see cref="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)"/>, 
             and finally call <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetLength(System.Int32)"/> to
             set the length of the term text.  See <a target="_top"
             href="https://issues.apache.org/jira/browse/LUCENE-969">LUCENE-969</a>
             for details.</para>
             <para>Typical Token reuse patterns:
             <list type="bullet">
                 <item><description> Copying text from a string (type is reset to <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> if not specified):
                 <code>
                     return reusableToken.Reinit(string, startOffset, endOffset[, type]);
                 </code>
                 </description></item>
                 <item><description> Copying some text from a string (type is reset to <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> if not specified):
                 <code>
                     return reusableToken.Reinit(string, 0, string.Length, startOffset, endOffset[, type]);
                 </code>
                 </description></item>
                 <item><description> Copying text from char[] buffer (type is reset to <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> if not specified):
                 <code>
                     return reusableToken.Reinit(buffer, 0, buffer.Length, startOffset, endOffset[, type]);
                 </code>
                 </description></item>
                 <item><description> Copying some text from a char[] buffer (type is reset to <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> if not specified):
                 <code>
                     return reusableToken.Reinit(buffer, start, end - start, startOffset, endOffset[, type]);
                 </code>
                 </description></item>
                 <item><description> Copying from one one <see cref="T:Lucene.Net.Analysis.Token"/> to another (type is reset to <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> if not specified):
                 <code>
                     return reusableToken.Reinit(source.Buffer, 0, source.Length, source.StartOffset, source.EndOffset[, source.Type]);
                 </code>
                 </description></item>
             </list>
             A few things to note:
             <list type="bullet">
                 <item><description><see cref="M:Lucene.Net.Analysis.Token.Clear"/> initializes all of the fields to default values. this was changed in contrast to Lucene 2.4, but should affect no one.</description></item>
                 <item><description>Because <see cref="T:Lucene.Net.Analysis.TokenStream"/>s can be chained, one cannot assume that the <see cref="T:Lucene.Net.Analysis.Token"/>'s current type is correct.</description></item>
                 <item><description>The startOffset and endOffset represent the start and offset in the source text, so be careful in adjusting them.</description></item>
                 <item><description>When caching a reusable token, clone it. When injecting a cached token into a stream that can be reset, clone it again.</description></item>
             </list>
             </para>
             <para>
             <b>Please note:</b> With Lucene 3.1, the <see cref="M:Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.ToString"/> method had to be changed to match the
             <see cref="T:J2N.Text.ICharSequence"/> interface introduced by the interface <see cref="T:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute"/>.
             this method now only prints the term text, no additional information anymore.
             </para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> will null text. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with null text and start &amp; end
            offsets. </summary>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text  </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with null text and start &amp; end
            offsets plus the <see cref="T:Lucene.Net.Analysis.Token"/> type. </summary>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text </param>
            <param name="typ"> the lexical type of this <see cref="T:Lucene.Net.Analysis.Token"/>  </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with null text and start &amp; end
            offsets plus flags. NOTE: flags is EXPERIMENTAL. </summary>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text </param>
            <param name="flags"> The bits to set for this token </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with the given term text, and start
            &amp; end offsets.  The type defaults to "word."
            <b>NOTE:</b> for better indexing speed you should
            instead use the char[] termBuffer methods to set the
            term text. </summary>
            <param name="text"> term text </param>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with the given text, start and end
            offsets, &amp; type.  <b>NOTE:</b> for better indexing
            speed you should instead use the char[] termBuffer
            methods to set the term text. </summary>
            <param name="text"> term text </param>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text </param>
            <param name="typ"> token type </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with the given text, start and end
            offsets, &amp; type.  <b>NOTE:</b> for better indexing
            speed you should instead use the char[] termBuffer
            methods to set the term text. </summary>
            <param name="text"> term text </param>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text </param>
            <param name="flags"> token type bits </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with the given term buffer (offset
            &amp; length), start and end offsets
            </summary>
            <param name="startTermBuffer"> buffer containing term text </param>
            <param name="termBufferOffset"> the index in the buffer of the first character </param>
            <param name="termBufferLength"> number of valid characters in the buffer </param>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text </param>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.PositionIncrement">
            <summary>
            Gets or Sets the position increment (the distance from the prior term). The default value is one.
            </summary>
            <exception cref="T:System.ArgumentException"> if value is set to a negative value. </exception>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IPositionIncrementAttribute"/>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.PositionLength">
            <summary>
            Gets or Sets the position length of this <see cref="T:Lucene.Net.Analysis.Token"/> (how many positions this token
            spans).
            <para/>
            The default value is one.
            </summary>
            <exception cref="T:System.ArgumentException"> if value
                    is set to zero or negative. </exception>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IPositionLengthAttribute"/>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.StartOffset">
            <summary>
            Returns this <see cref="T:Lucene.Net.Analysis.Token"/>'s starting offset, the position of the first character
            corresponding to this token in the source text.
            <para/>
            Note that the difference between <see cref="P:Lucene.Net.Analysis.Token.EndOffset"/> and <see cref="P:Lucene.Net.Analysis.Token.StartOffset"/>
            may not be equal to termText.Length, as the term text may have been altered by a
            stemmer or some other filter.
            </summary>
            <seealso cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute"/>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.EndOffset">
            <summary>
            Returns this <see cref="T:Lucene.Net.Analysis.Token"/>'s ending offset, one greater than the position of the
            last character corresponding to this token in the source text. The length
            of the token in the source text is (<code>EndOffset</code> - <see cref="P:Lucene.Net.Analysis.Token.StartOffset"/>).
            </summary>
            <seealso cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)">
            <summary>
            Set the starting and ending offset.
            </summary>
            <exception cref="T:System.ArgumentException"> If <paramref name="startOffset"/> or <paramref name="endOffset"/>
                    are negative, or if <paramref name="startOffset"/> is greater than
                    <paramref name="endOffset"/> </exception>
            <seealso cref="P:Lucene.Net.Analysis.Token.StartOffset"/>
            <seealso cref="P:Lucene.Net.Analysis.Token.EndOffset"/>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute"/>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.Type">
            <summary>Gets or Sets this <see cref="T:Lucene.Net.Analysis.Token"/>'s lexical type.  Defaults to "word". </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.Flags">
            <summary>
            Get the bitset for any bits that have been set.
            <para/>
            This is completely distinct from <see cref="P:Lucene.Net.Analysis.TokenAttributes.ITypeAttribute.Type" />, although they do share similar purposes.
            The flags can be used to encode information about the token for use by other <see cref="T:Lucene.Net.Analysis.TokenFilter" />s.
            </summary>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IFlagsAttribute"/>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.Payload">
            <summary>
            Gets or Sets this <see cref="T:Lucene.Net.Analysis.Token"/>'s payload.
            </summary>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IPayloadAttribute"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Clear">
            <summary>
            Resets the term text, payload, flags, and positionIncrement,
            startOffset, endOffset and token type to default.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Clone(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Makes a clone, but replaces the term buffer &amp;
            start/end offset in the process.  This is more
            efficient than doing a full clone (and then calling
            <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.CopyBuffer(System.Char[],System.Int32,System.Int32)"/>) because it saves a wasted copy of the old
            termBuffer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Shorthand for calling <see cref="M:Lucene.Net.Analysis.Token.Clear"/>,
            <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.CopyBuffer(System.Char[],System.Int32,System.Int32)"/>,
            <see cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>,
            <see cref="P:Lucene.Net.Analysis.Token.Type"/> (set) </summary>
            <returns> this <see cref="T:Lucene.Net.Analysis.Token"/> instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Shorthand for calling <see cref="M:Lucene.Net.Analysis.Token.Clear"/>,
            <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.CopyBuffer(System.Char[],System.Int32,System.Int32)"/>,
            <see cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>,
            <see cref="P:Lucene.Net.Analysis.Token.Type"/> (set) on <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> </summary>
            <returns> this <see cref="T:Lucene.Net.Analysis.Token"/> instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Shorthand for calling <see cref="M:Lucene.Net.Analysis.Token.Clear"/>,
            <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.String)"/>,
            <see cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>,
            <see cref="P:Lucene.Net.Analysis.Token.Type"/> (set) </summary>
            <returns> this <see cref="T:Lucene.Net.Analysis.Token"/> instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Shorthand for calling <see cref="M:Lucene.Net.Analysis.Token.Clear"/>,
            <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.String,System.Int32,System.Int32)"/>,
            <see cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>,
            <see cref="P:Lucene.Net.Analysis.Token.Type"/> (set) </summary>
            <returns> this <see cref="T:Lucene.Net.Analysis.Token"/> instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32)">
            <summary>
            Shorthand for calling <see cref="M:Lucene.Net.Analysis.Token.Clear"/>,
            <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.String)"/>,
            <see cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>,
            <see cref="P:Lucene.Net.Analysis.Token.Type"/> (set) on <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> </summary>
            <returns> this <see cref="T:Lucene.Net.Analysis.Token"/> instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Shorthand for calling <see cref="M:Lucene.Net.Analysis.Token.Clear"/>,
            <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.String,System.Int32,System.Int32)"/>,
            <see cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>,
            <see cref="P:Lucene.Net.Analysis.Token.Type"/> (set) on <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> </summary>
            <returns> this <see cref="T:Lucene.Net.Analysis.Token"/> instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(Lucene.Net.Analysis.Token)">
            <summary>
            Copy the prototype token's fields into this one. Note: Payloads are shared. </summary>
            <param name="prototype"> source <see cref="T:Lucene.Net.Analysis.Token"/> to copy fields from </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(Lucene.Net.Analysis.Token,System.String)">
            <summary>
            Copy the prototype token's fields into this one, with a different term. Note: Payloads are shared. </summary>
            <param name="prototype"> existing <see cref="T:Lucene.Net.Analysis.Token"/> </param>
            <param name="newTerm"> new term text </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(Lucene.Net.Analysis.Token,System.Char[],System.Int32,System.Int32)">
            <summary>
            Copy the prototype token's fields into this one, with a different term. Note: Payloads are shared. </summary>
            <param name="prototype"> existing <see cref="T:Lucene.Net.Analysis.Token"/> </param>
            <param name="newTermBuffer"> buffer containing new term text </param>
            <param name="offset"> the index in the buffer of the first character </param>
            <param name="length"> number of valid characters in the buffer </param>
        </member>
        <member name="F:Lucene.Net.Analysis.Token.TOKEN_ATTRIBUTE_FACTORY">
            <summary>
            Convenience factory that returns <see cref="T:Lucene.Net.Analysis.Token"/> as implementation for the basic
            attributes and return the default impl (with &quot;Impl&quot; appended) for all other
            attributes.
            @since 3.0
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Token.TokenAttributeFactory">
            <summary>
            <b>Expert:</b> Creates a <see cref="T:Lucene.Net.Analysis.Token.TokenAttributeFactory"/> returning <see cref="T:Lucene.Net.Analysis.Token"/> as instance for the basic attributes
            and for all other attributes calls the given delegate factory.
            @since 3.0
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.TokenAttributeFactory.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory)">
            <summary>
            <b>Expert</b>: Creates an <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/> returning <see cref="T:Lucene.Net.Analysis.Token"/> as instance for the basic attributes
            and for all other attributes calls the given delegate factory.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.CharTermAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.#ctor">
            <summary>
            Initialize this attribute with empty term text </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.ToString">
            <summary>
            Returns solely the term text as specified by the
            <see cref="T:J2N.Text.ICharSequence"/> interface.
            <para/>
            this method changed the behavior with Lucene 3.1,
            before it returned a String representation of the whole
            term with all attributes.
            this affects especially the
            <see cref="T:Lucene.Net.Analysis.Token"/> subclass.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.FlagsAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.IFlagsAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.FlagsAttribute.#ctor">
            <summary>
            Initialize this attribute with no bits set </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute">
            <summary>
            The term text of a <see cref="T:Lucene.Net.Analysis.Token"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.CopyBuffer(System.Char[],System.Int32,System.Int32)">
            <summary>
            Copies the contents of buffer, starting at offset for
            length characters, into the termBuffer array. </summary>
            <param name="buffer"> the buffer to copy </param>
            <param name="offset"> the index in the buffer of the first character to copy </param>
            <param name="length"> the number of characters to copy </param>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Buffer">
            <summary>
            Returns the internal termBuffer character array which
            you can then directly alter.  If the array is too
            small for your token, use <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.ResizeBuffer(System.Int32)"/>
            to increase it.  After
            altering the buffer be sure to call <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetLength(System.Int32)"/> 
            to record the number of valid
            characters that were placed into the termBuffer.
            <para>
            <b>NOTE</b>: The returned buffer may be larger than
            the valid <see cref="P:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Length"/>.
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.ResizeBuffer(System.Int32)">
            <summary>
            Grows the termBuffer to at least size <paramref name="newSize"/>, preserving the
            existing content. </summary>
            <param name="newSize"> minimum size of the new termBuffer </param>
            <returns> newly created termBuffer with length >= newSize </returns>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Length">
            <summary>
            Gets or Sets the number of valid characters (in
            the termBuffer array.
            <seealso cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetLength(System.Int32)"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetLength(System.Int32)">
            <summary>
            Set number of valid characters (length of the term) in
            the termBuffer array. Use this to truncate the termBuffer
            or to synchronize with external manipulation of the termBuffer.
            Note: to grow the size of the array,
            use <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.ResizeBuffer(System.Int32)"/> first. 
            NOTE: This is exactly the same operation as calling the <see cref="P:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Length"/> setter, the primary 
            difference is that this method returns a reference to the current object so it can be chained.
            <code>
            obj.SetLength(30).Append("hey you");
            </code>
            </summary>
            <param name="length"> the truncated length </param>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetEmpty">
            <summary>
            Sets the length of the termBuffer to zero.
            Use this method before appending contents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(J2N.Text.ICharSequence)">
            <summary>
            Appends the contents of the <see cref="T:J2N.Text.ICharSequence"/> to this character sequence.
            <para/>
            The characters of the <see cref="T:J2N.Text.ICharSequence"/> argument are appended, in order, increasing the length of
            this sequence by the length of the argument. If <paramref name="value"/> is <c>null</c>, this method is a no-op.
            <para/>
            IMPORTANT: This method uses .NET semantics. In Lucene, a <c>null</c> <paramref name="value"/> would append the
            string <c>"null"</c> to the instance, but in Lucene.NET a <c>null</c> value will be ignored.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(J2N.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Appends the a string representation of the specified <see cref="T:J2N.Text.ICharSequence"/> to this instance.
            <para>
            The characters of the <see cref="T:J2N.Text.ICharSequence"/> argument are appended, in order, increasing the length of
            this sequence by the length of <paramref name="count"/>. If <paramref name="value"/> is <c>null</c>
            and <paramref name="startIndex"/> and <paramref name="count"/> are not 0, an
            <see cref="T:System.ArgumentNullException"/> is thrown.
            </para>
            </summary>
            <param name="value">The sequence of characters to append.</param>
            <param name="startIndex">The start index of the <see cref="T:J2N.Text.ICharSequence"/> to begin copying characters.</param>
            <param name="count">The number of characters to append.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <c>null</c>, and
            <paramref name="startIndex"/> and <paramref name="count"/> are not zero.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="count"/> is less than zero.
            <para/>
            -or-
            <para/>
            <paramref name="startIndex"/> is less than zero.
            <para/>
            -or-
            <para/>
            <paramref name="startIndex"/> + <paramref name="count"/> is greater than the length of <paramref name="value"/>.
            </exception>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.Char)">
            <summary>
            Appends the supplied <see cref="T:System.Char"/> to this character sequence.
            </summary>
            <param name="value">The <see cref="T:System.Char"/> to append.</param>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.Char[])">
            <summary>
            Appends the contents of the <see cref="T:char[]"/> array to this character sequence.
            <para/>
            The characters of the <see cref="T:char[]"/> argument are appended, in order, increasing the length of
            this sequence by the length of the <paramref name="value"/>.
            If <paramref name="value"/> is <c>null</c>, this method is a no-op.
            <para/>
            This method uses .NET semantics. In Lucene, a <c>null</c> <paramref name="value"/> would append the
            string <c>"null"</c> to the instance, but in Lucene.NET a <c>null</c> value will be safely ignored.
            </summary>
            <param name="value">The <see cref="T:char[]"/> array to append.</param>
            <remarks>
            LUCENENET specific method, added to simulate using the CharBuffer class in Java.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.Char[],System.Int32,System.Int32)">
            <summary>
            Appends the string representation of the <see cref="T:char[]"/> array to this instance.
            <para>
            The characters of the <see cref="T:char[]"/> argument are appended, in order, increasing the length of
            this sequence by the length of the <paramref name="value"/>. If <paramref name="value"/> is <c>null</c>
            and <paramref name="startIndex"/> and <paramref name="count"/> are not 0, an
            <see cref="T:System.ArgumentNullException"/> is thrown.
            </para>
            </summary>
            <param name="value">The sequence of characters to append.</param>
            <param name="startIndex">The start index of the <see cref="T:char[]"/> to begin copying characters.</param>
            <param name="count">The number of characters to append.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <c>null</c>, and
            <paramref name="startIndex"/> and <paramref name="count"/> are not zero.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="count"/> is less than zero.
            <para/>
            -or-
            <para/>
            <paramref name="startIndex"/> is less than zero.
            <para/>
            -or-
            <para/>
            <paramref name="startIndex"/> + <paramref name="count"/> is greater than the length of <paramref name="value"/>.
            </exception>
            <remarks>
            LUCENENET specific method, added to simulate using the CharBuffer class in Java. Note that
            the <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.CopyBuffer(System.Char[],System.Int32,System.Int32)"/> method provides similar functionality.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.String)">
            <summary>
            Appends the specified <see cref="T:System.String"/> to this character sequence.
            <para>
            The characters of the <see cref="T:System.String"/> argument are appended, in order, increasing the length of
            this sequence by the length of the argument. If argument is <c>null</c>, this method is a no-op.
            <para/>
            This method uses .NET semantics. In Lucene, a <c>null</c> <paramref name="value"/> would append the
            string <c>"null"</c> to the instance, but in Lucene.NET a <c>null</c> value will be safely ignored.
            </para>
            </summary>
            <param name="value">The sequence of characters to append.</param>
            <remarks>
            LUCENENET specific method, added because the .NET <see cref="T:System.String"/> data type 
            doesn't implement <see cref="T:J2N.Text.ICharSequence"/>. 
            </remarks>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.String,System.Int32,System.Int32)">
            <summary>
            Appends the contents of the <see cref="T:System.String"/> to this character sequence.
            <para>
            The characters of the <see cref="T:System.String"/> argument are appended, in order, increasing the length of
            this sequence by the length of <paramref name="value"/>. If <paramref name="value"/> is <c>null</c>
            and <paramref name="startIndex"/> and <paramref name="count"/> are not 0, an
            <see cref="T:System.ArgumentNullException"/> is thrown.
            </para>
            </summary>
            <param name="value">The sequence of characters to append.</param>
            <param name="startIndex">The start index of the <see cref="T:System.String"/> to begin copying characters.</param>
            <param name="count">The number of characters to append.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <c>null</c>, and
            <paramref name="startIndex"/> and <paramref name="count"/> are not zero.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="count"/> is less than zero.
            <para/>
            -or-
            <para/>
            <paramref name="startIndex"/> is less than zero.
            <para/>
            -or-
            <para/>
            <paramref name="startIndex"/> + <paramref name="count"/> is greater than the length of <paramref name="value"/>.
            </exception>
            <remarks>
            LUCENENET specific method, added because the .NET <see cref="T:System.String"/> data type 
            doesn't implement <see cref="T:J2N.Text.ICharSequence"/>. 
            </remarks>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.Text.StringBuilder)">
            <summary>
            Appends a string representation of the specified <see cref="T:System.Text.StringBuilder"/> to this character sequence.
            <para>
            The characters of the <see cref="T:System.Text.StringBuilder"/> argument are appended, in order, increasing the length of
            this sequence by the length of the argument. If argument is <c>null</c>, this method is a no-op.
            <para/>
            This method uses .NET semantics. In Lucene, a <c>null</c> <paramref name="value"/> would append the
            string <c>"null"</c> to the instance, but in Lucene.NET a <c>null</c> value will be safely ignored.
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Appends a string representation of the specified <see cref="T:System.Text.StringBuilder"/> to this character sequence.
            <para/>The characters of the <see cref="T:System.Text.StringBuilder"/> argument are appended, in order, increasing the length of
            this sequence by the length of the argument. If <paramref name="value"/> is <c>null</c>
            and <paramref name="startIndex"/> and <paramref name="count"/> are not 0, an
            <see cref="T:System.ArgumentNullException"/> is thrown.
            </summary>
            <param name="value">The sequence of characters to append.</param>
            <param name="startIndex">The start index of the <see cref="T:System.Text.StringBuilder"/> to begin copying characters.</param>
            <param name="count">The number of characters to append.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <c>null</c>, and
            <paramref name="startIndex"/> and <paramref name="count"/> are not zero.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="count"/> is less than zero.
            <para/>
            -or-
            <para/>
            <paramref name="startIndex"/> is less than zero.
            <para/>
            -or-
            <para/>
            <paramref name="startIndex"/> + <paramref name="count"/> is greater than the length of <paramref name="value"/>.
            </exception>
            <remarks>
            LUCENENET specific method, added because the .NET <see cref="T:System.Text.StringBuilder"/> data type 
            doesn't implement <see cref="T:J2N.Text.ICharSequence"/>.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute)">
            <summary>
            Appends the contents of the other <see cref="T:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute"/> to this character sequence.
            <para/>The characters of the <see cref="T:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute"/> argument are appended, in order, increasing the length of
            this sequence by the length of the argument. If argument is <c>null</c>, this method is a no-op.
            <para/>
            This method uses .NET semantics. In Lucene, a <c>null</c> <paramref name="value"/> would append the
            string <c>"null"</c> to the instance, but in Lucene.NET a <c>null</c> value will be safely ignored.
            </summary>
            <param name="value">The sequence of characters to append.</param>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.IFlagsAttribute">
            <summary> This attribute can be used to pass different flags down the <see cref="T:Lucene.Net.Analysis.Tokenizer" /> chain,
            eg from one TokenFilter to another one.
            <para/>
            This is completely distinct from <see cref="T:Lucene.Net.Analysis.TokenAttributes.TypeAttribute"/>, although they do share similar purposes.
            The flags can be used to encode information about the token for use by other 
            <see cref="T:Lucene.Net.Analysis.TokenFilter"/>s.
            @lucene.experimental While we think this is here to stay, we may want to change it to be a long.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IFlagsAttribute.Flags">
            <summary>
            Get the bitset for any bits that have been set.
            <para/>
            This is completely distinct from <see cref="P:Lucene.Net.Analysis.TokenAttributes.ITypeAttribute.Type" />, although they do share similar purposes.
            The flags can be used to encode information about the token for use by other <see cref="T:Lucene.Net.Analysis.TokenFilter" />s.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.IKeywordAttribute">
            <summary>
            This attribute can be used to mark a token as a keyword. Keyword aware
            <see cref="T:Lucene.Net.Analysis.TokenStream"/>s can decide to modify a token based on the return value
            of <see cref="P:Lucene.Net.Analysis.TokenAttributes.IKeywordAttribute.IsKeyword"/> if the token is modified. Stemming filters for
            instance can use this attribute to conditionally skip a term if
            <see cref="P:Lucene.Net.Analysis.TokenAttributes.IKeywordAttribute.IsKeyword"/> returns <c>true</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IKeywordAttribute.IsKeyword">
            <summary>
            Gets or Sets whether the current token is a keyword. <c>true</c> if the current token is a keyword, otherwise
            <c>false</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute">
            <summary>
            The start and end character offset of a <see cref="T:Lucene.Net.Analysis.Token"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.StartOffset">
            <summary>
            Returns this <see cref="T:Lucene.Net.Analysis.Token"/>'s starting offset, the position of the first character
            corresponding to this token in the source text.
            <para/>
            Note that the difference between <see cref="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.EndOffset"/> and <see cref="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.StartOffset"/>
            may not be equal to termText.Length, as the term text may have been altered by a
            stemmer or some other filter.
            </summary>
            <seealso cref="M:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.SetOffset(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.SetOffset(System.Int32,System.Int32)">
            <summary>
            Set the starting and ending offset.
            </summary>
            <exception cref="T:System.ArgumentException"> If <paramref name="startOffset"/> or <paramref name="endOffset"/>
                    are negative, or if <paramref name="startOffset"/> is greater than
                    <paramref name="endOffset"/> </exception>
            <seealso cref="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.StartOffset"/>
            <seealso cref="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.EndOffset"/>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.EndOffset">
            <summary>
            Returns this <see cref="T:Lucene.Net.Analysis.Token"/>'s ending offset, one greater than the position of the
            last character corresponding to this token in the source text. The length
            of the token in the source text is (<code>EndOffset</code> - <see cref="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.StartOffset"/>).
            </summary>
            <seealso cref="M:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.SetOffset(System.Int32,System.Int32)"/>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.IPayloadAttribute">
            <summary>
            The payload of a Token.
            <para/>
            The payload is stored in the index at each position, and can
            be used to influence scoring when using Payload-based queries
            in the <see cref="N:Lucene.Net.Search.Payloads"/> and
            <see cref="N:Lucene.Net.Search.Spans"/> namespaces.
            <para/>
            NOTE: because the payload will be stored at each position, its usually
            best to use the minimum number of bytes necessary. Some codec implementations
            may optimize payload storage when all payloads have the same length.
            </summary>
            <seealso cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IPayloadAttribute.Payload">
            <summary>
            Gets or Sets this <see cref="T:Lucene.Net.Analysis.Token"/>'s payload.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.IPositionIncrementAttribute">
             <summary>
             Determines the position of this token
             relative to the previous <see cref="T:Lucene.Net.Analysis.Token"/> in a <see cref="T:Lucene.Net.Analysis.TokenStream"/>, used in phrase
             searching.
            
             <para/>The default value is one.
            
             <para/>Some common uses for this are:
             
             <list type="bullet">
             <item><description>Set it to zero to put multiple terms in the same position.  this is
             useful if, e.g., a word has multiple stems.  Searches for phrases
             including either stem will match.  In this case, all but the first stem's
             increment should be set to zero: the increment of the first instance
             should be one.  Repeating a token with an increment of zero can also be
             used to boost the scores of matches on that token.</description></item>
            
             <item><description>Set it to values greater than one to inhibit exact phrase matches.
             If, for example, one does not want phrases to match across removed stop
             words, then one could build a stop word filter that removes stop words and
             also sets the increment to the number of stop words removed before each
             non-stop word.  Then exact phrase queries will only match when the terms
             occur with no intervening stop words.</description></item>
             </list>
             </summary>
             <seealso cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IPositionIncrementAttribute.PositionIncrement">
            <summary>
            Gets or Sets the position increment (the distance from the prior term). The default value is one.
            </summary>
            <exception cref="T:System.ArgumentException"> if value is set to a negative value. </exception>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.IPositionLengthAttribute">
             <summary>
             Determines how many positions this
             token spans.  Very few analyzer components actually
             produce this attribute, and indexing ignores it, but
             it's useful to express the graph structure naturally
             produced by decompounding, word splitting/joining,
             synonym filtering, etc.
            
             <para/>NOTE: this is optional, and most analyzers
             don't change the default value (1).
             </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IPositionLengthAttribute.PositionLength">
            <summary>
            Gets or Sets the position length of this <see cref="T:Lucene.Net.Analysis.Token"/> (how many positions this token
            spans).
            <para/>
            The default value is one.
            </summary>
            <exception cref="T:System.ArgumentException"> if value
                    is set to zero or negative. </exception>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute">
             <summary>
             This attribute is requested by TermsHashPerField to index the contents.
             This attribute can be used to customize the final byte[] encoding of terms.
             <para/>
             Consumers of this attribute call <see cref="P:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute.BytesRef"/> up-front, and then
             invoke <see cref="M:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute.FillBytesRef"/> for each term. Example:
             <code>
               TermToBytesRefAttribute termAtt = tokenStream.GetAttribute&lt;TermToBytesRefAttribute&gt;;
               BytesRef bytes = termAtt.BytesRef;
            
               while (tokenStream.IncrementToken()
               {
                 // you must call termAtt.FillBytesRef() before doing something with the bytes.
                 // this encodes the term value (internally it might be a char[], etc) into the bytes.
                 int hashCode = termAtt.FillBytesRef();
            
                 if (IsInteresting(bytes))
                 {
                   // because the bytes are reused by the attribute (like CharTermAttribute's char[] buffer),
                   // you should make a copy if you need persistent access to the bytes, otherwise they will
                   // be rewritten across calls to IncrementToken()
            
                   DoSomethingWith(new BytesRef(bytes));
                 }
               }
               ...
             </code>
             @lucene.experimental this is a very expert API, please use
             <see cref="T:Lucene.Net.Analysis.TokenAttributes.CharTermAttribute"/> and its implementation of this method
             for UTF-8 terms.
             </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute.FillBytesRef">
            <summary>
            Updates the bytes <see cref="T:Lucene.Net.Util.BytesRef"/> to contain this term's
            final encoding.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute.BytesRef">
            <summary>
            Retrieve this attribute's <see cref="T:Lucene.Net.Util.BytesRef"/>. The bytes are updated
            from the current term when the consumer calls <see cref="M:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute.FillBytesRef"/>.
            </summary>
            <returns> this <see cref="T:Lucene.Net.Util.IAttribute"/>s internal <see cref="T:Lucene.Net.Util.BytesRef"/>. </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.ITypeAttribute">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.Token"/>'s lexical type. The Default value is "word".
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.ITypeAttribute.Type">
            <summary>
            Gets or Sets the lexical type. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.TypeAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.ITypeAttribute"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE">
            <summary>
            the default type
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.#ctor">
            <summary>
            Initialize this attribute with <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.#ctor(System.String)">
            <summary>
            Initialize this attribute with <paramref name="type"/> </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.KeywordAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.IKeywordAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.KeywordAttribute.#ctor">
            <summary>
            Initialize this attribute with the keyword value as false. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.OffsetAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.OffsetAttribute.#ctor">
            <summary>
            Initialize this attribute with startOffset and endOffset of 0. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.PayloadAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.IPayloadAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.PayloadAttribute.#ctor">
            <summary>
            Initialize this attribute with no payload.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.PayloadAttribute.#ctor(Lucene.Net.Util.BytesRef)">
            <summary>
            Initialize this attribute with the given payload.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.PositionIncrementAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.IPositionIncrementAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.PositionIncrementAttribute.#ctor">
            <summary>
            Initialize this attribute with position increment of 1 </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.PositionLengthAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.IPositionLengthAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.PositionLengthAttribute.#ctor">
            <summary>
            Initializes this attribute with position length of 1. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenFilter">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.TokenFilter"/> is a <see cref="T:Lucene.Net.Analysis.TokenStream"/> whose input is another <see cref="T:Lucene.Net.Analysis.TokenStream"/>.
            <para/>
            This is an abstract class; subclasses must override <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>.
            </summary>
            <seealso cref="T:Lucene.Net.Analysis.TokenStream"/>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenFilter.m_input">
            <summary>
            The source of tokens for this filter. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>
            Construct a token stream filtering the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.End">
            <summary>
            This method is called by the consumer after the last token has been
            consumed, after <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/> returned <c>false</c>
            (using the new <see cref="T:Lucene.Net.Analysis.TokenStream"/> API). Streams implementing the old API
            should upgrade to use this feature.
            <para/>
            This method can be used to perform any end-of-stream operations, such as
            setting the final offset of a stream. The final offset of a stream might
            differ from the offset of the last token eg in case one or more whitespaces
            followed after the last token, but a WhitespaceTokenizer was used.
            <para/>
            Additionally any skipped positions (such as those removed by a stopfilter)
            can be applied to the position increment, or any adjustment of other
            attributes where the end-of-stream value may be important.
            <para/>
            <b>NOTE:</b>
            The default implementation chains the call to the input TokenStream, so
            be sure to call <c>base.End()</c> first when overriding this method.
            </summary>
            <exception cref="T:System.IO.IOException"> If an I/O error occurs </exception>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.Dispose(System.Boolean)">
            <summary>
            Releases resources associated with this stream.
            <para/>
            If you override this method, always call <c>base.Dispose(disposing)</c>, otherwise
            some internal state will not be correctly reset (e.g., <see cref="T:Lucene.Net.Analysis.Tokenizer"/> will
            throw <see cref="T:System.InvalidOperationException"/> on reuse).
            <para/>
            <b>NOTE:</b>
            The default implementation chains the call to the input TokenStream, so
            be sure to call <c>base.Dispose(disposing)</c> when overriding this method.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.Reset">
            <summary>
            This method is called by a consumer before it begins consumption using
            <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>.
            <para/>
            Resets this stream to a clean state. Stateful implementations must implement
            this method so that they can be reused, just as if they had been created fresh.
            <para/>
            If you override this method, always call <c>base.Reset()</c>, otherwise
            some internal state will not be correctly reset (e.g., <see cref="T:Lucene.Net.Analysis.Tokenizer"/> will
            throw <see cref="T:System.InvalidOperationException"/> on further usage).
            </summary>
            <remarks>
            <b>NOTE:</b>
            The default implementation chains the call to the input <see cref="T:Lucene.Net.Analysis.TokenStream"/>, so
            be sure to call <c>base.Reset()</c> when overriding this method.
            </remarks>
        </member>
        <member name="T:Lucene.Net.Analysis.Tokenizer">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.Tokenizer"/> is a <see cref="T:Lucene.Net.Analysis.TokenStream"/> whose input is a <see cref="T:System.IO.TextReader"/>.
            <para/>
            This is an abstract class; subclasses must override <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>
            <para/>
            NOTE: Subclasses overriding <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/> must
            call <see cref="M:Lucene.Net.Util.AttributeSource.ClearAttributes"/> before
            setting attributes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Tokenizer.m_input">
            <summary>
            The text source for this <see cref="T:Lucene.Net.Analysis.Tokenizer"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Tokenizer.inputPending">
            <summary>
            Pending reader: not actually assigned to input until <see cref="M:Lucene.Net.Analysis.Tokenizer.Reset"/> </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor(System.IO.TextReader)">
            <summary>
            Construct a token stream processing the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory,System.IO.TextReader)">
            <summary>
            Construct a token stream processing the given input using the given <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.Dispose(System.Boolean)">
            <summary>
            Releases resources associated with this stream.
            <para/>
            If you override this method, always call <c>base.Dispose(disposing)</c>, otherwise
            some internal state will not be correctly reset (e.g., <see cref="T:Lucene.Net.Analysis.Tokenizer"/> will
            throw <see cref="T:System.InvalidOperationException"/> on reuse).
            </summary>
            <remarks>
            <b>NOTE:</b>
            The default implementation closes the input <see cref="T:System.IO.TextReader"/>, so
            be sure to call <c>base.Dispose(disposing)</c> when overriding this method.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.CorrectOffset(System.Int32)">
            <summary>
            Return the corrected offset. If <see cref="F:Lucene.Net.Analysis.Tokenizer.m_input"/> is a <see cref="T:Lucene.Net.Analysis.CharFilter"/> subclass
            this method calls <see cref="M:Lucene.Net.Analysis.CharFilter.CorrectOffset(System.Int32)"/>, else returns <paramref name="currentOff"/>. </summary>
            <param name="currentOff"> offset as seen in the output </param>
            <returns> corrected offset based on the input </returns>
            <seealso cref="M:Lucene.Net.Analysis.CharFilter.CorrectOffset(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.SetReader(System.IO.TextReader)">
            <summary>
            Expert: Set a new reader on the <see cref="T:Lucene.Net.Analysis.Tokenizer"/>. Typically, an
            analyzer (in its tokenStream method) will use
            this to re-use a previously created tokenizer.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenStream">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.TokenStream"/> enumerates the sequence of tokens, either from
            <see cref="T:Lucene.Net.Documents.Field"/>s of a <see cref="T:Lucene.Net.Documents.Document"/> or from query text.
            <para/>
            this is an abstract class; concrete subclasses are:
            <list type="bullet">
                <item><description><see cref="T:Lucene.Net.Analysis.Tokenizer"/>, a <see cref="T:Lucene.Net.Analysis.TokenStream"/> whose input is a <see cref="T:System.IO.TextReader"/>; and</description></item>
                <item><description><see cref="T:Lucene.Net.Analysis.TokenFilter"/>, a <see cref="T:Lucene.Net.Analysis.TokenStream"/> whose input is another
                    <see cref="T:Lucene.Net.Analysis.TokenStream"/>.</description></item>
            </list>
            A new <see cref="T:Lucene.Net.Analysis.TokenStream"/> API has been introduced with Lucene 2.9. this API
            has moved from being <see cref="T:Lucene.Net.Analysis.Token"/>-based to <see cref="T:Lucene.Net.Util.IAttribute"/>-based. While
            <see cref="T:Lucene.Net.Analysis.Token"/> still exists in 2.9 as a convenience class, the preferred way
            to store the information of a <see cref="T:Lucene.Net.Analysis.Token"/> is to use <see cref="T:System.Attribute"/>s.
            <para/>
            <see cref="T:Lucene.Net.Analysis.TokenStream"/> now extends <see cref="T:Lucene.Net.Util.AttributeSource"/>, which provides
            access to all of the token <see cref="T:Lucene.Net.Util.IAttribute"/>s for the <see cref="T:Lucene.Net.Analysis.TokenStream"/>.
            Note that only one instance per <see cref="T:System.Attribute"/> is created and reused
            for every token. This approach reduces object creation and allows local
            caching of references to the <see cref="T:System.Attribute"/>s. See
            <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/> for further details.
            <para/>
            <b>The workflow of the new <see cref="T:Lucene.Net.Analysis.TokenStream"/> API is as follows:</b>
            <list type="number">
                <item><description>Instantiation of <see cref="T:Lucene.Net.Analysis.TokenStream"/>/<see cref="T:Lucene.Net.Analysis.TokenFilter"/>s which add/get
                    attributes to/from the <see cref="T:Lucene.Net.Util.AttributeSource"/>.</description></item>
                <item><description>The consumer calls <see cref="M:Lucene.Net.Analysis.TokenStream.Reset"/>.</description></item>
                <item><description>The consumer retrieves attributes from the stream and stores local
                    references to all attributes it wants to access.</description></item>
                <item><description>The consumer calls <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/> until it returns false
                    consuming the attributes after each call.</description></item>
                <item><description>The consumer calls <see cref="M:Lucene.Net.Analysis.TokenStream.End"/> so that any end-of-stream operations
                    can be performed.</description></item>
                <item><description>The consumer calls <see cref="M:Lucene.Net.Analysis.TokenStream.Dispose"/> to release any resource when finished
                    using the <see cref="T:Lucene.Net.Analysis.TokenStream"/>.</description></item>
            </list>
            To make sure that filters and consumers know which attributes are available,
            the attributes must be added during instantiation. Filters and consumers are
            not required to check for availability of attributes in
            <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>.
            <para/>
            You can find some example code for the new API in the analysis 
            documentation.
            <para/>
            Sometimes it is desirable to capture a current state of a <see cref="T:Lucene.Net.Analysis.TokenStream"/>,
            e.g., for buffering purposes (see <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/>,
            TeeSinkTokenFilter). For this usecase
            <see cref="M:Lucene.Net.Util.AttributeSource.CaptureState"/> and <see cref="M:Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State)"/>
            can be used.
            <para/>The <see cref="T:Lucene.Net.Analysis.TokenStream"/>-API in Lucene is based on the decorator pattern.
            Therefore all non-abstract subclasses must be sealed or have at least a sealed
            implementation of <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>! This is checked when assertions are enabled.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.#ctor">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.TokenStream"/> using the default attribute factory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.#ctor(Lucene.Net.Util.AttributeSource)">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.TokenStream"/> that uses the same attributes as the supplied one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory)">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.TokenStream"/> using the supplied <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/> 
            for creating new <see cref="T:Lucene.Net.Util.IAttribute"/> instances.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.IncrementToken">
            <summary>
            Consumers (i.e., <see cref="T:Lucene.Net.Index.IndexWriter"/>) use this method to advance the stream to
            the next token. Implementing classes must implement this method and update
            the appropriate <see cref="T:Lucene.Net.Util.IAttribute"/>s with the attributes of the next
            token.
            <para/>
            The producer must make no assumptions about the attributes after the method
            has been returned: the caller may arbitrarily change it. If the producer
            needs to preserve the state for subsequent calls, it can use
            <see cref="M:Lucene.Net.Util.AttributeSource.CaptureState"/> to create a copy of the current attribute state.
            <para/>
            this method is called for every token of a document, so an efficient
            implementation is crucial for good performance. To avoid calls to
            <see cref="M:Lucene.Net.Util.AttributeSource.AddAttribute``1"/> and <see cref="M:Lucene.Net.Util.AttributeSource.GetAttribute``1"/>,
            references to all <see cref="T:Lucene.Net.Util.IAttribute"/>s that this stream uses should be
            retrieved during instantiation.
            <para/>
            To ensure that filters and consumers know which attributes are available,
            the attributes must be added during instantiation. Filters and consumers
            are not required to check for availability of attributes in
            <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>.
            </summary>
            <returns> false for end of stream; true otherwise </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.End">
            <summary>
            This method is called by the consumer after the last token has been
            consumed, after <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/> returned <c>false</c>
            (using the new <see cref="T:Lucene.Net.Analysis.TokenStream"/> API). Streams implementing the old API
            should upgrade to use this feature.
            <para/>
            This method can be used to perform any end-of-stream operations, such as
            setting the final offset of a stream. The final offset of a stream might
            differ from the offset of the last token eg in case one or more whitespaces
            followed after the last token, but a WhitespaceTokenizer was used.
            <para/>
            Additionally any skipped positions (such as those removed by a stopfilter)
            can be applied to the position increment, or any adjustment of other
            attributes where the end-of-stream value may be important.
            <para/>
            If you override this method, always call <c>base.End();</c>.
            </summary>
            <exception cref="T:System.IO.IOException"> If an I/O error occurs </exception>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.Reset">
            <summary>
            This method is called by a consumer before it begins consumption using
            <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>.
            <para/>
            Resets this stream to a clean state. Stateful implementations must implement
            this method so that they can be reused, just as if they had been created fresh.
            <para/>
            If you override this method, always call <c>base.Reset()</c>, otherwise
            some internal state will not be correctly reset (e.g., <see cref="T:Lucene.Net.Analysis.Tokenizer"/> will
            throw <see cref="T:System.InvalidOperationException"/> on further usage).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.Dispose(System.Boolean)">
            <summary>
            Releases resources associated with this stream.
            <para/>
            If you override this method, always call <c>base.Dispose(disposing)</c>, otherwise
            some internal state will not be correctly reset (e.g., <see cref="T:Lucene.Net.Analysis.Tokenizer"/> will
            throw <see cref="T:System.InvalidOperationException"/> on reuse).
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenStreamToAutomaton">
             <summary>
             Consumes a <see cref="T:Lucene.Net.Analysis.TokenStream"/> and creates an <see cref="T:Lucene.Net.Util.Automaton.Automaton"/>
             where the transition labels are UTF8 bytes (or Unicode
             code points if unicodeArcs is true) from the <see cref="T:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute"/>.
             Between tokens we insert
             <see cref="F:Lucene.Net.Analysis.TokenStreamToAutomaton.POS_SEP"/> and for holes we insert <see cref="F:Lucene.Net.Analysis.TokenStreamToAutomaton.HOLE"/>.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamToAutomaton.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenStreamToAutomaton.PreservePositionIncrements">
            <summary>
            Whether to generate holes in the automaton for missing positions, <c>true</c> by default. </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenStreamToAutomaton.UnicodeArcs">
            <summary>
            Whether to make transition labels Unicode code points instead of UTF8 bytes,
            <c>false</c> by default
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamToAutomaton.ChangeToken(Lucene.Net.Util.BytesRef)">
            <summary>
            Subclass &amp; implement this if you need to change the
            token (such as escaping certain bytes) before it's
            turned into a graph.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenStreamToAutomaton.POS_SEP">
            <summary>
            We create transition between two adjacent tokens. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenStreamToAutomaton.HOLE">
            <summary>
            We add this arc to represent a hole. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamToAutomaton.ToAutomaton(Lucene.Net.Analysis.TokenStream)">
            <summary>
            Pulls the graph (including <see cref="T:Lucene.Net.Analysis.TokenAttributes.IPositionLengthAttribute"/>
            from the provided <see cref="T:Lucene.Net.Analysis.TokenStream"/>, and creates the corresponding
            automaton where arcs are bytes (or Unicode code points
            if unicodeArcs = true) from each term.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.BlockTermState">
            <summary>
            Holds all state required for <see cref="T:Lucene.Net.Codecs.PostingsReaderBase"/>
            to produce a <see cref="T:Lucene.Net.Index.DocsEnum"/> without re-seeking the
            terms dict.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTermState.DocFreq">
            <summary>
            How many docs have this term? </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTermState.TotalTermFreq">
            <summary>
            Total number of occurrences of this term. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTermState.TermBlockOrd">
            <summary>
            The term's ord in the current block. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTermState.BlockFilePointer">
            <summary>
            File pointer into the terms dict primary file (_X.tim) that holds this term. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTermState.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.BlockTreeTermsReader">
             <summary>
             A block-based terms index and dictionary that assigns
             terms to variable length blocks according to how they
             share prefixes.  The terms index is a prefix trie
             whose leaves are term blocks.  The advantage of this
             approach is that SeekExact() is often able to
             determine a term cannot exist without doing any IO, and
             intersection with Automata is very fast.  Note that this
             terms dictionary has it's own fixed terms index (ie, it
             does not support a pluggable terms index
             implementation).
            
             <para><b>NOTE</b>: this terms dictionary does not support
             index divisor when opening an IndexReader.  Instead, you
             can change the min/maxItemsPerBlock during indexing.</para>
            
             <para>The data structure used by this implementation is very
             similar to a burst trie
             (http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.3499),
             but with added logic to break up too-large blocks of all
             terms sharing a given prefix into smaller ones.</para>
            
             <para>Use <see cref="T:Lucene.Net.Index.CheckIndex"/> with the <c>-verbose</c>
             option to see summary statistics on the blocks in the
             dictionary.</para>
            
             See <see cref="T:Lucene.Net.Codecs.BlockTreeTermsWriter"/>.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.dirOffset">
            <summary>
            File offset where the directory starts in the terms file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.indexDirOffset">
            <summary>
            File offset where the directory starts in the index file. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.FieldInfos,Lucene.Net.Index.SegmentInfo,Lucene.Net.Codecs.PostingsReaderBase,Lucene.Net.Store.IOContext,System.String,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.ReadHeader(Lucene.Net.Store.IndexInput)">
            <summary>
            Reads terms file header. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.ReadIndexHeader(Lucene.Net.Store.IndexInput)">
            <summary>
            Reads index file header. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.SeekDir(Lucene.Net.Store.IndexInput,System.Int64)">
            <summary>
            Seek <paramref name="input"/> to the directory offset. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.Dispose(System.Boolean)">
            <summary>
            Disposes all resources used by this object.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.BlockTreeTermsReader.Stats">
            <summary>
            BlockTree statistics for a single field
            returned by <see cref="M:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.ComputeStats"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.IndexNodeCount">
            <summary>
            How many nodes in the index FST. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.IndexArcCount">
            <summary>
            How many arcs in the index FST. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.IndexNumBytes">
            <summary>
            Byte size of the index. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalTermCount">
            <summary>
            Total number of terms in the field. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalTermBytes">
            <summary>
            Total number of bytes (sum of term lengths) across all terms in the field. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.NonFloorBlockCount">
            <summary>
            The number of normal (non-floor) blocks in the terms file. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.FloorBlockCount">
            <summary>
            The number of floor blocks (meta-blocks larger than the
             allowed <c>maxItemsPerBlock</c>) in the terms file.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.FloorSubBlockCount">
            <summary>
            The number of sub-blocks within the floor blocks. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.MixedBlockCount">
            <summary>
            The number of "internal" blocks (that have both
             terms and sub-blocks).
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TermsOnlyBlockCount">
            <summary>
            The number of "leaf" blocks (blocks that have only
             terms).
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.SubBlocksOnlyBlockCount">
            <summary>
            The number of "internal" blocks that do not contain
             terms (have only sub-blocks).
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalBlockCount">
            <summary>
            Total number of blocks. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.BlockCountByPrefixLen">
            <summary>
            Number of blocks at each prefix depth. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalBlockSuffixBytes">
            <summary>
            Total number of bytes used to store term suffixes. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalBlockStatsBytes">
            <summary>
            Total number of bytes used to store term stats (not
            including what the <see cref="T:Lucene.Net.Codecs.PostingsBaseFormat"/>
            stores.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalBlockOtherBytes">
            <summary>
            Total bytes stored by the <see cref="T:Lucene.Net.Codecs.PostingsBaseFormat"/>,
            plus the other few vInts stored in the frame.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.Segment">
            <summary>
            Segment name. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.Field">
            <summary>
            Field name. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader">
            <summary>
            BlockTree's implementation of <see cref="M:Lucene.Net.Codecs.BlockTreeTermsReader.GetTerms(System.String)"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.ComputeStats">
            <summary>
            For debugging -- used by CheckIndex too </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.IntersectEnum.Frame.Int64s">
            <summary>
            NOTE: This was longs (field) in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.SegmentTermsEnum.ComputeBlockStats">
            <summary>
            Runs next() through the entire terms dict,
             computing aggregate statistics.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.SegmentTermsEnum.Frame.Int64s">
            <summary>
            NOTE: This was longs (field) in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.SegmentTermsEnum.Frame.LoadBlock">
            <summary>
            Does initial decode of next block of terms; this
            doesn't actually decode the docFreq, totalTermFreq,
            postings details (frq/prx offset, etc.) metadata;
            it just loads them as byte[] blobs which are then
            decoded on-demand if the metadata is ever requested
            for any term in this block.  this enables terms-only
            intensive consumes (eg certain MTQs, respelling) to
            not pay the price of decoding metadata they won't
            use.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.SegmentTermsEnum.Frame.ScanToSubBlock(System.Int64)">
            <summary>
            Scans to sub-block that has this target fp; only
            called by Next(); NOTE: does not set
            startBytePos/suffix as a side effect
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.BlockTreeTermsWriter">
             <summary>
             Block-based terms index and dictionary writer.
             <para/>
             Writes terms dict and index, block-encoding (column
             stride) each term's metadata for each set of terms
             between two index terms.
             <para/>
             Files:
             <list type="bullet">
                 <item><term>.tim:</term> <description><a href="#Termdictionary">Term Dictionary</a></description></item>
                 <item><term>.tip:</term> <description><a href="#Termindex">Term Index</a></description></item>
             </list>
             <para/>
             <a name="Termdictionary" id="Termdictionary"></a>
             <h3>Term Dictionary</h3>
            
             <para>The .tim file contains the list of terms in each
             field along with per-term statistics (such as docfreq)
             and per-term metadata (typically pointers to the postings list
             for that term in the inverted index).
             </para>
            
             <para>The .tim is arranged in blocks: with blocks containing
             a variable number of entries (by default 25-48), where
             each entry is either a term or a reference to a
             sub-block.</para>
            
             <para>NOTE: The term dictionary can plug into different postings implementations:
             the postings writer/reader are actually responsible for encoding
             and decoding the Postings Metadata and Term Metadata sections.</para>
            
             <list type="bullet">
                <item><description>TermsDict (.tim) --&gt; Header, <i>PostingsHeader</i>, NodeBlock<sup>NumBlocks</sup>,
                                           FieldSummary, DirOffset, Footer</description></item>
                <item><description>NodeBlock --&gt; (OuterNode | InnerNode)</description></item>
                <item><description>OuterNode --&gt; EntryCount, SuffixLength, Byte<sup>SuffixLength</sup>, StatsLength, &lt; TermStats &gt;<sup>EntryCount</sup>, MetaLength, &lt;<i>TermMetadata</i>&gt;<sup>EntryCount</sup></description></item>
                <item><description>InnerNode --&gt; EntryCount, SuffixLength[,Sub?], Byte<sup>SuffixLength</sup>, StatsLength, &lt; TermStats ? &gt;<sup>EntryCount</sup>, MetaLength, &lt;<i>TermMetadata ? </i>&gt;<sup>EntryCount</sup></description></item>
                <item><description>TermStats --&gt; DocFreq, TotalTermFreq </description></item>
                <item><description>FieldSummary --&gt; NumFields, &lt;FieldNumber, NumTerms, RootCodeLength, Byte<sup>RootCodeLength</sup>,
                                        SumTotalTermFreq?, SumDocFreq, DocCount&gt;<sup>NumFields</sup></description></item>
                <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/></description></item>
                <item><description>DirOffset --&gt; Uint64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>)</description></item>
                <item><description>EntryCount,SuffixLength,StatsLength,DocFreq,MetaLength,NumFields,
                    FieldNumber,RootCodeLength,DocCount --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>_</description></item>
                <item><description>TotalTermFreq,NumTerms,SumTotalTermFreq,SumDocFreq --&gt;
                    VLong (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>)</description></item>
                <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>)</description></item>
             </list>
             <para>Notes:</para>
             <list type="bullet">
                <item><description>Header is a CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) storing the version information
                    for the BlockTree implementation.</description></item>
                <item><description>DirOffset is a pointer to the FieldSummary section.</description></item>
                <item><description>DocFreq is the count of documents which contain the term.</description></item>
                <item><description>TotalTermFreq is the total number of occurrences of the term. this is encoded
                    as the difference between the total number of occurrences and the DocFreq.</description></item>
                <item><description>FieldNumber is the fields number from <see cref="F:Lucene.Net.Codecs.BlockTreeTermsWriter.fieldInfos"/>. (.fnm)</description></item>
                <item><description>NumTerms is the number of unique terms for the field.</description></item>
                <item><description>RootCode points to the root block for the field.</description></item>
                <item><description>SumDocFreq is the total number of postings, the number of term-document pairs across
                    the entire field.</description></item>
                <item><description>DocCount is the number of documents that have at least one posting for this field.</description></item>
                <item><description>PostingsHeader and TermMetadata are plugged into by the specific postings implementation:
                    these contain arbitrary per-file data (such as parameters or versioning information)
                    and per-term data (such as pointers to inverted files).</description></item>
                <item><description>For inner nodes of the tree, every entry will steal one bit to mark whether it points
                    to child nodes(sub-block). If so, the corresponding <see cref="T:Lucene.Net.Codecs.TermStats"/> and TermMetadata are omitted </description></item>
             </list>
             <a name="Termindex" id="Termindex"></a>
             <h3>Term Index</h3>
             <para>The .tip file contains an index into the term dictionary, so that it can be
             accessed randomly.  The index is also used to determine
             when a given term cannot exist on disk (in the .tim file), saving a disk seek.</para>
             <list type="bullet">
               <item><description>TermsIndex (.tip) --&gt; Header, FSTIndex<sup>NumFields</sup>
                                            &lt;IndexStartFP&gt;<sup>NumFields</sup>, DirOffset, Footer</description></item>
               <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>)</description></item>
               <item><description>DirOffset --&gt; Uint64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/></description>)</item>
               <item><description>IndexStartFP --&gt; VLong (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/></description>)</item>
               <!-- TODO: better describe FST output here -->
               <item><description>FSTIndex --&gt; <see cref="T:FST{byte[]}"/></description></item>
               <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/></description></item>
             </list>
             <para>Notes:</para>
             <list type="bullet">
               <item><description>The .tip file contains a separate FST for each
                   field.  The FST maps a term prefix to the on-disk
                   block that holds all terms starting with that
                   prefix.  Each field's IndexStartFP points to its
                   FST.</description></item>
               <item><description>DirOffset is a pointer to the start of the IndexStartFPs
                   for all fields</description></item>
               <item><description>It's possible that an on-disk block would contain
                   too many terms (more than the allowed maximum
                   (default: 48)).  When this happens, the block is
                   sub-divided into new blocks (called "floor
                   blocks"), and then the output in the FST for the
                   block's prefix encodes the leading byte of each
                   sub-block, and its file pointer.</description></item>
             </list>
             <para/>
             @lucene.experimental
             </summary>
             <seealso cref="T:Lucene.Net.Codecs.BlockTreeTermsReader"/>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.DEFAULT_MIN_BLOCK_SIZE">
            <summary>
            Suggested default value for the 
            <c>minItemsInBlock</c> parameter to 
            <see cref="M:Lucene.Net.Codecs.BlockTreeTermsWriter.#ctor(Lucene.Net.Index.SegmentWriteState,Lucene.Net.Codecs.PostingsWriterBase,System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.DEFAULT_MAX_BLOCK_SIZE">
            <summary>
            Suggested default value for the 
            <c>maxItemsInBlock</c> parameter to 
            <see cref="M:Lucene.Net.Codecs.BlockTreeTermsWriter.#ctor(Lucene.Net.Index.SegmentWriteState,Lucene.Net.Codecs.PostingsWriterBase,System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.TERMS_EXTENSION">
            <summary>
            Extension of terms file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_START">
            <summary>
            Initial terms format. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_APPEND_ONLY">
            <summary>
            Append-only </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_META_ARRAY">
            <summary>
            Meta data as array. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_CHECKSUM">
            <summary>
            Checksums. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_CURRENT">
            <summary>
            Current terms format. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.TERMS_INDEX_EXTENSION">
            <summary>
            Extension of terms index file. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsWriter.FieldMetaData.Int64sSize">
            <summary>
            NOTE: This was longsSize (field) in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.#ctor(Lucene.Net.Index.SegmentWriteState,Lucene.Net.Codecs.PostingsWriterBase,System.Int32,System.Int32)">
            <summary>
            Create a new writer.  The number of items (terms or
            sub-blocks) per block will aim to be between
            <paramref name="minItemsInBlock"/> and <paramref name="maxItemsInBlock"/>, though in some
            cases the blocks may be smaller than the min.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.WriteHeader(Lucene.Net.Store.IndexOutput)">
            <summary>
            Writes the terms file header. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.WriteIndexHeader(Lucene.Net.Store.IndexOutput)">
            <summary>
            Writes the index file header. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.WriteTrailer(Lucene.Net.Store.IndexOutput,System.Int64)">
            <summary>
            Writes the terms file trailer. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.WriteIndexTrailer(Lucene.Net.Store.IndexOutput,System.Int64)">
            <summary>
            Writes the index file trailer. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.Dispose(System.Boolean)">
            <summary>
            Disposes all resources used by this object.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Codec">
            <summary>
            Encodes/decodes an inverted index segment.
            <para/>
            Note, when extending this class, the name (<see cref="P:Lucene.Net.Codecs.Codec.Name"/>) is
            written into the index. In order for the segment to be read, the
            name must resolve to your implementation via <see cref="M:Lucene.Net.Codecs.Codec.ForName(System.String)"/>.
            This method uses <see cref="M:Lucene.Net.Codecs.ICodecFactory.GetCodec(System.String)"/> to resolve codec names.
            <para/>
            To implement your own codec:
            <list type="number">
                <item><description>Subclass this class.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/>, override the <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.Initialize"/> method,
                    and add the line <c>base.ScanForCodecs(typeof(YourCodec).GetTypeInfo().Assembly)</c>. 
                    If you have any codec classes in your assembly 
                    that are not meant for reading, you can add the <see cref="T:Lucene.Net.Codecs.ExcludeCodecFromScanAttribute"/> 
                    to them so they are ignored by the scan.</description></item>
                <item><description>set the new <see cref="T:Lucene.Net.Codecs.ICodecFactory"/> by calling <see cref="M:Lucene.Net.Codecs.Codec.SetCodecFactory(Lucene.Net.Codecs.ICodecFactory)"/> at application startup.</description></item>
            </list>
            If your codec has dependencies, you may also override <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodec(System.Type)"/> to inject 
            them via pure DI or a DI container. See <a href="http://blog.ploeh.dk/2014/05/19/di-friendly-framework/">DI-Friendly Framework</a>
            to understand the approach used.
            <para/>
            <b>Codec Names</b>
            <para/>
            Unlike the Java version, codec names are by default convention-based on the class name. 
            If you name your custom codec class "MyCustomCodec", the codec name will the same name 
            without the "Codec" suffix: "MyCustom".
            <para/>
            You can override this default behavior by using the <see cref="T:Lucene.Net.Codecs.CodecNameAttribute"/> to
            name the codec differently than this convention. Codec names must be all ASCII alphanumeric, 
            and less than 128 characters in length.
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.ICodecFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.CodecNameAttribute"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.SetCodecFactory(Lucene.Net.Codecs.ICodecFactory)">
            <summary>
            Sets the <see cref="T:Lucene.Net.Codecs.ICodecFactory"/> instance used to instantiate
            <see cref="T:Lucene.Net.Codecs.Codec"/> subclasses.
            </summary>
            <param name="codecFactory">The new <see cref="T:Lucene.Net.Codecs.ICodecFactory"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="codecFactory"/> parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.GetCodecFactory">
            <summary>
            Gets the associated codec factory.
            </summary>
            <returns>The codec factory.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.#ctor">
            <summary>
            Creates a new codec.
            <para/>
            The <see cref="P:Lucene.Net.Codecs.Codec.Name"/> will be written into the index segment: in order for
            the segment to be read this class should be registered by subclassing <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/> and
            calling <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.ScanForCodecs(System.Reflection.Assembly)"/> in the class constructor. 
            The new <see cref="T:Lucene.Net.Codecs.ICodecFactory"/> can be registered by calling <see cref="M:Lucene.Net.Codecs.Codec.SetCodecFactory(Lucene.Net.Codecs.ICodecFactory)"/> at application startup.</summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.Name">
            <summary>
            Returns this codec's name. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.PostingsFormat">
            <summary>
            Encodes/decodes postings. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.DocValuesFormat">
            <summary>
            Encodes/decodes docvalues. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.StoredFieldsFormat">
            <summary>
            Encodes/decodes stored fields. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.TermVectorsFormat">
            <summary>
            Encodes/decodes term vectors. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.FieldInfosFormat">
            <summary>
            Encodes/decodes field infos file. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.SegmentInfoFormat">
            <summary>
            Encodes/decodes segment info file. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.NormsFormat">
            <summary>
            Encodes/decodes document normalization values. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.LiveDocsFormat">
            <summary>
            Encodes/decodes live docs. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.ForName(System.String)">
            <summary>
            Looks up a codec by name. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.AvailableCodecs">
            <summary>
            Returns a list of all available codec names. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.Default">
            <summary>
            Expert: returns the default codec used for newly created
            <seealso cref="T:Lucene.Net.Index.IndexWriterConfig"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.ToString">
            <summary>
            Returns the codec's name. Subclasses can override to provide
            more detail (such as parameters).
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.CodecUtil">
            <summary>
            Utility class for reading and writing versioned headers.
            <para/>
            Writing codec headers is useful to ensure that a file is in
            the format you think it is.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.CodecUtil.CODEC_MAGIC">
            <summary>
            Constant to identify the start of a codec header.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.CodecUtil.FOOTER_MAGIC">
            <summary>
            Constant to identify the start of a codec footer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)">
            <summary>
            Writes a codec header, which records both a string to
            identify the file and a version number. This header can
            be parsed and validated with
            <see cref="M:Lucene.Net.Codecs.CodecUtil.CheckHeader(Lucene.Net.Store.DataInput,System.String,System.Int32,System.Int32)"/>.
            <para/>
            CodecHeader --&gt; Magic,CodecName,Version
            <list type="bullet">
               <item><description>Magic --&gt; Uint32 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>). this
                   identifies the start of the header. It is always <see cref="F:Lucene.Net.Codecs.CodecUtil.CODEC_MAGIC"/>.</description></item>
               <item><description>CodecName --&gt; String (<see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>). this
                   is a string to identify this file.</description></item>
               <item><description>Version --&gt; Uint32 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>). Records
                   the version of the file.</description></item>
            </list>
            <para/>
            Note that the length of a codec header depends only upon the
            name of the codec, so this length can be computed at any time
            with <see cref="M:Lucene.Net.Codecs.CodecUtil.HeaderLength(System.String)"/>.
            </summary>
            <param name="out"> Output stream </param>
            <param name="codec"> String to identify this file. It should be simple ASCII,
                         less than 128 characters in length. </param>
            <param name="version"> Version number </param>
            <exception cref="T:System.IO.IOException"> If there is an I/O error writing to the underlying medium. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.HeaderLength(System.String)">
            <summary>
            Computes the length of a codec header.
            </summary>
            <param name="codec"> Codec name. </param>
            <returns> Length of the entire codec header. </returns>
            <seealso cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.CheckHeader(Lucene.Net.Store.DataInput,System.String,System.Int32,System.Int32)">
            <summary>
            Reads and validates a header previously written with
            <see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>.
            <para/>
            When reading a file, supply the expected <paramref name="codec"/> and
            an expected version range (<paramref name="minVersion"/> to <paramref name="maxVersion"/>).
            </summary>
            <param name="in"> Input stream, positioned at the point where the
                   header was previously written. Typically this is located
                   at the beginning of the file. </param>
            <param name="codec"> The expected codec name. </param>
            <param name="minVersion"> The minimum supported expected version number. </param>
            <param name="maxVersion"> The maximum supported expected version number. </param>
            <returns> The actual version found, when a valid header is found
                    that matches <paramref name="codec"/>, with an actual version
                    where <c>minVersion &lt;= actual &lt;= maxVersion</c>.
                    Otherwise an exception is thrown. </returns>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> If the first four bytes are not
                    <see cref="F:Lucene.Net.Codecs.CodecUtil.CODEC_MAGIC"/>, or if the actual codec found is
                    not <paramref name="codec"/>. </exception>
            <exception cref="T:Lucene.Net.Index.IndexFormatTooOldException"> If the actual version is less
                    than <paramref name="minVersion"/>. </exception>
            <exception cref="T:Lucene.Net.Index.IndexFormatTooNewException"> If the actual version is greater
                    than <paramref name="maxVersion"/>. </exception>
            <exception cref="T:System.IO.IOException"> If there is an I/O error reading from the underlying medium. </exception>
            <seealso cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.CheckHeaderNoMagic(Lucene.Net.Store.DataInput,System.String,System.Int32,System.Int32)">
            <summary>
            Like 
            <see cref="M:Lucene.Net.Codecs.CodecUtil.CheckHeader(Lucene.Net.Store.DataInput,System.String,System.Int32,System.Int32)"/> except this
            version assumes the first <see cref="T:System.Int32"/> has already been read
            and validated from the input.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)">
            <summary>
            Writes a codec footer, which records both a checksum
            algorithm ID and a checksum. This footer can
            be parsed and validated with
            <see cref="M:Lucene.Net.Codecs.CodecUtil.CheckFooter(Lucene.Net.Store.ChecksumIndexInput)"/>.
            <para/>
            CodecFooter --&gt; Magic,AlgorithmID,Checksum
            <list type="bullet">
               <item><description>Magic --&gt; Uint32 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>). this
                   identifies the start of the footer. It is always <see cref="F:Lucene.Net.Codecs.CodecUtil.FOOTER_MAGIC"/>.</description></item>
               <item><description>AlgorithmID --&gt; Uint32 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>). this
                   indicates the checksum algorithm used. Currently this is always 0,
                   for zlib-crc32.</description></item>
               <item><description>Checksum --&gt; Uint32 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>). The
                   actual checksum value for all previous bytes in the stream, including
                   the bytes from Magic and AlgorithmID.</description></item>
            </list>
            </summary>
            <param name="out"> Output stream </param>
            <exception cref="T:System.IO.IOException"> If there is an I/O error writing to the underlying medium. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.FooterLength">
            <summary>
            Computes the length of a codec footer.
            </summary>
            <returns> Length of the entire codec footer. </returns>
            <seealso cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.CheckFooter(Lucene.Net.Store.ChecksumIndexInput)">
            <summary>
            Validates the codec footer previously written by <see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>. </summary>
            <returns> Actual checksum value. </returns>
            <exception cref="T:System.IO.IOException"> If the footer is invalid, if the checksum does not match,
                                or if <paramref name="in"/> is not properly positioned before the footer
                                at the end of the stream. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.RetrieveChecksum(Lucene.Net.Store.IndexInput)">
            <summary>
            Returns (but does not validate) the checksum previously written by <see cref="M:Lucene.Net.Codecs.CodecUtil.CheckFooter(Lucene.Net.Store.ChecksumIndexInput)"/>. </summary>
            <returns> actual checksum value </returns>
            <exception cref="T:System.IO.IOException"> If the footer is invalid. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.CheckEOF(Lucene.Net.Store.IndexInput)">
            <summary>
            Checks that the stream is positioned at the end, and throws exception
            if it is not. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.ChecksumEntireFile(Lucene.Net.Store.IndexInput)">
            <summary>
            Clones the provided input, reads all bytes from the file, and calls <see cref="M:Lucene.Net.Codecs.CodecUtil.CheckFooter(Lucene.Net.Store.ChecksumIndexInput)"/>
            <para/>
            Note that this method may be slow, as it must process the entire file.
            If you just need to extract the checksum value, call <see cref="M:Lucene.Net.Codecs.CodecUtil.RetrieveChecksum(Lucene.Net.Store.IndexInput)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat">
            <summary>
            A <see cref="T:Lucene.Net.Codecs.StoredFieldsFormat"/> that is very similar to
            <see cref="T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat"/> but compresses documents in chunks in
            order to improve the compression ratio.
            <para/>
            For a chunk size of <c>chunkSize</c> bytes, this <see cref="T:Lucene.Net.Codecs.StoredFieldsFormat"/>
            does not support documents larger than (<c>2<sup>31</sup> - chunkSize</c>)
            bytes. In case this is a problem, you should use another format, such as
            <see cref="T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat"/>.
            <para/>
            For optimal performance, you should use a <see cref="T:Lucene.Net.Index.MergePolicy"/> that returns
            segments that have the biggest byte size first.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat.#ctor(System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat"/> with an empty segment
            suffix.
            </summary>
            <seealso cref="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat.#ctor(System.String,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat.#ctor(System.String,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat"/>.
            <para/>
            <paramref name="formatName"/> is the name of the format. This name will be used
            in the file formats to perform
            codec header checks (<see cref="M:Lucene.Net.Codecs.CodecUtil.CheckHeader(Lucene.Net.Store.DataInput,System.String,System.Int32,System.Int32)"/>).
            <para/>
            <paramref name="segmentSuffix"/> is the segment suffix. this suffix is added to
            the result file name only if it's not the empty string.
            <para/>
            The <paramref name="compressionMode"/> parameter allows you to choose between
            compression algorithms that have various compression and decompression
            speeds so that you can pick the one that best fits your indexing and
            searching throughput. You should never instantiate two
            <see cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat"/>s that have the same name but
            different <see cref="F:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat.compressionMode"/>s.
            <para/>
            <paramref name="chunkSize"/> is the minimum byte size of a chunk of documents.
            A value of <c>1</c> can make sense if there is redundancy across
            fields. In that case, both performance and compression ratio should be
            better than with <see cref="T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat"/> with compressed
            fields.
            <para/>
            Higher values of <paramref name="chunkSize"/> should improve the compression
            ratio but will require more memory at indexing time and might make document
            loading a little slower (depending on the size of your OS cache compared
            to the size of your index).
            </summary>
            <param name="formatName"> The name of the <see cref="T:Lucene.Net.Codecs.StoredFieldsFormat"/>. </param>
            <param name="segmentSuffix"></param>
            <param name="compressionMode"> The <see cref="T:Lucene.Net.Codecs.Compressing.CompressionMode"/> to use. </param>
            <param name="chunkSize"> The minimum number of bytes of a single chunk of stored documents. </param>
            <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressionMode"/>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexReader">
            <summary>
            Random-access reader for <see cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexWriter"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexWriter">
            <summary>
            Efficient index format for block-based <see cref="T:Lucene.Net.Codecs.Codec"/>s.
            <para/> this writer generates a file which can be loaded into memory using
            memory-efficient data structures to quickly locate the block that contains
            any document.
            <para>In order to have a compact in-memory representation, for every block of
            1024 chunks, this index computes the average number of bytes per
            chunk and for every chunk, only stores the difference between
            <list type="bullet">
            <li>${chunk number} * ${average length of a chunk}</li>
            <li>and the actual start offset of the chunk</li>
            </list>
            </para>
            <para>Data is written as follows:</para>
            <list type="bullet">
            <li>PackedIntsVersion, &lt;Block&gt;<sup>BlockCount</sup>, BlocksEndMarker</li>
            <li>PackedIntsVersion --&gt; <see cref="F:Lucene.Net.Util.Packed.PackedInt32s.VERSION_CURRENT"/> as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </li>
            <li>BlocksEndMarker --&gt; <tt>0</tt> as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) , this marks the end of blocks since blocks are not allowed to start with <tt>0</tt></li>
            <li>Block --&gt; BlockChunks, &lt;DocBases&gt;, &lt;StartPointers&gt;</li>
            <li>BlockChunks --&gt; a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>)  which is the number of chunks encoded in the block</li>
            <li>DocBases --&gt; DocBase, AvgChunkDocs, BitsPerDocBaseDelta, DocBaseDeltas</li>
            <li>DocBase --&gt; first document ID of the block of chunks, as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </li>
            <li>AvgChunkDocs --&gt; average number of documents in a single chunk, as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </li>
            <li>BitsPerDocBaseDelta --&gt; number of bits required to represent a delta from the average using <a href="https://developers.google.com/protocol-buffers/docs/encoding#types">ZigZag encoding</a></li>
            <li>DocBaseDeltas --&gt; packed (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>) array of BlockChunks elements of BitsPerDocBaseDelta bits each, representing the deltas from the average doc base using <a href="https://developers.google.com/protocol-buffers/docs/encoding#types">ZigZag encoding</a>.</li>
            <li>StartPointers --&gt; StartPointerBase, AvgChunkSize, BitsPerStartPointerDelta, StartPointerDeltas</li>
            <li>StartPointerBase --&gt; the first start pointer of the block, as a VLong (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>) </li>
            <li>AvgChunkSize --&gt; the average size of a chunk of compressed documents, as a VLong (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>) </li>
            <li>BitsPerStartPointerDelta --&gt; number of bits required to represent a delta from the average using <a href="https://developers.google.com/protocol-buffers/docs/encoding#types">ZigZag encoding</a></li>
            <li>StartPointerDeltas --&gt; packed (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>) array of BlockChunks elements of BitsPerStartPointerDelta bits each, representing the deltas from the average start pointer using <a href="https://developers.google.com/protocol-buffers/docs/encoding#types">ZigZag encoding</a></li>
            <li>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>) </li>
            </list>
            <para>Notes</para>
            <list type="bullet">
            <li>For any block, the doc base of the n-th chunk can be restored with
            <c>DocBase + AvgChunkDocs * n + DocBaseDeltas[n]</c>.</li>
            <li>For any block, the start pointer of the n-th chunk can be restored with
            <c>StartPointerBase + AvgChunkSize * n + StartPointerDeltas[n]</c>.</li>
            <li>Once data is loaded into memory, you can lookup the start pointer of any
            document by performing two binary searches: a first one based on the values
            of DocBase in order to find the right block, and then inside the block based
            on DocBaseDeltas (by reconstructing the doc bases for every chunk).</li>
            </list>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader">
            <summary>
            <see cref="T:Lucene.Net.Codecs.StoredFieldsReader"/> impl for <see cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,System.String,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext,System.String,Lucene.Net.Codecs.Compressing.CompressionMode)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.EnsureOpen">
            <exception cref="T:System.ObjectDisposedException"> If this FieldsReader is disposed. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.Dispose(System.Boolean)">
            <summary>
            Dispose the underlying <see cref="T:Lucene.Net.Store.IndexInput"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.ChunkSize">
            <summary>
            Return the decompressed size of the chunk
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.Next(System.Int32)">
            <summary>
            Go to the chunk containing the provided <paramref name="doc"/> ID.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.Decompress">
            <summary>
            Decompress the chunk.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.CopyCompressedData(Lucene.Net.Store.DataOutput)">
            <summary>
            Copy compressed data.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.CheckIntegrity">
            <summary>
            Check integrity of the data. The iterator is not usable after this method has been called.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter">
            <summary>
            <see cref="T:Lucene.Net.Codecs.StoredFieldsWriter"/> impl for <see cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter.NUMERIC_INT32">
            <summary>
            NOTE: This was NUMERIC_INT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter.NUMERIC_SINGLE">
            <summary>
            NOTE: This was NUMERIC_FLOAT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter.NUMERIC_INT64">
            <summary>
            NOTE:This was NUMERIC_LONG in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,System.String,Lucene.Net.Store.IOContext,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter.SaveInt32s(System.Int32[],System.Int32,Lucene.Net.Store.DataOutput)">
            <summary>
            NOTE: This was saveInts() in Lucene.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat">
            <summary>
            A <see cref="T:Lucene.Net.Codecs.TermVectorsFormat"/> that compresses chunks of documents together in
            order to improve the compression ratio.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat.#ctor(System.String,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat"/>.
            <para/>
            <paramref name="formatName"/> is the name of the format. this name will be used
            in the file formats to perform
            codec header checks (<see cref="M:Lucene.Net.Codecs.CodecUtil.CheckHeader(Lucene.Net.Store.DataInput,System.String,System.Int32,System.Int32)"/>).
            <para/>
            The <paramref name="compressionMode"/> parameter allows you to choose between
            compression algorithms that have various compression and decompression
            speeds so that you can pick the one that best fits your indexing and
            searching throughput. You should never instantiate two
            <see cref="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat"/>s that have the same name but
            different <see cref="T:Lucene.Net.Codecs.Compressing.CompressionMode"/>s.
            <para/>
            <paramref name="chunkSize"/> is the minimum byte size of a chunk of documents.
            Higher values of <paramref name="chunkSize"/> should improve the compression
            ratio but will require more memory at indexing time and might make document
            loading a little slower (depending on the size of your OS cache compared
            to the size of your index).
            </summary>
            <param name="formatName"> The name of the <see cref="T:Lucene.Net.Codecs.StoredFieldsFormat"/>. </param>
            <param name="segmentSuffix"> A suffix to append to files created by this format. </param>
            <param name="compressionMode"> The <see cref="T:Lucene.Net.Codecs.Compressing.CompressionMode"/> to use. </param>
            <param name="chunkSize"> The minimum number of bytes of a single chunk of stored documents. </param>
            <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressionMode"/>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsReader">
            <summary>
            <see cref="T:Lucene.Net.Codecs.TermVectorsReader"/> for <see cref="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,System.String,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext,System.String,Lucene.Net.Codecs.Compressing.CompressionMode)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Compressing.CompressingTermVectorsReader.PackedInt32sVersion">
            <summary>
            NOTE: This was getPackedIntsVersion() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsReader.EnsureOpen">
            <exception cref="T:System.ObjectDisposedException"> if this <see cref="T:Lucene.Net.Codecs.TermVectorsReader"/> is disposed. </exception>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter">
            <summary>
            <see cref="T:Lucene.Net.Codecs.TermVectorsWriter"/> for <see cref="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter.DocData">
            <summary>
            A pending doc. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter.FieldData">
            <summary>
            A pending field. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,System.String,Lucene.Net.Store.IOContext,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter.FlushFieldNums">
            <summary>
            Returns a sorted array containing unique field numbers. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressionMode">
            <summary>
            A compression mode. Tells how much effort should be spent on compression and
            decompression of stored fields.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressionMode.FAST">
            <summary>
            A compression mode that trades compression ratio for speed. Although the
            compression ratio might remain high, compression and decompression are
            very fast. Use this mode with indices that have a high update rate but
            should be able to load documents from disk quickly.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressionMode.HIGH_COMPRESSION">
            <summary>
            A compression mode that trades speed for compression ratio. Although
            compression and decompression might be slow, this compression mode should
            provide a good compression ratio. this mode might be interesting if/when
            your index size is much bigger than your OS cache.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressionMode.FAST_DECOMPRESSION">
            <summary>
            This compression mode is similar to <see cref="F:Lucene.Net.Codecs.Compressing.CompressionMode.FAST"/> but it spends more time
            compressing in order to improve the compression ratio. This compression
            mode is best used with indices that have a low update rate but should be
            able to load documents from disk quickly.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressionMode.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressionMode.NewCompressor">
            <summary>
            Create a new <see cref="T:Lucene.Net.Codecs.Compressing.Compressor"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressionMode.NewDecompressor">
            <summary>
            Create a new <see cref="T:Lucene.Net.Codecs.Compressing.Decompressor"/> instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.Compressor">
            <summary>
            A data compressor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.Compressor.#ctor">
            <summary>
            Sole constructor, typically called from sub-classes. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.Compressor.Compress(System.Byte[],System.Int32,System.Int32,Lucene.Net.Store.DataOutput)">
            <summary>
            Compress bytes into <paramref name="out"/>. It it the responsibility of the
            compressor to add all necessary information so that a <see cref="T:Lucene.Net.Codecs.Compressing.Decompressor"/>
            will know when to stop decompressing bytes from the stream.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.Decompressor">
            <summary>
            A decompressor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.Decompressor.#ctor">
            <summary>
            Sole constructor, typically called from sub-classes. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.Decompressor.Decompress(Lucene.Net.Store.DataInput,System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Decompress bytes that were stored between offsets <paramref name="offset"/> and
            <c>offset+length</c> in the original stream from the compressed
            stream <paramref name="in"/> to <paramref name="bytes"/>. After returning, the length
            of <paramref name="bytes"/> (<c>bytes.Length</c>) must be equal to
            <paramref name="length"/>. Implementations of this method are free to resize
            <paramref name="bytes"/> depending on their needs.
            </summary>
            <param name="in"> The input that stores the compressed stream. </param>
            <param name="originalLength"> The length of the original data (before compression). </param>
            <param name="offset"> Bytes before this offset do not need to be decompressed. </param>
            <param name="length"> Bytes after <c>offset+length</c> do not need to be decompressed. </param>
            <param name="bytes"> a <see cref="T:Lucene.Net.Util.BytesRef"/> where to store the decompressed data. </param>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.LZ4">
            <summary>
            LZ4 compression and decompression routines.
            <para/>
            http://code.google.com/p/lz4/
            http://fastcompression.blogspot.fr/p/lz4.html
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.ReadInt32(System.Byte[],System.Int32)">
            <summary>
            NOTE: This was readInt() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.ReadInt32Equals(System.Byte[],System.Int32,System.Int32)">
            <summary>
            NOTE: This was readIntEquals() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.Decompress(Lucene.Net.Store.DataInput,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decompress at least <paramref name="decompressedLen"/> bytes into
            <c>dest[dOff]</c>. Please note that <paramref name="dest"/> must be large
            enough to be able to hold <b>all</b> decompressed data (meaning that you
            need to know the total decompressed length).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.Compress(System.Byte[],System.Int32,System.Int32,Lucene.Net.Store.DataOutput,Lucene.Net.Codecs.Compressing.LZ4.HashTable)">
            <summary>
            Compress <c>bytes[off:off+len]</c> into <paramref name="out"/> using
            at most 16KB of memory. <paramref name="ht"/> shouldn't be shared across threads
            but can safely be reused.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.CompressHC(System.Byte[],System.Int32,System.Int32,Lucene.Net.Store.DataOutput,Lucene.Net.Codecs.Compressing.LZ4.HCHashTable)">
            <summary>
            Compress <c>bytes[off:off+len]</c> into <paramref name="out"/>. Compared to
            <see cref="M:Lucene.Net.Codecs.Compressing.LZ4.Compress(System.Byte[],System.Int32,System.Int32,Lucene.Net.Store.DataOutput,Lucene.Net.Codecs.Compressing.LZ4.HashTable)"/>, this method
            is slower and uses more memory (~ 256KB per thread) but should provide
            better compression ratios (especially on large inputs) because it chooses
            the best match among up to 256 candidates and then performs trade-offs to
            fix overlapping matches. <paramref name="ht"/> shouldn't be shared across threads
            but can safely be reused.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.DocValuesConsumer">
            <summary>
            Abstract API that consumes numeric, binary and
            sorted docvalues.  Concrete implementations of this
            actually do "something" with the docvalues (write it into
            the index in a specific format).
            <para/>
            The lifecycle is:
            <list type="number">
              <item><description>DocValuesConsumer is created by
                  <see cref="M:Lucene.Net.Codecs.DocValuesFormat.FieldsConsumer(Lucene.Net.Index.SegmentWriteState)"/> or
                  <see cref="M:Lucene.Net.Codecs.NormsFormat.NormsConsumer(Lucene.Net.Index.SegmentWriteState)"/>.</description></item>
              <item><description><see cref="M:Lucene.Net.Codecs.DocValuesConsumer.AddNumericField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})"/>, 
                  <see cref="M:Lucene.Net.Codecs.DocValuesConsumer.AddBinaryField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef})"/>,
                  or <see cref="M:Lucene.Net.Codecs.DocValuesConsumer.AddSortedField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})"/> are called for each Numeric,
                  Binary, or Sorted docvalues field. The API is a "pull" rather
                  than "push", and the implementation is free to iterate over the
                  values multiple times (<see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>).</description></item>
              <item><description>After all fields are added, the consumer is <see cref="M:Lucene.Net.Codecs.DocValuesConsumer.Dispose"/>d.</description></item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.AddNumericField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Writes numeric docvalues for a field. </summary>
            <param name="field"> Field information. </param>
            <param name="values"> <see cref="T:System.Collections.Generic.IEnumerable`1"/> of numeric values (one for each document). <c>null</c> indicates
                          a missing value. </param>
            <exception cref="T:System.IO.IOException"> If an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.AddBinaryField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef})">
            <summary>
            Writes binary docvalues for a field. </summary>
            <param name="field"> Field information. </param>
            <param name="values"> <see cref="T:System.Collections.Generic.IEnumerable`1"/> of binary values (one for each document). <c>null</c> indicates
                          a missing value. </param>
            <exception cref="T:System.IO.IOException"> If an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.AddSortedField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Writes pre-sorted binary docvalues for a field. </summary>
            <param name="field"> Field information. </param>
            <param name="values"> <see cref="T:System.Collections.Generic.IEnumerable`1"/> of binary values in sorted order (deduplicated). </param>
            <param name="docToOrd"> <see cref="T:System.Collections.Generic.IEnumerable`1"/> of ordinals (one for each document). <c>-1</c> indicates
                            a missing value. </param>
            <exception cref="T:System.IO.IOException"> If an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.AddSortedSetField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Writes pre-sorted set docvalues for a field </summary>
            <param name="field"> Field information. </param>
            <param name="values"> <see cref="T:System.Collections.Generic.IEnumerable`1"/> of binary values in sorted order (deduplicated). </param>
            <param name="docToOrdCount"> <see cref="T:System.Collections.Generic.IEnumerable`1"/> of the number of values for each document. A zero ordinal
                                 count indicates a missing value. </param>
            <param name="ords"> <see cref="T:System.Collections.Generic.IEnumerable`1"/> of ordinal occurrences (<paramref name="docToOrdCount"/>*maxDoc total). </param>
            <exception cref="T:System.IO.IOException"> If an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.MergeNumericField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.MergeState,System.Collections.Generic.IList{Lucene.Net.Index.NumericDocValues},System.Collections.Generic.IList{Lucene.Net.Util.IBits})">
            <summary>
            Merges the numeric docvalues from <paramref name="toMerge"/>.
            <para>
            The default implementation calls <see cref="M:Lucene.Net.Codecs.DocValuesConsumer.AddNumericField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})"/>, passing
            an <see cref="T:System.Collections.Generic.IEnumerable`1"/> that merges and filters deleted documents on the fly.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.MergeBinaryField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.MergeState,System.Collections.Generic.IList{Lucene.Net.Index.BinaryDocValues},System.Collections.Generic.IList{Lucene.Net.Util.IBits})">
            <summary>
            Merges the binary docvalues from <paramref name="toMerge"/>.
            <para>
            The default implementation calls <see cref="M:Lucene.Net.Codecs.DocValuesConsumer.AddBinaryField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef})"/>, passing
            an <see cref="T:System.Collections.Generic.IEnumerable`1"/> that merges and filters deleted documents on the fly.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.MergeSortedField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.MergeState,System.Collections.Generic.IList{Lucene.Net.Index.SortedDocValues})">
            <summary>
            Merges the sorted docvalues from <paramref name="toMerge"/>.
            <para>
            The default implementation calls <see cref="M:Lucene.Net.Codecs.DocValuesConsumer.AddSortedField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})"/>, passing
            an <see cref="T:System.Collections.Generic.IEnumerable`1"/> that merges ordinals and values and filters deleted documents.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.MergeSortedSetField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.MergeState,System.Collections.Generic.IList{Lucene.Net.Index.SortedSetDocValues})">
            <summary>
            Merges the sortedset docvalues from <paramref name="toMerge"/>.
            <para>
            The default implementation calls <see cref="M:Lucene.Net.Codecs.DocValuesConsumer.AddSortedSetField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})"/>, passing
            an <see cref="T:System.Collections.Generic.IEnumerable`1"/> that merges ordinals and values and filters deleted documents.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.Dispose">
            <summary>
            Disposes all resources used by this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.Dispose(System.Boolean)">
            <summary>
            Implementations must override and should dispose all resources used by this instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.DocValuesFormat">
            <summary>
            Encodes/decodes per-document values.
            <para/>
            Note, when extending this class, the name (<see cref="P:Lucene.Net.Codecs.DocValuesFormat.Name"/>) may
            written into the index in certain configurations. In order for the segment
            to be read, the name must resolve to your implementation via <see cref="M:Lucene.Net.Codecs.DocValuesFormat.ForName(System.String)"/>.
            This method uses <see cref="M:Lucene.Net.Codecs.IDocValuesFormatFactory.GetDocValuesFormat(System.String)"/> to resolve format names.
            <para/>
            To implement your own format:
            <list type="number">
                <item><description>Subclass this class.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/>, override the <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.Initialize"/> method,
                    and add the line <c>base.ScanForDocValuesFormats(typeof(YourDocValuesFormat).GetTypeInfo().Assembly)</c>. 
                    If you have any format classes in your assembly 
                    that are not meant for reading, you can add the <see cref="T:Lucene.Net.Codecs.ExcludeDocValuesFormatFromScanAttribute"/> 
                    to them so they are ignored by the scan.</description></item>
                <item><description>Set the new <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/> by calling <see cref="M:Lucene.Net.Codecs.DocValuesFormat.SetDocValuesFormatFactory(Lucene.Net.Codecs.IDocValuesFormatFactory)"/>
                    at application startup.</description></item>
            </list>
            If your format has dependencies, you may also override <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormat(System.Type)"/>
            to inject them via pure DI or a DI container. See <a href="http://blog.ploeh.dk/2014/05/19/di-friendly-framework/">DI-Friendly Framework</a>
            to understand the approach used.
            <para/>
            <b>DocValuesFormat Names</b>
            <para/>
            Unlike the Java version, format names are by default convention-based on the class name. 
            If you name your custom format class "MyCustomDocValuesFormat", the format name will the same name 
            without the "DocValuesFormat" suffix: "MyCustom".
            <para/>
            You can override this default behavior by using the <see cref="T:Lucene.Net.Codecs.DocValuesFormatNameAttribute"/> to
            name the format differently than this convention. Format names must be all ASCII alphanumeric, 
            and less than 128 characters in length.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.DocValuesFormatNameAttribute"/>
        </member>
        <member name="F:Lucene.Net.Codecs.DocValuesFormat.name">
            <summary>
            Unique name that's used to retrieve this format when
            reading the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.SetDocValuesFormatFactory(Lucene.Net.Codecs.IDocValuesFormatFactory)">
            <summary>
            Sets the <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/> instance used to instantiate
            <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> subclasses.
            </summary>
            <param name="docValuesFormatFactory">The new <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="docValuesFormatFactory"/> parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.GetDocValuesFormatFactory">
            <summary>
            Gets the associated <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> factory.
            </summary>
            <returns>The <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> factory.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.#ctor">
            <summary>
            Creates a new docvalues format.
            <para/>
            The provided name will be written into the index segment in some configurations
            (such as when using <see cref="T:Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat"/>): in such configurations,
            for the segment to be read this class should be registered by subclassing <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/> and
            calling <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.ScanForDocValuesFormats(System.Reflection.Assembly)"/> in the class constructor.
            The new <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/> can be registered by calling <see cref="M:Lucene.Net.Codecs.DocValuesFormat.SetDocValuesFormatFactory(Lucene.Net.Codecs.IDocValuesFormatFactory)"/>
            at application startup.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.FieldsConsumer(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Codecs.DocValuesConsumer"/> to write docvalues to the
            index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.FieldsProducer(Lucene.Net.Index.SegmentReadState)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Codecs.DocValuesProducer"/> to read docvalues from the index.
            <para/>
            NOTE: by the time this call returns, it must hold open any files it will
            need to use; else, those files may be deleted. Additionally, required files
            may be deleted during the execution of this call before there is a chance
            to open them. Under these circumstances an <see cref="T:System.IO.IOException"/> should be thrown by
            the implementation. <see cref="T:System.IO.IOException"/>s are expected and will automatically cause
            a retry of the segment opening logic with the newly revised segments.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.DocValuesFormat.Name">
            <summary>
            Unique name that's used to retrieve this format when
            reading the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.ForName(System.String)">
            <summary>
            Looks up a format by name. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.DocValuesFormat.AvailableDocValuesFormats">
            <summary>
            Returns a list of all available format names. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.DocValuesProducer">
            <summary>
            Abstract API that produces numeric, binary and
            sorted docvalues.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetNumeric(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.NumericDocValues"/> for this field.
            The returned instance need not be thread-safe: it will only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetBinary(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.BinaryDocValues"/> for this field.
            The returned instance need not be thread-safe: it will only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetSorted(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.SortedDocValues"/> for this field.
            The returned instance need not be thread-safe: it will only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetSortedSet(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.SortedSetDocValues"/> for this field.
            The returned instance need not be thread-safe: it will only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetDocsWithField(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Util.IBits"/> at the size of <c>reader.MaxDoc</c>,
            with turned on bits for each docid that does have a value for this field.
            The returned instance need not be thread-safe: it will only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.CheckIntegrity">
            <summary>
            Checks consistency of this producer.
            <para/>
            Note that this may be costly in terms of I/O, e.g.
            may involve computing a checksum value against large data files.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.Dispose">
            <summary>
            Disposes all resources used by this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.Dispose(System.Boolean)">
            <summary>
            Implementations must override and should dispose all resources used by this instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.FieldInfosFormat">
            <summary>
            Encodes/decodes <see cref="T:Lucene.Net.Index.FieldInfos"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.FieldInfosFormat.FieldInfosReader">
            <summary>
            Returns a <see cref="T:Lucene.Net.Codecs.FieldInfosReader"/> to read field infos
            from the index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.FieldInfosFormat.FieldInfosWriter">
            <summary>
            Returns a <see cref="T:Lucene.Net.Codecs.FieldInfosWriter"/> to write field infos
            to the index.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.FieldInfosReader">
            <summary>
            Codec API for reading <see cref="T:Lucene.Net.Index.FieldInfos"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosReader.Read(Lucene.Net.Store.Directory,System.String,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Read the <see cref="T:Lucene.Net.Index.FieldInfos"/> previously written with 
            <see cref="T:Lucene.Net.Codecs.FieldInfosWriter"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.FieldInfosWriter">
            <summary>
            Codec API for writing <see cref="T:Lucene.Net.Index.FieldInfos"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosWriter.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosWriter.Write(Lucene.Net.Store.Directory,System.String,System.String,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Writes the provided <see cref="T:Lucene.Net.Index.FieldInfos"/> to the
            directory.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.FieldsConsumer">
            <summary>
            Abstract API that consumes terms, doc, freq, prox, offset and
            payloads postings.  Concrete implementations of this
            actually do "something" with the postings (write it into
            the index in a specific format).
            <para/>
            The lifecycle is:
            <list type="number">
              <item><description>FieldsConsumer is created by
                  <see cref="M:Lucene.Net.Codecs.PostingsFormat.FieldsConsumer(Lucene.Net.Index.SegmentWriteState)"/>.</description></item>
              <item><description>For each field, <see cref="M:Lucene.Net.Codecs.FieldsConsumer.AddField(Lucene.Net.Index.FieldInfo)"/> is called,
                  returning a <see cref="T:Lucene.Net.Codecs.TermsConsumer"/> for the field.</description></item>
              <item><description>After all fields are added, the consumer is <see cref="M:Lucene.Net.Codecs.FieldsConsumer.Dispose"/>d.</description></item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.AddField(Lucene.Net.Index.FieldInfo)">
            <summary>
            Add a new field. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.Dispose">
            <summary>
            Called when we are done adding everything. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.Dispose(System.Boolean)">
            <summary>
            Implementations must override and should dispose all resources used by this instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.Merge(Lucene.Net.Index.MergeState,Lucene.Net.Index.Fields)">
            <summary>
            Called during merging to merge all <see cref="T:Lucene.Net.Index.Fields"/> from
            sub-readers.  this must recurse to merge all postings
            (terms, docs, positions, etc.).  A 
            <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> can override this default
            implementation to do its own merging.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.FieldsProducer">
            <summary>
            Abstract API that produces terms, doc, freq, prox, offset and
            payloads postings.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsProducer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsProducer.Dispose">
            <summary>
            Disposes all resources used by this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsProducer.Dispose(System.Boolean)">
            <summary>
            Implementations must override and should dispose all resources used by this instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsProducer.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsProducer.CheckIntegrity">
            <summary>
            Checks consistency of this reader.
            <para/>
            Note that this may be costly in terms of I/O, e.g.
            may involve computing a checksum value against large data files.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.FilterCodec">
             <summary>
             A codec that forwards all its method calls to another codec.
             <para/>
             Extend this class when you need to reuse the functionality of an existing
             codec. For example, if you want to build a codec that redefines Lucene46's
             <see cref="T:Lucene.Net.Codecs.LiveDocsFormat"/>:
             <code>
                 public sealed class CustomCodec : FilterCodec 
                 {
                     public CustomCodec()
                         : base("CustomCodec", new Lucene46Codec())
                     {
                     }
            
                     public override LiveDocsFormat LiveDocsFormat 
                     {
                         get { return new CustomLiveDocsFormat(); }
                     }
                 }
             </code>
            
             <para/>
             <em>Please note:</em> Don't call <see cref="M:Lucene.Net.Codecs.Codec.ForName(System.String)"/> from
             the no-arg constructor of your own codec. When the <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/>
             loads your own <see cref="T:Lucene.Net.Codecs.Codec"/>, the <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/> has not yet fully initialized!
             If you want to extend another <see cref="T:Lucene.Net.Codecs.Codec"/>, instantiate it directly by calling
             its constructor.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.FilterCodec.m_delegate">
            <summary>
            The codec to filter. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FilterCodec.#ctor(Lucene.Net.Codecs.Codec)">
            <summary>
            Sole constructor. When subclassing this codec,
            create a no-arg ctor and pass the delegate codec
            and a unique name to this ctor.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.LiveDocsFormat">
            <summary>
            Format for live/deleted documents.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.NewLiveDocs(System.Int32)">
            <summary>
            Creates a new MutableBits, with all bits set, for the specified size. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.NewLiveDocs(Lucene.Net.Util.IBits)">
            <summary>
            Creates a new mutablebits of the same bits set and size of existing. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.ReadLiveDocs(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Store.IOContext)">
            <summary>
            Read live docs bits. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.WriteLiveDocs(Lucene.Net.Util.IMutableBits,Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentCommitInfo,System.Int32,Lucene.Net.Store.IOContext)">
            <summary>
            Persist live docs bits.  Use 
            <see cref="P:Lucene.Net.Index.SegmentCommitInfo.NextDelGen"/> to determine the
            generation of the deletes file you should write to.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.Files(Lucene.Net.Index.SegmentCommitInfo,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Records all files in use by this <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/> into the files argument. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xCodec">
            <summary>
            Supports the Lucene 3.x index format (readonly) </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION">
            <summary>
            Extension of compound file for doc store files. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xCodec.GetDocStoreFiles(Lucene.Net.Index.SegmentInfo)">
            <summary>
            Returns file names for shared doc stores, if any, else
            <c>null</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xFieldInfosFormat">
            <summary>
            Lucene3x ReadOnly <see cref="T:Lucene.Net.Codecs.FieldInfosFormat"/> implementation.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xFieldInfosReader">
            <summary>
            @lucene.experimental </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xFieldInfosReader.FIELD_INFOS_EXTENSION">
            <summary>
            Extension of field infos. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xFields">
            <summary>
            Exposes flex API on a pre-flex index, as a codec.
            <para/>
            @lucene.experimental 
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsFormat">
            <summary>
            Lucene3x ReadOnly <see cref="T:Lucene.Net.Codecs.NormsFormat"/> implementation.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer">
            <summary>
            Reads Lucene 3.x norms format and exposes it via <see cref="T:Lucene.Net.Index.DocValues"/> API.
            <para/>
            @lucene.experimental 
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer.NORMS_HEADER">
            <summary>
            Norms header placeholder. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer.NORMS_EXTENSION">
            <summary>
            Extension of norms file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer.SEPARATE_NORMS_EXTENSION">
            <summary>
            Extension of separate norms file. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat">
            <summary>
            Codec that reads the pre-flex-indexing postings
            format.  It does not provide a writer because newly
            written segments should use the <see cref="T:Lucene.Net.Codecs.Codec"/> configured on <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat.TERMS_EXTENSION">
            <summary>
            Extension of terms file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat.TERMS_INDEX_EXTENSION">
            <summary>
            Extension of terms index file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat.FREQ_EXTENSION">
            <summary>
            Extension of freq postings file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat.PROX_EXTENSION">
            <summary>
            Extension of prox postings file </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat">
            <summary>
            Lucene3x ReadOnly <see cref="T:Lucene.Net.Codecs.SegmentInfoFormat"/> implementation.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.FORMAT_DIAGNOSTICS">
            <summary>
            This format adds optional per-segment String
            diagnostics storage, and switches userData to Map.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.FORMAT_HAS_VECTORS">
            <summary>
            Each segment records whether it has term vectors. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.FORMAT_3_1">
            <summary>
            Each segment records the Lucene version that created it. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.UPGRADED_SI_EXTENSION">
            <summary>
            Extension used for saving each SegmentInfo, once a 3.x
            index is first committed to with 4.0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.GetDocStoreOffset(Lucene.Net.Index.SegmentInfo)">
            <returns> If this segment shares stored fields &amp; vectors, this
                    offset is where in that file this segment's docs begin.  </returns>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.GetDocStoreSegment(Lucene.Net.Index.SegmentInfo)">
            <returns> Name used to derive fields/vectors file we share with other segments. </returns>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.GetDocStoreIsCompoundFile(Lucene.Net.Index.SegmentInfo)">
            <returns> Whether doc store files are stored in compound file (*.cfx). </returns>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoReader">
            <summary>
            Lucene 3x implementation of <see cref="T:Lucene.Net.Codecs.SegmentInfoReader"/>.
            <para/>
            @lucene.experimental 
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoReader.ReadLegacySegmentInfo(Lucene.Net.Store.Directory,System.Int32,Lucene.Net.Store.IndexInput)">
            <summary>
            Reads from legacy 3.x segments_N. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.Lucene3xSkipListReader.FreqPointer">
            <summary>
            Returns the freq pointer of the doc to which the last call of
            <see cref="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipTo(System.Int32)"/> has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.Lucene3xSkipListReader.ProxPointer">
            <summary>
            Returns the prox pointer of the doc to which the last call of
            <see cref="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipTo(System.Int32)"/> has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.Lucene3xSkipListReader.PayloadLength">
            <summary>
            Returns the payload length of the payload stored just before
            the doc to which the last call of <see cref="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipTo(System.Int32)"/>
            has skipped.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader">
            <summary>
            Class responsible for access to stored document fields.
            <para/>
            It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.FIELDS_EXTENSION">
            <summary>
            Extension of stored fields file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.FIELDS_INDEX_EXTENSION">
            <summary>
            Extension of stored fields index file. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.Clone">
            <summary>
            Returns a cloned FieldsReader that shares open
            IndexInputs with the original one.  It is the caller's
            job not to close the original FieldsReader until all
            clones are called (eg, currently SegmentReader manages
            this logic).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.CheckCodeVersion(Lucene.Net.Store.Directory,System.String)">
            <summary>
            Verifies that the code version which wrote the segment is supported. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.EnsureOpen">
            <exception cref="T:System.ObjectDisposedException"> If this FieldsReader is disposed. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.Dispose(System.Boolean)">
            <summary>
            Closes the underlying <see cref="T:Lucene.Net.Store.IndexInput"/> streams.
            This means that the Fields values will not be accessible.
            </summary>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsFormat">
            <summary>
            Lucene3x ReadOnly <see cref="T:Lucene.Net.Codecs.TermVectorsFormat"/> implementation 
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader.VECTORS_FIELDS_EXTENSION">
            <summary>
            Extension of vectors fields file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader.VECTORS_DOCUMENTS_EXTENSION">
            <summary>
            Extension of vectors documents file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader.VECTORS_INDEX_EXTENSION">
            <summary>
            Extension of vectors index file. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader.Count">
            <summary>
            The number of documents in the reader. 
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.SegmentTermDocs">
            <summary>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermDocs.Read(System.Int32[],System.Int32[])">
            <summary>
            Optimized implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermDocs.SkipProx(System.Int64,System.Int32)">
            <summary>
            Overridden by <see cref="T:Lucene.Net.Codecs.Lucene3x.SegmentTermPositions"/> to skip in prox stream. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermDocs.SkipTo(System.Int32)">
            <summary>
            Optimized implementation. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum">
            <summary>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Next">
            <summary>
            Increments the enumeration to the next element.  True if one exists. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Term">
            <summary>
            Returns the current Term in the enumeration.
            Initially invalid, valid after <see cref="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Next"/> called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Prev">
            <summary>
            Returns the previous Term enumerated. Initially <c>null</c>. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.TermInfo">
            <summary>
            Returns the current <see cref="T:Lucene.Net.Codecs.Lucene3x.TermInfo"/> in the enumeration.
            Initially invalid, valid after <see cref="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Next"/> called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.TermInfo(Lucene.Net.Codecs.Lucene3x.TermInfo)">
            <summary>
            Sets the argument to the current <see cref="T:Lucene.Net.Codecs.Lucene3x.TermInfo"/> in the enumeration.
            Initially invalid, valid after <see cref="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Next"/> called for the first time.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.DocFreq">
            <summary>
            Returns the docFreq from the current <see cref="T:Lucene.Net.Codecs.Lucene3x.TermInfo"/> in the enumeration.
            Initially invalid, valid after <see cref="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Next"/> called for the first time.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.FreqPointer">
            <summary>
            Returns the freqPointer from the current <see cref="T:Lucene.Net.Codecs.Lucene3x.TermInfo"/> in the enumeration.
            Initially invalid, valid after<see cref="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Next"/> called for the first time.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.ProxPointer">
            <summary>
            Returns the proxPointer from the current <see cref="T:Lucene.Net.Codecs.Lucene3x.TermInfo"/> in the enumeration.
            Initially invalid, valid after<see cref="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Next"/> called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Dispose">
            <summary>
            Closes the enumeration to further activity, freeing resources. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.SegmentTermPositions">
            <summary>
            @lucene.experimental 
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermPositions.SkipProx(System.Int64,System.Int32)">
            <summary>
            Called by <c>base.SkipTo()</c>. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.TermBuffer">
            <summary>
            @lucene.experimental 
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.TermInfo">
            <summary>
            A <see cref="T:Lucene.Net.Codecs.Lucene3x.TermInfo"/> is the record of information stored for a
            term. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.TermInfo.DocFreq">
            <summary>
            The number of documents which contain the term. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.TermInfosReader">
            <summary>
            This stores a monotonically increasing set of <c>Term, TermInfo</c> pairs in a
            Directory.  Pairs are accessed either by <see cref="T:Lucene.Net.Index.Term"/> or by ordinal position the
            set.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.TermInfosReader.ThreadResources">
            <summary>
            Per-thread resources managed by ThreadLocal.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Count">
            <summary>
            Returns the number of term/value pairs in the set.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Get(Lucene.Net.Index.Term)">
            <summary>
            Returns the <see cref="T:Lucene.Net.Codecs.Lucene3x.TermInfo"/> for a <see cref="T:Lucene.Net.Index.Term"/> in the set, or <c>null</c>. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Get(Lucene.Net.Index.Term,System.Boolean)">
            <summary>
            Returns the <see cref="T:Lucene.Net.Codecs.Lucene3x.TermInfo"/> for a <see cref="T:Lucene.Net.Index.Term"/> in the set, or <c>null</c>. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.GetPosition(Lucene.Net.Index.Term)">
            <summary>
            Returns the position of a <see cref="T:Lucene.Net.Index.Term"/> in the set or -1. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Terms">
            <summary>
            Returns an enumeration of all the <see cref="T:Lucene.Net.Index.Term"/>s and <see cref="T:Lucene.Net.Codecs.Lucene3x.TermInfo"/>s in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Terms(Lucene.Net.Index.Term)">
            <summary>
            Returns an enumeration of terms starting at or after the named term. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex">
            <summary>
            This stores a monotonically increasing set of <c>Term, TermInfo</c> pairs in an
            index segment. Pairs are accessed either by <see cref="T:Lucene.Net.Index.Term"/> or by ordinal position the
            set. The <see cref="T:Lucene.Net.Index.Terms"/> and <see cref="T:Lucene.Net.Codecs.Lucene3x.TermInfo"/> are actually serialized and stored into a byte
            array and pointers to the position of each are stored in a <see cref="T:System.Int32"/> array. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.#ctor(Lucene.Net.Codecs.Lucene3x.SegmentTermEnum,System.Int32,System.Int64,System.Int32)">
            <summary>
            Loads the segment information at segment load time.
            </summary>
            <param name="indexEnum">
                     The term enum. </param>
            <param name="indexDivisor">
                     The index divisor. </param>
            <param name="tiiFileLength">
                     The size of the tii file, used to approximate the size of the
                     buffer. </param>
            <param name="totalIndexInterval">
                     The total index interval. </param>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.GetIndexOffset(Lucene.Net.Index.Term)">
            <summary>
            Binary search for the given term.
            </summary>
            <param name="term">
                     The term to locate. </param>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.GetTerm(System.Int32)">
            <summary>
            Gets the term at the given position.  For testing.
            </summary>
            <param name="termIndex">
                     The position to read the term from the index. </param>
            <returns> The term. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.Length">
            <summary>
            Returns the number of terms.
            </summary>
            <returns> int. </returns>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.CompareTo(Lucene.Net.Index.Term,System.Int32)">
            <summary>
            The compares the given term against the term in the index specified by the
            term index. ie It returns negative N when term is less than index term;
            </summary>
            <param name="term">
                     The given term. </param>
            <param name="termIndex">
                     The index of the of term to compare. </param>
            <returns> int. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.CompareTo(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Util.PagedBytes.PagedBytesDataInput,Lucene.Net.Util.BytesRef)">
            <summary>
            Compare the fields of the terms first, and if not equals return from
            compare. If equal compare terms.
            </summary>
            <param name="term">
                     The term to compare. </param>
            <param name="termIndex">
                     The position of the term in the input to compare </param>
            <param name="input">
                     The input buffer. </param>
            <returns> int. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.CompareField(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Util.PagedBytes.PagedBytesDataInput)">
            <summary>
            Compares the fields before checking the text of the terms.
            </summary>
            <param name="term">
                     The given term. </param>
            <param name="termIndex">
                     The term that exists in the data block. </param>
            <param name="input">
                     The data block. </param>
            <returns> int. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.BitVector">
            <summary>
            Optimized implementation of a vector of bits.  This is more-or-less like
            <c>java.util.BitSet</c>, but also includes the following:
            <list type="bullet">
                <item><description>a count() method, which efficiently computes the number of one bits;</description></item>
                <item><description>optimized read from and write to disk;</description></item>
                <item><description>inlinable get() method;</description></item>
                <item><description>store and load, as bit set or d-gaps, depending on sparseness;</description></item>
            </list>
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.#ctor(System.Int32)">
            <summary>
            Constructs a vector capable of holding <paramref name="n"/> bits. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Set(System.Int32)">
            <summary>
            Sets the value of <paramref name="bit"/> to one. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.GetAndSet(System.Int32)">
            <summary>
            Sets the value of <paramref name="bit"/> to <c>true</c>, and
            returns <c>true</c> if bit was already set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Clear(System.Int32)">
            <summary>
            Sets the value of <paramref name="bit"/> to zero. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Get(System.Int32)">
            <summary>
            Returns <c>true</c> if <paramref name="bit"/> is one and
            <c>false</c> if it is zero.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.BitVector.Length">
            <summary>
            Returns the number of bits in this vector.  This is also one greater than
            the number of the largest valid bit number.
            <para/>
            This is the equivalent of either size() or length() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Count">
            <summary>
            Returns the total number of one bits in this vector.  This is efficiently
            computed and cached, so that, if the vector is not changed, no
            recomputation is done for repeated calls.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.GetRecomputedCount">
            <summary>
            For testing </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Write(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Writes this vector to the file <paramref name="name"/> in Directory
            <paramref name="d"/>, in a format that can be read by the constructor 
            <see cref="M:Lucene.Net.Codecs.Lucene40.BitVector.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.InvertAll">
            <summary>
            Invert all bits. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.SetAll">
            <summary>
            Set all bits. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.WriteBits(Lucene.Net.Store.IndexOutput)">
            <summary>
            Write as a bit set. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.WriteClearedDgaps(Lucene.Net.Store.IndexOutput)">
            <summary>
            Write as a d-gaps list. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.BitVector.IsSparse">
            <summary>
            Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Constructs a bit vector from the file <paramref name="name"/> in Directory
            <paramref name="d"/>, as written by the <see cref="M:Lucene.Net.Codecs.Lucene40.BitVector.Write(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)"/> method.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.ReadBits(Lucene.Net.Store.IndexInput)">
            <summary>
            Read as a bit set. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.ReadSetDgaps(Lucene.Net.Store.IndexInput)">
            <summary>
            Read as a d-gaps list. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.ReadClearedDgaps(Lucene.Net.Store.IndexInput)">
            <summary>
            Read as a d-gaps cleared bits list. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40Codec">
            <summary>
            Implements the Lucene 4.0 index format, with configurable per-field postings formats.
            <para/>
            If you want to reuse functionality of this codec in another codec, extend
            <see cref="T:Lucene.Net.Codecs.FilterCodec"/>.
            <para/>
            See <see cref="N:Lucene.Net.Codecs.Lucene40"/> package documentation for file format details.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40Codec.GetPostingsFormatForField(System.String)">
            <summary>
            Returns the postings format that should be used for writing
            new segments of <paramref name="field"/>.
            <para/>
            The default implementation always returns "Lucene40".
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat">
            <summary>
            Lucene 4.0 DocValues format.
            <para/>
            Files:
            <list type="bullet">
              <item><description><c>.dv.cfs</c>: compound container (<see cref="T:Lucene.Net.Store.CompoundFileDirectory"/>)</description></item>
              <item><description><c>.dv.cfe</c>: compound entries (<see cref="T:Lucene.Net.Store.CompoundFileDirectory"/>)</description></item>
            </list>
            Entries within the compound file:
            <list type="bullet">
              <item><description><c>&lt;segment&gt;_&lt;fieldNumber&gt;.dat</c>: data values</description></item>
              <item><description><c>&lt;segment&gt;_&lt;fieldNumber&gt;.idx</c>: index into the .dat for DEREF types</description></item>
            </list>
            <para>
            There are several many types of <see cref="T:Lucene.Net.Index.DocValues"/> with different encodings.
            From the perspective of filenames, all types store their values in <c>.dat</c>
            entries within the compound file. In the case of dereferenced/sorted types, the <c>.dat</c>
            actually contains only the unique values, and an additional <c>.idx</c> file contains
            pointers to these unique values.
            </para>
            Formats:
            <list type="bullet">
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.VAR_INTS"/> .dat --&gt; Header, PackedType, MinValue,
                   DefaultValue, PackedStream</description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.FIXED_INTS_8"/> .dat --&gt; Header, ValueSize,
                   Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) <sup>maxdoc</sup></description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.FIXED_INTS_16"/> .dat --&gt; Header, ValueSize,
                   Short (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt16(System.Int16)"/>) <sup>maxdoc</sup></description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.FIXED_INTS_32"/> .dat --&gt; Header, ValueSize,
                   Int32 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>) <sup>maxdoc</sup></description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.FIXED_INTS_64"/> .dat --&gt; Header, ValueSize,
                   Int64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>) <sup>maxdoc</sup></description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.FLOAT_32"/> .dat --&gt; Header, ValueSize, Float32<sup>maxdoc</sup></description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.FLOAT_64"/> .dat --&gt; Header, ValueSize, Float64<sup>maxdoc</sup></description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_FIXED_STRAIGHT"/> .dat --&gt; Header, ValueSize,
                   (Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) * ValueSize)<sup>maxdoc</sup></description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_VAR_STRAIGHT"/> .idx --&gt; Header, TotalBytes, Addresses</description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_VAR_STRAIGHT"/> .dat --&gt; Header,
                     (Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) * <i>variable ValueSize</i>)<sup>maxdoc</sup></description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_FIXED_DEREF"/> .idx --&gt; Header, NumValues, Addresses</description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_FIXED_DEREF"/> .dat --&gt; Header, ValueSize,
                   (Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) * ValueSize)<sup>NumValues</sup></description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_VAR_DEREF"/> .idx --&gt; Header, TotalVarBytes, Addresses</description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_VAR_DEREF"/> .dat --&gt; Header,
                   (LengthPrefix + Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) * <i>variable ValueSize</i>)<sup>NumValues</sup></description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_FIXED_SORTED"/> .idx --&gt; Header, NumValues, Ordinals</description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_FIXED_SORTED"/> .dat --&gt; Header, ValueSize,
                   (Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) * ValueSize)<sup>NumValues</sup></description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_VAR_SORTED"/> .idx --&gt; Header, TotalVarBytes, Addresses, Ordinals</description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_VAR_SORTED"/> .dat --&gt; Header,
                   (Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) * <i>variable ValueSize</i>)<sup>NumValues</sup></description></item>
            </list>
            Data Types:
            <list type="bullet">
               <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
               <item><description>PackedType --&gt; Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>)</description></item>
               <item><description>MaxAddress, MinValue, DefaultValue --&gt; Int64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>) </description></item>
               <item><description>PackedStream, Addresses, Ordinals --&gt; <see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/></description></item>
               <item><description>ValueSize, NumValues --&gt; Int32 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>) </description></item>
               <item><description>Float32 --&gt; 32-bit float encoded with <see cref="M:J2N.BitConversion.SingleToRawInt32Bits(System.Single)"/>
                                  then written as Int32 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>) </description></item>
               <item><description>Float64 --&gt; 64-bit float encoded with <see cref="M:J2N.BitConversion.DoubleToRawInt64Bits(System.Double)"/>
                                  then written as Int64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>) </description></item>
               <item><description>TotalBytes --&gt; VLong (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>) </description></item>
               <item><description>TotalVarBytes --&gt; Int64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>) </description></item>
               <item><description>LengthPrefix --&gt; Length of the data value as VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) (maximum
                                  of 2 bytes)</description></item>
            </list>
            Notes:
            <list type="bullet">
               <item><description>PackedType is a 0 when compressed, 1 when the stream is written as 64-bit integers.</description></item>
               <item><description>Addresses stores pointers to the actual byte location (indexed by docid). In the VAR_STRAIGHT
                   case, each entry can have a different length, so to determine the length, docid+1 is
                   retrieved. A sentinel address is written at the end for the VAR_STRAIGHT case, so the Addresses
                   stream contains maxdoc+1 indices. For the deduplicated VAR_DEREF case, each length
                   is encoded as a prefix to the data itself as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>)
                   (maximum of 2 bytes).</description></item>
               <item><description>Ordinals stores the term ID in sorted order (indexed by docid). In the FIXED_SORTED case,
                   the address into the .dat can be computed from the ordinal as
                   <c>Header+ValueSize+(ordinal*ValueSize)</c> because the byte length is fixed.
                   In the VAR_SORTED case, there is double indirection (docid -> ordinal -> address), but
                   an additional sentinel ordinal+address is always written (so there are NumValues+1 ordinals). To
                   determine the length, ord+1's address is looked up as well.</description></item>
               <item><description><see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_VAR_STRAIGHT"/> in contrast to other straight
                   variants uses a <c>.idx</c> file to improve lookup perfromance. In contrast to
                   <see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_VAR_DEREF"/> it doesn't apply deduplication of the document values.
               </description></item>
            </list>
            <para/>
            Limitations:
            <list type="bullet">
              <item><description> Binary doc values can be at most <see cref="F:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH"/> in length.</description></item>
            </list> 
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH">
            <summary>
            Maximum length for each binary doc values field. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader">
            <summary>
            Reads the 4.0 format of norms/docvalues.
            <para/>
            @lucene.experimental 
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader.LoadVarInt32sField(Lucene.Net.Index.FieldInfo,Lucene.Net.Store.IndexInput)">
            <summary>
            NOTE: This was loadVarIntsField() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader.LoadInt16Field(Lucene.Net.Index.FieldInfo,Lucene.Net.Store.IndexInput)">
            <summary>
            NOTE: This was loadShortField() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader.LoadInt32Field(Lucene.Net.Index.FieldInfo,Lucene.Net.Store.IndexInput)">
            <summary>
            NOTE: This was loadIntField() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader.LoadInt64Field(Lucene.Net.Index.FieldInfo,Lucene.Net.Store.IndexInput)">
            <summary>
            NOTE: This was loadLongField() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader.LoadSingleField(Lucene.Net.Index.FieldInfo,Lucene.Net.Store.IndexInput)">
            <summary>
            NOTE: This was loadFloatField() in Lucene.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosFormat">
             <summary>
             Lucene 4.0 Field Infos format.
             <para/>
             <para>Field names are stored in the field info file, with suffix <tt>.fnm</tt>.</para>
             <para>FieldInfos (.fnm) --&gt; Header,FieldsCount, &lt;FieldName,FieldNumber,
             FieldBits,DocValuesBits,Attributes&gt; <sup>FieldsCount</sup></para>
             <para>Data types:
             <list type="bullet">
               <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
               <item><description>FieldsCount --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
               <item><description>FieldName --&gt; String (<see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>) </description></item>
               <item><description>FieldBits, DocValuesBits --&gt; Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) </description></item>
               <item><description>FieldNumber --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>) </description></item>
               <item><description>Attributes --&gt; IDictionary&lt;String,String&gt; (<see cref="M:Lucene.Net.Store.DataOutput.WriteStringStringMap(System.Collections.Generic.IDictionary{System.String,System.String})"/>) </description></item>
             </list>
             </para>
             Field Descriptions:
             <list type="bullet">
               <item><description>FieldsCount: the number of fields in this file.</description></item>
               <item><description>FieldName: name of the field as a UTF-8 String.</description></item>
               <item><description>FieldNumber: the field's number. Note that unlike previous versions of
                   Lucene, the fields are not numbered implicitly by their order in the
                   file, instead explicitly.</description></item>
               <item><description>FieldBits: a byte containing field options.
                   <list type="bullet">
                     <item><description>The low-order bit is one for indexed fields, and zero for non-indexed
                         fields.</description></item>
                     <item><description>The second lowest-order bit is one for fields that have term vectors
                         stored, and zero for fields without term vectors.</description></item>
                     <item><description>If the third lowest order-bit is set (0x4), offsets are stored into
                         the postings list in addition to positions.</description></item>
                     <item><description>Fourth bit is unused.</description></item>
                     <item><description>If the fifth lowest-order bit is set (0x10), norms are omitted for the
                         indexed field.</description></item>
                     <item><description>If the sixth lowest-order bit is set (0x20), payloads are stored for the
                         indexed field.</description></item>
                     <item><description>If the seventh lowest-order bit is set (0x40), term frequencies and
                         positions omitted for the indexed field.</description></item>
                     <item><description>If the eighth lowest-order bit is set (0x80), positions are omitted for the
                         indexed field.</description></item>
                   </list>
                </description></item>
                <item><description>DocValuesBits: a byte containing per-document value types. The type
                    recorded as two four-bit integers, with the high-order bits representing
                    <c>norms</c> options, and the low-order bits representing
                    <see cref="T:Lucene.Net.Index.DocValues"/> options. Each four-bit integer can be decoded as such:
                    <list type="bullet">
                      <item><description>0: no DocValues for this field.</description></item>
                      <item><description>1: variable-width signed integers. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.VAR_INTS"/>)</description></item>
                      <item><description>2: 32-bit floating point values. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.FLOAT_32"/>)</description></item>
                      <item><description>3: 64-bit floating point values. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.FLOAT_64"/>)</description></item>
                      <item><description>4: fixed-length byte array values. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_FIXED_STRAIGHT"/>)</description></item>
                      <item><description>5: fixed-length dereferenced byte array values. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_FIXED_DEREF"/>)</description></item>
                      <item><description>6: variable-length byte array values. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_VAR_STRAIGHT"/>)</description></item>
                      <item><description>7: variable-length dereferenced byte array values. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_VAR_DEREF"/>)</description></item>
                      <item><description>8: 16-bit signed integers. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.FIXED_INTS_16"/>)</description></item>
                      <item><description>9: 32-bit signed integers. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.FIXED_INTS_32"/>)</description></item>
                      <item><description>10: 64-bit signed integers. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.FIXED_INTS_64"/>)</description></item>
                      <item><description>11: 8-bit signed integers. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.FIXED_INTS_8"/>)</description></item>
                      <item><description>12: fixed-length sorted byte array values. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_FIXED_SORTED"/>)</description></item>
                      <item><description>13: variable-length sorted byte array values. (<see cref="F:Lucene.Net.Codecs.Lucene40.LegacyDocValuesType.BYTES_VAR_SORTED"/>)</description></item>
                    </list>
                </description></item>
                <item><description>Attributes: a key-value map of codec-private attributes.</description></item>
             </list>
            
             @lucene.experimental 
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosFormat.FIELD_INFOS_EXTENSION">
            <summary>
            Extension of field infos </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosReader">
            <summary>
            Lucene 4.0 FieldInfos reader.
            <para/>
            @lucene.experimental 
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40LiveDocsFormat">
            <summary>
            Lucene 4.0 Live Documents Format.
            <para/>
            <para>The .del file is optional, and only exists when a segment contains
            deletions.</para>
            <para>Although per-segment, this file is maintained exterior to compound segment
            files.</para>
            <para>Deletions (.del) --&gt; Format,Header,ByteCount,BitCount, Bits | DGaps (depending
            on Format)</para>
            <list type="bullet">
              <item><description>Format,ByteSize,BitCount --&gt; Uint32 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>) </description></item>
              <item><description>Bits --&gt; &lt; Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) &gt; <sup>ByteCount</sup></description></item>
              <item><description>DGaps --&gt; &lt;DGap,NonOnesByte&gt; <sup>NonzeroBytesCount</sup></description></item>
              <item><description>DGap --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
              <item><description>NonOnesByte --&gt;  Byte(<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) </description></item>
              <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
            </list>
            <para>Format is 1: indicates cleared DGaps.</para>
            <para>ByteCount indicates the number of bytes in Bits. It is typically
            (SegSize/8)+1.</para>
            <para>BitCount indicates the number of bits that are currently set in Bits.</para>
            <para>Bits contains one bit for each document indexed. When the bit corresponding
            to a document number is cleared, that document is marked as deleted. Bit ordering
            is from least to most significant. Thus, if Bits contains two bytes, 0x00 and
            0x02, then document 9 is marked as alive (not deleted).</para>
            <para>DGaps represents sparse bit-vectors more efficiently than Bits. It is made
            of DGaps on indexes of nonOnes bytes in Bits, and the nonOnes bytes themselves.
            The number of nonOnes bytes in Bits (NonOnesBytesCount) is not stored.</para>
            <para>For example, if there are 8000 bits and only bits 10,12,32 are cleared, DGaps
            would be used:</para>
            <para>(VInt) 1 , (byte) 20 , (VInt) 3 , (Byte) 1</para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40LiveDocsFormat.DELETES_EXTENSION">
            <summary>
            Extension of deletes </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40LiveDocsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40NormsFormat">
            <summary>
            Lucene 4.0 Norms Format.
            <para/>
            Files:
            <list type="bullet">
              <item><description><c>.nrm.cfs</c>: compound container (<see cref="T:Lucene.Net.Store.CompoundFileDirectory"/>) </description></item>
              <item><description><c>.nrm.cfe</c>: compound entries (<see cref="T:Lucene.Net.Store.CompoundFileDirectory"/>) </description></item>
            </list>
            Norms are implemented as DocValues, so other than file extension, norms are
            written exactly the same way as <see cref="T:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat"/>.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40NormsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsBaseFormat">
            <summary>
            Provides a <see cref="T:Lucene.Net.Codecs.PostingsReaderBase"/> and
            <see cref="T:Lucene.Net.Codecs.PostingsWriterBase"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsBaseFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat">
             <summary>
             Lucene 4.0 Postings format.
             <para>
             Files:
             <list type="bullet">
               <item><description><tt>.tim</tt>: <a href="#Termdictionary">Term Dictionary</a></description></item>
               <item><description><tt>.tip</tt>: <a href="#Termindex">Term Index</a></description></item>
               <item><description><tt>.frq</tt>: <a href="#Frequencies">Frequencies</a></description></item>
               <item><description><tt>.prx</tt>: <a href="#Positions">Positions</a></description></item>
             </list>
             </para>
             <para/>
             <a name="Termdictionary" id="Termdictionary"></a>
             <h3>Term Dictionary</h3>
            
             <para>The .tim file contains the list of terms in each
             field along with per-term statistics (such as docfreq)
             and pointers to the frequencies, positions and
             skip data in the .frq and .prx files.
             See <see cref="T:Lucene.Net.Codecs.BlockTreeTermsWriter"/> for more details on the format.
             </para>
            
             <para>NOTE: The term dictionary can plug into different postings implementations:
             the postings writer/reader are actually responsible for encoding
             and decoding the Postings Metadata and Term Metadata sections described here:</para>
             <list type="bullet">
                <item><description>Postings Metadata --&gt; Header, SkipInterval, MaxSkipLevels, SkipMinimum</description></item>
                <item><description>Term Metadata --&gt; FreqDelta, SkipDelta?, ProxDelta?</description></item>
                <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
                <item><description>SkipInterval,MaxSkipLevels,SkipMinimum --&gt; Uint32 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>) </description></item>
                <item><description>SkipDelta,FreqDelta,ProxDelta --&gt; VLong (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>) </description></item>
             </list>
             <para>Notes:</para>
             <list type="bullet">
                <item><description>Header is a CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>)  storing the version information
                    for the postings.</description></item>
                <item><description>SkipInterval is the fraction of TermDocs stored in skip tables. It is used to accelerate
                    <see cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/>. Larger values result in smaller indexes, greater
                    acceleration, but fewer accelerable cases, while smaller values result in bigger indexes,
                    less acceleration (in case of a small value for MaxSkipLevels) and more accelerable cases.
                    </description></item>
                <item><description>MaxSkipLevels is the max. number of skip levels stored for each term in the .frq file. A
                    low value results in smaller indexes but less acceleration, a larger value results in
                    slightly larger indexes but greater acceleration. See format of .frq file for more
                    information about skip levels.</description></item>
                <item><description>SkipMinimum is the minimum document frequency a term must have in order to write any
                    skip data at all.</description></item>
                <item><description>FreqDelta determines the position of this term's TermFreqs within the .frq
                    file. In particular, it is the difference between the position of this term's
                    data in that file and the position of the previous term's data (or zero, for
                    the first term in the block).</description></item>
                <item><description>ProxDelta determines the position of this term's TermPositions within the
                    .prx file. In particular, it is the difference between the position of this
                    term's data in that file and the position of the previous term's data (or zero,
                    for the first term in the block. For fields that omit position data, this will
                    be 0 since prox information is not stored.</description></item>
                <item><description>SkipDelta determines the position of this term's SkipData within the .frq
                    file. In particular, it is the number of bytes after TermFreqs that the
                    SkipData starts. In other words, it is the length of the TermFreq data.
                    SkipDelta is only stored if DocFreq is not smaller than SkipMinimum.</description></item>
             </list>
             <a name="Termindex" id="Termindex"></a>
             <h3>Term Index</h3>
             <para>The .tip file contains an index into the term dictionary, so that it can be
             accessed randomly.  See <see cref="T:Lucene.Net.Codecs.BlockTreeTermsWriter"/> for more details on the format.</para>
             <a name="Frequencies" id="Frequencies"></a>
             <h3>Frequencies</h3>
             <para>The .frq file contains the lists of documents which contain each term, along
             with the frequency of the term in that document (except when frequencies are
             omitted: <see cref="F:Lucene.Net.Index.IndexOptions.DOCS_ONLY"/>).</para>
             <list type="bullet">
               <item><description>FreqFile (.frq) --&gt; Header, &lt;TermFreqs, SkipData?&gt; <sup>TermCount</sup></description></item>
               <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
               <item><description>TermFreqs --&gt; &lt;TermFreq&gt; <sup>DocFreq</sup></description></item>
               <item><description>TermFreq --&gt; DocDelta[, Freq?]</description></item>
               <item><description>SkipData --&gt; &lt;&lt;SkipLevelLength, SkipLevel&gt;
                   <sup>NumSkipLevels-1</sup>, SkipLevel&gt; &lt;SkipDatum&gt;</description></item>
               <item><description>SkipLevel --&gt; &lt;SkipDatum&gt; <sup>DocFreq/(SkipInterval^(Level +
                   1))</sup></description></item>
               <item><description>SkipDatum --&gt;
                   DocSkip,PayloadLength?,OffsetLength?,FreqSkip,ProxSkip,SkipChildLevelPointer?</description></item>
               <item><description>DocDelta,Freq,DocSkip,PayloadLength,OffsetLength,FreqSkip,ProxSkip --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
               <item><description>SkipChildLevelPointer --&gt; VLong (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>) </description></item>
             </list>
             <para>TermFreqs are ordered by term (the term is implicit, from the term dictionary).</para>
             <para>TermFreq entries are ordered by increasing document number.</para>
             <para>DocDelta: if frequencies are indexed, this determines both the document
             number and the frequency. In particular, DocDelta/2 is the difference between
             this document number and the previous document number (or zero when this is the
             first document in a TermFreqs). When DocDelta is odd, the frequency is one.
             When DocDelta is even, the frequency is read as another VInt. If frequencies
             are omitted, DocDelta contains the gap (not multiplied by 2) between document
             numbers and no frequency information is stored.</para>
             <para>For example, the TermFreqs for a term which occurs once in document seven
             and three times in document eleven, with frequencies indexed, would be the
             following sequence of VInts:</para>
             <para>15, 8, 3</para>
             <para>If frequencies were omitted (<see cref="F:Lucene.Net.Index.IndexOptions.DOCS_ONLY"/>) it would be this
             sequence of VInts instead:</para>
             <para>7,4</para>
             <para>DocSkip records the document number before every SkipInterval <sup>th</sup>
             document in TermFreqs. If payloads and offsets are disabled for the term's field, then
             DocSkip represents the difference from the previous value in the sequence. If
             payloads and/or offsets are enabled for the term's field, then DocSkip/2 represents the
             difference from the previous value in the sequence. In this case when
             DocSkip is odd, then PayloadLength and/or OffsetLength are stored indicating the length of
             the last payload/offset before the SkipInterval<sup>th</sup> document in TermPositions.</para>
             <para>PayloadLength indicates the length of the last payload.</para>
             <para>OffsetLength indicates the length of the last offset (endOffset-startOffset).</para>
             <para>
             FreqSkip and ProxSkip record the position of every SkipInterval <sup>th</sup>
             entry in FreqFile and ProxFile, respectively. File positions are relative to
             the start of TermFreqs and Positions, to the previous SkipDatum in the
             sequence.</para>
             <para>For example, if DocFreq=35 and SkipInterval=16, then there are two SkipData
             entries, containing the 15 <sup>th</sup> and 31 <sup>st</sup> document numbers
             in TermFreqs. The first FreqSkip names the number of bytes after the beginning
             of TermFreqs that the 16 <sup>th</sup> SkipDatum starts, and the second the
             number of bytes after that that the 32 <sup>nd</sup> starts. The first ProxSkip
             names the number of bytes after the beginning of Positions that the 16
             <sup>th</sup> SkipDatum starts, and the second the number of bytes after that
             that the 32 <sup>nd</sup> starts.</para>
             <para>Each term can have multiple skip levels. The amount of skip levels for a
             term is NumSkipLevels = Min(MaxSkipLevels,
             floor(log(DocFreq/log(SkipInterval)))). The number of SkipData entries for a
             skip level is DocFreq/(SkipInterval^(Level + 1)), whereas the lowest skip level
             is Level=0.
             <para/>
             Example: SkipInterval = 4, MaxSkipLevels = 2, DocFreq = 35. Then skip level 0
             has 8 SkipData entries, containing the 3<sup>rd</sup>, 7<sup>th</sup>,
             11<sup>th</sup>, 15<sup>th</sup>, 19<sup>th</sup>, 23<sup>rd</sup>,
             27<sup>th</sup>, and 31<sup>st</sup> document numbers in TermFreqs. Skip level
             1 has 2 SkipData entries, containing the 15<sup>th</sup> and 31<sup>st</sup>
             document numbers in TermFreqs.
             <para/>
             The SkipData entries on all upper levels &gt; 0 contain a SkipChildLevelPointer
             referencing the corresponding SkipData entry in level-1. In the example has
             entry 15 on level 1 a pointer to entry 15 on level 0 and entry 31 on level 1 a
             pointer to entry 31 on level 0.
             </para>
             <a name="Positions" id="Positions"></a>
             <h3>Positions</h3>
             <para>The .prx file contains the lists of positions that each term occurs at
             within documents. Note that fields omitting positional data do not store
             anything into this file, and if all fields in the index omit positional data
             then the .prx file will not exist.</para>
             <list type="bullet">
               <item><description>ProxFile (.prx) --&gt; Header, &lt;TermPositions&gt; <sup>TermCount</sup></description></item>
               <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
               <item><description>TermPositions --&gt; &lt;Positions&gt; <sup>DocFreq</sup></description></item>
               <item><description>Positions --&gt; &lt;PositionDelta,PayloadLength?,OffsetDelta?,OffsetLength?,PayloadData?&gt; <sup>Freq</sup></description></item>
               <item><description>PositionDelta,OffsetDelta,OffsetLength,PayloadLength --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
               <item><description>PayloadData --&gt; byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) <sup>PayloadLength</sup></description></item>
             </list>
             <para>TermPositions are ordered by term (the term is implicit, from the term dictionary).</para>
             <para>Positions entries are ordered by increasing document number (the document
             number is implicit from the .frq file).</para>
             <para>PositionDelta is, if payloads are disabled for the term's field, the
             difference between the position of the current occurrence in the document and
             the previous occurrence (or zero, if this is the first occurrence in this
             document). If payloads are enabled for the term's field, then PositionDelta/2
             is the difference between the current and the previous position. If payloads
             are enabled and PositionDelta is odd, then PayloadLength is stored, indicating
             the length of the payload at the current term position.</para>
             <para>For example, the TermPositions for a term which occurs as the fourth term in
             one document, and as the fifth and ninth term in a subsequent document, would
             be the following sequence of VInts (payloads disabled):</para>
             <para>4, 5, 4</para>
             <para>PayloadData is metadata associated with the current term position. If
             PayloadLength is stored at the current position, then it indicates the length
             of this payload. If PayloadLength is not stored, then this payload has the same
             length as the payload at the previous position.</para>
             <para>OffsetDelta/2 is the difference between this position's startOffset from the
             previous occurrence (or zero, if this is the first occurrence in this document).
             If OffsetDelta is odd, then the length (endOffset-startOffset) differs from the
             previous occurrence and an OffsetLength follows. Offset data is only written for
             <see cref="F:Lucene.Net.Index.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS"/>.</para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.m_minBlockSize">
            <summary>
            Minimum items (terms or sub-blocks) per block for BlockTree. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.m_maxBlockSize">
            <summary>
            Maximum items (terms or sub-blocks) per block for BlockTree. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.#ctor">
            <summary>
            Creates <see cref="T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat"/> with default
            settings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates <see cref="T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat"/> with custom
            values for <paramref name="minBlockSize"/> and 
            <paramref name="maxBlockSize"/> passed to block terms dictionary. </summary>
             <seealso cref="M:Lucene.Net.Codecs.BlockTreeTermsWriter.#ctor(Lucene.Net.Index.SegmentWriteState,Lucene.Net.Codecs.PostingsWriterBase,System.Int32,System.Int32)"/>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.FREQ_EXTENSION">
            <summary>
            Extension of freq postings file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.PROX_EXTENSION">
            <summary>
            Extension of prox postings file. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader">
            <summary>
            Concrete class that reads the 4.0 frq/prox
            postings format.
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.FieldInfos,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext,System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader.SegmentDocsAndPositionsEnum.GetPayload">
            <summary>
            Returns the payload at this position, or <c>null</c> if no
            payload was indexed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader.SegmentFullPositionsEnum.GetPayload">
            <summary>
            Returns the payload at this position, or <c>null</c> if no
            payload was indexed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoFormat">
            <summary>
            Lucene 4.0 Segment info format.
            <para>
            Files:
            <list type="bullet">
              <item><description><tt>.si</tt>: Header, SegVersion, SegSize, IsCompoundFile, Diagnostics, Attributes, Files</description></item>
            </list>
            </para>
            Data types:
            <para>
            <list type="bullet">
              <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
              <item><description>SegSize --&gt; Int32 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>) </description></item>
              <item><description>SegVersion --&gt; String (<see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>) </description></item>
              <item><description>Files --&gt; ISet&lt;String&gt; (<see cref="M:Lucene.Net.Store.DataOutput.WriteStringSet(System.Collections.Generic.ISet{System.String})"/>) </description></item>
              <item><description>Diagnostics, Attributes --&gt; IDictionary&lt;String,String&gt; (<see cref="M:Lucene.Net.Store.DataOutput.WriteStringStringMap(System.Collections.Generic.IDictionary{System.String,System.String})"/>) </description></item>
              <item><description>IsCompoundFile --&gt; Int8 (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) </description></item>
            </list>
            </para>
            Field Descriptions:
            <para>
            <list type="bullet">
              <item><description>SegVersion is the code version that created the segment.</description></item>
              <item><description>SegSize is the number of documents contained in the segment index.</description></item>
              <item><description>IsCompoundFile records whether the segment is written as a compound file or
                  not. If this is -1, the segment is not a compound file. If it is 1, the segment
                  is a compound file.</description></item>
              <item><description>Checksum contains the CRC32 checksum of all bytes in the segments_N file up
                  until the checksum. This is used to verify integrity of the file on opening the
                  index.</description></item>
              <item><description>The Diagnostics Map is privately written by <see cref="T:Lucene.Net.Index.IndexWriter"/>, as a debugging aid,
                  for each segment it creates. It includes metadata like the current Lucene
                  version, OS, .NET/Java version, why the segment was created (merge, flush,
                  addIndexes), etc.</description></item>
              <item><description>Attributes: a key-value map of codec-private attributes.</description></item>
              <item><description>Files is a list of files referred to by this segment.</description></item>
            </list>
            </para>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Index.SegmentInfos"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoFormat.SI_EXTENSION">
            <summary>
            File extension used to store <see cref="T:Lucene.Net.Index.SegmentInfo"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoReader">
            <summary>
            Lucene 4.0 implementation of <see cref="T:Lucene.Net.Codecs.SegmentInfoReader"/>.
            <para/>
            @lucene.experimental 
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoWriter">
            <summary>
            Lucene 4.0 implementation of <see cref="T:Lucene.Net.Codecs.SegmentInfoWriter"/>.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoWriter.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoWriter.Write(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Save a single segment's info. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader">
            <summary>
            Implements the skip list reader for the 4.0 posting list format
            that stores positions and payloads.
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.Init(System.Int64,System.Int64,System.Int64,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Per-term initialization. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.FreqPointer">
            <summary>
            Returns the freq pointer of the doc to which the last call of
            <see cref="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipTo(System.Int32)"/> has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.ProxPointer">
            <summary>
            Returns the prox pointer of the doc to which the last call of
            <see cref="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipTo(System.Int32)"/> has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.PayloadLength">
            <summary>
            Returns the payload length of the payload stored just before
            the doc to which the last call of <see cref="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipTo(System.Int32)"/>
            has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.OffsetLength">
            <summary>
            Returns the offset length (endOffset-startOffset) of the position stored just before
            the doc to which the last call of <see cref="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipTo(System.Int32)"/>
            has skipped.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat">
            <summary>
            Lucene 4.0 Stored Fields Format.
            <para>Stored fields are represented by two files:</para>
            <list type="number">
                <item><description><a name="field_index" id="field_index"></a>
                    <para>The field index, or <c>.fdx</c> file.</para>
                    <para>This is used to find the location within the field data file of the fields
                    of a particular document. Because it contains fixed-length data, this file may
                    be easily randomly accessed. The position of document <i>n</i> 's field data is
                    the Uint64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>) at <i>n*8</i> in this file.</para>
                    <para>This contains, for each document, a pointer to its field data, as
                    follows:</para>
                    <list type="bullet">
                        <item><description>FieldIndex (.fdx) --&gt; &lt;Header&gt;, &lt;FieldValuesPosition&gt; <sup>SegSize</sup></description></item>
                        <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
                        <item><description>FieldValuesPosition --&gt; Uint64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>) </description></item>
                    </list>
                </description></item>
                <item><description>
                    <para><a name="field_data" id="field_data"></a>The field data, or <c>.fdt</c> file.</para>
                    <para>This contains the stored fields of each document, as follows:</para>
                    <list type="bullet">
                        <item><description>FieldData (.fdt) --&gt; &lt;Header&gt;, &lt;DocFieldData&gt; <sup>SegSize</sup></description></item>
                        <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
                        <item><description>DocFieldData --&gt; FieldCount, &lt;FieldNum, Bits, Value&gt;
                            <sup>FieldCount</sup></description></item>
                        <item><description>FieldCount --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
                        <item><description>FieldNum --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
                        <item><description>Bits --&gt; Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>)
                            <list type="bullet">
                                <item><description>low order bit reserved.</description></item>
                                <item><description>second bit is one for fields containing binary data</description></item>
                                <item><description>third bit reserved.</description></item>
                                <item><description>4th to 6th bit (mask: 0x7&lt;&lt;3) define the type of a numeric field:
                                    <list type="bullet">
                                        <item><description>all bits in mask are cleared if no numeric field at all</description></item>
                                        <item><description>1&lt;&lt;3: Value is Int</description></item>
                                        <item><description>2&lt;&lt;3: Value is Long</description></item>
                                        <item><description>3&lt;&lt;3: Value is Int as Float (as of <see cref="M:J2N.BitConversion.Int32BitsToSingle(System.Int32)"/></description></item>
                                        <item><description>4&lt;&lt;3: Value is Long as Double (as of <see cref="M:J2N.BitConversion.Int64BitsToDouble(System.Int64)"/></description></item>
                                    </list>
                                </description></item>
                            </list>
                        </description></item>
                        <item><description>Value --&gt; String | BinaryValue | Int | Long (depending on Bits)</description></item>
                        <item><description>BinaryValue --&gt; ValueSize, &lt; Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) &gt;^ValueSize</description></item>
                        <item><description>ValueSize --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
                    </list>
                </description></item>
            </list>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader">
            <summary>
            Class responsible for access to stored document fields.
            <para/>
            It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files.
            <para/>
            @lucene.internal
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.Clone">
            <summary>
            Returns a cloned FieldsReader that shares open
            <see cref="T:Lucene.Net.Store.IndexInput"/>s with the original one.  It is the caller's
            job not to dispose the original FieldsReader until all
            clones are called (eg, currently <see cref="T:Lucene.Net.Index.SegmentReader"/> manages
            this logic).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.#ctor(Lucene.Net.Index.FieldInfos,System.Int32,System.Int32,Lucene.Net.Store.IndexInput,Lucene.Net.Store.IndexInput)">
            <summary>
            Used only by clone. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.EnsureOpen">
            <exception cref="T:System.ObjectDisposedException"> if this FieldsReader is disposed. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.Dispose(System.Boolean)">
            <summary>
            Closes the underlying <see cref="T:Lucene.Net.Store.IndexInput"/> streams.
            This means that the <see cref="T:Lucene.Net.Index.Fields"/> values will not be accessible.
            </summary>
            <exception cref="T:System.IO.IOException"> If an I/O error occurs. </exception>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.Count">
            <summary>
            Returns number of documents.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.RawDocs(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Returns the length in bytes of each raw document in a
            contiguous range of length <paramref name="numDocs"/> starting with
            <paramref name="startDocID"/>.  Returns the <see cref="T:Lucene.Net.Store.IndexInput"/> (the fieldStream),
            already seeked to the starting point for <paramref name="startDocID"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter">
            <summary>
            Class responsible for writing stored document fields.
            <para/>
            It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat"/>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.FIELDS_EXTENSION">
            <summary>
            Extension of stored fields file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.FIELDS_INDEX_EXTENSION">
            <summary>
            Extension of stored fields index file. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.AddRawDocuments(Lucene.Net.Store.IndexInput,System.Int32[],System.Int32)">
            <summary>
            Bulk write a contiguous series of documents.  The
            <paramref name="lengths"/> array is the length (in bytes) of each raw
            document.  The <paramref name="stream"/> <see cref="T:Lucene.Net.Store.IndexInput"/> is the
            fieldsStream from which we should bulk-copy all
            bytes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.MAX_RAW_MERGE_DOCS">
            <summary>
            Maximum number of contiguous documents to bulk-copy
            when merging stored fields.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsFormat">
            <summary>
            Lucene 4.0 Term Vectors format.
            <para>Term Vector support is an optional on a field by field basis. It consists of
            3 files.</para>
            <list type="number">
            <item><description><a name="tvx" id="tvx"></a>
            <para>The Document Index or .tvx file.</para>
            <para>For each document, this stores the offset into the document data (.tvd) and
            field data (.tvf) files.</para>
            <para>DocumentIndex (.tvx) --&gt; Header,&lt;DocumentPosition,FieldPosition&gt;
            <sup>NumDocs</sup></para>
            <list type="bullet">
              <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
              <item><description>DocumentPosition --&gt; UInt64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>)  (offset in the .tvd file)</description></item>
              <item><description>FieldPosition --&gt; UInt64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>)  (offset in the .tvf file)</description></item>
            </list>
            </description></item>
            <item><description><a name="tvd" id="tvd"></a>
            <para>The Document or .tvd file.</para>
            <para>This contains, for each document, the number of fields, a list of the fields
            with term vector info and finally a list of pointers to the field information
            in the .tvf (Term Vector Fields) file.</para>
            <para>The .tvd file is used to map out the fields that have term vectors stored
            and where the field information is in the .tvf file.</para>
            <para>Document (.tvd) --&gt; Header,&lt;NumFields, FieldNums,
            FieldPositions&gt; <sup>NumDocs</sup></para>
            <list type="bullet">
              <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
              <item><description>NumFields --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
              <item><description>FieldNums --&gt; &lt;FieldNumDelta&gt; <sup>NumFields</sup></description></item>
              <item><description>FieldNumDelta --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
              <item><description>FieldPositions --&gt; &lt;FieldPositionDelta&gt; <sup>NumFields-1</sup></description></item>
              <item><description>FieldPositionDelta --&gt; VLong (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>) </description></item>
            </list>
            </description></item>
            <item><description><a name="tvf" id="tvf"></a>
            <para>The Field or .tvf file.</para>
            <para>This file contains, for each field that has a term vector stored, a list of
            the terms, their frequencies and, optionally, position, offset, and payload
            information.</para>
            <para>Field (.tvf) --&gt; Header,&lt;NumTerms, Flags, TermFreqs&gt;
            <sup>NumFields</sup></para>
            <list type="bullet">
              <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
              <item><description>NumTerms --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
              <item><description>Flags --&gt; Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) </description></item>
              <item><description>TermFreqs --&gt; &lt;TermText, TermFreq, Positions?, PayloadData?, Offsets?&gt;
                  <sup>NumTerms</sup></description></item>
              <item><description>TermText --&gt; &lt;PrefixLength, Suffix&gt;</description></item>
              <item><description>PrefixLength --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
              <item><description>Suffix --&gt; String (<see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>) </description></item>
              <item><description>TermFreq --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
              <item><description>Positions --&gt; &lt;PositionDelta PayloadLength?&gt;<sup>TermFreq</sup></description></item>
              <item><description>PositionDelta --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
              <item><description>PayloadLength --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
              <item><description>PayloadData --&gt; Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) <sup>NumPayloadBytes</sup></description></item>
              <item><description>Offsets --&gt; &lt;VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>), VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) &gt;<sup>TermFreq</sup></description></item>
            </list>
            <para>Notes:</para>
            <list type="bullet">
            <item><description>Flags byte stores whether this term vector has position, offset, payload.
            information stored.</description></item>
            <item><description>Term byte prefixes are shared. The PrefixLength is the number of initial
            bytes from the previous term which must be pre-pended to a term's suffix
            in order to form the term's bytes. Thus, if the previous term's text was "bone"
            and the term is "boy", the PrefixLength is two and the suffix is "y".</description></item>
            <item><description>PositionDelta is, if payloads are disabled for the term's field, the
            difference between the position of the current occurrence in the document and
            the previous occurrence (or zero, if this is the first occurrence in this
            document). If payloads are enabled for the term's field, then PositionDelta/2
            is the difference between the current and the previous position. If payloads
            are enabled and PositionDelta is odd, then PayloadLength is stored, indicating
            the length of the payload at the current term position.</description></item>
            <item><description>PayloadData is metadata associated with a term position. If
            PayloadLength is stored at the current position, then it indicates the length
            of this payload. If PayloadLength is not stored, then this payload has the same
            length as the payload at the previous position. PayloadData encodes the
            concatenated bytes for all of a terms occurrences.</description></item>
            <item><description>Offsets are stored as delta encoded VInts. The first VInt is the
            startOffset, the second is the endOffset.</description></item>
            </list>
            </description></item>
            </list>
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader">
            <summary>
            Lucene 4.0 Term Vectors reader.
            <para/>
            It reads .tvd, .tvf, and .tvx files.
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsFormat"/>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.VECTORS_FIELDS_EXTENSION">
            <summary>
            Extension of vectors fields file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.VECTORS_DOCUMENTS_EXTENSION">
            <summary>
            Extension of vectors documents file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.VECTORS_INDEX_EXTENSION">
            <summary>
            Extension of vectors index file. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.#ctor(Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IndexInput,Lucene.Net.Store.IndexInput,Lucene.Net.Store.IndexInput,System.Int32,System.Int32)">
            <summary>
            Used by clone. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.RawDocs(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Retrieve the length (in bytes) of the tvd and tvf
            entries for the next <paramref name="numDocs"/> starting with
            <paramref name="startDocID"/>.  This is used for bulk copying when
            merging segments, if the field numbers are
            congruent.  Once this returns, the tvf &amp; tvd streams
            are seeked to the <paramref name="startDocID"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.Count">
            <summary>
            The number of documents in the reader.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter">
            <summary>
            Lucene 4.0 Term Vectors writer.
            <para/>
            It writes .tvd, .tvf, and .tvx files.
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter.AddRawDocuments(Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader,System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Do a bulk copy of numDocs documents from reader to our
            streams.  This is used to expedite merging, if the
            field numbers are congruent.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter.MAX_RAW_MERGE_DOCS">
            <summary>
            Maximum number of contiguous documents to bulk-copy
            when merging term vectors.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter.Dispose(System.Boolean)">
            <summary>
            Close all streams. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.ForUtil">
            <summary>
            Encode all values in normal area with fixed bit width,
            which is determined by the max value in this block.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.ForUtil.ALL_VALUES_EQUAL">
            <summary>
            Special number of bits per value used whenever all values to encode are equal.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.ForUtil.MAX_ENCODED_SIZE">
            <summary>
            Upper limit of the number of bytes that might be required to stored
            <see cref="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.BLOCK_SIZE"/> encoded values.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.ForUtil.MAX_DATA_SIZE">
            <summary>
            Upper limit of the number of values that might be decoded in a single call to
            <see cref="M:Lucene.Net.Codecs.Lucene41.ForUtil.ReadBlock(Lucene.Net.Store.IndexInput,System.Byte[],System.Int32[])"/>. Although values after
            <see cref="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.BLOCK_SIZE"/> are garbage, it is necessary to allocate value buffers
            whose size is &gt;= MAX_DATA_SIZE to avoid <see cref="T:System.IndexOutOfRangeException"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.ComputeIterations(Lucene.Net.Util.Packed.PackedInt32s.IDecoder)">
            <summary>
            Compute the number of iterations required to decode <see cref="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.BLOCK_SIZE"/>
            values with the provided <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.IDecoder"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.EncodedSize(Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32)">
            <summary>
            Compute the number of bytes required to encode a block of values that require
            <paramref name="bitsPerValue"/> bits per value with format <paramref name="format"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.#ctor(System.Single,Lucene.Net.Store.DataOutput)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Codecs.Lucene41.ForUtil"/> instance and save state into <paramref name="out"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.#ctor(Lucene.Net.Store.DataInput)">
            <summary>
            Restore a <see cref="T:Lucene.Net.Codecs.Lucene41.ForUtil"/> from a <see cref="T:Lucene.Net.Store.DataInput"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.WriteBlock(System.Int32[],System.Byte[],Lucene.Net.Store.IndexOutput)">
            <summary>
            Write a block of data (<c>For</c> format).
            </summary>
            <param name="data">     The data to write. </param>
            <param name="encoded">  A buffer to use to encode data. </param>
            <param name="out">      The destination output. </param>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.ReadBlock(Lucene.Net.Store.IndexInput,System.Byte[],System.Int32[])">
            <summary>
            Read the next block of data (<c>For</c> format).
            </summary>
            <param name="in">        The input to use to read data. </param>
            <param name="encoded">   A buffer that can be used to store encoded data. </param>
            <param name="decoded">   Where to write decoded data. </param>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.SkipBlock(Lucene.Net.Store.IndexInput)">
            <summary>
            Skip the next block of data.
            </summary>
            <param name="in">      The input where to read data. </param>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.BitsRequired(System.Int32[])">
            <summary>
            Compute the number of bits required to serialize any of the longs in
            <paramref name="data"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41Codec">
            <summary>
            Implements the Lucene 4.1 index format, with configurable per-field postings formats.
            <para/>
            If you want to reuse functionality of this codec in another codec, extend
            <see cref="T:Lucene.Net.Codecs.FilterCodec"/>.
            <para/>
            See <see cref="N:Lucene.Net.Codecs.Lucene41"/> package documentation for file format details.
            <para/>
            @lucene.experimental 
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41Codec.GetPostingsFormatForField(System.String)">
            <summary>
            Returns the postings format that should be used for writing
            new segments of <paramref name="field"/>.
            <para/>
            The default implementation always returns "Lucene41"
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsBaseFormat">
            <summary>
            Provides a <see cref="T:Lucene.Net.Codecs.PostingsReaderBase"/> and 
            <see cref="T:Lucene.Net.Codecs.PostingsWriterBase"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsBaseFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat">
             <summary>
             Lucene 4.1 postings format, which encodes postings in packed integer blocks
             for fast decode.
            
             <para><b>NOTE</b>: this format is still experimental and
             subject to change without backwards compatibility.
            
             <para>
             Basic idea:
             <list type="bullet">
               <item><description>
               <b>Packed Blocks and VInt Blocks</b>:
               <para>In packed blocks, integers are encoded with the same bit width packed format (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>):
                  the block size (i.e. number of integers inside block) is fixed (currently 128). Additionally blocks
                  that are all the same value are encoded in an optimized way.</para>
               <para>In VInt blocks, integers are encoded as VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>):
                  the block size is variable.</para>
               </description></item>
            
               <item><description>
               <b>Block structure</b>:
               <para>When the postings are long enough, Lucene41PostingsFormat will try to encode most integer data
                  as a packed block.</para>
               <para>Take a term with 259 documents as an example, the first 256 document ids are encoded as two packed
                  blocks, while the remaining 3 are encoded as one VInt block. </para>
               <para>Different kinds of data are always encoded separately into different packed blocks, but may
                  possibly be interleaved into the same VInt block. </para>
               <para>This strategy is applied to pairs:
                  &lt;document number, frequency&gt;,
                  &lt;position, payload length&gt;,
                  &lt;position, offset start, offset length&gt;, and
                  &lt;position, payload length, offsetstart, offset length&gt;.</para>
               </description></item>
            
               <item><description>
               <b>Skipdata settings</b>:
               <para>The structure of skip table is quite similar to previous version of Lucene. Skip interval is the
                  same as block size, and each skip entry points to the beginning of each block. However, for
                  the first block, skip data is omitted.</para>
               </description></item>
            
               <item><description>
               <b>Positions, Payloads, and Offsets</b>:
               <para>A position is an integer indicating where the term occurs within one document.
                  A payload is a blob of metadata associated with current position.
                  An offset is a pair of integers indicating the tokenized start/end offsets for given term
                  in current position: it is essentially a specialized payload. </para>
               <para>When payloads and offsets are not omitted, numPositions==numPayloads==numOffsets (assuming a
                  null payload contributes one count). As mentioned in block structure, it is possible to encode
                  these three either combined or separately.</para>
               <para>In all cases, payloads and offsets are stored together. When encoded as a packed block,
                  position data is separated out as .pos, while payloads and offsets are encoded in .pay (payload
                  metadata will also be stored directly in .pay). When encoded as VInt blocks, all these three are
                  stored interleaved into the .pos (so is payload metadata).</para>
               <para>With this strategy, the majority of payload and offset data will be outside .pos file.
                  So for queries that require only position data, running on a full index with payloads and offsets,
                  this reduces disk pre-fetches.</para>
               </description></item>
             </list>
             </para>
            
             <para>
             Files and detailed format:
             <list type="bullet">
               <item><description><c>.tim</c>: <a href="#Termdictionary">Term Dictionary</a></description></item>
               <item><description><c>.tip</c>: <a href="#Termindex">Term Index</a></description></item>
               <item><description><c>.doc</c>: <a href="#Frequencies">Frequencies and Skip Data</a></description></item>
               <item><description><c>.pos</c>: <a href="#Positions">Positions</a></description></item>
               <item><description><c>.pay</c>: <a href="#Payloads">Payloads and Offsets</a></description></item>
             </list>
             </para>
            
             <a name="Termdictionary" id="Termdictionary"></a>
             <dl>
             <dd>
             <b>Term Dictionary</b>
            
             <para>The .tim file contains the list of terms in each
             field along with per-term statistics (such as docfreq)
             and pointers to the frequencies, positions, payload and
             skip data in the .doc, .pos, and .pay files.
             See <see cref="T:Lucene.Net.Codecs.BlockTreeTermsWriter"/> for more details on the format.
             </para>
            
             <para>NOTE: The term dictionary can plug into different postings implementations:
             the postings writer/reader are actually responsible for encoding
             and decoding the PostingsHeader and TermMetadata sections described here:</para>
            
             <list type="bullet">
               <item><description>PostingsHeader --&gt; Header, PackedBlockSize</description></item>
               <item><description>TermMetadata --&gt; (DocFPDelta|SingletonDocID), PosFPDelta?, PosVIntBlockFPDelta?, PayFPDelta?,
                                        SkipFPDelta?</description></item>
               <item><description>Header, --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
               <item><description>PackedBlockSize, SingletonDocID --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
               <item><description>DocFPDelta, PosFPDelta, PayFPDelta, PosVIntBlockFPDelta, SkipFPDelta --&gt; VLong (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>) </description></item>
               <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>) </description></item>
             </list>
             <para>Notes:</para>
             <list type="bullet">
                <item><description>Header is a CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) storing the version information
                    for the postings.</description></item>
                <item><description>PackedBlockSize is the fixed block size for packed blocks. In packed block, bit width is
                    determined by the largest integer. Smaller block size result in smaller variance among width
                    of integers hence smaller indexes. Larger block size result in more efficient bulk i/o hence
                    better acceleration. This value should always be a multiple of 64, currently fixed as 128 as
                    a tradeoff. It is also the skip interval used to accelerate <see cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/>.</description></item>
                <item><description>DocFPDelta determines the position of this term's TermFreqs within the .doc file.
                    In particular, it is the difference of file offset between this term's
                    data and previous term's data (or zero, for the first term in the block).On disk it is
                    stored as the difference from previous value in sequence. </description></item>
                <item><description>PosFPDelta determines the position of this term's TermPositions within the .pos file.
                    While PayFPDelta determines the position of this term's &lt;TermPayloads, TermOffsets?&gt; within
                    the .pay file. Similar to DocFPDelta, it is the difference between two file positions (or
                    neglected, for fields that omit payloads and offsets).</description></item>
                <item><description>PosVIntBlockFPDelta determines the position of this term's last TermPosition in last pos packed
                    block within the .pos file. It is synonym for PayVIntBlockFPDelta or OffsetVIntBlockFPDelta.
                    This is actually used to indicate whether it is necessary to load following
                    payloads and offsets from .pos instead of .pay. Every time a new block of positions are to be
                    loaded, the PostingsReader will use this value to check whether current block is packed format
                    or VInt. When packed format, payloads and offsets are fetched from .pay, otherwise from .pos.
                    (this value is neglected when total number of positions i.e. totalTermFreq is less or equal
                    to PackedBlockSize).</description></item>
                <item><description>SkipFPDelta determines the position of this term's SkipData within the .doc
                    file. In particular, it is the length of the TermFreq data.
                    SkipDelta is only stored if DocFreq is not smaller than SkipMinimum
                    (i.e. 128 in Lucene41PostingsFormat).</description></item>
                <item><description>SingletonDocID is an optimization when a term only appears in one document. In this case, instead
                    of writing a file pointer to the .doc file (DocFPDelta), and then a VIntBlock at that location, the
                    single document ID is written to the term dictionary.</description></item>
             </list>
             </dd>
             </dl>
            
             <a name="Termindex" id="Termindex"></a>
             <dl>
             <dd>
             <b>Term Index</b>
             <para>The .tip file contains an index into the term dictionary, so that it can be
             accessed randomly.  See <see cref="T:Lucene.Net.Codecs.BlockTreeTermsWriter"/> for more details on the format.</para>
             </dd>
             </dl>
            
            
             <a name="Frequencies" id="Frequencies"></a>
             <dl>
             <dd>
             <b>Frequencies and Skip Data</b>
            
             <para>The .doc file contains the lists of documents which contain each term, along
             with the frequency of the term in that document (except when frequencies are
             omitted: <see cref="F:Lucene.Net.Index.IndexOptions.DOCS_ONLY"/>). It also saves skip data to the beginning of
             each packed or VInt block, when the length of document list is larger than packed block size.</para>
            
             <list type="bullet">
               <item><description>docFile(.doc) --&gt; Header, &lt;TermFreqs, SkipData?&gt;<sup>TermCount</sup>, Footer</description></item>
               <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>)</description></item>
               <item><description>TermFreqs --&gt; &lt;PackedBlock&gt; <sup>PackedDocBlockNum</sup>,
                                    VIntBlock? </description></item>
               <item><description>PackedBlock --&gt; PackedDocDeltaBlock, PackedFreqBlock?</description></item>
               <item><description>VIntBlock --&gt; &lt;DocDelta[, Freq?]&gt;<sup>DocFreq-PackedBlockSize*PackedDocBlockNum</sup></description></item>
               <item><description>SkipData --&gt; &lt;&lt;SkipLevelLength, SkipLevel&gt;
                   <sup>NumSkipLevels-1</sup>, SkipLevel&gt;, SkipDatum?</description></item>
               <item><description>SkipLevel --&gt; &lt;SkipDatum&gt; <sup>TrimmedDocFreq/(PackedBlockSize^(Level + 1))</sup></description></item>
               <item><description>SkipDatum --&gt; DocSkip, DocFPSkip, &lt;PosFPSkip, PosBlockOffset, PayLength?,
                                    PayFPSkip?&gt;?, SkipChildLevelPointer?</description></item>
               <item><description>PackedDocDeltaBlock, PackedFreqBlock --&gt; PackedInts (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>) </description></item>
               <item><description>DocDelta, Freq, DocSkip, DocFPSkip, PosFPSkip, PosBlockOffset, PayByteUpto, PayFPSkip
                   --&gt;
               VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
               <item><description>SkipChildLevelPointer --&gt; VLong (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>) </description></item>
               <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>) </description></item>
             </list>
             <para>Notes:</para>
             <list type="bullet">
               <item><description>PackedDocDeltaBlock is theoretically generated from two steps:
                 <list type="number">
                   <item><description>Calculate the difference between each document number and previous one,
                       and get a d-gaps list (for the first document, use absolute value); </description></item>
                   <item><description>For those d-gaps from first one to PackedDocBlockNum*PackedBlockSize<sup>th</sup>,
                       separately encode as packed blocks.</description></item>
                 </list>
                 If frequencies are not omitted, PackedFreqBlock will be generated without d-gap step.
               </description></item>
               <item><description>VIntBlock stores remaining d-gaps (along with frequencies when possible) with a format
                   that encodes DocDelta and Freq:
                   <para>DocDelta: if frequencies are indexed, this determines both the document
                   number and the frequency. In particular, DocDelta/2 is the difference between
                   this document number and the previous document number (or zero when this is the
                   first document in a TermFreqs). When DocDelta is odd, the frequency is one.
                   When DocDelta is even, the frequency is read as another VInt. If frequencies
                   are omitted, DocDelta contains the gap (not multiplied by 2) between document
                   numbers and no frequency information is stored.</para>
                   <para>For example, the TermFreqs for a term which occurs once in document seven
                      and three times in document eleven, with frequencies indexed, would be the
                      following sequence of VInts:</para>
                   <para>15, 8, 3</para>
                   <para>If frequencies were omitted (<see cref="F:Lucene.Net.Index.IndexOptions.DOCS_ONLY"/>) it would be this
                      sequence of VInts instead:</para>
                   <para>7,4</para>
               </description></item>
               <item><description>PackedDocBlockNum is the number of packed blocks for current term's docids or frequencies.
                   In particular, PackedDocBlockNum = floor(DocFreq/PackedBlockSize) </description></item>
               <item><description>TrimmedDocFreq = DocFreq % PackedBlockSize == 0 ? DocFreq - 1 : DocFreq.
                   We use this trick since the definition of skip entry is a little different from base interface.
                   In <see cref="T:Lucene.Net.Codecs.MultiLevelSkipListWriter"/>, skip data is assumed to be saved for
                   skipInterval<sup>th</sup>, 2*skipInterval<sup>th</sup> ... posting in the list. However,
                   in Lucene41PostingsFormat, the skip data is saved for skipInterval+1<sup>th</sup>,
                   2*skipInterval+1<sup>th</sup> ... posting (skipInterval==PackedBlockSize in this case).
                   When DocFreq is multiple of PackedBlockSize, MultiLevelSkipListWriter will expect one
                   more skip data than Lucene41SkipWriter. </description></item>
               <item><description>SkipDatum is the metadata of one skip entry.
                  For the first block (no matter packed or VInt), it is omitted.</description></item>
               <item><description>DocSkip records the document number of every PackedBlockSize<sup>th</sup> document number in
                   the postings (i.e. last document number in each packed block). On disk it is stored as the
                   difference from previous value in the sequence. </description></item>
               <item><description>DocFPSkip records the file offsets of each block (excluding )posting at
                   PackedBlockSize+1<sup>th</sup>, 2*PackedBlockSize+1<sup>th</sup> ... , in DocFile.
                   The file offsets are relative to the start of current term's TermFreqs.
                   On disk it is also stored as the difference from previous SkipDatum in the sequence.</description></item>
               <item><description>Since positions and payloads are also block encoded, the skip should skip to related block first,
                   then fetch the values according to in-block offset. PosFPSkip and PayFPSkip record the file
                   offsets of related block in .pos and .pay, respectively. While PosBlockOffset indicates
                   which value to fetch inside the related block (PayBlockOffset is unnecessary since it is always
                   equal to PosBlockOffset). Same as DocFPSkip, the file offsets are relative to the start of
                   current term's TermFreqs, and stored as a difference sequence.</description></item>
               <item><description>PayByteUpto indicates the start offset of the current payload. It is equivalent to
                   the sum of the payload lengths in the current block up to PosBlockOffset</description></item>
             </list>
             </dd>
             </dl>
            
             <a name="Positions" id="Positions"></a>
             <dl>
             <dd>
             <b>Positions</b>
             <para>The .pos file contains the lists of positions that each term occurs at within documents. It also
                sometimes stores part of payloads and offsets for speedup.</para>
             <list type="bullet">
               <item><description>PosFile(.pos) --&gt; Header, &lt;TermPositions&gt; <sup>TermCount</sup>, Footer</description></item>
               <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
               <item><description>TermPositions --&gt; &lt;PackedPosDeltaBlock&gt; <sup>PackedPosBlockNum</sup>,
                                        VIntBlock? </description></item>
               <item><description>VIntBlock --&gt; &lt;PositionDelta[, PayloadLength?], PayloadData?,
                                    OffsetDelta?, OffsetLength?&gt;<sup>PosVIntCount</sup></description></item>
               <item><description>PackedPosDeltaBlock --&gt; PackedInts (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>)</description></item>
               <item><description>PositionDelta, OffsetDelta, OffsetLength --&gt;
                   VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
               <item><description>PayloadData --&gt; byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>)<sup>PayLength</sup></description></item>
               <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>) </description></item>
             </list>
             <para>Notes:</para>
             <list type="bullet">
               <item><description>TermPositions are order by term (terms are implicit, from the term dictionary), and position
                   values for each term document pair are incremental, and ordered by document number.</description></item>
               <item><description>PackedPosBlockNum is the number of packed blocks for current term's positions, payloads or offsets.
                   In particular, PackedPosBlockNum = floor(totalTermFreq/PackedBlockSize) </description></item>
               <item><description>PosVIntCount is the number of positions encoded as VInt format. In particular,
                   PosVIntCount = totalTermFreq - PackedPosBlockNum*PackedBlockSize</description></item>
               <item><description>The procedure how PackedPosDeltaBlock is generated is the same as PackedDocDeltaBlock
                   in chapter <a href="#Frequencies">Frequencies and Skip Data</a>.</description></item>
               <item><description>PositionDelta is, if payloads are disabled for the term's field, the
                   difference between the position of the current occurrence in the document and
                   the previous occurrence (or zero, if this is the first occurrence in this
                   document). If payloads are enabled for the term's field, then PositionDelta/2
                   is the difference between the current and the previous position. If payloads
                   are enabled and PositionDelta is odd, then PayloadLength is stored, indicating
                   the length of the payload at the current term position.</description></item>
               <item><description>For example, the TermPositions for a term which occurs as the fourth term in
                   one document, and as the fifth and ninth term in a subsequent document, would
                   be the following sequence of VInts (payloads disabled):
                   <para>4, 5, 4</para></description></item>
               <item><description>PayloadData is metadata associated with the current term position. If
                   PayloadLength is stored at the current position, then it indicates the length
                   of this payload. If PayloadLength is not stored, then this payload has the same
                   length as the payload at the previous position.</description></item>
               <item><description>OffsetDelta/2 is the difference between this position's startOffset from the
                   previous occurrence (or zero, if this is the first occurrence in this document).
                   If OffsetDelta is odd, then the length (endOffset-startOffset) differs from the
                   previous occurrence and an OffsetLength follows. Offset data is only written for
                   <see cref="F:Lucene.Net.Index.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS"/>.</description></item>
             </list>
             </dd>
             </dl>
            
             <a name="Payloads" id="Payloads"></a>
             <dl>
             <dd>
             <b>Payloads and Offsets</b>
             <para>The .pay file will store payloads and offsets associated with certain term-document positions.
                Some payloads and offsets will be separated out into .pos file, for performance reasons.</para>
             <list type="bullet">
               <item><description>PayFile(.pay): --&gt; Header, &lt;TermPayloads, TermOffsets?&gt; <sup>TermCount</sup>, Footer</description></item>
               <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
               <item><description>TermPayloads --&gt; &lt;PackedPayLengthBlock, SumPayLength, PayData&gt; <sup>PackedPayBlockNum</sup></description></item>
               <item><description>TermOffsets --&gt; &lt;PackedOffsetStartDeltaBlock, PackedOffsetLengthBlock&gt; <sup>PackedPayBlockNum</sup></description></item>
               <item><description>PackedPayLengthBlock, PackedOffsetStartDeltaBlock, PackedOffsetLengthBlock --&gt; PackedInts (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>) </description></item>
               <item><description>SumPayLength --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
               <item><description>PayData --&gt; byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) <sup>SumPayLength</sup></description></item>
               <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>) </description></item>
             </list>
             <para>Notes:</para>
             <list type="bullet">
               <item><description>The order of TermPayloads/TermOffsets will be the same as TermPositions, note that part of
                   payload/offsets are stored in .pos.</description></item>
               <item><description>The procedure how PackedPayLengthBlock and PackedOffsetLengthBlock are generated is the
                   same as PackedFreqBlock in chapter <a href="#Frequencies">Frequencies and Skip Data</a>.
                   While PackedStartDeltaBlock follows a same procedure as PackedDocDeltaBlock.</description></item>
               <item><description>PackedPayBlockNum is always equal to PackedPosBlockNum, for the same term. It is also synonym
                   for PackedOffsetBlockNum.</description></item>
               <item><description>SumPayLength is the total length of payloads written within one block, should be the sum
                   of PayLengths in one packed block.</description></item>
               <item><description>PayLength in PackedPayLengthBlock is the length of each payload associated with the current
                   position.</description></item>
             </list>
             </dd>
             </dl>
             </para>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.DOC_EXTENSION">
            <summary>
            Filename extension for document number, frequencies, and skip data.
            See chapter: <a href="#Frequencies">Frequencies and Skip Data</a>
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.POS_EXTENSION">
            <summary>
            Filename extension for positions.
            See chapter: <a href="#Positions">Positions</a>
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.PAY_EXTENSION">
            <summary>
            Filename extension for payloads and offsets.
            See chapter: <a href="#Payloads">Payloads and Offsets</a>
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.BLOCK_SIZE">
            <summary>
            Fixed packed block size, number of integers encoded in
            a single packed block.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.#ctor">
            <summary>
            Creates <see cref="T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat"/> with default
            settings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates <see cref="T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat"/> with custom
            values for <paramref name="minTermBlockSize"/> and 
            <paramref name="maxTermBlockSize"/> passed to block terms dictionary. </summary>
            <seealso cref="M:Lucene.Net.Codecs.BlockTreeTermsWriter.#ctor(Lucene.Net.Index.SegmentWriteState,Lucene.Net.Codecs.PostingsWriterBase,System.Int32,System.Int32)"/>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsReader">
            <summary>
            Concrete class that reads docId(maybe frq,pos,offset,payloads) list
            with postings format.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene41.Lucene41SkipReader"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.FieldInfos,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext,System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsReader.ReadVInt32Block(Lucene.Net.Store.IndexInput,System.Int32[],System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Read values that have been written using variable-length encoding instead of bit-packing.
            <para/>
            NOTE: This was readVIntBlock() in Lucene.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter">
            <summary>
            Concrete class that writes docId(maybe frq,pos,offset,payloads) list
            with postings format.
            <para/>
            Postings list for each term will be stored separately.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene41.Lucene41SkipWriter"/> for details about skipping setting and postings layout.
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.maxSkipLevels">
            <summary>
            Expert: The maximum number of skip levels. Smaller values result in
            slightly smaller indexes, but slower skipping in big posting lists.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.#ctor(Lucene.Net.Index.SegmentWriteState,System.Single)">
            <summary>
            Creates a postings writer with the specified PackedInts overhead ratio </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.#ctor(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Creates a postings writer with <code>PackedInts.COMPACT</code> </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.Int32BlockTermState">
            <summary>
            NOTE: This was IntBlockTermState in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.AddPosition(System.Int32,Lucene.Net.Util.BytesRef,System.Int32,System.Int32)">
            <summary>
            Add a new position &amp; payload </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.FinishTerm(Lucene.Net.Codecs.BlockTermState)">
            <summary>
            Called when we are done adding docs to this term. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41SkipReader">
            <summary>
            Implements the skip list reader for block postings format
            that stores positions and payloads.
            <para/>
            Although this skipper uses MultiLevelSkipListReader as an interface,
            its definition of skip position will be a little different.
            <para/>
            For example, when skipInterval = blockSize = 3, df = 2*skipInterval = 6,
            <para/>
            0 1 2 3 4 5
            d d d d d d    (posting list)
                ^     ^    (skip point in MultiLeveSkipWriter)
                  ^        (skip point in Lucene41SkipWriter)
            <para/>
            In this case, MultiLevelSkipListReader will use the last document as a skip point,
            while Lucene41SkipReader should assume no skip point will comes.
            <para/>
            If we use the interface directly in Lucene41SkipReader, it may silly try to read
            another skip data after the only skip point is loaded.
            <para/>
            To illustrate this, we can call skipTo(d[5]), since skip point d[3] has smaller docId,
            and numSkipped+blockSize== df, the MultiLevelSkipListReader will assume the skip list
            isn't exhausted yet, and try to load a non-existed skip point
            <para/>
            Therefore, we'll trim df before passing it to the interface. see <see cref="M:Lucene.Net.Codecs.Lucene41.Lucene41SkipReader.Trim(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41SkipReader.Trim(System.Int32)">
            <summary>
            Trim original docFreq to tell skipReader read proper number of skip points.
            <para/>
            Since our definition in Lucene41Skip* is a little different from MultiLevelSkip*
            this trimmed docFreq will prevent skipReader from:
            1. silly reading a non-existed skip point after the last block boundary
            2. moving into the vInt block
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene41.Lucene41SkipReader.DocPointer">
            <summary>
            Returns the doc pointer of the doc to which the last call of
            <seealso cref="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipTo(System.Int32)"/> has skipped.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41SkipWriter">
             <summary>
             Write skip lists with multiple levels, and support skip within block ints.
             <para/>
             Assume that docFreq = 28, skipInterval = blockSize = 12
            
              |       block#0       | |      block#1        | |vInts|
              d d d d d d d d d d d d d d d d d d d d d d d d d d d d (posting list)
                                      ^                       ^       (level 0 skip point)
             <para/>
             Note that skipWriter will ignore first document in block#0, since
             it is useless as a skip point.  Also, we'll never skip into the vInts
             block, only record skip data at the start its start point(if it exist).
             <para/>
             For each skip point, we will record:
             1. docID in former position, i.e. for position 12, record docID[11], etc.
             2. its related file points(position, payload),
             3. related numbers or uptos(position, payload).
             4. start offset.
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41SkipWriter.BufferSkip(System.Int32,System.Int32,System.Int64,System.Int64,System.Int32,System.Int32)">
            <summary>
            Sets the values for the current skip data.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41StoredFieldsFormat">
             <summary>
             Lucene 4.1 stored fields format.
            
             <para><b>Principle</b></para>
             <para>This <seealso cref="T:Lucene.Net.Codecs.StoredFieldsFormat"/> compresses blocks of 16KB of documents in
             order to improve the compression ratio compared to document-level
             compression. It uses the <a href="http://code.google.com/p/lz4/">LZ4</a>
             compression algorithm, which is fast to compress and very fast to decompress
             data. Although the compression method that is used focuses more on speed
             than on compression ratio, it should provide interesting compression ratios
             for redundant inputs (such as log files, HTML or plain text).</para>
             <para><b>File formats</b></para>
             <para>Stored fields are represented by two files:</para>
             <list type="number">
             <item><description><a name="field_data" id="field_data"></a>
             <para>A fields data file (extension <c>.fdt</c>). this file stores a compact
             representation of documents in compressed blocks of 16KB or more. When
             writing a segment, documents are appended to an in-memory <c>byte[]</c>
             buffer. When its size reaches 16KB or more, some metadata about the documents
             is flushed to disk, immediately followed by a compressed representation of
             the buffer using the
             <a href="http://code.google.com/p/lz4/">LZ4</a>
             <a href="http://fastcompression.blogspot.fr/2011/05/lz4-explained.html">compression format</a>.</para>
             <para>Here is a more detailed description of the field data file format:</para>
             <list type="bullet">
             <item><description>FieldData (.fdt) --&gt; &lt;Header&gt;, PackedIntsVersion, &lt;Chunk&gt;<sup>ChunkCount</sup></description></item>
             <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
             <item><description>PackedIntsVersion --&gt; <see cref="F:Lucene.Net.Util.Packed.PackedInt32s.VERSION_CURRENT"/> as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
             <item><description>ChunkCount is not known in advance and is the number of chunks necessary to store all document of the segment</description></item>
             <item><description>Chunk --&gt; DocBase, ChunkDocs, DocFieldCounts, DocLengths, &lt;CompressedDocs&gt;</description></item>
             <item><description>DocBase --&gt; the ID of the first document of the chunk as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
             <item><description>ChunkDocs --&gt; the number of documents in the chunk as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
             <item><description>DocFieldCounts --&gt; the number of stored fields of every document in the chunk, encoded as followed:
             <list type="bullet">
               <item><description>if chunkDocs=1, the unique value is encoded as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
               <item><description>else read a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) (let's call it <c>bitsRequired</c>)
               <list type="bullet">
                 <item><description>if <c>bitsRequired</c> is <c>0</c> then all values are equal, and the common value is the following VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
                 <item><description>else <c>bitsRequired</c> is the number of bits required to store any value, and values are stored in a packed (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>) array where every value is stored on exactly <c>bitsRequired</c> bits</description></item>
               </list>
               </description></item>
             </list>
             </description></item>
             <item><description>DocLengths --&gt; the lengths of all documents in the chunk, encoded with the same method as DocFieldCounts</description></item>
             <item><description>CompressedDocs --&gt; a compressed representation of &lt;Docs&gt; using the LZ4 compression format</description></item>
             <item><description>Docs --&gt; &lt;Doc&gt;<sup>ChunkDocs</sup></description></item>
             <item><description>Doc --&gt; &lt;FieldNumAndType, Value&gt;<sup>DocFieldCount</sup></description></item>
             <item><description>FieldNumAndType --&gt; a VLong (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>), whose 3 last bits are Type and other bits are FieldNum</description></item>
             <item><description>Type --&gt;
             <list type="bullet">
               <item><description>0: Value is String</description></item>
               <item><description>1: Value is BinaryValue</description></item>
               <item><description>2: Value is Int</description></item>
               <item><description>3: Value is Float</description></item>
               <item><description>4: Value is Long</description></item>
               <item><description>5: Value is Double</description></item>
               <item><description>6, 7: unused</description></item>
             </list>
             </description></item>
             <item><description>FieldNum --&gt; an ID of the field</description></item>
             <item><description>Value --&gt; String (<see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>) | BinaryValue | Int | Float | Long | Double depending on Type</description></item>
             <item><description>BinaryValue --&gt; ValueLength &lt;Byte&gt;<sup>ValueLength</sup></description></item>
             </list>
             <para>Notes</para>
             <list type="bullet">
             <item><description>If documents are larger than 16KB then chunks will likely contain only
             one document. However, documents can never spread across several chunks (all
             fields of a single document are in the same chunk).</description></item>
             <item><description>When at least one document in a chunk is large enough so that the chunk
             is larger than 32KB, the chunk will actually be compressed in several LZ4
             blocks of 16KB. this allows <see cref="T:Lucene.Net.Index.StoredFieldVisitor"/>s which are only
             interested in the first fields of a document to not have to decompress 10MB
             of data if the document is 10MB, but only 16KB.</description></item>
             <item><description>Given that the original lengths are written in the metadata of the chunk,
             the decompressor can leverage this information to stop decoding as soon as
             enough data has been decompressed.</description></item>
             <item><description>In case documents are incompressible, CompressedDocs will be less than
             0.5% larger than Docs.</description></item>
             </list>
             </description></item>
             <item><description><a name="field_index" id="field_index"></a>
             <para>A fields index file (extension <c>.fdx</c>).</para>
             <list type="bullet">
             <item><description>FieldsIndex (.fdx) --&gt; &lt;Header&gt;, &lt;ChunkIndex&gt;</description></item>
             <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
             <item><description>ChunkIndex: See <see cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexWriter"/></description></item>
             </list>
             </description></item>
             </list>
             <para><b>Known limitations</b></para>
             <para>This <see cref="T:Lucene.Net.Codecs.StoredFieldsFormat"/> does not support individual documents
             larger than (<c>2<sup>31</sup> - 2<sup>14</sup></c>) bytes. In case this
             is a problem, you should use another format, such as
             <see cref="T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat"/>.</para>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41StoredFieldsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene42.Lucene42Codec">
            <summary>
            Implements the Lucene 4.2 index format, with configurable per-field postings
            and docvalues formats.
            <para/>
            If you want to reuse functionality of this codec in another codec, extend
            <see cref="T:Lucene.Net.Codecs.FilterCodec"/>.
            <para/>
            See <see cref="N:Lucene.Net.Codecs.Lucene42"/> package documentation for file format details.
            <para/>
            @lucene.experimental 
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42Codec.GetPostingsFormatForField(System.String)">
            <summary>
            Returns the postings format that should be used for writing
            new segments of <paramref name="field"/>.
            <para/>
            The default implementation always returns "Lucene41"
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42Codec.GetDocValuesFormatForField(System.String)">
            <summary>
            Returns the docvalues format that should be used for writing
            new segments of <paramref name="field"/>.
            <para/>
            The default implementation always returns "Lucene42"
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat">
            <summary>
            Lucene 4.2 DocValues format.
            <para/>
            Encodes the four per-document value types (Numeric,Binary,Sorted,SortedSet) with seven basic strategies.
            <para/>
            <list type="bullet">
               <item><description>Delta-compressed Numerics: per-document integers written in blocks of 4096. For each block
                   the minimum value is encoded, and each entry is a delta from that minimum value.</description></item>
               <item><description>Table-compressed Numerics: when the number of unique values is very small, a lookup table
                   is written instead. Each per-document entry is instead the ordinal to this table.</description></item>
               <item><description>Uncompressed Numerics: when all values would fit into a single byte, and the
                   <c>acceptableOverheadRatio</c> would pack values into 8 bits per value anyway, they
                   are written as absolute values (with no indirection or packing) for performance.</description></item>
               <item><description>GCD-compressed Numerics: when all numbers share a common divisor, such as dates, the greatest
                   common denominator (GCD) is computed, and quotients are stored using Delta-compressed Numerics.</description></item>
               <item><description>Fixed-width Binary: one large concatenated byte[] is written, along with the fixed length.
                   Each document's value can be addressed by <c>maxDoc*length</c>.</description></item>
               <item><description>Variable-width Binary: one large concatenated byte[] is written, along with end addresses
                   for each document. The addresses are written in blocks of 4096, with the current absolute
                   start for the block, and the average (expected) delta per entry. For each document the
                   deviation from the delta (actual - expected) is written.</description></item>
               <item><description>Sorted: an FST mapping deduplicated terms to ordinals is written, along with the per-document
                   ordinals written using one of the numeric strategies above.</description></item>
               <item><description>SortedSet: an FST mapping deduplicated terms to ordinals is written, along with the per-document
                   ordinal list written using one of the binary strategies above.</description></item>
            </list>
            <para/>
            Files:
            <list type="number">
              <item><description><c>.dvd</c>: DocValues data</description></item>
              <item><description><c>.dvm</c>: DocValues metadata</description></item>
            </list>
            <list type="number">
              <item><description><a name="dvm" id="dvm"></a>
              <para>The DocValues metadata or .dvm file.</para>
              <para>For DocValues field, this stores metadata, such as the offset into the
                 DocValues data (.dvd)</para>
              <para>DocValues metadata (.dvm) --&gt; Header,&lt;FieldNumber,EntryType,Entry&gt;<sup>NumFields</sup>,Footer</para>
              <list type="bullet">
                <item><description>Entry --&gt; NumericEntry | BinaryEntry | SortedEntry</description></item>
                <item><description>NumericEntry --&gt; DataOffset,CompressionType,PackedVersion</description></item>
                <item><description>BinaryEntry --&gt; DataOffset,DataLength,MinLength,MaxLength,PackedVersion?,BlockSize?</description></item>
                <item><description>SortedEntry --&gt; DataOffset,ValueCount</description></item>
                <item><description>FieldNumber,PackedVersion,MinLength,MaxLength,BlockSize,ValueCount --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
                <item><description>DataOffset,DataLength --&gt; Int64  (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>) </description></item>
                <item><description>EntryType,CompressionType --&gt; Byte  (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) </description></item>
                <item><description>Header --&gt; CodecHeader  (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
                <item><description>Footer --&gt; CodecFooter  (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>) </description></item>
              </list>
              <para>Sorted fields have two entries: a SortedEntry with the FST metadata,
                 and an ordinary NumericEntry for the document-to-ord metadata.</para>
              <para>SortedSet fields have two entries: a SortedEntry with the FST metadata,
                 and an ordinary BinaryEntry for the document-to-ord-list metadata.</para>
              <para>FieldNumber of -1 indicates the end of metadata.</para>
              <para>EntryType is a 0 (NumericEntry), 1 (BinaryEntry, or 2 (SortedEntry)</para>
              <para>DataOffset is the pointer to the start of the data in the DocValues data (.dvd)</para>
              <para/>CompressionType indicates how Numeric values will be compressed:
                 <list type="bullet">
                    <item><description>0 --&gt; delta-compressed. For each block of 4096 integers, every integer is delta-encoded
                        from the minimum value within the block.</description></item>
                    <item><description>1 --&gt; table-compressed. When the number of unique numeric values is small and it would save space,
                        a lookup table of unique values is written, followed by the ordinal for each document.</description></item>
                    <item><description>2 --&gt; uncompressed. When the <c>acceptableOverheadRatio</c> parameter would upgrade the number
                        of bits required to 8, and all values fit in a byte, these are written as absolute binary values
                        for performance.</description></item>
                    <item><description>3 --&gt; gcd-compressed. When all integers share a common divisor, only quotients are stored
                        using blocks of delta-encoded ints.</description></item>
                 </list>
              <para/>MinLength and MaxLength represent the min and max byte[] value lengths for Binary values.
                 If they are equal, then all values are of a fixed size, and can be addressed as <c>DataOffset + (docID * length)</c>.
                 Otherwise, the binary values are of variable size, and packed integer metadata (PackedVersion,BlockSize)
                 is written for the addresses.</description></item>
              <item><description><a name="dvd" id="dvd"></a>
              <para>The DocValues data or .dvd file.</para>
              <para>For DocValues field, this stores the actual per-document data (the heavy-lifting)</para>
              <para>DocValues data (.dvd) --&gt; Header,&lt;NumericData | BinaryData | SortedData&gt;<sup>NumFields</sup>,Footer</para>
              <list type="bullet">
                <item><description>NumericData --&gt; DeltaCompressedNumerics | TableCompressedNumerics | UncompressedNumerics | GCDCompressedNumerics</description></item>
                <item><description>BinaryData --&gt; Byte  (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) <sup>DataLength</sup>,Addresses</description></item>
                <item><description>SortedData --&gt; FST&lt;Int64&gt; (<see cref="T:Lucene.Net.Util.Fst.FST`1"/>) </description></item>
                <item><description>DeltaCompressedNumerics --&gt; BlockPackedInts(blockSize=4096) (<see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>) </description></item>
                <item><description>TableCompressedNumerics --&gt; TableSize, Int64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>) <sup>TableSize</sup>, PackedInts (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>) </description></item>
                <item><description>UncompressedNumerics --&gt; Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) <sup>maxdoc</sup></description></item>
                <item><description>Addresses --&gt; MonotonicBlockPackedInts(blockSize=4096) (<see cref="T:Lucene.Net.Util.Packed.MonotonicBlockPackedWriter"/>) </description></item>
                <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/></description></item>
              </list>
              <para>SortedSet entries store the list of ordinals in their BinaryData as a
                 sequences of increasing vLongs (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>), delta-encoded.</para></description></item>
            </list>
            <para/>
            Limitations:
            <list type="bullet">
              <item><description> Binary doc values can be at most <see cref="F:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat.MAX_BINARY_FIELD_LENGTH"/> in length.</description></item>
            </list> 
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat.MAX_BINARY_FIELD_LENGTH">
            <summary>
            Maximum length for each binary doc values field. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat.#ctor">
            <summary>
            Calls <c>Lucene42DocValuesFormat(PackedInts.DEFAULT)</c> (<see cref="M:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat.#ctor(System.Single)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat.#ctor(System.Single)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat"/> with the specified
            <paramref name="acceptableOverheadRatio"/> for <see cref="T:Lucene.Net.Index.NumericDocValues"/>. 
            <para/>
            @lucene.experimental
            </summary>
            <param name="acceptableOverheadRatio"> Compression parameter for numerics.
                   Currently this is only used when the number of unique values is small.</param>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesProducer">
            <summary>
            Reader for <see cref="T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesProducer.NumericEntry.PackedInt32sVersion">
            <summary>
            NOTE: This was packedIntsVersion (field) in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesProducer.BinaryEntry.PackedInt32sVersion">
            <summary>
            NOTE: This was packedIntsVersion (field) in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosFormat">
            <summary>
            Lucene 4.2 Field Infos format.
            <para/>
            <para>Field names are stored in the field info file, with suffix <c>.fnm</c>.</para>
            <para>FieldInfos (.fnm) --&gt; Header,FieldsCount, &lt;FieldName,FieldNumber,
            FieldBits,DocValuesBits,Attributes&gt; <sup>FieldsCount</sup></para>
            <para>Data types:
            <list type="bullet">
              <item><description>Header --&gt; CodecHeader <see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/></description></item>
              <item><description>FieldsCount --&gt; VInt <see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/></description></item>
              <item><description>FieldName --&gt; String <see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/></description></item>
              <item><description>FieldBits, DocValuesBits --&gt; Byte <see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/></description></item>
              <item><description>FieldNumber --&gt; VInt <see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/></description></item>
              <item><description>Attributes --&gt; IDictionary&lt;String,String&gt; <see cref="M:Lucene.Net.Store.DataOutput.WriteStringStringMap(System.Collections.Generic.IDictionary{System.String,System.String})"/></description></item>
            </list>
            </para>
            Field Descriptions:
            <list type="bullet">
              <item><description>FieldsCount: the number of fields in this file.</description></item>
              <item><description>FieldName: name of the field as a UTF-8 String.</description></item>
              <item><description>FieldNumber: the field's number. Note that unlike previous versions of
                  Lucene, the fields are not numbered implicitly by their order in the
                  file, instead explicitly.</description></item>
              <item><description>FieldBits: a byte containing field options.
                  <list type="bullet">
                    <item><description>The low-order bit is one for indexed fields, and zero for non-indexed
                        fields.</description></item>
                    <item><description>The second lowest-order bit is one for fields that have term vectors
                        stored, and zero for fields without term vectors.</description></item>
                    <item><description>If the third lowest order-bit is set (0x4), offsets are stored into
                        the postings list in addition to positions.</description></item>
                    <item><description>Fourth bit is unused.</description></item>
                    <item><description>If the fifth lowest-order bit is set (0x10), norms are omitted for the
                        indexed field.</description></item>
                    <item><description>If the sixth lowest-order bit is set (0x20), payloads are stored for the
                        indexed field.</description></item>
                    <item><description>If the seventh lowest-order bit is set (0x40), term frequencies and
                        positions omitted for the indexed field.</description></item>
                    <item><description>If the eighth lowest-order bit is set (0x80), positions are omitted for the
                        indexed field.</description></item>
                  </list>
               </description></item>
               <item><description>DocValuesBits: a byte containing per-document value types. The type
                   recorded as two four-bit integers, with the high-order bits representing
                   <c>norms</c> options, and the low-order bits representing
                   <see cref="T:Lucene.Net.Index.DocValues"/> options. Each four-bit integer can be decoded as such:
                   <list type="bullet">
                     <item><description>0: no DocValues for this field.</description></item>
                     <item><description>1: NumericDocValues. (<see cref="F:Lucene.Net.Index.DocValuesType.NUMERIC"/>)</description></item>
                     <item><description>2: BinaryDocValues. (<see cref="F:Lucene.Net.Index.DocValuesType.BINARY"/>)</description></item>
                     <item><description>3: SortedDocValues. (<see cref="F:Lucene.Net.Index.DocValuesType.SORTED"/>)</description></item>
                   </list>
               </description></item>
               <item><description>Attributes: a key-value map of codec-private attributes.</description></item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosFormat.EXTENSION">
            <summary>
            Extension of field infos. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosReader">
            <summary>
            Lucene 4.2 FieldInfos reader.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene42.Lucene42NormsConsumer">
            <summary>
            Writer for <see cref="T:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat">
            <summary>
            Lucene 4.2 score normalization format.
            <para/>
            NOTE: this uses the same format as <see cref="T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat"/>
            Numeric DocValues, but with different file extensions, and passing
            <see cref="F:Lucene.Net.Util.Packed.PackedInt32s.FASTEST"/> for uncompressed encoding: trading off
            space for performance.
            <para/>
            Files:
            <list type="bullet">
              <item><description><c>.nvd</c>: DocValues data</description></item>
              <item><description><c>.nvm</c>: DocValues metadata</description></item>
            </list>
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat.#ctor">
            <summary>
            Calls <c>Lucene42DocValuesFormat(PackedInt32s.FASTEST)</c> (<see cref="M:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat.#ctor(System.Single)"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat.#ctor(System.Single)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat"/> with the specified
            <paramref name="acceptableOverheadRatio"/> for <see cref="T:Lucene.Net.Index.NumericDocValues"/>. 
            <para/>
            @lucene.experimental
            </summary>
            <param name="acceptableOverheadRatio"> Compression parameter for numerics.
                   Currently this is only used when the number of unique values is small.</param>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene42.Lucene42TermVectorsFormat">
            <summary>
            Lucene 4.2 term vectors format (<see cref="T:Lucene.Net.Codecs.TermVectorsFormat"/>).
            <para/>
            Very similarly to <see cref="T:Lucene.Net.Codecs.Lucene41.Lucene41StoredFieldsFormat"/>, this format is based
            on compressed chunks of data, with document-level granularity so that a
            document can never span across distinct chunks. Moreover, data is made as
            compact as possible:
            <list type="bullet">
                <item><description>textual data is compressed using the very light,
                    <a href="http://code.google.com/p/lz4/">LZ4</a> compression algorithm,</description></item>
                <item><description>binary data is written using fixed-size blocks of
                    packed <see cref="T:System.Int32"/>s (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>).</description></item>
            </list>
            <para/>
            Term vectors are stored using two files
            <list type="bullet">
                <item><description>a data file where terms, frequencies, positions, offsets and payloads
                    are stored,</description></item>
                <item><description>an index file, loaded into memory, used to locate specific documents in
                    the data file.</description></item>
            </list>
            Looking up term vectors for any document requires at most 1 disk seek.
            <para/><b>File formats</b>
            <list type="number">
                <item><description><a name="vector_data" id="vector_data"></a>
                    <para>A vector data file (extension <c>.tvd</c>). this file stores terms,
                    frequencies, positions, offsets and payloads for every document. Upon writing
                    a new segment, it accumulates data into memory until the buffer used to store
                    terms and payloads grows beyond 4KB. Then it flushes all metadata, terms
                    and positions to disk using <a href="http://code.google.com/p/lz4/">LZ4</a>
                    compression for terms and payloads and
                    blocks of packed <see cref="T:System.Int32"/>s (<see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>) for positions.</para>
                    <para>Here is a more detailed description of the field data file format:</para>
                    <list type="bullet">
                        <item><description>VectorData (.tvd) --&gt; &lt;Header&gt;, PackedIntsVersion, ChunkSize, &lt;Chunk&gt;<sup>ChunkCount</sup>, Footer</description></item>
                        <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
                        <item><description>PackedIntsVersion --&gt; <see cref="F:Lucene.Net.Util.Packed.PackedInt32s.VERSION_CURRENT"/> as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
                        <item><description>ChunkSize is the number of bytes of terms to accumulate before flushing, as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
                        <item><description>ChunkCount is not known in advance and is the number of chunks necessary to store all document of the segment</description></item>
                        <item><description>Chunk --&gt; DocBase, ChunkDocs, &lt; NumFields &gt;, &lt; FieldNums &gt;, &lt; FieldNumOffs &gt;, &lt; Flags &gt;,
                            &lt; NumTerms &gt;, &lt; TermLengths &gt;, &lt; TermFreqs &gt;, &lt; Positions &gt;, &lt; StartOffsets &gt;, &lt; Lengths &gt;,
                            &lt; PayloadLengths &gt;, &lt; TermAndPayloads &gt;</description></item>
                        <item><description>DocBase is the ID of the first doc of the chunk as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
                        <item><description>ChunkDocs is the number of documents in the chunk</description></item>
                        <item><description>NumFields --&gt; DocNumFields<sup>ChunkDocs</sup></description></item>
                        <item><description>DocNumFields is the number of fields for each doc, written as a VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) if ChunkDocs==1 and as a <see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/> array otherwise</description></item>
                        <item><description>FieldNums --&gt; FieldNumDelta<sup>TotalDistincFields</sup>, a delta-encoded list of the sorted unique field numbers present in the chunk</description></item>
                        <item><description>FieldNumOffs --&gt; FieldNumOff<sup>TotalFields</sup>, as a <see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/> array</description></item>
                        <item><description>FieldNumOff is the offset of the field number in FieldNums</description></item>
                        <item><description>TotalFields is the total number of fields (sum of the values of NumFields)</description></item>
                        <item><description>Flags --&gt; Bit &lt; FieldFlags &gt;</description></item>
                        <item><description>Bit  is a single bit which when true means that fields have the same options for every document in the chunk</description></item>
                        <item><description>FieldFlags --&gt; if Bit==1: Flag<sup>TotalDistinctFields</sup> else Flag<sup>TotalFields</sup></description></item>
                        <item><description>Flag: a 3-bits int where:
                            <list type="bullet">
                                <item><description>the first bit means that the field has positions</description></item>
                                <item><description>the second bit means that the field has offsets</description></item>
                                <item><description>the third bit means that the field has payloads</description></item>
                            </list>
                        </description></item>
                        <item><description>NumTerms --&gt; FieldNumTerms<sup>TotalFields</sup></description></item>
                        <item><description>FieldNumTerms: the number of terms for each field, using blocks of 64 packed <see cref="T:System.Int32"/>s (<see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>) </description></item>
                        <item><description>TermLengths --&gt; PrefixLength<sup>TotalTerms</sup> SuffixLength<sup>TotalTerms</sup></description></item>
                        <item><description>TotalTerms: total number of terms (sum of NumTerms)</description></item>
                        <item><description>PrefixLength: 0 for the first term of a field, the common prefix with the previous term otherwise using blocks of 64 packed <see cref="T:System.Int32"/>s (<see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>) </description></item>
                        <item><description>SuffixLength: length of the term minus PrefixLength for every term using blocks of 64 packed <see cref="T:System.Int32"/>s (<see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>) </description></item>
                        <item><description>TermFreqs --&gt; TermFreqMinus1<sup>TotalTerms</sup></description></item>
                        <item><description>TermFreqMinus1: (frequency - 1) for each term using blocks of 64 packed <see cref="T:System.Int32"/>s (<see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>) </description></item>
                        <item><description>Positions --&gt; PositionDelta<sup>TotalPositions</sup></description></item>
                        <item><description>TotalPositions is the sum of frequencies of terms of all fields that have positions</description></item>
                        <item><description>PositionDelta: the absolute position for the first position of a term, and the difference with the previous positions for following positions using blocks of 64 packed <see cref="T:System.Int32"/>s (<see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>) </description></item>
                        <item><description>StartOffsets --&gt; (AvgCharsPerTerm<sup>TotalDistinctFields</sup>) StartOffsetDelta<sup>TotalOffsets</sup></description></item>
                        <item><description>TotalOffsets is the sum of frequencies of terms of all fields that have offsets</description></item>
                        <item><description>AvgCharsPerTerm: average number of chars per term, encoded as a float on 4 bytes. They are not present if no field has both positions and offsets enabled.</description></item>
                        <item><description>StartOffsetDelta: (startOffset - previousStartOffset - AvgCharsPerTerm * PositionDelta). previousStartOffset is 0 for the first offset and AvgCharsPerTerm is 0 if the field has no positions using blocks of 64 packed <see cref="T:System.Int32"/>s (<see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>) </description></item>
                        <item><description>Lengths --&gt; LengthMinusTermLength<sup>TotalOffsets</sup></description></item>
                        <item><description>LengthMinusTermLength: (endOffset - startOffset - termLength) using blocks of 64 packed <see cref="T:System.Int32"/>s (<see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>) </description></item>
                        <item><description>PayloadLengths --&gt; PayloadLength<sup>TotalPayloads</sup></description></item>
                        <item><description>TotalPayloads is the sum of frequencies of terms of all fields that have payloads</description></item>
                        <item><description>PayloadLength is the payload length encoded using blocks of 64 packed <see cref="T:System.Int32"/>s (<see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>) </description></item>
                        <item><description>TermAndPayloads --&gt; LZ4-compressed representation of &lt; FieldTermsAndPayLoads &gt;<sup>TotalFields</sup></description></item>
                        <item><description>FieldTermsAndPayLoads --&gt; Terms (Payloads)</description></item>
                        <item><description>Terms: term bytes</description></item>
                        <item><description>Payloads: payload bytes (if the field has payloads)</description></item>
                        <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>) </description></item>
                    </list>
                </description></item>
                <item><description><a name="vector_index" id="vector_index"></a>
                    <para>An index file (extension <c>.tvx</c>).</para>
                    <list type="bullet">
                        <item><description>VectorIndex (.tvx) --&gt; &lt;Header&gt;, &lt;ChunkIndex&gt;, Footer</description></item>
                        <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
                        <item><description>ChunkIndex: See <see cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexWriter"/></description></item>
                        <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>) </description></item>
                    </list>
                </description></item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42TermVectorsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45Codec">
            <summary>
            Implements the Lucene 4.5 index format, with configurable per-field postings
            and docvalues formats.
            <para/>
            If you want to reuse functionality of this codec in another codec, extend
            <see cref="T:Lucene.Net.Codecs.FilterCodec"/>.
            <para/>
            See <see cref="N:Lucene.Net.Codecs.Lucene45"/> package documentation for file format details.
            <para/>
            @lucene.experimental 
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45Codec.GetPostingsFormatForField(System.String)">
            <summary>
            Returns the postings format that should be used for writing
            new segments of <paramref name="field"/>.
            <para/>
            The default implementation always returns "Lucene41"
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45Codec.GetDocValuesFormatForField(System.String)">
            <summary>
            Returns the docvalues format that should be used for writing
            new segments of <paramref name="field"/>.
            <para/>
            The default implementation always returns "Lucene45"
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer">
            <summary>
            Writer for <see cref="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat"/> </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.DELTA_COMPRESSED">
            <summary>
            Compressed using packed blocks of <see cref="T:System.Int32"/>s. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.GCD_COMPRESSED">
            <summary>
            Compressed by computing the GCD. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.TABLE_COMPRESSED">
            <summary>
            Compressed by giving IDs to unique values. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.BINARY_FIXED_UNCOMPRESSED">
            <summary>
            Uncompressed binary, written directly (fixed length). </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.BINARY_VARIABLE_UNCOMPRESSED">
            <summary>
            Uncompressed binary, written directly (variable length). </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.BINARY_PREFIX_COMPRESSED">
            <summary>
            Compressed binary with shared prefixes </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.SORTED_SET_WITH_ADDRESSES">
            <summary>
            Standard storage for sorted set values with 1 level of indirection:
            docId -> address -> ord.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.SORTED_SET_SINGLE_VALUED_SORTED">
            <summary>
            Single-valued sorted set values, encoded as sorted values, so no level
            of indirection: docId -> ord.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.#ctor(Lucene.Net.Index.SegmentWriteState,System.String,System.String,System.String,System.String)">
            <summary>
            Expert: Creates a new writer. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.AddTermsDict(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef})">
            <summary>
            Expert: writes a value dictionary for a sorted/sortedset field. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat">
            <summary>
            Lucene 4.5 DocValues format.
            <para/>
            Encodes the four per-document value types (Numeric,Binary,Sorted,SortedSet) with these strategies:
            <para/>
            <see cref="F:Lucene.Net.Index.DocValuesType.NUMERIC"/>:
            <list type="bullet">
               <item><description>Delta-compressed: per-document integers written in blocks of 16k. For each block
                   the minimum value in that block is encoded, and each entry is a delta from that
                   minimum value. Each block of deltas is compressed with bitpacking. For more
                   information, see <see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>.</description></item>
               <item><description>Table-compressed: when the number of unique values is very small (&lt; 256), and
                   when there are unused "gaps" in the range of values used (such as <see cref="T:Lucene.Net.Util.SmallSingle"/>),
                   a lookup table is written instead. Each per-document entry is instead the ordinal
                   to this table, and those ordinals are compressed with bitpacking (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>).</description></item>
               <item><description>GCD-compressed: when all numbers share a common divisor, such as dates, the greatest
                   common denominator (GCD) is computed, and quotients are stored using Delta-compressed Numerics.</description></item>
            </list>
            <para/>
            <see cref="F:Lucene.Net.Index.DocValuesType.BINARY"/>:
            <list type="bullet">
               <item><description>Fixed-width Binary: one large concatenated <see cref="T:byte[]"/> is written, along with the fixed length.
                   Each document's value can be addressed directly with multiplication (<c>docID * length</c>).</description></item>
               <item><description>Variable-width Binary: one large concatenated <see cref="T:byte[]"/> is written, along with end addresses
                   for each document. The addresses are written in blocks of 16k, with the current absolute
                   start for the block, and the average (expected) delta per entry. For each document the
                   deviation from the delta (actual - expected) is written.</description></item>
               <item><description>Prefix-compressed Binary: values are written in chunks of 16, with the first value written
                   completely and other values sharing prefixes. Chunk addresses are written in blocks of 16k,
                   with the current absolute start for the block, and the average (expected) delta per entry.
                   For each chunk the deviation from the delta (actual - expected) is written.</description></item>
            </list>
            <para/>
            <see cref="F:Lucene.Net.Index.DocValuesType.SORTED"/>:
            <list type="bullet">
               <item><description>Sorted: a mapping of ordinals to deduplicated terms is written as Prefix-Compressed Binary,
                   along with the per-document ordinals written using one of the numeric strategies above.</description></item>
            </list>
            <para/>
            <see cref="F:Lucene.Net.Index.DocValuesType.SORTED_SET"/>:
            <list type="bullet">
               <item><description>SortedSet: a mapping of ordinals to deduplicated terms is written as Prefix-Compressed Binary,
                   an ordinal list and per-document index into this list are written using the numeric strategies
                   above.</description></item>
            </list>
            <para/>
            Files:
            <list type="number">
              <item><description><c>.dvd</c>: DocValues data</description></item>
              <item><description><c>.dvm</c>: DocValues metadata</description></item>
            </list>
            <list type="number">
              <item><description><a name="dvm" id="dvm"></a>
              <para>The DocValues metadata or .dvm file.</para>
              <para>For DocValues field, this stores metadata, such as the offset into the
                 DocValues data (.dvd)</para>
              <para>DocValues metadata (.dvm) --&gt; Header,&lt;Entry&gt;<sup>NumFields</sup>,Footer</para>
              <list type="bullet">
                <item><description>Entry --&gt; NumericEntry | BinaryEntry | SortedEntry | SortedSetEntry</description></item>
                <item><description>NumericEntry --&gt; GCDNumericEntry | TableNumericEntry | DeltaNumericEntry</description></item>
                <item><description>GCDNumericEntry --&gt; NumericHeader,MinValue,GCD</description></item>
                <item><description>TableNumericEntry --&gt; NumericHeader,TableSize,Int64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>) <sup>TableSize</sup></description></item>
                <item><description>DeltaNumericEntry --&gt; NumericHeader</description></item>
                <item><description>NumericHeader --&gt; FieldNumber,EntryType,NumericType,MissingOffset,PackedVersion,DataOffset,Count,BlockSize</description></item>
                <item><description>BinaryEntry --&gt; FixedBinaryEntry | VariableBinaryEntry | PrefixBinaryEntry</description></item>
                <item><description>FixedBinaryEntry --&gt; BinaryHeader</description></item>
                <item><description>VariableBinaryEntry --&gt; BinaryHeader,AddressOffset,PackedVersion,BlockSize</description></item>
                <item><description>PrefixBinaryEntry --&gt; BinaryHeader,AddressInterval,AddressOffset,PackedVersion,BlockSize</description></item>
                <item><description>BinaryHeader --&gt; FieldNumber,EntryType,BinaryType,MissingOffset,MinLength,MaxLength,DataOffset</description></item>
                <item><description>SortedEntry --&gt; FieldNumber,EntryType,BinaryEntry,NumericEntry</description></item>
                <item><description>SortedSetEntry --&gt; EntryType,BinaryEntry,NumericEntry,NumericEntry</description></item>
                <item><description>FieldNumber,PackedVersion,MinLength,MaxLength,BlockSize,ValueCount --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/></description></item>
                <item><description>EntryType,CompressionType --&gt; Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/></description></item>
                <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
                <item><description>MinValue,GCD,MissingOffset,AddressOffset,DataOffset --&gt; Int64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>) </description></item>
                <item><description>TableSize --&gt; vInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>) </description></item>
                <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>) </description></item>
              </list>
              <para>Sorted fields have two entries: a <see cref="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry"/> with the value metadata,
                 and an ordinary <see cref="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry"/> for the document-to-ord metadata.</para>
              <para>SortedSet fields have three entries: a <see cref="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry"/> with the value metadata,
                 and two <see cref="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry"/>s for the document-to-ord-index and ordinal list metadata.</para>
              <para>FieldNumber of -1 indicates the end of metadata.</para>
              <para>EntryType is a 0 (<see cref="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry"/>) or 1 (<see cref="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry"/>)</para>
              <para>DataOffset is the pointer to the start of the data in the DocValues data (.dvd)</para>
              <para/>NumericType indicates how Numeric values will be compressed:
                 <list type="bullet">
                    <item><description>0 --&gt; delta-compressed. For each block of 16k integers, every integer is delta-encoded
                        from the minimum value within the block.</description></item>
                    <item><description>1 --&gt; gcd-compressed. When all integers share a common divisor, only quotients are stored
                        using blocks of delta-encoded ints.</description></item>
                    <item><description>2 --&gt; table-compressed. When the number of unique numeric values is small and it would save space,
                        a lookup table of unique values is written, followed by the ordinal for each document.</description></item>
                 </list>
              <para/>BinaryType indicates how Binary values will be stored:
                 <list type="bullet">
                    <item><description>0 --&gt; fixed-width. All values have the same length, addressing by multiplication.</description></item>
                    <item><description>1 --&gt; variable-width. An address for each value is stored.</description></item>
                    <item><description>2 --&gt; prefix-compressed. An address to the start of every interval'th value is stored.</description></item>
                 </list>
              <para/>MinLength and MaxLength represent the min and max byte[] value lengths for Binary values.
                 If they are equal, then all values are of a fixed size, and can be addressed as DataOffset + (docID * length).
                 Otherwise, the binary values are of variable size, and packed integer metadata (PackedVersion,BlockSize)
                 is written for the addresses.
              <para/>MissingOffset points to a <see cref="T:byte[]"/> containing a bitset of all documents that had a value for the field.
                 If its -1, then there are no missing values.
              <para/>Checksum contains the CRC32 checksum of all bytes in the .dvm file up
                 until the checksum. this is used to verify integrity of the file on opening the
                 index.</description></item>
              <item><description><a name="dvd" id="dvd"></a>
              <para>The DocValues data or .dvd file.</para>
              <para>For DocValues field, this stores the actual per-document data (the heavy-lifting)</para>
              <para>DocValues data (.dvd) --&gt; Header,&lt;NumericData | BinaryData | SortedData&gt;<sup>NumFields</sup>,Footer</para>
              <list type="bullet">
                <item><description>NumericData --&gt; DeltaCompressedNumerics | TableCompressedNumerics | GCDCompressedNumerics</description></item>
                <item><description>BinaryData --&gt;  Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) <sup>DataLength</sup>,Addresses</description></item>
                <item><description>SortedData --&gt; FST&lt;Int64&gt; (<see cref="T:Lucene.Net.Util.Fst.FST`1"/>) </description></item>
                <item><description>DeltaCompressedNumerics --&gt; BlockPackedInts(blockSize=16k) (<see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>) </description></item>
                <item><description>TableCompressedNumerics --&gt; PackedInts (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>) </description></item>
                <item><description>GCDCompressedNumerics --&gt; BlockPackedInts(blockSize=16k) (<see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>) </description></item>
                <item><description>Addresses --&gt; MonotonicBlockPackedInts(blockSize=16k) (<see cref="T:Lucene.Net.Util.Packed.MonotonicBlockPackedWriter"/>) </description></item>
                <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>) </description></item>
              </list>
              <para>SortedSet entries store the list of ordinals in their BinaryData as a
                 sequences of increasing vLongs (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>), delta-encoded.</para></description></item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat.#ctor">
            <summary>
            Sole Constructor </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer">
            <summary>
            Reader for <see cref="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.#ctor(Lucene.Net.Index.SegmentReadState,System.String,System.String,System.String,System.String)">
            <summary>
            Expert: instantiates a new reader. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.GetAddressInstance(Lucene.Net.Store.IndexInput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry)">
            <summary>
            Returns an address instance for variable-length binary values.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.GetIntervalInstance(Lucene.Net.Store.IndexInput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry)">
            <summary>
            Returns an address instance for prefix-compressed binary values.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.GetOrdIndexInstance(Lucene.Net.Store.IndexInput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry)">
            <summary>
            Returns an address instance for sortedset ordinal lists.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry">
            <summary>
            Metadata entry for a numeric docvalues field. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.missingOffset">
            <summary>
            Offset to the bitset representing docsWithField, or -1 if no documents have missing values. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.Offset">
            <summary>
            Offset to the actual numeric values. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.PackedInt32sVersion">
            <summary>
            Packed <see cref="T:System.Int32"/>s version used to encode these numerics. 
            <para/>
            NOTE: This was packedIntsVersion (field) in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.Count">
            <summary>
            Count of values written. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.BlockSize">
            <summary>
            Packed <see cref="T:System.Int32"/>s blocksize. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry">
            <summary>
            Metadata entry for a binary docvalues field. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.missingOffset">
            <summary>
            Offset to the bitset representing docsWithField, or -1 if no documents have missing values. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.offset">
            <summary>
            Offset to the actual binary values. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.Count">
            <summary>
            Count of values written. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.AddressesOffset">
            <summary>
            Offset to the addressing data that maps a value to its slice of the <see cref="T:byte[]"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.AddressInterval">
            <summary>
            Interval of shared prefix chunks (when using prefix-compressed binary). </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.PackedInt32sVersion">
            <summary>
            Packed ints version used to encode addressing information.
            <para/>
            NOTE: This was packedIntsVersion (field) in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.BlockSize">
            <summary>
            Packed ints blocksize. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.SortedSetEntry">
            <summary>
            Metadata entry for a sorted-set docvalues field. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.Int64BinaryDocValues">
            <summary>
            NOTE: This was LongBinaryDocValues in Lucene.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene46.Lucene46Codec">
            <summary>
            Implements the Lucene 4.6 index format, with configurable per-field postings
            and docvalues formats.
            <para/>
            If you want to reuse functionality of this codec in another codec, extend
            <see cref="T:Lucene.Net.Codecs.FilterCodec"/>.
            <para/>
            See <see cref="N:Lucene.Net.Codecs.Lucene46"/> package documentation for file format details.
            <para/>
            @lucene.experimental 
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46Codec.GetPostingsFormatForField(System.String)">
            <summary>
            Returns the postings format that should be used for writing
            new segments of <paramref name="field"/>.
            <para/>
            The default implementation always returns "Lucene41"
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46Codec.GetDocValuesFormatForField(System.String)">
            <summary>
            Returns the docvalues format that should be used for writing
            new segments of <paramref name="field"/>.
            <para/>
            The default implementation always returns "Lucene45"
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosFormat">
            <summary>
            Lucene 4.6 Field Infos format.
            <para/>
            <para>Field names are stored in the field info file, with suffix <c>.fnm</c>.</para>
            <para>FieldInfos (.fnm) --&gt; Header,FieldsCount, &lt;FieldName,FieldNumber,
            FieldBits,DocValuesBits,DocValuesGen,Attributes&gt; <sup>FieldsCount</sup>,Footer</para>
            <para>Data types:
            <list type="bullet">
              <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>)</description></item>
              <item><description>FieldsCount --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>)</description></item>
              <item><description>FieldName --&gt; String (<see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>)</description></item>
              <item><description>FieldBits, DocValuesBits --&gt; Byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>)</description></item>
              <item><description>FieldNumber --&gt; VInt (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>)</description></item>
              <item><description>Attributes --&gt; IDictionary&lt;String,String&gt; (<see cref="M:Lucene.Net.Store.DataOutput.WriteStringStringMap(System.Collections.Generic.IDictionary{System.String,System.String})"/>)</description></item>
              <item><description>DocValuesGen --&gt; Int64 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>)</description></item>
              <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>)</description></item>
            </list>
            </para>
            Field Descriptions:
            <list type="bullet">
              <item><description>FieldsCount: the number of fields in this file.</description></item>
              <item><description>FieldName: name of the field as a UTF-8 string.</description></item>
              <item><description>FieldNumber: the field's number. Note that unlike previous versions of
                  Lucene, the fields are not numbered implicitly by their order in the
                  file, instead explicitly.</description></item>
              <item><description>FieldBits: a <see cref="T:System.Byte"/> containing field options.
                  <list type="bullet">
                    <item><description>The low-order bit is one for indexed fields, and zero for non-indexed
                        fields.</description></item>
                    <item><description>The second lowest-order bit is one for fields that have term vectors
                        stored, and zero for fields without term vectors.</description></item>
                    <item><description>If the third lowest order-bit is set (0x4), offsets are stored into
                        the postings list in addition to positions.</description></item>
                    <item><description>Fourth bit is unused.</description></item>
                    <item><description>If the fifth lowest-order bit is set (0x10), norms are omitted for the
                        indexed field.</description></item>
                    <item><description>If the sixth lowest-order bit is set (0x20), payloads are stored for the
                        indexed field.</description></item>
                    <item><description>If the seventh lowest-order bit is set (0x40), term frequencies and
                        positions omitted for the indexed field.</description></item>
                    <item><description>If the eighth lowest-order bit is set (0x80), positions are omitted for the
                        indexed field.</description></item>
                  </list>
               </description></item>
               <item><description>DocValuesBits: a <see cref="T:System.Byte"/> containing per-document value types. The type
                   recorded as two four-bit integers, with the high-order bits representing
                   <c>norms</c> options, and the low-order bits representing
                   <see cref="T:Lucene.Net.Index.DocValues"/> options. Each four-bit integer can be decoded as such:
                   <list type="bullet">
                     <item><description>0: no DocValues for this field.</description></item>
                     <item><description>1: <see cref="T:Lucene.Net.Index.NumericDocValues"/>. (<see cref="F:Lucene.Net.Index.DocValuesType.NUMERIC"/>)</description></item>
                     <item><description>2: <see cref="T:Lucene.Net.Index.BinaryDocValues"/>. (<see cref="F:Lucene.Net.Index.DocValuesType.BINARY"/>)</description></item>
                     <item><description>3: <see cref="T:Lucene.Net.Index.SortedDocValues"/>. (<see cref="F:Lucene.Net.Index.DocValuesType.SORTED"/>)</description></item>
                   </list>
               </description></item>
               <item><description>DocValuesGen is the generation count of the field's <see cref="T:Lucene.Net.Index.DocValues"/>. If this is -1,
                   there are no <see cref="T:Lucene.Net.Index.DocValues"/> updates to that field. Anything above zero means there
                   are updates stored by <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>.</description></item>
               <item><description>Attributes: a key-value map of codec-private attributes.</description></item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosFormat.EXTENSION">
            <summary>
            Extension of field infos </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosReader">
            <summary>
            Lucene 4.6 FieldInfos reader.
            <para/>
            @lucene.experimental 
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosWriter">
            <summary>
            Lucene 4.6 FieldInfos writer.
            <para/>
            @lucene.experimental 
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosWriter.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoFormat">
            <summary>
            Lucene 4.6 Segment info format.
            <para>
            Files:
            <list type="bullet">
              <item><description><c>.si</c>: Header, SegVersion, SegSize, IsCompoundFile, Diagnostics, Files, Footer</description></item>
            </list>
            </para>
            Data types:
            <para>
            <list type="bullet">
              <item><description>Header --&gt; CodecHeader (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/>) </description></item>
              <item><description>SegSize --&gt; Int32 (<see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>) </description></item>
              <item><description>SegVersion --&gt; String (<see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>) </description></item>
              <item><description>Files --&gt; ISet&lt;String&gt; (<see cref="M:Lucene.Net.Store.DataOutput.WriteStringSet(System.Collections.Generic.ISet{System.String})"/>) </description></item>
              <item><description>Diagnostics --&gt; IDictionary&lt;String,String&gt; (<see cref="M:Lucene.Net.Store.DataOutput.WriteStringStringMap(System.Collections.Generic.IDictionary{System.String,System.String})"/>) </description></item>
              <item><description>IsCompoundFile --&gt; Int8 (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>) </description></item>
              <item><description>Footer --&gt; CodecFooter (<see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/>) </description></item>
            </list>
            </para>
            Field Descriptions:
            <para>
            <list type="bullet">
              <item><description>SegVersion is the code version that created the segment.</description></item>
              <item><description>SegSize is the number of documents contained in the segment index.</description></item>
              <item><description>IsCompoundFile records whether the segment is written as a compound file or
                  not. If this is -1, the segment is not a compound file. If it is 1, the segment
                  is a compound file.</description></item>
              <item><description>The Diagnostics Map is privately written by <see cref="T:Lucene.Net.Index.IndexWriter"/>, as a debugging aid,
                  for each segment it creates. It includes metadata like the current Lucene
                  version, OS, .NET/Java version, why the segment was created (merge, flush,
                  addIndexes), etc.</description></item>
              <item><description>Files is a list of files referred to by this segment.</description></item>
            </list>
            </para>
            @lucene.experimental 
            </summary>
            <seealso cref="T:Lucene.Net.Index.SegmentInfos"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoFormat.SI_EXTENSION">
            <summary>
            File extension used to store <see cref="T:Lucene.Net.Index.SegmentInfo"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoReader">
            <summary>
            Lucene 4.6 implementation of <see cref="T:Lucene.Net.Codecs.SegmentInfoReader"/>.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoWriter">
            <summary>
            Lucene 4.0 implementation of <see cref="T:Lucene.Net.Codecs.SegmentInfoWriter"/>.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoFormat"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoWriter.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoWriter.Write(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Save a single segment's info. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum">
            <summary>
            Exposes flex API, merged from flex API of sub-segments,
            remapping docIDs (this is used for segment merging).
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.MergeState">
            <summary>
            Gets or Sets the <see cref="T:Lucene.Net.Index.MergeState"/>, which is used to re-map
            document IDs.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.NumSubs">
            <summary>
            How many sub-readers we are merging. </summary>
            <seealso cref="P:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.Subs"/>
        </member>
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.Subs">
            <summary>
            Returns sub-readers we are merging. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MappingMultiDocsEnum">
            <summary>
            Exposes flex API, merged from flex API of sub-segments,
            remapping docIDs (this is used for segment merging).
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MappingMultiDocsEnum.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsEnum.MergeState">
            <summary>
            Sets the <see cref="P:Lucene.Net.Codecs.MappingMultiDocsEnum.MergeState"/>, which is used to re-map
            document IDs.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsEnum.NumSubs">
            <summary>
            How many sub-readers we are merging. </summary>
            <seealso cref="P:Lucene.Net.Codecs.MappingMultiDocsEnum.Subs"/>
        </member>
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsEnum.Subs">
            <summary>
            Returns sub-readers we are merging. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MultiLevelSkipListReader">
            <summary>
            This abstract class reads skip lists with multiple levels.
            <para/>
            See <see cref="T:Lucene.Net.Codecs.MultiLevelSkipListWriter"/> for the information about the encoding
            of the multi level skip lists.
            <para/>
            Subclasses must implement the abstract method <see cref="M:Lucene.Net.Codecs.MultiLevelSkipListReader.ReadSkipData(System.Int32,Lucene.Net.Store.IndexInput)"/>
            which defines the actual format of the skip data.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.m_maxNumberOfSkipLevels">
            <summary>
            The maximum number of skip levels possible for this index. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.skipStream">
            <summary>
            SkipStream for each level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.skipPointer">
            <summary>
            The start pointer of each skip level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.skipInterval">
            <summary>
            SkipInterval of each level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.numSkipped">
            <summary>
            Number of docs skipped per level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.m_skipDoc">
            <summary>
            Doc id of current skip entry per level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.lastDoc">
            <summary>
            Doc id of last read skip entry with docId &lt;= target. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.childPointer">
            <summary>
            Child pointer of current skip entry per level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.lastChildPointer">
            <summary>
            childPointer of last read skip entry with docId &lt;=
            target.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Codecs.MultiLevelSkipListReader"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Codecs.MultiLevelSkipListReader"/>, where
            <see cref="F:Lucene.Net.Codecs.MultiLevelSkipListReader.skipInterval"/> and <see cref="F:Lucene.Net.Codecs.MultiLevelSkipListReader.skipMultiplier"/> are
            the same.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.MultiLevelSkipListReader.Doc">
            <summary>
            Returns the id of the doc to which the last call of <see cref="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipTo(System.Int32)"/>
            has skipped.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipTo(System.Int32)">
            <summary>
            Skips entries to the first beyond the current whose document number is
            greater than or equal to <paramref name="target"/>. Returns the current doc count.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SeekChild(System.Int32)">
            <summary>
            Seeks the skip entry on the given level. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.Dispose">
            <summary>
            Disposes all resources used by this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.Dispose(System.Boolean)">
            <summary>
            Disposes all resources used by this object. Subclasses may override
            to dispose their own resources.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.Init(System.Int64,System.Int32)">
            <summary>
            Initializes the reader, for reuse on a new term. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.LoadSkipLevels">
            <summary>
            Loads the skip levels. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.ReadSkipData(System.Int32,Lucene.Net.Store.IndexInput)">
            <summary>
            Subclasses must implement the actual skip data encoding in this method.
            </summary>
            <param name="level"> The level skip data shall be read from. </param>
            <param name="skipStream"> The skip stream to read from. </param>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SetLastSkipData(System.Int32)">
            <summary>
            Copies the values of the last read skip entry on this <paramref name="level"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipBuffer">
            <summary>
            Used to buffer the top skip levels. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MultiLevelSkipListWriter">
             <summary>
             This abstract class writes skip lists with multiple levels.
            
             <code>
            
             Example for skipInterval = 3:
                                                                 c            (skip level 2)
                             c                 c                 c            (skip level 1)
                 x     x     x     x     x     x     x     x     x     x      (skip level 0)
             d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  (posting list)
                 3     6     9     12    15    18    21    24    27    30     (df)
            
             d - document
             x - skip data
             c - skip data with child pointer
            
             Skip level i contains every skipInterval-th entry from skip level i-1.
             Therefore the number of entries on level i is: floor(df / ((skipInterval ^ (i + 1))).
            
             Each skip entry on a level i>0 contains a pointer to the corresponding skip entry in list i-1.
             this guarantees a logarithmic amount of skips to find the target document.
            
             While this class takes care of writing the different skip levels,
             subclasses must define the actual format of the skip data.
             </code>
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.m_numberOfSkipLevels">
            <summary>
            Number of levels in this skip list. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.skipInterval">
            <summary>
            The skip interval in the list with level = 0. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.skipMultiplier">
            <summary>
            SkipInterval used for level &gt; 0. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.skipBuffer">
            <summary>
            For every skip level a different buffer is used. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Codecs.MultiLevelSkipListWriter"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Codecs.MultiLevelSkipListWriter"/>, where
            <see cref="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.skipInterval"/> and <see cref="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.skipMultiplier"/> are
            the same.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.Init">
            <summary>
            Allocates internal skip buffers. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.ResetSkip">
            <summary>
            Creates new buffers or empties the existing ones. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.WriteSkipData(System.Int32,Lucene.Net.Store.IndexOutput)">
            <summary>
            Subclasses must implement the actual skip data encoding in this method.
            </summary>
            <param name="level"> The level skip data shall be writing for. </param>
            <param name="skipBuffer"> The skip buffer to write to. </param>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.BufferSkip(System.Int32)">
            <summary>
            Writes the current skip data to the buffers. The current document frequency determines
            the max level is skip data is to be written to.
            </summary>
            <param name="df"> The current document frequency. </param>
            <exception cref="T:System.IO.IOException"> If an I/O error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.WriteSkip(Lucene.Net.Store.IndexOutput)">
            <summary>
            Writes the buffered skip lists to the given output.
            </summary>
            <param name="output"> The <see cref="T:Lucene.Net.Store.IndexOutput"/> the skip lists shall be written to. </param>
            <returns> The pointer the skip list starts. </returns>
        </member>
        <member name="T:Lucene.Net.Codecs.NormsFormat">
            <summary>
            Encodes/decodes per-document score normalization values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.NormsFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.NormsFormat.NormsConsumer(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Codecs.DocValuesConsumer"/> to write norms to the
            index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.NormsFormat.NormsProducer(Lucene.Net.Index.SegmentReadState)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Codecs.DocValuesProducer"/> to read norms from the index.
            <para/>
            NOTE: by the time this call returns, it must hold open any files it will
            need to use; else, those files may be deleted. Additionally, required files
            may be deleted during the execution of this call before there is a chance
            to open them. Under these circumstances an <see cref="T:System.IO.IOException"/> should be thrown by
            the implementation. <see cref="T:System.IO.IOException"/> are expected and will automatically cause
            a retry of the segment opening logic with the newly revised segments.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat">
            <summary>
            Enables per field docvalues support.
            <para/>
            Note, when extending this class, the name (<see cref="P:Lucene.Net.Codecs.DocValuesFormat.Name"/>) is
            written into the index. In order for the field to be read, the
            name must resolve to your implementation via <see cref="M:Lucene.Net.Codecs.DocValuesFormat.ForName(System.String)"/>.
            This method uses <see cref="M:Lucene.Net.Codecs.IDocValuesFormatFactory.GetDocValuesFormat(System.String)"/> to resolve format names.
            See <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/> for information about how to implement your own <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>.
            <para/>
            Files written by each docvalues format have an additional suffix containing the
            format name. For example, in a per-field configuration instead of <c>_1.dat</c>
            filenames would look like <c>_1_Lucene40_0.dat</c>. 
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/>
        </member>
        <member name="F:Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat.PER_FIELD_FORMAT_KEY">
            <summary>
            <see cref="T:Lucene.Net.Index.FieldInfo"/> attribute name used to store the
            format name for each field.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat.PER_FIELD_SUFFIX_KEY">
            <summary>
            <see cref="T:Lucene.Net.Index.FieldInfo"/> attribute name used to store the
            segment suffix name for each field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat.GetDocValuesFormatForField(System.String)">
            <summary>
            Returns the doc values format that should be used for writing
            new segments of <paramref name="field"/>.
            <para/>
            The field to format mapping is written to the index, so
            this method is only invoked when writing, not when reading.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat">
            <summary>
            Enables per field postings support.
            <para/>
            Note, when extending this class, the name (<see cref="P:Lucene.Net.Codecs.PostingsFormat.Name"/>) is
            written into the index. In order for the field to be read, the
            name must resolve to your implementation via <see cref="M:Lucene.Net.Codecs.PostingsFormat.ForName(System.String)"/>.
            This method uses <see cref="M:Lucene.Net.Codecs.IPostingsFormatFactory.GetPostingsFormat(System.String)"/> to resolve format names.
            See <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/> for information about how to implement your own <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>.
            <para/>
            Files written by each posting format have an additional suffix containing the
            format name. For example, in a per-field configuration instead of <c>_1.prx</c>
            filenames would look like <c>_1_Lucene40_0.prx</c>. 
            <para/>
            @lucene.experimental 
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/>
        </member>
        <member name="F:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat.PER_FIELD_FORMAT_KEY">
            <summary>
            <see cref="T:Lucene.Net.Index.FieldInfo"/> attribute name used to store the
            format name for each field.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat.PER_FIELD_SUFFIX_KEY">
            <summary>
            <see cref="T:Lucene.Net.Index.FieldInfo"/> attribute name used to store the
            segment suffix name for each field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat.GetPostingsFormatForField(System.String)">
            <summary>
            Returns the postings format that should be used for writing
            new segments of <paramref name="field"/>.
            <para/>
            The field to format mapping is written to the index, so
            this method is only invoked when writing, not when reading.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.PostingsBaseFormat">
            <summary>
            Provides a <see cref="T:Lucene.Net.Codecs.PostingsReaderBase"/> and 
            <see cref="T:Lucene.Net.Codecs.PostingsWriterBase"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.PostingsBaseFormat.Name">
            <summary>
            Unique name that's used to retrieve this codec when
            reading the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsBaseFormat.#ctor(System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsBaseFormat.PostingsReaderBase(Lucene.Net.Index.SegmentReadState)">
            <summary>
            Creates the <see cref="T:Lucene.Net.Codecs.PostingsReaderBase"/> for this
            format.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsBaseFormat.PostingsWriterBase(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Creates the <see cref="T:Lucene.Net.Codecs.PostingsWriterBase"/> for this
            format.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.PostingsConsumer">
            <summary>
            Abstract API that consumes postings for an individual term.
            <para/>
            The lifecycle is:
            <list type="number">
               <item><description>PostingsConsumer is returned for each term by
                   <see cref="M:Lucene.Net.Codecs.TermsConsumer.StartTerm(Lucene.Net.Util.BytesRef)"/>.</description></item>
               <item><description><see cref="M:Lucene.Net.Codecs.PostingsConsumer.StartDoc(System.Int32,System.Int32)"/> is called for each
                   document where the term occurs, specifying id
                   and term frequency for that document.</description></item>
               <item><description>If positions are enabled for the field, then
                   <see cref="M:Lucene.Net.Codecs.PostingsConsumer.AddPosition(System.Int32,Lucene.Net.Util.BytesRef,System.Int32,System.Int32)"/>
                   will be called for each occurrence in the
                   document.</description></item>
               <item><description><see cref="M:Lucene.Net.Codecs.PostingsConsumer.FinishDoc"/> is called when the producer
                   is done adding positions to the document.</description></item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsConsumer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsConsumer.StartDoc(System.Int32,System.Int32)">
            <summary>
            Adds a new doc in this term.
            <paramref name="freq"/> will be -1 when term frequencies are omitted
            for the field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsConsumer.AddPosition(System.Int32,Lucene.Net.Util.BytesRef,System.Int32,System.Int32)">
            <summary>
            Add a new position &amp; payload, and start/end offset.  A
            <c>null</c> <paramref name="payload"/> means no payload; a non-<c>null</c> <paramref name="payload"/> with
            zero length also means no payload.  Caller may reuse
            the <see cref="T:Lucene.Net.Util.BytesRef"/> for the <paramref name="payload"/> between calls
            (method must fully consume the payload). <paramref name="startOffset"/>
            and <paramref name="endOffset"/> will be -1 when offsets are not indexed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsConsumer.FinishDoc">
            <summary>
            Called when we are done adding positions &amp; payloads
            for each doc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsConsumer.Merge(Lucene.Net.Index.MergeState,Lucene.Net.Index.IndexOptions,Lucene.Net.Index.DocsEnum,Lucene.Net.Util.FixedBitSet)">
            <summary>
            Default merge impl: append documents, mapping around
            deletes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.PostingsFormat">
            <summary>
            Encodes/decodes terms, postings, and proximity data.
            <para/>
            Note, when extending this class, the name (<see cref="P:Lucene.Net.Codecs.PostingsFormat.Name"/>) may
            written into the index in certain configurations. In order for the segment
            to be read, the name must resolve to your implementation via <see cref="M:Lucene.Net.Codecs.PostingsFormat.ForName(System.String)"/>.
            This method uses <see cref="M:Lucene.Net.Codecs.IPostingsFormatFactory.GetPostingsFormat(System.String)"/> to resolve format names.
            <para/>
            If you implement your own format:
            <list type="number">
                <item><description>Subclass this class.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/>, override <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.Initialize"/>,
                    and add the line <c>base.ScanForPostingsFormats(typeof(YourPostingsFormat).GetTypeInfo().Assembly)</c>. 
                    If you have any format classes in your assembly 
                    that are not meant for reading, you can add the <see cref="T:Lucene.Net.Codecs.ExcludePostingsFormatFromScanAttribute"/> 
                    to them so they are ignored by the scan.</description></item>
                <item><description>Set the new <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/> by calling <see cref="M:Lucene.Net.Codecs.PostingsFormat.SetPostingsFormatFactory(Lucene.Net.Codecs.IPostingsFormatFactory)"/> 
                    at application startup.</description></item>
            </list>
            If your format has dependencies, you may also override <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormat(System.Type)"/> to inject 
            them via pure DI or a DI container. See <a href="http://blog.ploeh.dk/2014/05/19/di-friendly-framework/">DI-Friendly Framework</a>
            to understand the approach used.
            <para/>
            <b>PostingsFormat Names</b>
            <para/>
            Unlike the Java version, format names are by default convention-based on the class name. 
            If you name your custom format class "MyCustomPostingsFormat", the codec name will the same name 
            without the "PostingsFormat" suffix: "MyCustom".
            <para/>
            You can override this default behavior by using the <see cref="T:Lucene.Net.Codecs.PostingsFormatNameAttribute"/> to
            name the format differently than this convention. Format names must be all ASCII alphanumeric, 
            and less than 128 characters in length.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.PostingsFormatNameAttribute"/>
        </member>
        <member name="F:Lucene.Net.Codecs.PostingsFormat.EMPTY">
            <summary>
            Zero-length <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> array. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.PostingsFormat.name">
            <summary>
            Unique name that's used to retrieve this format when
            reading the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.SetPostingsFormatFactory(Lucene.Net.Codecs.IPostingsFormatFactory)">
            <summary>
            Sets the <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/> instance used to instantiate
            <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> subclasses.
            </summary>
            <param name="postingsFormatFactory">The new <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="postingsFormatFactory"/> parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.GetPostingsFormatFactory">
            <summary>
            Gets the associated <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> factory.
            </summary>
            <returns>The <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> factory.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.#ctor">
            <summary>
            Creates a new postings format.
            <para/>
            The provided name will be written into the index segment in some configurations
            (such as when using <see cref="T:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat"/>): in such configurations,
            for the segment to be read this class should be registered by subclassing <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/> and
            calling <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.ScanForPostingsFormats(System.Reflection.Assembly)"/> in the class constructor. 
            The new <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/> can be registered by calling <see cref="M:Lucene.Net.Codecs.PostingsFormat.SetPostingsFormatFactory(Lucene.Net.Codecs.IPostingsFormatFactory)"/> at application startup.</summary>
        </member>
        <member name="P:Lucene.Net.Codecs.PostingsFormat.Name">
            <summary>
            Returns this posting format's name. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.FieldsConsumer(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Writes a new segment. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.FieldsProducer(Lucene.Net.Index.SegmentReadState)">
            <summary>
            Reads a segment.  NOTE: by the time this call
            returns, it must hold open any files it will need to
            use; else, those files may be deleted.
            Additionally, required files may be deleted during the execution of
            this call before there is a chance to open them. Under these
            circumstances an <see cref="T:System.IO.IOException"/> should be thrown by the implementation.
            <see cref="T:System.IO.IOException"/>s are expected and will automatically cause a retry of the
            segment opening logic with the newly revised segments.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.ForName(System.String)">
            <summary>
            Looks up a format by name. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.PostingsFormat.AvailablePostingsFormats">
            <summary>
            Returns a list of all available format names. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.PostingsReaderBase">
            <summary>
            The core terms dictionaries (BlockTermsReader,
            <see cref="T:Lucene.Net.Codecs.BlockTreeTermsReader"/>) interact with a single instance
            of this class to manage creation of <see cref="T:Lucene.Net.Index.DocsEnum"/> and
            <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> instances.  It provides an
            <see cref="T:Lucene.Net.Store.IndexInput"/> (termsIn) where this class may read any
            previously stored data that it had written in its
            corresponding <see cref="T:Lucene.Net.Codecs.PostingsWriterBase"/> at indexing
            time.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.Init(Lucene.Net.Store.IndexInput)">
            <summary>
            Performs any initialization, such as reading and
            verifying the header from the provided terms
            dictionary <see cref="T:Lucene.Net.Store.IndexInput"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.NewTermState">
            <summary>
            Return a newly created empty <see cref="T:Lucene.Net.Index.TermState"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.DecodeTerm(System.Int64[],Lucene.Net.Store.DataInput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,System.Boolean)">
            <summary>
            Actually decode metadata for next term. </summary>
            <seealso cref="M:Lucene.Net.Codecs.PostingsWriterBase.EncodeTerm(System.Int64[],Lucene.Net.Store.DataOutput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.Docs(Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum,Lucene.Net.Index.DocsFlags)">
            <summary>
            Must fully consume state, since after this call that
            <see cref="T:Lucene.Net.Index.TermState"/> may be reused.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.DocsAndPositions(Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum,Lucene.Net.Index.DocsAndPositionsFlags)">
            <summary>
            Must fully consume state, since after this call that
            <see cref="T:Lucene.Net.Index.TermState"/> may be reused.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.CheckIntegrity">
            <summary>
            Checks consistency of this reader.
            <para/>
            Note that this may be costly in terms of I/O, e.g.
            may involve computing a checksum value against large data files.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.Dispose">
            <summary>
            Disposes all resources used by this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.Dispose(System.Boolean)">
            <summary>
            Implementations must override and should dispose all resources used by this instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.PostingsWriterBase">
            <summary>
            Extension of <see cref="T:Lucene.Net.Codecs.PostingsConsumer"/> to support pluggable term dictionaries.
            <para/>
            This class contains additional hooks to interact with the provided
            term dictionaries such as <see cref="T:Lucene.Net.Codecs.BlockTreeTermsWriter"/>. If you want
            to re-use an existing implementation and are only interested in
            customizing the format of the postings list, extend this class
            instead.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.PostingsReaderBase"/>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.Init(Lucene.Net.Store.IndexOutput)">
            <summary>
            Called once after startup, before any terms have been
            added.  Implementations typically write a header to
            the provided <paramref name="termsOut"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.NewTermState">
            <summary>
            Return a newly created empty <see cref="T:Lucene.Net.Index.TermState"/> </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.StartTerm">
            <summary>
            Start a new term.  Note that a matching call to 
            <see cref="M:Lucene.Net.Codecs.PostingsWriterBase.FinishTerm(Lucene.Net.Codecs.BlockTermState)"/> is done, only if the term has at least one
            document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.FinishTerm(Lucene.Net.Codecs.BlockTermState)">
            <summary>
            Finishes the current term.  The provided 
            <see cref="T:Lucene.Net.Codecs.BlockTermState"/> contains the term's summary statistics,
            and will holds metadata from PBF when returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.EncodeTerm(System.Int64[],Lucene.Net.Store.DataOutput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,System.Boolean)">
            <summary>
            Encode metadata as <see cref="T:long[]"/> and <see cref="T:byte[]"/>. <paramref name="absolute"/> controls whether
            current term is delta encoded according to latest term.
            Usually elements in <paramref name="longs"/> are file pointers, so each one always
            increases when a new term is consumed. <paramref name="out"/> is used to write generic
            bytes, which are not monotonic.
            <para/>
            NOTE: sometimes <see cref="T:long[]"/> might contain "don't care" values that are unused, e.g.
            the pointer to postings list may not be defined for some terms but is defined
            for others, if it is designed to inline some postings data in term dictionary.
            In this case, the postings writer should always use the last value, so that each
            element in metadata <see cref="T:long[]"/> remains monotonic.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.SetField(Lucene.Net.Index.FieldInfo)">
            <summary>
            Sets the current field for writing, and returns the
            fixed length of <see cref="T:long[]"/> metadata (which is fixed per
            field), called when the writing switches to another field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.Dispose">
            <summary>
            Disposes all resources used by this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.Dispose(System.Boolean)">
            <summary>
            Implementations must override and should dispose all resources used by this instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.SegmentInfoFormat">
            <summary>
            Expert: Controls the format of the
            <see cref="T:Lucene.Net.Index.SegmentInfo"/> (segment metadata file).
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Index.SegmentInfo"/>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.SegmentInfoFormat.SegmentInfoReader">
            <summary>
            Returns the <see cref="T:Lucene.Net.Codecs.SegmentInfoReader"/> for reading
            <see cref="T:Lucene.Net.Index.SegmentInfo"/> instances.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.SegmentInfoFormat.SegmentInfoWriter">
            <summary>
            Returns the <see cref="T:Lucene.Net.Codecs.SegmentInfoWriter"/> for writing
            <see cref="T:Lucene.Net.Index.SegmentInfo"/> instances.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.SegmentInfoReader">
            <summary>
            Specifies an API for classes that can read <see cref="T:Lucene.Net.Index.SegmentInfo"/> information.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoReader.Read(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Read <see cref="T:Lucene.Net.Index.SegmentInfo"/> data from a directory. </summary>
            <param name="directory"> Directory to read from. </param>
            <param name="segmentName"> Name of the segment to read. </param>
            <param name="context"> IO context. </param>
            <returns> Infos instance to be populated with data. </returns>
            <exception cref="T:System.IO.IOException"> If an I/O error occurs. </exception>
        </member>
        <member name="T:Lucene.Net.Codecs.SegmentInfoWriter">
            <summary>
            Specifies an API for classes that can write out <see cref="T:Lucene.Net.Index.SegmentInfo"/> data.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoWriter.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoWriter.Write(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Write <see cref="T:Lucene.Net.Index.SegmentInfo"/> data. </summary>
            <exception cref="T:System.IO.IOException"> If an I/O error occurs. </exception>
        </member>
        <member name="T:Lucene.Net.Codecs.StoredFieldsFormat">
            <summary>
            Controls the format of stored fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsFormat.FieldsReader(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Codecs.StoredFieldsReader"/> to load stored
            fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsFormat.FieldsWriter(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Codecs.StoredFieldsWriter"/> to write stored
            fields.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.StoredFieldsReader">
            <summary>
            Codec API for reading stored fields.
            <para/>
            You need to implement <see cref="M:Lucene.Net.Codecs.StoredFieldsReader.VisitDocument(System.Int32,Lucene.Net.Index.StoredFieldVisitor)"/> to
            read the stored fields for a document, implement <see cref="M:Lucene.Net.Codecs.StoredFieldsReader.Clone"/> (creating
            clones of any <see cref="T:Lucene.Net.Store.IndexInput"/>s used, etc), and <see cref="M:Lucene.Net.Codecs.StoredFieldsReader.Dispose(System.Boolean)"/>
            to cleanup any allocated resources.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.VisitDocument(System.Int32,Lucene.Net.Index.StoredFieldVisitor)">
            <summary>
            Visit the stored fields for document <paramref name="n"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.Dispose">
            <summary>
            Disposes all resources used by this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.Dispose(System.Boolean)">
            <summary>
            Implementations must override and should dispose all resources used by this instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.CheckIntegrity">
            <summary>
            Checks consistency of this reader.
            <para/>
            Note that this may be costly in terms of I/O, e.g.
            may involve computing a checksum value against large data files.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.StoredFieldsWriter">
            <summary>
            Codec API for writing stored fields:
            <para/>
            <list type="number">
              <item><description>For every document, <see cref="M:Lucene.Net.Codecs.StoredFieldsWriter.StartDocument(System.Int32)"/> is called,
                  informing the Codec how many fields will be written.</description></item>
              <item><description><see cref="M:Lucene.Net.Codecs.StoredFieldsWriter.WriteField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.IIndexableField)"/> is called for
                  each field in the document.</description></item>
              <item><description>After all documents have been written, <see cref="M:Lucene.Net.Codecs.StoredFieldsWriter.Finish(Lucene.Net.Index.FieldInfos,System.Int32)"/>
                  is called for verification/sanity-checks.</description></item>
              <item><description>Finally the writer is disposed (<see cref="M:Lucene.Net.Codecs.StoredFieldsWriter.Dispose(System.Boolean)"/>)</description></item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.StartDocument(System.Int32)">
            <summary>
            Called before writing the stored fields of the document.
            <see cref="M:Lucene.Net.Codecs.StoredFieldsWriter.WriteField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.IIndexableField)"/> will be called
            <paramref name="numStoredFields"/> times. Note that this is
            called even if the document has no stored fields, in
            this case <paramref name="numStoredFields"/> will be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.FinishDocument">
            <summary>
            Called when a document and all its fields have been added. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.WriteField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.IIndexableField)">
            <summary>
            Writes a single stored field. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.Abort">
            <summary>
            Aborts writing entirely, implementation should remove
            any partially-written files, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.Finish(Lucene.Net.Index.FieldInfos,System.Int32)">
            <summary>
            Called before <see cref="M:Lucene.Net.Codecs.StoredFieldsWriter.Dispose"/>, passing in the number
            of documents that were written. Note that this is
            intentionally redundant (equivalent to the number of
            calls to <see cref="M:Lucene.Net.Codecs.StoredFieldsWriter.StartDocument(System.Int32)"/>, but a <see cref="T:Lucene.Net.Codecs.Codec"/> should
            check that this is the case to detect the bug described
            in LUCENE-1282.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.Merge(Lucene.Net.Index.MergeState)">
            <summary>
            Merges in the stored fields from the readers in
            <paramref name="mergeState"/>. The default implementation skips
            over deleted documents, and uses <see cref="M:Lucene.Net.Codecs.StoredFieldsWriter.StartDocument(System.Int32)"/>,
            <see cref="M:Lucene.Net.Codecs.StoredFieldsWriter.WriteField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.IIndexableField)"/>, and <see cref="M:Lucene.Net.Codecs.StoredFieldsWriter.Finish(Lucene.Net.Index.FieldInfos,System.Int32)"/>,
            returning the number of documents that were written.
            Implementations can override this method for more sophisticated
            merging (bulk-byte copying, etc).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.AddDocument``1(System.Collections.Generic.IEnumerable{``0},Lucene.Net.Index.FieldInfos)">
            <summary>
            Sugar method for <see cref="M:Lucene.Net.Codecs.StoredFieldsWriter.StartDocument(System.Int32)"/> + <see cref="M:Lucene.Net.Codecs.StoredFieldsWriter.WriteField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.IIndexableField)"/> 
            for every stored field in the document. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.Dispose">
            <summary>
            Disposes all resources used by this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.Dispose(System.Boolean)">
            <summary>
            Implementations must override and should dispose all resources used by this instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.TermsConsumer">
            <summary>
            Abstract API that consumes terms for an individual field.
            <para/>
            The lifecycle is:
            <list type="number">
              <item><description>TermsConsumer is returned for each field
                  by <see cref="M:Lucene.Net.Codecs.FieldsConsumer.AddField(Lucene.Net.Index.FieldInfo)"/>.</description></item>
              <item><description>TermsConsumer returns a <see cref="T:Lucene.Net.Codecs.PostingsConsumer"/> for
                  each term in <see cref="M:Lucene.Net.Codecs.TermsConsumer.StartTerm(Lucene.Net.Util.BytesRef)"/>.</description></item>
              <item><description>When the producer (e.g. IndexWriter)
                  is done adding documents for the term, it calls
                  <see cref="M:Lucene.Net.Codecs.TermsConsumer.FinishTerm(Lucene.Net.Util.BytesRef,Lucene.Net.Codecs.TermStats)"/>, passing in
                  the accumulated term statistics.</description></item>
              <item><description>Producer calls <see cref="M:Lucene.Net.Codecs.TermsConsumer.Finish(System.Int64,System.Int64,System.Int32)"/> with
                  the accumulated collection statistics when it is finished
                  adding terms to the field.</description></item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.StartTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            Starts a new term in this field; this may be called
            with no corresponding call to finish if the term had
            no docs.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.FinishTerm(Lucene.Net.Util.BytesRef,Lucene.Net.Codecs.TermStats)">
            <summary>
            Finishes the current term; numDocs must be &gt; 0.
            <c>stats.TotalTermFreq</c> will be -1 when term
            frequencies are omitted for the field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.Finish(System.Int64,System.Int64,System.Int32)">
            <summary>
            Called when we are done adding terms to this field.
            <paramref name="sumTotalTermFreq"/> will be -1 when term
            frequencies are omitted for the field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.TermsConsumer.Comparer">
            <summary>
            Gets the <see cref="T:IComparer{BytesRef}"/> used to sort terms
            before feeding to this API.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.Merge(Lucene.Net.Index.MergeState,Lucene.Net.Index.IndexOptions,Lucene.Net.Index.TermsEnum)">
            <summary>
            Default merge impl. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.TermStats">
            <summary>
            Holder for per-term statistics.
            </summary>
            <seealso cref="P:Lucene.Net.Index.TermsEnum.DocFreq"/>
            <seealso cref="P:Lucene.Net.Index.TermsEnum.TotalTermFreq"/>
        </member>
        <member name="P:Lucene.Net.Codecs.TermStats.DocFreq">
            <summary>
            How many documents have at least one occurrence of
            this term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.TermStats.TotalTermFreq">
            <summary>
            Total number of times this term occurs across all
            documents in the field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermStats.#ctor(System.Int32,System.Int64)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.TermVectorsFormat">
            <summary>
            Controls the format of term vectors.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsFormat.VectorsReader(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Codecs.TermVectorsReader"/> to read term
            vectors.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsFormat.VectorsWriter(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Codecs.TermVectorsWriter"/> to write term
            vectors.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.TermVectorsReader">
            <summary>
            Codec API for reading term vectors:
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.Get(System.Int32)">
            <summary>
            Returns term vectors for this document, or <c>null</c> if
            term vectors were not indexed. If offsets are
            available they are in an <see cref="T:Lucene.Net.Analysis.TokenAttributes.OffsetAttribute"/>
            available from the <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.CheckIntegrity">
            <summary>
            Checks consistency of this reader.
            <para/>
            Note that this may be costly in terms of I/O, e.g.
            may involve computing a checksum value against large data files.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.Clone">
            <summary>
            Create a clone that one caller at a time may use to
            read term vectors.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.Dispose">
            <summary>
            Disposes all resources used by this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.Dispose(System.Boolean)">
            <summary>
            Implementations must override and should dispose all resources used by this instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.TermVectorsWriter">
            <summary>
            Codec API for writing term vectors:
            <para/>
            <list type="number">
              <item><description>For every document, <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.StartDocument(System.Int32)"/> is called,
                  informing the <see cref="T:Lucene.Net.Codecs.Codec"/> how many fields will be written.</description></item>
              <item><description><see cref="M:Lucene.Net.Codecs.TermVectorsWriter.StartField(Lucene.Net.Index.FieldInfo,System.Int32,System.Boolean,System.Boolean,System.Boolean)"/> is called for
                  each field in the document, informing the codec how many terms
                  will be written for that field, and whether or not positions,
                  offsets, or payloads are enabled.</description></item>
              <item><description>Within each field, <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.StartTerm(Lucene.Net.Util.BytesRef,System.Int32)"/> is called
                  for each term.</description></item>
              <item><description>If offsets and/or positions are enabled, then
                  <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.AddPosition(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)"/> will be called for each term
                  occurrence.</description></item>
              <item><description>After all documents have been written, <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.Finish(Lucene.Net.Index.FieldInfos,System.Int32)"/>
                  is called for verification/sanity-checks.</description></item>
              <item><description>Finally the writer is disposed (<see cref="M:Lucene.Net.Codecs.TermVectorsWriter.Dispose(System.Boolean)"/>)</description></item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.StartDocument(System.Int32)">
            <summary>
            Called before writing the term vectors of the document.
            <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.StartField(Lucene.Net.Index.FieldInfo,System.Int32,System.Boolean,System.Boolean,System.Boolean)"/> will
            be called <paramref name="numVectorFields"/> times. Note that if term
            vectors are enabled, this is called even if the document
            has no vector fields, in this case <paramref name="numVectorFields"/>
            will be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.FinishDocument">
            <summary>
            Called after a doc and all its fields have been added. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.StartField(Lucene.Net.Index.FieldInfo,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Called before writing the terms of the field.
            <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.StartTerm(Lucene.Net.Util.BytesRef,System.Int32)"/> will be called <paramref name="numTerms"/> times.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.FinishField">
            <summary>
            Called after a field and all its terms have been added. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.StartTerm(Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            Adds a <paramref name="term"/> and its term frequency <paramref name="freq"/>.
            If this field has positions and/or offsets enabled, then
            <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.AddPosition(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)"/> will be called
            <paramref name="freq"/> times respectively.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.FinishTerm">
            <summary>
            Called after a term and all its positions have been added. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.AddPosition(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Adds a term <paramref name="position"/> and offsets. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.Abort">
            <summary>
            Aborts writing entirely, implementation should remove
            any partially-written files, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.Finish(Lucene.Net.Index.FieldInfos,System.Int32)">
            <summary>
            Called before <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.Dispose(System.Boolean)"/>, passing in the number
            of documents that were written. Note that this is
            intentionally redundant (equivalent to the number of
            calls to <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.StartDocument(System.Int32)"/>, but a <see cref="T:Lucene.Net.Codecs.Codec"/> should
            check that this is the case to detect the bug described
            in LUCENE-1282.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.AddProx(System.Int32,Lucene.Net.Store.DataInput,Lucene.Net.Store.DataInput)">
            <summary>
            Called by <see cref="T:Lucene.Net.Index.IndexWriter"/> when writing new segments.
            <para/>
            This is an expert API that allows the codec to consume
            positions and offsets directly from the indexer.
            <para/>
            The default implementation calls <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.AddPosition(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)"/>,
            but subclasses can override this if they want to efficiently write
            all the positions, then all the offsets, for example.
            <para/>
            NOTE: this API is extremely expert and subject to change or removal!!!
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.Merge(Lucene.Net.Index.MergeState)">
            <summary>
            Merges in the term vectors from the readers in
            <paramref name="mergeState"/>. The default implementation skips
            over deleted documents, and uses <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.StartDocument(System.Int32)"/>,
            <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.StartField(Lucene.Net.Index.FieldInfo,System.Int32,System.Boolean,System.Boolean,System.Boolean)"/>,
            <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.StartTerm(Lucene.Net.Util.BytesRef,System.Int32)"/>, <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.AddPosition(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)"/>,
            and <see cref="M:Lucene.Net.Codecs.TermVectorsWriter.Finish(Lucene.Net.Index.FieldInfos,System.Int32)"/>,
            returning the number of documents that were written.
            Implementations can override this method for more sophisticated
            merging (bulk-byte copying, etc).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.AddAllDocVectors(Lucene.Net.Index.Fields,Lucene.Net.Index.MergeState)">
            <summary>
            Safe (but, slowish) default method to write every
            vector field in the document.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.TermVectorsWriter.Comparer">
            <summary>
            Return the <see cref="T:IComparer{BytesRef}"/> used to sort terms
            before feeding to this API.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.Dispose">
            <summary>
            Disposes all resources used by this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.Dispose(System.Boolean)">
            <summary>
            Implementations must override and should dispose all resources used by this instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.CodecNameAttribute">
            <summary>
            Represents an attribute that is used to name a <see cref="T:Lucene.Net.Codecs.Codec"/>, if a name
            other than the default <see cref="T:Lucene.Net.Codecs.Codec"/> naming convention is desired.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.DefaultCodecFactory">
            <summary>
            LUCENENET specific class that implements the default functionality for the 
            <see cref="T:Lucene.Net.Codecs.ICodecFactory"/>.
            <para/>
            The most common use cases are:
            <list type="bullet">
                <item><description>Initialize <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/> with a set of <see cref="P:Lucene.Net.Codecs.DefaultCodecFactory.CustomCodecTypes"/>.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/> and override
                    <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodec(System.Type)"/> so an external dependency injection
                    container can be used to supply the instances (lifetime should be singleton). Note that you could 
                    alternately use the "named type" feature that many DI containers have to supply the type based on name by 
                    overriding <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodec(System.String)"/>.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/> and override
                    <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodecType(System.String)"/> so a type new type can be
                    supplied that is not in the <see cref="F:Lucene.Net.Codecs.DefaultCodecFactory.codecNameToTypeMap"/>.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/> to add new or override the default <see cref="T:Lucene.Net.Codecs.Codec"/> 
                    types by overriding <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.Initialize"/> and calling <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.PutCodecType(System.Type)"/>.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/> to scan additional assemblies for <see cref="T:Lucene.Net.Codecs.Codec"/>
                    subclasses in by overriding <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.Initialize"/> and calling <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.ScanForCodecs(System.Reflection.Assembly)"/>. 
                    For performance reasons, the default behavior only loads Lucene.Net codecs.</description></item>
            </list>
            <para/>
            To set the <see cref="T:Lucene.Net.Codecs.ICodecFactory"/>, call <see cref="M:Lucene.Net.Codecs.Codec.SetCodecFactory(Lucene.Net.Codecs.ICodecFactory)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.#ctor">
            <summary>
            Creates a new instance of <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.DefaultCodecFactory.CustomCodecTypes">
            <summary>
            An array of custom <see cref="T:Lucene.Net.Codecs.Codec"/>-derived types to be registered. This property
            can be initialized during construction of <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/>
            to make your custom codecs known to Lucene.
            <para/>
            These types will be registered after the default Lucene types, so if a custom type has the same
            name as a Lucene <see cref="T:Lucene.Net.Codecs.Codec"/> (via <see cref="T:Lucene.Net.Codecs.CodecNameAttribute"/>) 
            the custom type will replace the Lucene type with the same name.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.Initialize">
            <summary>
            Initializes the codec type cache with the known <see cref="T:Lucene.Net.Codecs.Codec"/> types.
            Override this method (and optionally call <c>base.Initialize()</c>) to add your
            own <see cref="T:Lucene.Net.Codecs.Codec"/> types by calling <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.PutCodecType(System.Type)"/> 
            or <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.ScanForCodecs(System.Reflection.Assembly)"/>.
            <para/>
            If two types have the same name by using the <see cref="T:Lucene.Net.Codecs.CodecNameAttribute"/>, the
            last one registered wins.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.ScanForCodecs(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Scans the given <paramref name="assemblies"/> for subclasses of <see cref="T:Lucene.Net.Codecs.Codec"/>
            and adds their names to the <see cref="F:Lucene.Net.Codecs.DefaultCodecFactory.codecNameToTypeMap"/>. Note that names will be
            automatically overridden if the <see cref="T:Lucene.Net.Codecs.Codec"/> name appears multiple times - the last match wins.
            </summary>
            <param name="assemblies">A list of assemblies to scan. The assemblies will be scanned from first to last, 
            and the last match for each <see cref="T:Lucene.Net.Codecs.Codec"/> name wins.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.ScanForCodecs(System.Reflection.Assembly)">
            <summary>
            Scans the given <paramref name="assembly"/> for subclasses of <see cref="T:Lucene.Net.Codecs.Codec"/>
            and adds their names to the <see cref="F:Lucene.Net.Codecs.DefaultCodecFactory.codecNameToTypeMap"/>. Note that names will be
            automatically overridden if the <see cref="T:Lucene.Net.Codecs.Codec"/> name appears multiple times - the last match wins.
            </summary>
            <param name="assembly">The assembly to scan.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.PutCodecType(System.Type)">
            <summary>
            Adds a <see cref="T:Lucene.Net.Codecs.Codec"/> type to the <see cref="F:Lucene.Net.Codecs.DefaultCodecFactory.codecNameToTypeMap"/>, using 
            the name provided in the <see cref="T:Lucene.Net.Codecs.CodecNameAttribute"/>, if present, or the name
            of the codec class minus the "Codec" suffix as the name by default.
            <para/>
            Note that if a <see cref="T:Lucene.Net.Codecs.Codec"/> with the same name already exists in the map,
            calling this method will update it to the new type.
            </summary>
            <param name="codec">A type that subclasses <see cref="T:Lucene.Net.Codecs.Codec"/>.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodec(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.Codec"/> instance from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.Codec"/> instance to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.Codec"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodec(System.Type)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.Codec"/> instance from the provided <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Lucene.Net.Codecs.Codec"/> to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.Codec"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.NewCodec(System.Type)">
            <summary>
            Instantiates a <see cref="T:Lucene.Net.Codecs.Codec"/> based on the provided <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Lucene.Net.Codecs.Codec"/> to instantiate.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodecType(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.Codec"/> <see cref="T:System.Type"/> from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.Codec"/> <see cref="T:System.Type"/> to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.Codec"/> <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="P:Lucene.Net.Codecs.DefaultCodecFactory.AvailableServices">
            <summary>
            Gets a list of the available <see cref="T:Lucene.Net.Codecs.Codec"/>s (by name).
            </summary>
            <returns>A <see cref="T:ICollection{string}"/> of <see cref="T:Lucene.Net.Codecs.Codec"/> names.</returns>
        </member>
        <member name="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory">
            <summary>
            LUCENENET specific class that implements the default functionality for the 
            <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>.
            <para/>
            The most common use cases are:
            <list type="bullet">
                <item><description>Initialize <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/> with a set of <see cref="P:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.CustomDocValuesFormatTypes"/>.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/> and override
                    <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormat(System.Type)"/> so an external dependency injection
                    container can be used to supply the instances (lifetime should be singleton). Note that you could 
                    alternately use the "named type" feature that many DI containers have to supply the type based on name by 
                    overriding <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormat(System.String)"/>.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/> and override
                    <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormatType(System.String)"/> so a type new type can be
                    supplied that is not in the <see cref="F:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.docValuesFormatNameToTypeMap"/>.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/> to add new or override the default <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> 
                    types by overriding <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.Initialize"/> and calling <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.PutDocValuesFormatType(System.Type)"/>.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/> to scan additional assemblies for <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>
                    subclasses in by overriding <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.Initialize"/> and calling <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.ScanForDocValuesFormats(System.Reflection.Assembly)"/>. 
                    For performance reasons, the default behavior only loads Lucene.Net codecs.</description></item>
            </list>
            <para/>
            To set the <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>, call <see cref="M:Lucene.Net.Codecs.DocValuesFormat.SetDocValuesFormatFactory(Lucene.Net.Codecs.IDocValuesFormatFactory)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.#ctor">
            <summary>
            Creates a new instance of <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.CustomDocValuesFormatTypes">
            <summary>
            An array of custom <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>-derived types to be registered. This property
            can be initialized during construction of <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/>
            to make your custom codecs known to Lucene.
            <para/>
            These types will be registered after the default Lucene types, so if a custom type has the same
            name as a Lucene <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> (via <see cref="T:Lucene.Net.Codecs.DocValuesFormatNameAttribute"/>) 
            the custom type will replace the Lucene type with the same name.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.Initialize">
            <summary>
            Initializes the doc values type cache with the known <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> types.
            Override this method (and optionally call <c>base.Initialize()</c>) to add your
            own <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> types by calling <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.PutDocValuesFormatType(System.Type)"/> 
            or <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.ScanForDocValuesFormats(System.Reflection.Assembly)"/>.
            <para/>
            If two types have the same name by using the <see cref="T:Lucene.Net.Codecs.DocValuesFormatNameAttribute"/>, the
            last one registered wins.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.ScanForDocValuesFormats(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Scans the given <paramref name="assemblies"/> for subclasses of <see cref="T:Lucene.Net.Codecs.Codec"/>
            and adds their names to the <see cref="F:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.docValuesFormatNameToTypeMap"/>. Note that names will be
            automatically overridden if the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> name appears multiple times - the last match wins.
            </summary>
            <param name="assemblies">A list of assemblies to scan. The assemblies will be scanned from first to last, 
            and the last match for each <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> name wins.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.ScanForDocValuesFormats(System.Reflection.Assembly)">
            <summary>
            Scans the given <paramref name="assembly"/> for subclasses of <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>
            and adds their names to the <see cref="F:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.docValuesFormatNameToTypeMap"/>. Note that names will be
            automatically overridden if the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> name appears multiple times - the last match wins.
            </summary>
            <param name="assembly">The assembly to scan.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.PutDocValuesFormatType(System.Type)">
            <summary>
            Adds a <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> type to the <see cref="F:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.docValuesFormatNameToTypeMap"/>, using 
            the name provided in the <see cref="T:Lucene.Net.Codecs.DocValuesFormatNameAttribute"/>, if present, or the name
            of the codec class minus the "DocValuesFormat" suffix as the name by default.
            <para/>
            Note that if a <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> with the same name already exists in the map,
            calling this method will update it to the new type.
            </summary>
            <param name="docValuesFormat">A type that subclasses <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormat(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormat(System.Type)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance from the provided <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.NewDocValuesFormat(System.Type)">
            <summary>
            Instantiates a <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> based on the provided <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> to instantiate.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormatType(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> <see cref="T:System.Type"/> from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> <see cref="T:System.Type"/> to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="P:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.AvailableServices">
            <summary>
            Gets a list of the available <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>s (by name).
            </summary>
            <returns>A <see cref="T:ICollection{string}"/> of <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> names.</returns>
        </member>
        <member name="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory">
            <summary>
            LUCENENET specific class that implements the default functionality for the 
            <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/>.
            <para/>
            The most common use cases are:
            <list type="bullet">
                <item><description>Initialize <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/> with a set of <see cref="P:Lucene.Net.Codecs.DefaultPostingsFormatFactory.CustomPostingsFormatTypes"/>.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/> and override
                    <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormat(System.Type)"/> so an external dependency injection
                    container can be used to supply the instances (lifetime should be singleton). Note that you could 
                    alternately use the "named type" feature that many DI containers have to supply the type based on name by 
                    overriding <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormat(System.String)"/>.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/> and override
                    <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormatType(System.String)"/> so a type new type can be
                    supplied that is not in the <see cref="F:Lucene.Net.Codecs.DefaultPostingsFormatFactory.postingsFormatNameToTypeMap"/>.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/> to add new or override the default <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> 
                    types by overriding <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.Initialize"/> and calling <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.PutPostingsFormatType(System.Type)"/>.</description></item>
                <item><description>Subclass <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/> to scan additional assemblies for <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>
                    subclasses in by overriding <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.Initialize"/> and calling <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.ScanForPostingsFormats(System.Reflection.Assembly)"/>. 
                    For performance reasons, the default behavior only loads Lucene.Net codecs.</description></item>
            </list>
            <para/>
            To set the <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/>, call <see cref="M:Lucene.Net.Codecs.PostingsFormat.SetPostingsFormatFactory(Lucene.Net.Codecs.IPostingsFormatFactory)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.#ctor">
            <summary>
            Creates a new instance of <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.DefaultPostingsFormatFactory.CustomPostingsFormatTypes">
            <summary>
            An array of custom <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>-derived types to be registered. This property
            can be initialized during construction of <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/>
            to make your custom codecs known to Lucene.
            <para/>
            These types will be registered after the default Lucene types, so if a custom type has the same
            name as a Lucene <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> (via <see cref="T:Lucene.Net.Codecs.PostingsFormatNameAttribute"/>) 
            the custom type will replace the Lucene type with the same name.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.Initialize">
            <summary>
            Initializes the codec type cache with the known <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> types.
            Override this method (and optionally call <c>base.Initialize()</c>) to add your
            own <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> types by calling <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.PutPostingsFormatType(System.Type)"/> 
            or <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.ScanForPostingsFormats(System.Reflection.Assembly)"/>.
            <para/>
            If two types have the same name by using the <see cref="T:Lucene.Net.Codecs.PostingsFormatNameAttribute"/>, the
            last one registered wins.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.ScanForPostingsFormats(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Scans the given <paramref name="assemblies"/> for subclasses of <see cref="T:Lucene.Net.Codecs.Codec"/>
            and adds their names to the <see cref="F:Lucene.Net.Codecs.DefaultPostingsFormatFactory.postingsFormatNameToTypeMap"/>. Note that names will be
            automatically overridden if the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> name appears multiple times - the last match wins.
            </summary>
            <param name="assemblies">A list of assemblies to scan. The assemblies will be scanned from first to last, 
            and the last match for each <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> name wins.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.ScanForPostingsFormats(System.Reflection.Assembly)">
            <summary>
            Scans the given <paramref name="assembly"/> for subclasses of <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>
            and adds their names to the <see cref="F:Lucene.Net.Codecs.DefaultPostingsFormatFactory.postingsFormatNameToTypeMap"/>. Note that names will be
            automatically overridden if the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> name appears multiple times - the last match wins.
            </summary>
            <param name="assembly">The assembly to scan.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.PutPostingsFormatType(System.Type)">
            <summary>
            Adds a <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> type to the <see cref="F:Lucene.Net.Codecs.DefaultPostingsFormatFactory.postingsFormatNameToTypeMap"/>, using 
            the name provided in the <see cref="T:Lucene.Net.Codecs.PostingsFormatNameAttribute"/>, if present, or the name
            of the codec class minus the "Codec" suffix as the name by default.
            <para/>
            Note that if a <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> with the same name already exists in the map,
            calling this method will update it to the new type.
            </summary>
            <param name="postingsFormat">A type that subclasses <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormat(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormat(System.Type)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance from the provided <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.NewPostingsFormat(System.Type)">
            <summary>
            Instantiates a <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> based on the provided <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> to instantiate.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormatType(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> <see cref="T:System.Type"/> from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> <see cref="T:System.Type"/> to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="P:Lucene.Net.Codecs.DefaultPostingsFormatFactory.AvailableServices">
            <summary>
            Gets a list of the available <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>s (by name).
            </summary>
            <returns>A <see cref="T:ICollection{string}"/> of <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> names.</returns>
        </member>
        <member name="T:Lucene.Net.Codecs.DocValuesFormatNameAttribute">
            <summary>
            Represents an attribute that is used to name a <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>, if a name
            other than the default <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> naming convention is desired.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.ExcludeCodecFromScanAttribute">
            <summary>
            When placed on a class that subclasses <see cref="T:Lucene.Net.Codecs.Codec"/>, adding this
            attribute will exclude the type from consideration in the 
            <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.ScanForCodecs(System.Reflection.Assembly)"/> method.
            <para/>
            However, the <see cref="T:Lucene.Net.Codecs.Codec"/> type can still be added manually using
            <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.PutCodecType(System.Type)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.ExcludeDocValuesFormatFromScanAttribute">
            <summary>
            When placed on a class that subclasses <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>, adding this
            attribute will exclude the type from consideration in the 
            <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.ScanForDocValuesFormats(System.Reflection.Assembly)"/> method.
            <para/>
            However, the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> type can still be added manually using
            <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.PutDocValuesFormatType(System.Type)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.ExcludePostingsFormatFromScanAttribute">
            <summary>
            When placed on a class that subclasses <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>, adding this
            attribute will exclude the type from consideration in the 
            <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.ScanForPostingsFormats(System.Reflection.Assembly)"/> method.
            <para/>
            However, the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> type can still be added manually using
            <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.PutPostingsFormatType(System.Type)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.ICodecFactory">
            <summary>
            LUCENENET specific contract for extending the functionality of <see cref="T:Lucene.Net.Codecs.Codec"/> implementations so
            they can be injected with dependencies.
            <para/>
            To set the <see cref="T:Lucene.Net.Codecs.ICodecFactory"/>, call <see cref="M:Lucene.Net.Codecs.Codec.SetCodecFactory(Lucene.Net.Codecs.ICodecFactory)"/>.
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/>
        </member>
        <member name="M:Lucene.Net.Codecs.ICodecFactory.GetCodec(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.Codec"/> instance from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.Codec"/> instance to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.Codec"/> instance.</returns>
        </member>
        <member name="T:Lucene.Net.Codecs.IDocValuesFormatFactory">
            <summary>
            LUCENENET specific contract for extending the functionality of <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> implementations so
            they can be injected with dependencies.
            <para/>
            To set the <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>, call <see cref="M:Lucene.Net.Codecs.DocValuesFormat.SetDocValuesFormatFactory(Lucene.Net.Codecs.IDocValuesFormatFactory)"/>.
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/>
        </member>
        <member name="M:Lucene.Net.Codecs.IDocValuesFormatFactory.GetDocValuesFormat(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance.</returns>
        </member>
        <member name="T:Lucene.Net.Codecs.IPostingsFormatFactory">
            <summary>
            LUCENENET specific contract for extending the functionality of <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> implementations so
            they can be injected with dependencies.
            <para/>
            To set the <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/>, call <see cref="M:Lucene.Net.Codecs.PostingsFormat.SetPostingsFormatFactory(Lucene.Net.Codecs.IPostingsFormatFactory)"/>.
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/>
        </member>
        <member name="M:Lucene.Net.Codecs.IPostingsFormatFactory.GetPostingsFormat(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance.</returns>
        </member>
        <member name="T:Lucene.Net.Codecs.PostingsFormatNameAttribute">
            <summary>
            Represents an attribute that is used to name a <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>, if a name
            other than the default <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> naming convention is desired.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.BinaryDocValuesField">
             <summary>
             Field that stores a per-document <see cref="T:Lucene.Net.Util.BytesRef"/> value.
             <para/>
             The values are stored directly with no sharing, which is a good fit when
             the fields don't share (many) values, such as a title field.  If values
             may be shared and sorted it's better to use <see cref="T:Lucene.Net.Documents.SortedDocValuesField"/>.
             Here's an example usage:
            
             <code>
               document.Add(new BinaryDocValuesField(name, new BytesRef("hello")));
             </code>
             <para/>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </summary>
             <seealso cref="T:Lucene.Net.Index.BinaryDocValues"/>
        </member>
        <member name="F:Lucene.Net.Documents.BinaryDocValuesField.fType">
            <summary>
            Type for straight bytes <see cref="T:Lucene.Net.Index.DocValues"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.BinaryDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new binary <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="value"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is null </exception>
        </member>
        <member name="T:Lucene.Net.Documents.ByteDocValuesField">
             <summary>
             Field that stores a per-document <see cref="T:System.Byte"/> value for scoring,
             sorting or value retrieval. Here's an example usage:
            
             <code>
               document.Add(new ByteDocValuesField(name, (byte) 22));
             </code>
             
             <para/>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </summary>
             <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>
        </member>
        <member name="M:Lucene.Net.Documents.ByteDocValuesField.#ctor(System.String,System.Byte)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.DocValues"/> field with the specified 8-bit byte value </summary>
            <param name="name"> field name </param>
            <param name="value"> 8-bit byte value </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is null. </exception>
        </member>
        <member name="T:Lucene.Net.Documents.CompressionTools">
            <summary>
            Simple utility class providing static methods to
            compress and decompress binary data for stored fields.
            this class uses the <see cref="T:System.IO.Compression.DeflateStream"/>
            class to compress and decompress.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Compress(System.Byte[],System.Int32,System.Int32,System.IO.Compression.CompressionLevel)">
            <summary>
            Compresses the specified <see cref="T:System.Byte"/> range using the
            specified <paramref name="compressionLevel"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Compress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compresses the specified <see cref="T:System.Byte"/> range, with default <see cref="F:System.IO.Compression.CompressionLevel.Optimal"/> level 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Compress(System.Byte[])">
            <summary>
            Compresses all <see cref="T:System.Byte"/>s in the array, with default <see cref="F:System.IO.Compression.CompressionLevel.Optimal"/> level </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.CompressString(System.String)">
            <summary>
            Compresses the <see cref="T:System.String"/> value, with default <see cref="F:System.IO.Compression.CompressionLevel.Optimal"/> level </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.CompressString(System.String,System.IO.Compression.CompressionLevel)">
            <summary>
            Compresses the <see cref="T:System.String"/> value using the specified
            <paramref name="compressionLevel"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Decompress(Lucene.Net.Util.BytesRef)">
            <summary>
            Decompress the <see cref="T:System.Byte"/> array previously returned by
            compress (referenced by the provided <see cref="T:Lucene.Net.Util.BytesRef"/>)
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Decompress(System.Byte[])">
            <summary>
            Decompress the <see cref="T:System.Byte"/> array previously returned by
            compress
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Decompress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompress the <see cref="T:System.Byte"/> array previously returned by
            compress
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.DecompressString(System.Byte[])">
            <summary>
            Decompress the <see cref="T:System.Byte"/> array previously returned by
            <see cref="M:Lucene.Net.Documents.CompressionTools.CompressString(System.String)"/> back into a <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.DecompressString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompress the <see cref="T:System.Byte"/> array previously returned by
            <see cref="M:Lucene.Net.Documents.CompressionTools.CompressString(System.String)"/> back into a <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.DecompressString(Lucene.Net.Util.BytesRef)">
            <summary>
            Decompress the <see cref="T:System.Byte"/> array (referenced by the provided <see cref="T:Lucene.Net.Util.BytesRef"/>)
            previously returned by <see cref="M:Lucene.Net.Documents.CompressionTools.CompressString(System.String)"/> back into a <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.DateTools">
             <summary>
             Provides support for converting dates to strings and vice-versa.
             The strings are structured so that lexicographic sorting orders
             them by date, which makes them suitable for use as field values
             and search terms.
            
             <para/>This class also helps you to limit the resolution of your dates. Do not
             save dates with a finer resolution than you really need, as then
             <see cref="T:Lucene.Net.Search.TermRangeQuery"/> and <see cref="T:Lucene.Net.Search.PrefixQuery"/> will require more memory and become slower.
            
             <para/>
             Another approach is <see cref="T:Lucene.Net.Util.NumericUtils"/>, which provides
             a sortable binary representation (prefix encoded) of numeric values, which
             date/time are.
             
             For indexing a <see cref="T:System.DateTime"/>, just get the <see cref="P:System.DateTime.Ticks"/> and index
             this as a numeric value with <see cref="T:Lucene.Net.Documents.Int64Field"/> and use <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>
             to query it.
             </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.DateToString(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> to a string suitable for indexing.
            </summary>
            <param name="date"> the date to be converted </param>
            <param name="resolution"> the desired resolution, see
            <see cref="M:Lucene.Net.Documents.DateTools.Round(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)"/> </param>
            <returns> a string in format <c>yyyyMMddHHmmssSSS</c> or shorter,
            depending on <paramref name="resolution"/>; using GMT as timezone  </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.TimeToString(System.Int64,Lucene.Net.Documents.DateTools.Resolution)">
            <summary>
            Converts a millisecond time to a string suitable for indexing.
            </summary>
            <param name="time"> the date expressed as milliseconds since January 1, 1970, 00:00:00 GMT (also known as the "epoch") </param>
            <param name="resolution"> the desired resolution, see
            <see cref="M:Lucene.Net.Documents.DateTools.Round(System.Int64,Lucene.Net.Documents.DateTools.Resolution)"/> </param>
            <returns> a string in format <c>yyyyMMddHHmmssSSS</c> or shorter,
            depending on <paramref name="resolution"/>; using GMT as timezone </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.StringToTime(System.String)">
            <summary>
            Converts a string produced by <see cref="M:Lucene.Net.Documents.DateTools.TimeToString(System.Int64,Lucene.Net.Documents.DateTools.Resolution)"/> or
            <see cref="M:Lucene.Net.Documents.DateTools.DateToString(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)"/> back to a time, represented as the
            number of milliseconds since January 1, 1970, 00:00:00 GMT (also known as the "epoch").
            </summary>
            <param name="dateString"> the date string to be converted </param>
            <returns> the number of milliseconds since January 1, 1970, 00:00:00 GMT (also known as the "epoch")</returns>
            <exception cref="T:System.FormatException"> if <paramref name="dateString"/> is not in the
            expected format </exception>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.StringToDate(System.String)">
            <summary>
            Converts a string produced by <see cref="M:Lucene.Net.Documents.DateTools.TimeToString(System.Int64,Lucene.Net.Documents.DateTools.Resolution)"/> or
            <see cref="M:Lucene.Net.Documents.DateTools.DateToString(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)"/> back to a time, represented as a
            <see cref="T:System.DateTime"/> object.
            </summary>
            <param name="dateString"> the date string to be converted </param>
            <returns> the parsed time as a <see cref="T:System.DateTime"/> object </returns>
            <exception cref="T:System.FormatException"> if <paramref name="dateString"/> is not in the
            expected format </exception>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.Round(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)">
            <summary>
            Limit a date's resolution. For example, the date <c>2004-09-21 13:50:11</c>
            will be changed to <c>2004-09-01 00:00:00</c> when using
            <see cref="F:Lucene.Net.Documents.DateTools.Resolution.MONTH"/>.
            </summary>
            <param name="date"> the date to be rounded </param>
            <param name="resolution"> The desired resolution of the date to be returned </param>
            <returns> the date with all values more precise than <paramref name="resolution"/>
            set to 0 or 1 </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.Round(System.Int64,Lucene.Net.Documents.DateTools.Resolution)">
            <summary>
            Limit a date's resolution. For example, the date <c>1095767411000</c>
            (which represents 2004-09-21 13:50:11) will be changed to
            <c>1093989600000</c> (2004-09-01 00:00:00) when using
            <see cref="F:Lucene.Net.Documents.DateTools.Resolution.MONTH"/>.
            </summary>
            <param name="time"> the time to be rounded </param>
            <param name="resolution"> The desired resolution of the date to be returned </param>
            <returns> the date with all values more precise than <paramref name="resolution"/>
            set to 0 or 1, expressed as milliseconds since January 1, 1970, 00:00:00 GMT 
            (also known as the "epoch")</returns>
        </member>
        <member name="T:Lucene.Net.Documents.DateTools.Resolution">
            <summary>
            Specifies the time granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.YEAR">
            <summary>
            Limit a date's resolution to year granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.MONTH">
            <summary>
            Limit a date's resolution to month granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.DAY">
            <summary>
            Limit a date's resolution to day granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.HOUR">
            <summary>
            Limit a date's resolution to hour granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.MINUTE">
            <summary>
            Limit a date's resolution to minute granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.SECOND">
            <summary>
            Limit a date's resolution to second granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.MILLISECOND">
            <summary>
            Limit a date's resolution to millisecond granularity. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.DerefBytesDocValuesField">
             <summary>
             Field that stores
             a per-document <see cref="T:Lucene.Net.Util.BytesRef"/> value. Here's an example usage:
            
             <code>
               document.Add(new DerefBytesDocValuesField(name, new BytesRef("hello")));
             </code>
            
             <para/>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </summary>
             <seealso cref="T:Lucene.Net.Index.BinaryDocValues"/>
        </member>
        <member name="F:Lucene.Net.Documents.DerefBytesDocValuesField.TYPE_FIXED_LEN">
            <summary>
            Type for bytes <see cref="T:Lucene.Net.Index.DocValues"/>: all with the same length
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DerefBytesDocValuesField.TYPE_VAR_LEN">
            <summary>
            Type for bytes <see cref="T:Lucene.Net.Index.DocValues"/>: can have variable lengths
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DerefBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new fixed or variable-length <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is null </exception>
        </member>
        <member name="M:Lucene.Net.Documents.DerefBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef,System.Boolean)">
            <summary>
            Create a new fixed or variable length <see cref="T:Lucene.Net.Index.DocValues"/> field.
            </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <param name="isFixedLength"> (ignored) </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is null </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Document">
            <summary>
            Documents are the unit of indexing and search.
            <para/>
            A Document is a set of fields.  Each field has a name and a textual value.
            A field may be stored (<see cref="P:Lucene.Net.Index.IIndexableFieldType.IsStored"/>) with the document, in which
            case it is returned with search hits on the document.  Thus each document
            should typically contain one or more stored fields which uniquely identify
            it.
            <para/>
            Note that fields which are <i>not</i> <see cref="P:Lucene.Net.Index.IIndexableFieldType.IsStored"/> are
            <i>not</i> available in documents retrieved from the index, e.g. with 
            <see cref="P:Lucene.Net.Search.ScoreDoc.Doc"/> or <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.#ctor">
            <summary>
            Constructs a new document with no fields. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Add(Lucene.Net.Index.IIndexableField)">
            <summary>
            <para>Adds a field to a document.  Several fields may be added with
            the same name.  In this case, if the fields are indexed, their text is
            treated as though appended for the purposes of search.</para>
            <para> Note that add like the <see cref="M:Lucene.Net.Documents.Document.RemoveField(System.String)"/> and <see cref="M:Lucene.Net.Documents.Document.RemoveFields(System.String)"/> methods only makes sense
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveField(System.String)">
            <summary>
            <para>Removes field with the specified name from the document.
            If multiple fields exist with this name, this method removes the first field that has been added.
            If there is no field with the specified name, the document remains unchanged.</para>
            <para> Note that the <see cref="M:Lucene.Net.Documents.Document.RemoveField(System.String)"/> and <see cref="M:Lucene.Net.Documents.Document.RemoveFields(System.String)"/> methods like the add method only make sense
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveFields(System.String)">
            <summary>
            <para>Removes all fields with the given name from the document.
            If there is no field with the specified name, the document remains unchanged.</para>
            <para> Note that the <see cref="M:Lucene.Net.Documents.Document.RemoveField(System.String)"/> and <see cref="M:Lucene.Net.Documents.Document.RemoveFields(System.String)"/> methods like the add method only make sense
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetBinaryValues(System.String)">
            <summary>
            Returns an array of byte arrays for of the fields that have the name specified
            as the method parameter. This method returns an empty
            array when there are no matching fields.  It never
            returns <c>null</c>.
            </summary>
            <param name="name"> the name of the field </param>
            <returns> a <see cref="T:BytesRef[]"/> of binary field values </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetBinaryValue(System.String)">
            <summary>
            Returns an array of bytes for the first (or only) field that has the name
            specified as the method parameter. this method will return <c>null</c>
            if no binary fields with the specified name are available.
            There may be non-binary fields with the same name.
            </summary>
            <param name="name"> the name of the field. </param>
            <returns> a <see cref="T:Lucene.Net.Util.BytesRef"/> containing the binary field value or <c>null</c> </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetField(System.String)">
            <summary>
            Returns a field with the given name if any exist in this document, or
            <c>null</c>. If multiple fields exists with this name, this method returns the
            first value added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetFields(System.String)">
            <summary>
            Returns an array of <see cref="T:Lucene.Net.Index.IIndexableField"/>s with the given name.
            This method returns an empty array when there are no
            matching fields. It never returns <c>null</c>.
            </summary>
            <param name="name"> the name of the field </param>
            <returns> a <see cref="T:IndexableField[]"/> array </returns>
        </member>
        <member name="P:Lucene.Net.Documents.Document.Fields">
            <summary>
            Returns a List of all the fields in a document.
            <para>Note that fields which are <i>not</i> stored are
            <i>not</i> available in documents retrieved from the
            index, e.g. <see cref="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)"/> or 
            <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/>.
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetValues(System.String)">
            <summary>
            Returns an array of values of the field specified as the method parameter.
            This method returns an empty array when there are no
            matching fields. It never returns <c>null</c>.
            For <see cref="T:Lucene.Net.Documents.Int32Field"/>, <see cref="T:Lucene.Net.Documents.Int64Field"/>, 
            <see cref="T:Lucene.Net.Documents.SingleField"/> and <seealso cref="T:Lucene.Net.Documents.DoubleField"/> it returns the string value of the number. If you want
            the actual numeric field instances back, use <see cref="M:Lucene.Net.Documents.Document.GetFields(System.String)"/>. </summary>
            <param name="name"> the name of the field </param>
            <returns> a <see cref="T:string[]"/> of field values </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Get(System.String)">
            <summary>
            Returns the string value of the field with the given name if any exist in
            this document, or <c>null</c>.  If multiple fields exist with this name, this
            method returns the first value added. If only binary fields with this name
            exist, returns <c>null</c>.
            For <see cref="T:Lucene.Net.Documents.Int32Field"/>, <see cref="T:Lucene.Net.Documents.Int64Field"/>, 
            <see cref="T:Lucene.Net.Documents.SingleField"/> and <seealso cref="T:Lucene.Net.Documents.DoubleField"/> it returns the string value of the number. If you want
            the actual numeric field instance back, use <see cref="M:Lucene.Net.Documents.Document.GetField(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.ToString">
            <summary>
            Prints the fields of a document for human consumption. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.DocumentStoredFieldVisitor">
             <summary>
             A <see cref="T:Lucene.Net.Index.StoredFieldVisitor"/> that creates a 
             <see cref="P:Lucene.Net.Documents.DocumentStoredFieldVisitor.Document"/> containing all stored fields, or only specific
             requested fields provided to <see cref="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor(System.Collections.Generic.ISet{System.String})"/>.
             <para/>
             This is used by <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/> to load a
             document.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor(System.Collections.Generic.ISet{System.String})">
            <summary>
            Load only fields named in the provided <see cref="T:System.Collections.Generic.ISet`1"/>. </summary>
            <param name="fieldsToAdd"> Set of fields to load, or <c>null</c> (all fields). </param>
        </member>
        <member name="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor(System.String[])">
            <summary>
            Load only fields named in the provided fields. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor">
            <summary>
            Load all stored fields. </summary>
        </member>
        <member name="P:Lucene.Net.Documents.DocumentStoredFieldVisitor.Document">
            <summary>
            Retrieve the visited document. </summary>
            <returns> Document populated with stored fields. Note that only
                    the stored information in the field instances is valid,
                    data such as boosts, indexing options, term vector options,
                    etc is not set. </returns>
        </member>
        <member name="T:Lucene.Net.Documents.DoubleDocValuesField">
            <summary>
            Syntactic sugar for encoding doubles as <see cref="T:Lucene.Net.Index.NumericDocValues"/>
            via <see cref="M:J2N.BitConversion.DoubleToRawInt64Bits(System.Double)"/>.
            <para/>
            Per-document double values can be retrieved via
            <see cref="M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)"/>.
            <para/>
            <b>NOTE</b>: In most all cases this will be rather inefficient,
            requiring eight bytes per document. Consider encoding double
            values yourself with only as much precision as you require.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DoubleDocValuesField.#ctor(System.String,System.Double)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.DocValues"/> field with the specified 64-bit double value </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit double value </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.DoubleField">
             <summary>
             <para>
             Field that indexes <see cref="T:System.Double"/> values
             for efficient range filtering and sorting. Here's an example usage:
            
             <code>
             document.Add(new DoubleField(name, 6.0, Field.Store.NO));
             </code>
            
             For optimal performance, re-use the <see cref="T:Lucene.Net.Documents.DoubleField"/> and
             <see cref="T:Lucene.Net.Documents.Document"/> instance for more than one document:
            
             <code>
                 DoubleField field = new DoubleField(name, 0.0, Field.Store.NO);
                 Document document = new Document();
                 document.Add(field);
            
                 for (all documents)
                 {
                     ...
                     field.SetDoubleValue(value)
                     writer.AddDocument(document);
                     ...
                 }
             </code>
            
             See also <seealso cref="T:Lucene.Net.Documents.Int32Field"/>, <seealso cref="T:Lucene.Net.Documents.Int64Field"/>, 
             <see cref="T:Lucene.Net.Documents.SingleField"/>.</para>
            
             <para>To perform range querying or filtering against a
             <see cref="T:Lucene.Net.Documents.DoubleField"/>, use <see cref="T:Lucene.Net.Search.NumericRangeQuery"/> or 
             <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.  To sort according to a
             <see cref="T:Lucene.Net.Documents.DoubleField"/>, use the normal numeric sort types, eg
             <see cref="F:Lucene.Net.Search.SortFieldType.DOUBLE"/>. <see cref="T:Lucene.Net.Documents.DoubleField"/>
             values can also be loaded directly from <see cref="T:Lucene.Net.Search.IFieldCache"/>.</para>
            
             <para>You may add the same field name as an <see cref="T:Lucene.Net.Documents.DoubleField"/> to
             the same document more than once.  Range querying and
             filtering will be the logical OR of all values; so a range query
             will hit all documents that have at least one value in
             the range. However sort behavior is not defined.  If you need to sort,
             you should separately index a single-valued <see cref="T:Lucene.Net.Documents.DoubleField"/>.</para>
            
             <para>A <see cref="T:Lucene.Net.Documents.DoubleField"/> will consume somewhat more disk space
             in the index than an ordinary single-valued field.
             However, for a typical index that includes substantial
             textual content per document, this increase will likely
             be in the noise. </para>
            
             <para>Within Lucene, each numeric value is indexed as a
             <em>trie</em> structure, where each term is logically
             assigned to larger and larger pre-defined brackets (which
             are simply lower-precision representations of the value).
             The step size between each successive bracket is called the
             <c>precisionStep</c>, measured in bits.  Smaller
             <c>precisionStep</c> values result in larger number
             of brackets, which consumes more disk space in the index
             but may result in faster range search performance.  The
             default value, 4, was selected for a reasonable tradeoff
             of disk space consumption versus performance.  You can
             create a custom <see cref="T:Lucene.Net.Documents.FieldType"/> and invoke the
             <see cref="P:Lucene.Net.Documents.FieldType.NumericPrecisionStep"/> setter if you'd
             like to change the value.  Note that you must also
             specify a congruent value when creating 
             <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> or <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.
             For low cardinality fields larger precision steps are good.
             If the cardinality is &lt; 100, it is fair
             to use <see cref="F:System.Int32.MaxValue"/>, which produces one
             term per value.</para>
            
             <para>For more information on the internals of numeric trie
             indexing, including the <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/> (<a
             href="../search/NumericRangeQuery.html#precisionStepDesc"><c>precisionStep</c></a>)
             configuration, see <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>. The format of
             indexed values is described in <see cref="T:Lucene.Net.Util.NumericUtils"/>.</para>
            
             <para>If you only need to sort by numeric value, and never
             run range querying/filtering, you can index using a
             <c>precisionStep</c> of <see cref="F:System.Int32.MaxValue"/>.
             this will minimize disk space consumed. </para>
            
             <para>More advanced users can instead use 
             <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/> directly, when indexing numbers. This
             class is a wrapper around this token stream type for
             easier, more intuitive usage.</para>
            
             @since 2.9
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DoubleField.TYPE_NOT_STORED">
            <summary>
            Type for a <see cref="T:Lucene.Net.Documents.DoubleField"/> that is not stored:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DoubleField.TYPE_STORED">
            <summary>
            Type for a stored <see cref="T:Lucene.Net.Documents.DoubleField"/>:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DoubleField.#ctor(System.String,System.Double,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a stored or un-stored <see cref="T:Lucene.Net.Documents.DoubleField"/> with the provided value
            and default <c>precisionStep</c> 
            <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4).
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Double"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is <c>null</c>.  </exception>
        </member>
        <member name="M:Lucene.Net.Documents.DoubleField.#ctor(System.String,System.Double,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: allows you to customize the <see cref="T:Lucene.Net.Documents.FieldType"/>. 
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit double value </param>
            <param name="type"> customized field type: must have <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/>
                    of <see cref="F:Lucene.Net.Documents.NumericType.DOUBLE"/>. </param>
            <exception cref="T:System.ArgumentNullException"> if the field name or type is <c>null</c>, or
                     if the field type does not have a <see cref="F:Lucene.Net.Documents.NumericType.DOUBLE"/> <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Field">
             <summary>
             Expert: directly create a field for a document.  Most
             users should use one of the sugar subclasses: <see cref="T:Lucene.Net.Documents.Int32Field"/>, 
             <see cref="T:Lucene.Net.Documents.Int64Field"/>, <see cref="T:Lucene.Net.Documents.SingleField"/>, <see cref="T:Lucene.Net.Documents.DoubleField"/>, 
             <see cref="T:Lucene.Net.Documents.BinaryDocValuesField"/>, <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/>,
             <see cref="T:Lucene.Net.Documents.SortedDocValuesField"/>, <see cref="T:Lucene.Net.Documents.StringField"/>,
             <see cref="T:Lucene.Net.Documents.TextField"/>, <see cref="T:Lucene.Net.Documents.StoredField"/>.
            
             <para/> A field is a section of a <see cref="T:Lucene.Net.Documents.Document"/>. Each field has three
             parts: name, type and value. Values may be text
             (<see cref="T:System.String"/>, <see cref="T:System.IO.TextReader"/> or pre-analyzed <see cref="T:Lucene.Net.Analysis.TokenStream"/>), binary
             (<see cref="T:byte[]"/>), or numeric (<see cref="T:System.Int32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.Single"/>, or <see cref="T:System.Double"/>). 
             Fields are optionally stored in the
             index, so that they may be returned with hits on the document.
            
             <para/>
             NOTE: the field type is an <see cref="T:Lucene.Net.Index.IIndexableFieldType"/>.  Making changes
             to the state of the <see cref="T:Lucene.Net.Index.IIndexableFieldType"/> will impact any
             Field it is used in.  It is strongly recommended that no
             changes be made after <see cref="T:Lucene.Net.Documents.Field"/> instantiation.
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.m_type">
            <summary>
            Field's type
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.m_name">
            <summary>
            Field's name
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.fieldsData">
            <summary>
            Field's value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.FieldsData">
            <summary>
            Field's value 
            <para/>
            Setting this property will automatically set the backing field for the
            <see cref="P:Lucene.Net.Documents.Field.NumericType"/> property.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.numericType">
            <summary>
            Field's numeric data type (or <see cref="F:Lucene.Net.Documents.NumericFieldType.NONE"/> if field non-numeric).
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.m_tokenStream">
            <summary>
            Pre-analyzed <see cref="T:Lucene.Net.Analysis.TokenStream"/> for indexed fields; this is
            separate from <see cref="P:Lucene.Net.Documents.Field.FieldsData"/> because you are allowed to
            have both; eg maybe field has a <see cref="T:System.String"/> value but you
            customize how it's tokenized
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.m_boost">
            <summary>
            Field's boost </summary>
            <seealso cref="P:Lucene.Net.Documents.Field.Boost"/>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: creates a field with no initial value.
            Intended only for custom <see cref="T:Lucene.Net.Documents.Field"/> subclasses.
            </summary>
            <param name="name"> field name </param>
            <param name="type"> field type </param>
            <exception cref="T:System.ArgumentNullException"> if either the <paramref name="name"/> or <paramref name="type"/>
                    is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader,Lucene.Net.Documents.FieldType)">
            <summary>
            Create field with <see cref="T:System.IO.TextReader"/> value. </summary>
            <param name="name"> field name </param>
            <param name="reader"> reader value </param>
            <param name="type"> field type </param>
            <exception cref="T:System.ArgumentException"> if <see cref="P:Lucene.Net.Documents.FieldType.IsStored"/> is true, or
                    if <see cref="P:Lucene.Net.Documents.FieldType.IsTokenized"/> is false. </exception>
            <exception cref="T:System.ArgumentNullException"> if either the <paramref name="name"/> or <paramref name="type"/>
                    is <c>null</c>, or if the reader is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Analysis.TokenStream,Lucene.Net.Documents.FieldType)">
            <summary>
            Create field with <see cref="T:Lucene.Net.Analysis.TokenStream"/> value. </summary>
            <param name="name"> field name </param>
            <param name="tokenStream"> TokenStream value </param>
            <param name="type"> field type </param>
            <exception cref="T:System.ArgumentException"> if <see cref="P:Lucene.Net.Documents.FieldType.IsStored"/> is true, or
                    if <see cref="P:Lucene.Net.Documents.FieldType.IsTokenized"/> is false, or if <see cref="P:Lucene.Net.Documents.FieldType.IsIndexed"/> is false. </exception>
            <exception cref="T:System.ArgumentNullException"> if either the <paramref name="name"/> or <paramref name="type"/>
                    is <c>null</c>, or if the <paramref name="tokenStream"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[],Lucene.Net.Documents.FieldType)">
             <summary>
             Create field with binary value.
            
             <para/>NOTE: the provided <see cref="T:byte[]"/> is not copied so be sure
             not to change it until you're done with this field.
             </summary>
             <param name="name"> field name </param>
             <param name="value"> byte array pointing to binary content (not copied) </param>
             <param name="type"> field type </param>
             <exception cref="T:System.ArgumentException"> if the <see cref="P:Lucene.Net.Documents.FieldType.IsIndexed"/> is true </exception>
             <exception cref="T:System.ArgumentNullException"> the field <paramref name="name"/> is <c>null</c>,
                     or if the <paramref name="type"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[],System.Int32,System.Int32,Lucene.Net.Documents.FieldType)">
             <summary>
             Create field with binary value.
            
             <para/>NOTE: the provided <see cref="T:byte[]"/> is not copied so be sure
             not to change it until you're done with this field.
             </summary>
             <param name="name"> field name </param>
             <param name="value"> byte array pointing to binary content (not copied) </param>
             <param name="offset"> starting position of the byte array </param>
             <param name="length"> valid length of the byte array </param>
             <param name="type"> field type </param>
             <exception cref="T:System.ArgumentException"> if the <see cref="P:Lucene.Net.Documents.FieldType.IsIndexed"/> is true </exception>
             <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>,
                     or the <paramref name="type"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Documents.FieldType)">
             <summary>
             Create field with binary value.
            
             <para/>NOTE: the provided BytesRef is not copied so be sure
             not to change it until you're done with this field.
             </summary>
             <param name="name"> field name </param>
             <param name="bytes"> BytesRef pointing to binary content (not copied) </param>
             <param name="type"> field type </param>
             <exception cref="T:System.ArgumentException"> if the <see cref="P:Lucene.Net.Documents.FieldType.IsIndexed"/> is true </exception>
             <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>,
                     or the <paramref name="type"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.FieldType)">
            <summary>
            Create field with <see cref="T:System.String"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> string value </param>
            <param name="type"> field type </param>
            <exception cref="T:System.ArgumentException"> if the field's type is neither indexed() nor stored(),
                    or if indexed() is false but storeTermVectors() is true. </exception>
            <exception cref="T:System.ArgumentNullException"> if either the <paramref name="name"/> or <paramref name="value"/>
                    is <c>null</c>, or if the <paramref name="type"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetStringValue">
            <summary>
            The value of the field as a <see cref="T:System.String"/>, or <c>null</c>. If <c>null</c>, the <see cref="T:System.IO.TextReader"/> value or
            binary value is used. Exactly one of <see cref="M:Lucene.Net.Documents.Field.GetStringValue"/>, <see cref="M:Lucene.Net.Documents.Field.GetReaderValue"/>, and
            <see cref="M:Lucene.Net.Documents.Field.GetBinaryValue"/> must be set.
            </summary>
            <returns>The string representation of the value if it is either a <see cref="T:System.String"/> or numeric type.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetStringValue(System.IFormatProvider)">
            <summary>
            The value of the field as a <see cref="T:System.String"/>, or <c>null</c>. If <c>null</c>, the <see cref="T:System.IO.TextReader"/> value or
            binary value is used. Exactly one of <see cref="M:Lucene.Net.Documents.Field.GetStringValue"/>, <see cref="M:Lucene.Net.Documents.Field.GetReaderValue"/>, and
            <see cref="M:Lucene.Net.Documents.Field.GetBinaryValue"/> must be set.
            </summary>
            <param name="provider">An object that supplies culture-specific formatting information. This parameter has no effect if this field is non-numeric.</param>
            <returns>The string representation of the value if it is either a <see cref="T:System.String"/> or numeric type.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetStringValue(System.String)">
            <summary>
            The value of the field as a <see cref="T:System.String"/>, or <c>null</c>. If <c>null</c>, the <see cref="T:System.IO.TextReader"/> value or
            binary value is used. Exactly one of <see cref="M:Lucene.Net.Documents.Field.GetStringValue"/>, <see cref="M:Lucene.Net.Documents.Field.GetReaderValue"/>, and
            <see cref="M:Lucene.Net.Documents.Field.GetBinaryValue"/> must be set.
            </summary>
            <param name="format">A standard or custom numeric format string. This parameter has no effect if this field is non-numeric.</param>
            <returns>The string representation of the value if it is either a <see cref="T:System.String"/> or numeric type.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetStringValue(System.String,System.IFormatProvider)">
            <summary>
            The value of the field as a <see cref="T:System.String"/>, or <c>null</c>. If <c>null</c>, the <see cref="T:System.IO.TextReader"/> value or
            binary value is used. Exactly one of <see cref="M:Lucene.Net.Documents.Field.GetStringValue"/>, <see cref="M:Lucene.Net.Documents.Field.GetReaderValue"/>, and
            <see cref="M:Lucene.Net.Documents.Field.GetBinaryValue"/> must be set.
            </summary>
            <param name="format">A standard or custom numeric format string. This parameter has no effect if this field is non-numeric.</param>
            <param name="provider">An object that supplies culture-specific formatting information. This parameter has no effect if this field is non-numeric.</param>
            <returns>The string representation of the value if it is either a <see cref="T:System.String"/> or numeric type.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetReaderValue">
            <summary>
            The value of the field as a <see cref="T:System.IO.TextReader"/>, or <c>null</c>. If <c>null</c>, the <see cref="T:System.String"/> value or
            binary value is used. Exactly one of <see cref="M:Lucene.Net.Documents.Field.GetStringValue"/>, <see cref="M:Lucene.Net.Documents.Field.GetReaderValue"/>, and
            <see cref="M:Lucene.Net.Documents.Field.GetBinaryValue"/> must be set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetTokenStreamValue">
            <summary>
            The <see cref="T:Lucene.Net.Analysis.TokenStream"/> for this field to be used when indexing, or <c>null</c>. If <c>null</c>,
            the <see cref="T:System.IO.TextReader"/> value or <see cref="T:System.String"/> value is analyzed to produce the indexed tokens.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetStringValue(System.String)">
             <summary>
             <para>
             Expert: change the value of this field. This can be used during indexing to
             re-use a single <see cref="T:Lucene.Net.Documents.Field"/> instance to improve indexing speed by avoiding GC
             cost of new'ing and reclaiming <see cref="T:Lucene.Net.Documents.Field"/> instances. Typically a single
             <see cref="T:Lucene.Net.Documents.Document"/> instance is re-used as well. This helps most on small
             documents.
             </para>
            
             <para>
             Each <see cref="T:Lucene.Net.Documents.Field"/> instance should only be used once within a single
             <see cref="T:Lucene.Net.Documents.Document"/> instance. See <a
             href="http://wiki.apache.org/lucene-java/ImproveIndexingSpeed"
             >ImproveIndexingSpeed</a> for details.
             </para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetReaderValue(System.IO.TextReader)">
            <summary>
            Expert: change the value of this field. See 
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetBytesValue(Lucene.Net.Util.BytesRef)">
             <summary>
             Expert: change the value of this field. See
             <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            
             <para/>NOTE: the provided <see cref="T:Lucene.Net.Util.BytesRef"/> is not copied so be sure
             not to change it until you're done with this field.
             </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetBytesValue(System.Byte[])">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetByteValue(System.Byte)">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetInt16Value(System.Int16)">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetInt32Value(System.Int32)">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetInt64Value(System.Int64)">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetSingleValue(System.Single)">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetDoubleValue(System.Double)">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetTokenStream(Lucene.Net.Analysis.TokenStream)">
            <summary>
            Expert: sets the token stream to be used for indexing and causes
            <see cref="P:Lucene.Net.Documents.FieldType.IsIndexed"/> and <see cref="P:Lucene.Net.Documents.FieldType.IsTokenized"/> to return true. May be combined with stored
            values from <see cref="M:Lucene.Net.Documents.Field.GetStringValue"/> or <see cref="M:Lucene.Net.Documents.Field.GetBinaryValue"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.Name">
            <summary>
            The field's name
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.Boost">
            <summary>
            Gets or sets the boost factor on this field.
            </summary>
            <remarks>The default value is <c>1.0f</c> (no boost).</remarks>
            <exception cref="T:System.ArgumentException"> (setter only) if this field is not indexed,
                    or if it omits norms. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.Field.NumericType">
            <summary>
            Gets the <see cref="T:Lucene.Net.Documents.NumericFieldType"/> of the underlying value, or <see cref="F:Lucene.Net.Documents.NumericFieldType.NONE"/> if the value is not set or non-numeric.
            <para/>
            Expert: The difference between this property and <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> is 
            this is represents the current state of the field (whether being written or read) and the
            <see cref="P:Lucene.Net.Documents.Field.FieldType"/> property represents instructions on how the field will be written,
            but does not re-populate when reading back from an index (it is write-only).
            <para/>
            In Java, the numeric type was determined by checking the type of  
            <see cref="M:Lucene.Net.Documents.Field.GetNumericValue"/>. However, since there are no reference number
            types in .NET, using <see cref="M:Lucene.Net.Documents.Field.GetNumericValue"/> so will cause boxing/unboxing. It is
            therefore recommended to use this property to check the underlying type and the corresponding 
            <c>Get*Value()</c> method to retrieve the value.
            <para/>
            NOTE: Since Lucene codecs do not support <see cref="F:Lucene.Net.Documents.NumericFieldType.BYTE"/> or <see cref="F:Lucene.Net.Documents.NumericFieldType.INT16"/>,
            fields created with these types will always be <see cref="F:Lucene.Net.Documents.NumericFieldType.INT32"/> when read back from the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetByteValue">
            <summary>
            Returns the field value as <see cref="T:System.Byte"/> or <c>null</c> if the type
            is non-numeric.
            </summary>
            <returns>The field value or <c>null</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetInt16Value">
            <summary>
            Returns the field value as <see cref="T:System.Int16"/> or <c>null</c> if the type
            is non-numeric.
            </summary>
            <returns>The field value or <c>null</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetInt32Value">
            <summary>
            Returns the field value as <see cref="T:System.Int32"/> or <c>null</c> if the type
            is non-numeric.
            </summary>
            <returns>The field value or <c>null</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetInt64Value">
            <summary>
            Returns the field value as <see cref="T:System.Int64"/> or <c>null</c> if the type
            is non-numeric.
            </summary>
            <returns>The field value or <c>null</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetSingleValue">
            <summary>
            Returns the field value as <see cref="T:System.Single"/> or <c>null</c> if the type
            is non-numeric.
            </summary>
            <returns>The field value or <c>null</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetDoubleValue">
            <summary>
            Returns the field value as <see cref="T:System.Double"/> or <c>null</c> if the type
            is non-numeric.
            </summary>
            <returns>The field value or <c>null</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetBinaryValue">
            <summary>
            Non-null if this field has a binary value. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.ToString">
            <summary>
            Prints a <see cref="T:Lucene.Net.Documents.Field"/> for human consumption. </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.FieldType">
            <summary>
            Returns the <see cref="T:Lucene.Net.Documents.FieldType"/> for this field as type <see cref="T:Lucene.Net.Documents.FieldType"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.IndexableFieldType">
            <summary>
            Returns the <see cref="T:Lucene.Net.Documents.FieldType"/> for this field as type <see cref="T:Lucene.Net.Index.IIndexableFieldType"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.StringTokenStream.#ctor">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Analysis.TokenStream"/> that returns a <see cref="T:System.String"/> as single token.
            <para/>Warning: Does not initialize the value, you must call
            <see cref="M:Lucene.Net.Documents.Field.StringTokenStream.SetValue(System.String)"/> afterwards!
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.StringTokenStream.SetValue(System.String)">
            <summary>
            Sets the string value. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field.Store">
            <summary>
            Specifies whether and how a field should be stored. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.YES">
            <summary>
            Store the original field value in the index. this is useful for short texts
            like a document's title which should be displayed with the results. The
            value is stored in its original form, i.e. no analyzer is used before it is
            stored.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.NO">
            <summary>
            Do not store the field's value in the index. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field.Index">
            <summary>
            Specifies whether and how a field should be indexed. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NO">
            <summary>Do not index the field value. This field can thus not be searched,
            but one can still access its contents provided it is
            <see cref="T:Lucene.Net.Documents.Field.Store">stored</see>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.ANALYZED">
            <summary>Index the tokens produced by running the field's
            value through an <see cref="T:Lucene.Net.Analysis.Analyzer"/>.  This is useful for
            common text.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NOT_ANALYZED">
            <summary>Index the field's value without using an <see cref="T:Lucene.Net.Analysis.Analyzer"/>, so it can be searched.
            As no analyzer is used the value will be stored as a single term. This is
            useful for unique Ids like product numbers.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NOT_ANALYZED_NO_NORMS">
            <summary>Expert: Index the field's value without an Analyzer,
            and also disable the storing of norms.  Note that you
            can also separately enable/disable norms by setting
            <see cref="P:Lucene.Net.Documents.FieldType.OmitNorms" />.  No norms means that
            index-time field and document boosting and field
            length normalization are disabled.  The benefit is
            less memory usage as norms take up one byte of RAM
            per indexed field for every document in the index,
            during searching.  Note that once you index a given
            field <i>with</i> norms enabled, disabling norms will
            have no effect.  In other words, for this to have the
            above described effect on a field, all instances of
            that field must be indexed with NOT_ANALYZED_NO_NORMS
            from the beginning.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.ANALYZED_NO_NORMS">
            <summary>Expert: Index the tokens produced by running the
            field's value through an Analyzer, and also
            separately disable the storing of norms.  See
            <see cref="F:Lucene.Net.Documents.Field.Index.NOT_ANALYZED_NO_NORMS" /> for what norms are
            and why you may want to disable them.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field.TermVector">
            <summary>
            Specifies whether and how a field should have term vectors. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.NO">
            <summary>
            Do not store term vectors. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.YES">
            <summary>
            Store the term vectors of each document. A term vector is a list
            of the document's terms and their number of occurrences in that document.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS">
            <summary>
            Store the term vector + token position information
            </summary>
            <seealso cref="F:Lucene.Net.Documents.Field.TermVector.YES"/>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_OFFSETS">
            <summary>
            Store the term vector + Token offset information
            </summary>
            <seealso cref="F:Lucene.Net.Documents.Field.TermVector.YES"/>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS_OFFSETS">
            <summary>
            Store the term vector + Token position and offset information
            </summary>
            <seealso cref="F:Lucene.Net.Documents.Field.TermVector.YES"/>
            <seealso cref="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS"/>
            <seealso cref="F:Lucene.Net.Documents.Field.TermVector.WITH_OFFSETS"/>
        </member>
        <member name="M:Lucene.Net.Documents.Field.TranslateFieldType(Lucene.Net.Documents.Field.Store,Lucene.Net.Documents.Field.Index,Lucene.Net.Documents.Field.TermVector)">
            <summary>
            Translates the pre-4.0 enums for specifying how a
            field should be indexed into the 4.0 <see cref="T:Lucene.Net.Documents.FieldType"/>
            approach.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store,Lucene.Net.Documents.Field.Index)">
            <summary>
            Create a field by specifying its <paramref name="name"/>, <paramref name="value"/> and how it will
            be saved in the index. Term vectors will not be stored in the index.
            </summary>
            <param name="name">The name of the field</param>
            <param name="value">The string to process</param>
            <param name="store">Whether <paramref name="value"/> should be stored in the index</param>
            <param name="index">Whether the field should be indexed, and if so, if it should
            be tokenized before indexing</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name"/> or <paramref name="value"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">if the field is neither stored nor indexed</exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store,Lucene.Net.Documents.Field.Index,Lucene.Net.Documents.Field.TermVector)">
            <summary>
            Create a field by specifying its <paramref name="name"/>, <paramref name="value"/> and how it will
            be saved in the index.
            </summary>
            <param name="name">The name of the field</param>
            <param name="value">The string to process</param>
            <param name="store">Whether <paramref name="value"/> should be stored in the index</param>
            <param name="index">Whether the field should be indexed, and if so, if it should
            be tokenized before indexing</param>
            <param name="termVector">Whether term vector should be stored</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name"/> or <paramref name="value"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">in any of the following situations:
            <list type="bullet">
                <item><description>the field is neither stored nor indexed</description></item>
                <item><description>the field is not indexed but termVector is <see cref="F:Lucene.Net.Documents.Field.TermVector.YES"/></description></item>
            </list>
            </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader)">
            <summary>
            Create a tokenized and indexed field that is not stored. Term vectors will
            not be stored.  The <see cref="T:System.IO.TextReader"/> is read only when the <see cref="T:Lucene.Net.Documents.Document"/> is added to the index,
            i.e. you may not close the <see cref="T:System.IO.TextReader"/> until <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>
            has been called.
            </summary>
            <param name="name">The name of the field</param>
            <param name="reader">The reader with the content</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name"/> or <paramref name="reader"/> is <c>null</c></exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader,Lucene.Net.Documents.Field.TermVector)">
            <summary>
            Create a tokenized and indexed field that is not stored, optionally with 
            storing term vectors.  The <see cref="T:System.IO.TextReader"/> is read only when the <see cref="T:Lucene.Net.Documents.Document"/> is added to the index,
            i.e. you may not close the <see cref="T:System.IO.TextReader"/> until <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>
            has been called.
            </summary>
            <param name="name">The name of the field</param>
            <param name="reader">The reader with the content</param>
            <param name="termVector">Whether term vector should be stored</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name"/> or <paramref name="reader"/> is <c>null</c></exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Analysis.TokenStream)">
            <summary>
            Create a tokenized and indexed field that is not stored. Term vectors will
            not be stored. This is useful for pre-analyzed fields.
            The <see cref="T:Lucene.Net.Analysis.TokenStream"/> is read only when the <see cref="T:Lucene.Net.Documents.Document"/> is added to the index,
            i.e. you may not close the <see cref="T:Lucene.Net.Analysis.TokenStream"/> until <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>
            has been called.
            </summary>
            <param name="name">The name of the field</param>
            <param name="tokenStream">The <see cref="T:Lucene.Net.Analysis.TokenStream"/> with the content</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name"/> or <paramref name="tokenStream"/> is <c>null</c></exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Analysis.TokenStream,Lucene.Net.Documents.Field.TermVector)">
            <summary>
            Create a tokenized and indexed field that is not stored, optionally with 
            storing term vectors.  This is useful for pre-analyzed fields.
            The <see cref="T:Lucene.Net.Analysis.TokenStream"/> is read only when the <see cref="T:Lucene.Net.Documents.Document"/> is added to the index,
            i.e. you may not close the <see cref="T:Lucene.Net.Analysis.TokenStream"/> until <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>
            has been called.
            </summary>
            <param name="name">The name of the field</param>
            <param name="tokenStream">The <see cref="T:Lucene.Net.Analysis.TokenStream"/> with the content</param>
            <param name="termVector">Whether term vector should be stored</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name"/> or <paramref name="tokenStream"/> is <c>null</c></exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[])">
            <summary>
            Create a stored field with binary value. Optionally the value may be compressed.
            </summary>
            <param name="name">The name of the field</param>
            <param name="value">The binary value</param>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a stored field with binary value. Optionally the value may be compressed.
            </summary>
            <param name="name">The name of the field</param>
            <param name="value">The binary value</param>
            <param name="offset">Starting offset in value where this <see cref="T:Lucene.Net.Documents.Field"/>'s bytes are</param>
            <param name="length">Number of bytes to use for this <see cref="T:Lucene.Net.Documents.Field"/>, starting at offset</param>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Number.GetByteValue">
            <summary>
            Returns this object's value as a <see cref="T:System.Byte"/>. Might involve rounding and/or
            truncating the value, so it fits into a <see cref="T:System.Byte"/>.
            </summary>
            <returns>the primitive <see cref="T:System.Byte"/> value of this object.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Number.GetDoubleValue">
            <summary>
            Returns this object's value as a <see cref="T:System.Double"/>. Might involve rounding.
            </summary>
            <returns>the primitive <see cref="T:System.Double"/> value of this object.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Number.GetSingleValue">
            <summary>
            Returns this object's value as a <see cref="T:System.Single"/>. Might involve rounding.
            </summary>
            <returns>the primitive <see cref="T:System.Single"/> value of this object.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Number.GetInt32Value">
            <summary>
            Returns this object's value as an <see cref="T:System.Int32"/>. Might involve rounding and/or
            truncating the value, so it fits into an <see cref="T:System.Int32"/>.
            </summary>
            <returns>the primitive <see cref="T:System.Int32"/> value of this object.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Number.GetInt64Value">
            <summary>
            Returns this object's value as a <see cref="T:System.Int64"/>. Might involve rounding and/or
            truncating the value, so it fits into a <see cref="T:System.Int64"/>.
            </summary>
            <returns>the primitive <see cref="T:System.Int64"/> value of this object.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Field.Number.GetInt16Value">
            <summary>
            Returns this object's value as a <see cref="T:System.Int16"/>. Might involve rounding and/or
            truncating the value, so it fits into a <see cref="T:System.Int16"/>.
            </summary>
            <returns>the primitive <see cref="T:System.Int16"/> value of this object.</returns>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Byte.value">
            <summary>
            The value which the receiver represents.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Int16.value">
            <summary>
            The value which the receiver represents.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Int32.value">
            <summary>
            The value which the receiver represents.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Int64.value">
            <summary>
            The value which the receiver represents.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Double.value">
            <summary>
            The value which the receiver represents.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Single.value">
            <summary>
            The value which the receiver represents.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.FieldExtensions">
            <summary>
            LUCENENET specific extension methods to add functionality to enumerations
            that mimic Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldExtensions.ToTermVector(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Get the best representation of a TermVector given the flags.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.NumericFieldType">
            <summary>
            Data type of the numeric <see cref="T:Lucene.Net.Index.IIndexableField"/> value
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericFieldType.NONE">
            <summary>
            No numeric type (the field is not numeric).
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericFieldType.BYTE">
            <summary>
            8-bit unsigned integer numeric type
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericFieldType.INT16">
            <summary>
            16-bit short numeric type
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericFieldType.INT32">
            <summary>
            32-bit integer numeric type
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericFieldType.INT64">
            <summary>
            64-bit long numeric type
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericFieldType.SINGLE">
            <summary>
            32-bit float numeric type
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericFieldType.DOUBLE">
            <summary>
            64-bit double numeric type 
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.FieldType">
            <summary>
            Describes the properties of a field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldType.#ctor(Lucene.Net.Documents.FieldType)">
            <summary>
            Create a new mutable <see cref="T:Lucene.Net.Documents.FieldType"/> with all of the properties from <paramref name="ref"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldType.#ctor">
            <summary>
            Create a new <see cref="T:Lucene.Net.Documents.FieldType"/> with default properties.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldType.Freeze">
            <summary>
            Prevents future changes. Note, it is recommended that this is called once
            the <see cref="T:Lucene.Net.Documents.FieldType"/>'s properties have been set, to prevent unintentional state
            changes.
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.IsIndexed">
            <summary>
            Set to <c>true</c> to index (invert) this field. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.IsStored">
            <summary>
            Set to <c>true</c> to store this field. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.IsTokenized">
            <summary>
            Set to <c>true</c> to tokenize this field's contents via the
            configured <see cref="T:Lucene.Net.Analysis.Analyzer"/>. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.StoreTermVectors">
            <summary>
            Set to <c>true</c> if this field's indexed form should be also stored
            into term vectors. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.StoreTermVectorOffsets">
            <summary>
            Set to <c>true</c> to also store token character offsets into the term
            vector for this field. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.StoreTermVectorPositions">
            <summary>
            Set to <c>true</c> to also store token positions into the term
            vector for this field. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.StoreTermVectorPayloads">
            <summary>
            Set to <c>true</c> to also store token payloads into the term
            vector for this field. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.OmitNorms">
            <summary>
            Set to <c>true</c> to omit normalization values for the field. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.IndexOptions">
            <summary>
            Sets the indexing options for the field. 
            <para/>
            The default is <see cref="F:Lucene.Net.Index.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.NumericType">
            <summary>
            Specifies the field's numeric type, or set to <c>null</c> if the field has no numeric type.
            If non-null then the field's value will be indexed numerically so that 
            <see cref="T:Lucene.Net.Search.NumericRangeQuery"/> can be used at search time.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.NumericPrecisionStep">
            <summary>
            Sets the numeric precision step for the field.
            <para/>
            This has no effect if <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> returns <see cref="F:Lucene.Net.Documents.NumericType.NONE"/>.
            <para/>
            The default is <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/>.
            </summary>
            <exception cref="T:System.ArgumentException"> if precisionStep is less than 1. </exception>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.FieldType.ToString">
            <summary>
            Prints a <see cref="T:Lucene.Net.Documents.FieldType"/> for human consumption. </summary>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.DocValueType">
            <summary>
            Sets the field's <see cref="T:Lucene.Net.Index.DocValuesType"/>, or set to <see cref="F:Lucene.Net.Index.DocValuesType.NONE"/> if no <see cref="T:Lucene.Net.Index.DocValues"/> should be stored.
            <para/>
            The default is <see cref="F:Lucene.Net.Index.DocValuesType.NONE"/> (no <see cref="T:Lucene.Net.Index.DocValues"/>).
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="T:Lucene.Net.Documents.NumericType">
            <summary>
            Data type of the numeric value
            @since 3.2
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericType.NONE">
            <summary>
            No numeric type will be used.
            <para/>
            NOTE: This is the same as setting to <c>null</c> in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericType.INT32">
            <summary>
            32-bit integer numeric type
            <para/>
            NOTE: This was INT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericType.INT64">
            <summary>
            64-bit long numeric type
            <para/>
            NOTE: This was LONG in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericType.SINGLE">
            <summary>
            32-bit float numeric type
            <para/>
            NOTE: This was FLOAT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericType.DOUBLE">
            <summary>
            64-bit double numeric type </summary>
        </member>
        <member name="T:Lucene.Net.Documents.SingleDocValuesField">
            <summary>
            Syntactic sugar for encoding floats as <see cref="T:Lucene.Net.Index.NumericDocValues"/>
            via <see cref="M:J2N.BitConversion.SingleToRawInt32Bits(System.Single)"/>.
            <para>
            Per-document floating point values can be retrieved via
            <seealso cref="M:Lucene.Net.Search.IFieldCache.GetSingles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)"/>.</para>
            <para>
            <b>NOTE</b>: In most all cases this will be rather inefficient,
            requiring four bytes per document. Consider encoding floating
            point values yourself with only as much precision as you require.
            </para>
            <para>
            NOTE: This was FloatDocValuesField in Lucene
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SingleDocValuesField.#ctor(System.String,System.Single)">
            <summary>
            Creates a new DocValues field with the specified 32-bit <see cref="T:System.Single"/> value </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Single"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.SingleField">
             <summary>
             <para>
             Field that indexes <see cref="T:System.Single"/> values
             for efficient range filtering and sorting. Here's an example usage:
            
             <code>
             document.Add(new SingleField(name, 6.0F, Field.Store.NO));
             </code>
            
             For optimal performance, re-use the <see cref="T:Lucene.Net.Documents.SingleField"/> and
             <see cref="T:Lucene.Net.Documents.Document"/> instance for more than one document:
            
             <code>
                 FloatField field = new SingleField(name, 0.0F, Field.Store.NO);
                 Document document = new Document();
                 document.Add(field);
            
                 for (all documents) 
                 {
                     ...
                     field.SetSingleValue(value)
                     writer.AddDocument(document);
                     ...
                 }
             </code>
            
             See also <see cref="T:Lucene.Net.Documents.Int32Field"/>, <seealso cref="T:Lucene.Net.Documents.Int64Field"/>, 
             <see cref="T:Lucene.Net.Documents.DoubleField"/>.</para>
            
             <para>To perform range querying or filtering against a
             <see cref="T:Lucene.Net.Documents.SingleField"/>, use <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> or 
             <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.  To sort according to a
             <see cref="T:Lucene.Net.Documents.SingleField"/>, use the normal numeric sort types, eg
             <see cref="F:Lucene.Net.Search.SortFieldType.SINGLE"/>. <see cref="T:Lucene.Net.Documents.SingleField"/>
             values can also be loaded directly from <see cref="T:Lucene.Net.Search.IFieldCache"/>.</para>
            
             <para>You may add the same field name as an <see cref="T:Lucene.Net.Documents.SingleField"/> to
             the same document more than once.  Range querying and
             filtering will be the logical OR of all values; so a range query
             will hit all documents that have at least one value in
             the range. However sort behavior is not defined.  If you need to sort,
             you should separately index a single-valued <see cref="T:Lucene.Net.Documents.SingleField"/>.</para>
            
             <para>A <see cref="T:Lucene.Net.Documents.SingleField"/> will consume somewhat more disk space
             in the index than an ordinary single-valued field.
             However, for a typical index that includes substantial
             textual content per document, this increase will likely
             be in the noise. </para>
            
             <para>Within Lucene, each numeric value is indexed as a
             <em>trie</em> structure, where each term is logically
             assigned to larger and larger pre-defined brackets (which
             are simply lower-precision representations of the value).
             The step size between each successive bracket is called the
             <c>precisionStep</c>, measured in bits.  Smaller
             <c>precisionStep</c> values result in larger number
             of brackets, which consumes more disk space in the index
             but may result in faster range search performance.  The
             default value, 4, was selected for a reasonable tradeoff
             of disk space consumption versus performance.  You can
             create a custom <see cref="T:Lucene.Net.Documents.FieldType"/> and invoke the 
             <see cref="P:Lucene.Net.Documents.FieldType.NumericPrecisionStep"/> setter if you'd
             like to change the value.  Note that you must also
             specify a congruent value when creating 
             <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>
             or <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.
             For low cardinality fields larger precision steps are good.
             If the cardinality is &lt; 100, it is fair
             to use <see cref="F:System.Int32.MaxValue"/>, which produces one
             term per value.</para>
            
             <para>For more information on the internals of numeric trie
             indexing, including the <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/> <a
             href="../search/NumericRangeQuery.html#precisionStepDesc"><c>precisionStep</c></a>
             configuration, see <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>. The format of
             indexed values is described in <see cref="T:Lucene.Net.Util.NumericUtils"/>.</para>
            
             <para>If you only need to sort by numeric value, and never
             run range querying/filtering, you can index using a
             <c>precisionStep</c> of <see cref="F:System.Int32.MaxValue"/>.
             this will minimize disk space consumed. </para>
            
             <para>More advanced users can instead use 
             <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>
             directly, when indexing numbers. This
             class is a wrapper around this token stream type for
             easier, more intuitive usage.</para>
             <para>
             NOTE: This was FloatField in Lucene
             </para>
             @since 2.9
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.SingleField.TYPE_NOT_STORED">
            <summary>
            Type for a <see cref="T:Lucene.Net.Documents.SingleField"/> that is not stored:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.SingleField.TYPE_STORED">
            <summary>
            Type for a stored <see cref="T:Lucene.Net.Documents.SingleField"/>:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SingleField.#ctor(System.String,System.Single,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a stored or un-stored <see cref="T:Lucene.Net.Documents.SingleField"/> with the provided value
            and default <c>precisionStep</c> <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/>
            (4).
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Single"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.SingleField.#ctor(System.String,System.Single,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: allows you to customize the <see cref="T:Lucene.Net.Documents.FieldType"/>. 
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Single"/> value </param>
            <param name="type"> customized field type: must have <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/>
                    of <see cref="F:Lucene.Net.Documents.NumericType.SINGLE"/>. </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="type"/> is <see cref="F:Lucene.Net.Documents.NumericType.NONE"/> </exception>
            <exception cref="T:System.ArgumentException">if the field type does not have a <see cref="F:Lucene.Net.Documents.NumericType.SINGLE"/> <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/></exception>
        </member>
        <member name="T:Lucene.Net.Documents.Int32DocValuesField">
             <summary>
             Field that stores a per-document <see cref="T:System.Int32"/> value for scoring,
             sorting or value retrieval. Here's an example usage:
            
             <code>
                 document.Add(new Int32DocValuesField(name, 22));
             </code>
            
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance. 
             <para/>
             NOTE: This was IntDocValuesField in Lucene
             </summary>
             <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>
        </member>
        <member name="M:Lucene.Net.Documents.Int32DocValuesField.#ctor(System.String,System.Int32)">
            <summary>
            Creates a new DocValues field with the specified 32-bit <see cref="T:System.Int32"/> value </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Int32"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Int32Field">
             <summary>
             <para>
             Field that indexes <see cref="T:System.Int32"/> values
             for efficient range filtering and sorting. Here's an example usage:
            
             <code>
                 document.Add(new Int32Field(name, 6, Field.Store.NO));
             </code>
            
             For optimal performance, re-use the <see cref="T:Lucene.Net.Documents.Int32Field"/> and
             <see cref="T:Lucene.Net.Documents.Document"/> instance for more than one document:
            
             <code>
                 Int32Field field = new Int32Field(name, 6, Field.Store.NO);
                 Document document = new Document();
                 document.Add(field);
            
                 for (all documents) 
                 {
                     ...
                     field.SetInt32Value(value)
                     writer.AddDocument(document);
                     ...
                 }
             </code>
            
             See also <see cref="T:Lucene.Net.Documents.Int64Field"/>, <see cref="T:Lucene.Net.Documents.SingleField"/>, 
             <see cref="T:Lucene.Net.Documents.DoubleField"/>.</para>
            
             <para>To perform range querying or filtering against a
             <see cref="T:Lucene.Net.Documents.Int32Field"/>, use <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> or 
             <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.  To sort according to a
             <see cref="T:Lucene.Net.Documents.Int32Field"/>, use the normal numeric sort types, eg
             <see cref="F:Lucene.Net.Search.SortFieldType.INT32"/>. <see cref="T:Lucene.Net.Documents.Int32Field"/>
             values can also be loaded directly from <see cref="T:Lucene.Net.Search.IFieldCache"/>.</para>
            
             <para>You may add the same field name as an <see cref="T:Lucene.Net.Documents.Int32Field"/> to
             the same document more than once.  Range querying and
             filtering will be the logical OR of all values; so a range query
             will hit all documents that have at least one value in
             the range. However sort behavior is not defined.  If you need to sort,
             you should separately index a single-valued <see cref="T:Lucene.Net.Documents.Int32Field"/>.</para>
            
             <para>An <see cref="T:Lucene.Net.Documents.Int32Field"/> will consume somewhat more disk space
             in the index than an ordinary single-valued field.
             However, for a typical index that includes substantial
             textual content per document, this increase will likely
             be in the noise. </para>
            
             <para>Within Lucene, each numeric value is indexed as a
             <em>trie</em> structure, where each term is logically
             assigned to larger and larger pre-defined brackets (which
             are simply lower-precision representations of the value).
             The step size between each successive bracket is called the
             <c>precisionStep</c>, measured in bits.  Smaller
             <c>precisionStep</c> values result in larger number
             of brackets, which consumes more disk space in the index
             but may result in faster range search performance.  The
             default value, 4, was selected for a reasonable tradeoff
             of disk space consumption versus performance.  You can
             create a custom <see cref="T:Lucene.Net.Documents.FieldType"/> and invoke the 
             <see cref="P:Lucene.Net.Documents.FieldType.NumericPrecisionStep"/> setter if you'd
             like to change the value.  Note that you must also
             specify a congruent value when creating 
             <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> or <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.
             For low cardinality fields larger precision steps are good.
             If the cardinality is &lt; 100, it is fair
             to use <see cref="F:System.Int32.MaxValue"/>, which produces one
             term per value.</para>
            
             <para>For more information on the internals of numeric trie
             indexing, including the <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/> <a
             href="../search/NumericRangeQuery.html#precisionStepDesc"><c>precisionStep</c></a>
             configuration, see <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>. The format of
             indexed values is described in <see cref="T:Lucene.Net.Util.NumericUtils"/>.</para>
            
             <para>If you only need to sort by numeric value, and never
             run range querying/filtering, you can index using a
             <c>precisionStep</c> of <see cref="F:System.Int32.MaxValue"/>.
             this will minimize disk space consumed. </para>
            
             <para>More advanced users can instead use 
             <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/> directly, 
             when indexing numbers. this
             class is a wrapper around this token stream type for
             easier, more intuitive usage.</para>
             <para>
             NOTE: This was IntField in Lucene
             </para>
             @since 2.9
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Int32Field.TYPE_NOT_STORED">
            <summary>
            Type for an <see cref="T:Lucene.Net.Documents.Int32Field"/> that is not stored:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Int32Field.TYPE_STORED">
            <summary>
            Type for a stored <see cref="T:Lucene.Net.Documents.Int32Field"/>:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Int32Field.#ctor(System.String,System.Int32,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a stored or un-stored <see cref="T:Lucene.Net.Documents.Int32Field"/> with the provided value
            and default <c>precisionStep</c> 
            <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4). 
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Int32"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Int32Field.#ctor(System.String,System.Int32,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: allows you to customize the 
            <see cref="T:Lucene.Net.Documents.FieldType"/>.
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Int32"/> value </param>
            <param name="type"> customized field type: must have <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/>
                    of <see cref="F:Lucene.Net.Documents.NumericType.INT32"/>. </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="type"/> is <see cref="F:Lucene.Net.Documents.NumericType.NONE"/> </exception>
            <exception cref="T:System.ArgumentException">if the field type does not have a 
                    <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> of <see cref="F:Lucene.Net.Documents.NumericType.INT32"/> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Int64DocValuesField">
             <summary>
             <para>
             Field that stores a per-document <see cref="T:System.Int64"/> value for scoring,
             sorting or value retrieval. Here's an example usage:
            
             <code>
                 document.Add(new Int64DocValuesField(name, 22L));
             </code></para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.</para>
             <para>
             NOTE: This was LongDocValuesField in Lucene
             </para>
             </summary>
             <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>
        </member>
        <member name="M:Lucene.Net.Documents.Int64DocValuesField.#ctor(System.String,System.Int64)">
            <summary>
            Creates a new DocValues field with the specified 64-bit <see cref="T:System.Int64"/> value </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Int64Field">
             <summary>
             <para>
             Field that indexes <see cref="T:System.Int64"/> values
             for efficient range filtering and sorting. Here's an example usage:
            
             <code>
             document.Add(new Int64Field(name, 6L, Field.Store.NO));
             </code>
            
             For optimal performance, re-use the <see cref="T:Lucene.Net.Documents.Int64Field"/> and
             <see cref="T:Lucene.Net.Documents.Document"/> instance for more than one document:
            
             <code>
                 Int64Field field = new Int64Field(name, 0L, Field.Store.NO);
                 Document document = new Document();
                 document.Add(field);
            
                 for (all documents) {
                     ...
                     field.SetInt64Value(value)
                     writer.AddDocument(document);
                     ...
                 }
             </code>
            
             See also <see cref="T:Lucene.Net.Documents.Int32Field"/>, <see cref="T:Lucene.Net.Documents.SingleField"/>, 
             <see cref="T:Lucene.Net.Documents.DoubleField"/>.
             </para>
             
             <para>
             Any type that can be converted to long can also be
             indexed.  For example, date/time values represented by a
             <see cref="T:System.DateTime"/> can be translated into a long
             value using the <see cref="P:System.DateTime.Ticks"/> property.  If you
             don't need millisecond precision, you can quantize the
             value, either by dividing the result of
             <see cref="P:System.DateTime.Ticks"/> or using the separate getters
             (for year, month, etc.) to construct an <see cref="T:System.Int32"/> or
             <see cref="T:System.Int64"/> value.</para>
            
             <para>To perform range querying or filtering against a
             <see cref="T:Lucene.Net.Documents.Int64Field"/>, use <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> or 
             <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.  To sort according to a
             <see cref="T:Lucene.Net.Documents.Int64Field"/>, use the normal numeric sort types, eg
             <see cref="F:Lucene.Net.Search.SortFieldType.INT64"/>. <see cref="T:Lucene.Net.Documents.Int64Field"/>
             values can also be loaded directly from <see cref="T:Lucene.Net.Search.IFieldCache"/>.</para>
            
             <para>You may add the same field name as an <see cref="T:Lucene.Net.Documents.Int64Field"/> to
             the same document more than once.  Range querying and
             filtering will be the logical OR of all values; so a range query
             will hit all documents that have at least one value in
             the range. However sort behavior is not defined.  If you need to sort,
             you should separately index a single-valued <see cref="T:Lucene.Net.Documents.Int64Field"/>.</para>
            
             <para>An <see cref="T:Lucene.Net.Documents.Int64Field"/> will consume somewhat more disk space
             in the index than an ordinary single-valued field.
             However, for a typical index that includes substantial
             textual content per document, this increase will likely
             be in the noise. </para>
            
             <para>Within Lucene, each numeric value is indexed as a
             <em>trie</em> structure, where each term is logically
             assigned to larger and larger pre-defined brackets (which
             are simply lower-precision representations of the value).
             The step size between each successive bracket is called the
             <c>precisionStep</c>, measured in bits.  Smaller
             <c>precisionStep</c> values result in larger number
             of brackets, which consumes more disk space in the index
             but may result in faster range search performance.  The
             default value, 4, was selected for a reasonable tradeoff
             of disk space consumption versus performance.  You can
             create a custom <see cref="T:Lucene.Net.Documents.FieldType"/> and invoke the 
             <see cref="P:Lucene.Net.Documents.FieldType.NumericPrecisionStep"/> setter if you'd
             like to change the value.  Note that you must also
             specify a congruent value when creating 
             <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> or <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.
             For low cardinality fields larger precision steps are good.
             If the cardinality is &lt; 100, it is fair
             to use <see cref="F:System.Int32.MaxValue"/>, which produces one
             term per value.</para>
            
             <para>For more information on the internals of numeric trie
             indexing, including the <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/> <a
             href="../search/NumericRangeQuery.html#precisionStepDesc"><c>precisionStep</c></a>
             configuration, see <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>. The format of
             indexed values is described in <see cref="T:Lucene.Net.Util.NumericUtils"/>.</para>
            
             <para>If you only need to sort by numeric value, and never
             run range querying/filtering, you can index using a
             <c>precisionStep</c> of <see cref="F:System.Int32.MaxValue"/>.
             this will minimize disk space consumed. </para>
            
             <para>More advanced users can instead use 
             <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/> directly, 
             when indexing numbers. this
             class is a wrapper around this token stream type for
             easier, more intuitive usage.</para>
             <para>
             NOTE: This was LongField in Lucene
             </para>
             @since 2.9
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Int64Field.TYPE_NOT_STORED">
            <summary>
            Type for a <see cref="T:Lucene.Net.Documents.Int64Field"/> that is not stored:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Int64Field.TYPE_STORED">
            <summary>
            Type for a stored <see cref="T:Lucene.Net.Documents.Int64Field"/>:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Int64Field.#ctor(System.String,System.Int64,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a stored or un-stored <see cref="T:Lucene.Net.Documents.Int64Field"/> with the provided value
            and default <c>precisionStep</c> 
            <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4). 
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Int64Field.#ctor(System.String,System.Int64,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: allows you to customize the <see cref="T:Lucene.Net.Documents.FieldType"/>. 
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <param name="type"> customized field type: must have <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/>
                    of <see cref="F:Lucene.Net.Documents.NumericType.INT64"/>. </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="type"/> is <see cref="F:Lucene.Net.Documents.NumericType.NONE"/> </exception>
            <exception cref="T:System.ArgumentException"> if the field type does not have a 
            <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> of <see cref="F:Lucene.Net.Documents.NumericType.INT64"/> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.NumericDocValuesField">
             <summary>
             Field that stores a per-document <see cref="T:System.Int64"/> value for scoring,
             sorting or value retrieval. Here's an example usage:
            
             <code>
                 document.Add(new NumericDocValuesField(name, 22L));
             </code>
            
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericDocValuesField.TYPE">
            <summary>
            Type for numeric <see cref="T:Lucene.Net.Index.DocValues"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.NumericDocValuesField.#ctor(System.String,System.Int64)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.DocValues"/> field with the specified 64-bit <see cref="T:System.Int64"/> value </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.PackedInt64DocValuesField">
             <summary>
             <para>
             Field that stores a per-document <see cref="T:System.Int64"/> value
             for scoring, sorting or value retrieval. Here's an example usage:
            
             <code>
                 document.Add(new PackedInt64DocValuesField(name, 22L));
             </code>
             </para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </para>
             <para>
             NOTE: This was PackedLongDocValuesField in Lucene
             </para>
             </summary>
             <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>
        </member>
        <member name="M:Lucene.Net.Documents.PackedInt64DocValuesField.#ctor(System.String,System.Int64)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.DocValues"/> field with the specified <see cref="T:System.Int64"/> value </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <exception cref="T:System.ArgumentException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Int16DocValuesField">
             <summary>
             <para>
             Field that stores a per-document <see cref="T:System.Int16"/> value for scoring,
             sorting or value retrieval. Here's an example usage:
            
             <code>
                 document.Add(new Int16DocValuesField(name, (short) 22));
             </code>
             </para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </para>
             <para>
             NOTE: This was ShortDocValuesField in Lucene
             </para>
             </summary>
             <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>
        </member>
        <member name="M:Lucene.Net.Documents.Int16DocValuesField.#ctor(System.String,System.Int16)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.DocValues"/> field with the specified 16-bit <see cref="T:System.Int16"/> value </summary>
            <param name="name"> field name </param>
            <param name="value"> 16-bit <see cref="T:System.Int16"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.SortedBytesDocValuesField">
             <summary>
             <para>
             Field that stores
             a per-document <see cref="T:Lucene.Net.Util.BytesRef"/> value, indexed for
             sorting.  Here's an example usage:
            
             <code>
                 document.Add(new SortedBytesDocValuesField(name, new BytesRef("hello")));
             </code>
             </para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </para>
             </summary>
             <seealso cref="T:Lucene.Net.Documents.SortedDocValuesField"/>
        </member>
        <member name="F:Lucene.Net.Documents.SortedBytesDocValuesField.TYPE_FIXED_LEN">
            <summary>
            Type for sorted bytes <see cref="T:Lucene.Net.Index.DocValues"/>: all with the same length
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.SortedBytesDocValuesField.TYPE_VAR_LEN">
            <summary>
            Type for sorted bytes <see cref="T:Lucene.Net.Index.DocValues"/>: can have variable lengths
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SortedBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new fixed or variable-length sorted <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.SortedBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef,System.Boolean)">
            <summary>
            Create a new fixed or variable length sorted <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <param name="isFixedLength"> (ignored) </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.SortedDocValuesField">
             <summary>
             <para>
             Field that stores
             a per-document <see cref="T:Lucene.Net.Util.BytesRef"/> value, indexed for
             sorting.  Here's an example usage:
            
             <code>
                 document.Add(new SortedDocValuesField(name, new BytesRef("hello")));
             </code></para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.</para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.SortedDocValuesField.TYPE">
            <summary>
            Type for sorted bytes <see cref="T:Lucene.Net.Index.DocValues"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SortedDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new sorted <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.SortedSetDocValuesField">
             <summary>
             <para>
             Field that stores
             a set of per-document <see cref="T:Lucene.Net.Util.BytesRef"/> values, indexed for
             faceting,grouping,joining.  Here's an example usage:
            
             <code>
                 document.Add(new SortedSetDocValuesField(name, new BytesRef("hello")));
                 document.Add(new SortedSetDocValuesField(name, new BytesRef("world")));
             </code>
             </para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.</para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.SortedSetDocValuesField.TYPE">
            <summary>
            Type for sorted bytes <see cref="T:Lucene.Net.Index.DocValues"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SortedSetDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new sorted <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.StoredField">
            <summary>
            A field whose value is stored so that 
            <see cref="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)"/> and <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/> will
            return the field and its value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.StoredField.TYPE">
            <summary>
            Type for a stored-only field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Byte[])">
            <summary>
            Create a stored-only field with the given binary value.
            <para>NOTE: the provided <see cref="T:byte[]"/> is not copied so be sure
            not to change it until you're done with this field.</para>
            </summary>
            <param name="name"> field name </param>
            <param name="value"> byte array pointing to binary content (not copied) </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a stored-only field with the given binary value.
            <para>NOTE: the provided <see cref="T:byte[]"/> is not copied so be sure
            not to change it until you're done with this field.</para>
            </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Byte"/> array pointing to binary content (not copied) </param>
            <param name="offset"> starting position of the byte array </param>
            <param name="length"> valid length of the byte array </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a stored-only field with the given binary value.
            <para>NOTE: the provided <see cref="T:Lucene.Net.Util.BytesRef"/> is not copied so be sure
            not to change it until you're done with this field.</para>
            </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:Lucene.Net.Util.BytesRef"/> pointing to binary content (not copied) </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.String)">
            <summary>
            Create a stored-only field with the given <see cref="T:System.String"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.String"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="value"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Int32)">
            <summary>
            Create a stored-only field with the given <see cref="T:System.Int32"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Int32"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Single)">
            <summary>
            Create a stored-only field with the given <see cref="T:System.Single"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Single"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Int64)">
            <summary>
            Create a stored-only field with the given <see cref="T:System.Int64"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Int64"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Double)">
            <summary>
            Create a stored-only field with the given <see cref="T:System.Double"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Double"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="T:Lucene.Net.Documents.StraightBytesDocValuesField">
             <summary>
             <para>
             Field that stores
             a per-document <see cref="T:Lucene.Net.Util.BytesRef"/> value.  If values may be shared it's
             better to use <see cref="T:Lucene.Net.Documents.SortedDocValuesField"/>.  Here's an example usage:
            
             <code>
                 document.Add(new StraightBytesDocValuesField(name, new BytesRef("hello")));
             </code></para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.</para>
             </summary>
             <seealso cref="T:Lucene.Net.Documents.BinaryDocValuesField"/>
        </member>
        <member name="F:Lucene.Net.Documents.StraightBytesDocValuesField.TYPE_FIXED_LEN">
            <summary>
            Type for direct bytes <see cref="T:Lucene.Net.Index.DocValues"/>: all with the same length
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.StraightBytesDocValuesField.TYPE_VAR_LEN">
            <summary>
            Type for direct bytes <see cref="T:Lucene.Net.Index.DocValues"/>: can have variable lengths
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.StraightBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new fixed or variable length <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StraightBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef,System.Boolean)">
            <summary>
            Create a new fixed or variable length direct <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <param name="isFixedLength"> (ignored) </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.StringField">
            <summary>
            A field that is indexed but not tokenized: the entire
            <see cref="T:System.String"/> value is indexed as a single token.  For example
            this might be used for a 'country' field or an 'id'
            field, or any field that you intend to use for sorting
            or access through the field cache.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.StringField.TYPE_NOT_STORED">
            <summary>
            Indexed, not tokenized, omits norms, indexes
            <see cref="F:Lucene.Net.Index.IndexOptions.DOCS_ONLY"/>, not stored.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.StringField.TYPE_STORED">
            <summary>
            Indexed, not tokenized, omits norms, indexes
            <see cref="F:Lucene.Net.Index.IndexOptions.DOCS_ONLY"/>, stored
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.StringField.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Documents.StringField"/> (a field that is indexed but not tokenized)
            </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.String"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="value"/> is <c>null</c>. </exception>
        </member>
        <member name="T:Lucene.Net.Documents.TextField">
            <summary>
            A field that is indexed and tokenized, without term
            vectors.  For example this would be used on a 'body'
            field, that contains the bulk of a document's text.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.TextField.TYPE_NOT_STORED">
            <summary>
            Indexed, tokenized, not stored. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.TextField.TYPE_STORED">
            <summary>
            Indexed, tokenized, stored. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.TextField.#ctor(System.String,System.IO.TextReader)">
            <summary>
            Creates a new un-stored <see cref="T:Lucene.Net.Documents.TextField"/> with <see cref="T:System.IO.TextReader"/> value. </summary>
            <param name="name"> field name </param>
            <param name="reader"> <see cref="T:System.IO.TextReader"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="reader"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.TextField.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Documents.TextField"/> with <see cref="T:System.String"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.String"/> value </param>
            <param name="store"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="value"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.TextField.#ctor(System.String,Lucene.Net.Analysis.TokenStream)">
            <summary>
            Creates a new un-stored <see cref="T:Lucene.Net.Documents.TextField"/> with <see cref="T:Lucene.Net.Analysis.TokenStream"/> value. </summary>
            <param name="name"> field name </param>
            <param name="stream"> <see cref="T:Lucene.Net.Analysis.TokenStream"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="stream"/> is <c>null</c>. </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Extensions.DocumentExtensions">
            <summary>
            LUCENENET specific extensions to the <see cref="T:Lucene.Net.Documents.Document"/> class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.GetField``1(Lucene.Net.Documents.Document,System.String)">
            <summary>
            Returns a field with the given name if any exist in this document cast to type <typeparamref name="T"/>, or
            <c>null</c>. If multiple fields exists with this name, this method returns the
            first value added.
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name">Field name</param>
            <exception cref="T:System.InvalidCastException">If the field type cannot be cast to <typeparamref name="T"/>.</exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.GetFields``1(Lucene.Net.Documents.Document,System.String)">
            <summary>
            Returns an array of <see cref="T:Lucene.Net.Index.IIndexableField"/>s with the given name, cast to type <typeparamref name="T"/>.
            This method returns an empty array when there are no
            matching fields. It never returns <c>null</c>.
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> the name of the field </param>
            <returns> a <see cref="T:IndexableField[]"/> array </returns>
            <exception cref="T:System.InvalidCastException">If the field type cannot be cast to <typeparam name="T"/>.</exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddBinaryDocValuesField(Lucene.Net.Documents.Document,System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Adds a new <see cref="T:Lucene.Net.Documents.BinaryDocValuesField"/>.
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> binary content </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field name is null </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddDoubleDocValuesField(Lucene.Net.Documents.Document,System.String,System.Double)">
            <summary>
            Adds a new <see cref="T:Lucene.Net.Documents.DoubleDocValuesField"/> field with the specified 64-bit double value </summary>
            <remarks>
            Syntactic sugar for encoding doubles as <see cref="T:Lucene.Net.Index.NumericDocValues"/>
            via <see cref="M:J2N.BitConversion.DoubleToRawInt64Bits(System.Double)"/>.
            <para/>
            Per-document double values can be retrieved via
            <see cref="M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)"/>.
            <para/>
            <b>NOTE</b>: In most all cases this will be rather inefficient,
            requiring eight bytes per document. Consider encoding double
            values yourself with only as much precision as you require.
            </remarks>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> 64-bit double value </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field name is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddDoubleField(Lucene.Net.Documents.Document,System.String,System.Double,Lucene.Net.Documents.Field.Store)">
            <summary>
            Adds a stored or un-stored <see cref="T:Lucene.Net.Documents.DoubleField"/> with the provided value
            and default <c>precisionStep</c> 
            <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4).
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Double"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field name is <c>null</c>.  </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddDoubleField(Lucene.Net.Documents.Document,System.String,System.Double,Lucene.Net.Documents.FieldType)">
            <summary>
            Adds a stored or un-stored <see cref="T:Lucene.Net.Documents.DoubleField"/> with the provided value.
            <para/>
            Expert: allows you to customize the <see cref="T:Lucene.Net.Documents.FieldType"/>. 
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> 64-bit double value </param>
            <param name="type"> customized field type: must have <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/>
                    of <see cref="F:Lucene.Net.Documents.NumericType.DOUBLE"/>. </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field name or type is <c>null</c>, or
                     if the field type does not have a <see cref="F:Lucene.Net.Documents.NumericType.DOUBLE"/> <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddSingleDocValuesField(Lucene.Net.Documents.Document,System.String,System.Single)">
            <summary>
            Adds a new <see cref="T:Lucene.Net.Documents.SingleDocValuesField"/> field with the specified 32-bit <see cref="T:System.Single"/> value </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Single"/> value </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field name is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddSingleField(Lucene.Net.Documents.Document,System.String,System.Single,Lucene.Net.Documents.Field.Store)">
            <summary>
            Adds a stored or un-stored <see cref="T:Lucene.Net.Documents.SingleField"/> with the provided value
            and default <c>precisionStep</c> <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/>
            (4).
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Single"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddSingleField(Lucene.Net.Documents.Document,System.String,System.Single,Lucene.Net.Documents.FieldType)">
            <summary>
            Adds a stored or un-stored <see cref="T:Lucene.Net.Documents.SingleField"/> with the provided value.
            <para/>
            Expert: allows you to customize the <see cref="T:Lucene.Net.Documents.FieldType"/>. 
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Single"/> value </param>
            <param name="type"> customized field type: must have <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/>
                    of <see cref="F:Lucene.Net.Documents.NumericType.SINGLE"/>. </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="type"/> is <see cref="F:Lucene.Net.Documents.NumericType.NONE"/> </exception>
            <exception cref="T:System.ArgumentException">if the field type does not have a <see cref="F:Lucene.Net.Documents.NumericType.SINGLE"/> <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/></exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddInt32Field(Lucene.Net.Documents.Document,System.String,System.Int32,Lucene.Net.Documents.Field.Store)">
            <summary>
            Adds a stored or un-stored <see cref="T:Lucene.Net.Documents.Int32Field"/> with the provided value
            and default <c>precisionStep</c> 
            <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4). 
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Int32"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddInt32Field(Lucene.Net.Documents.Document,System.String,System.Int32,Lucene.Net.Documents.FieldType)">
            <summary>
            Adds a stored or un-stored <see cref="T:Lucene.Net.Documents.Int32Field"/> with the provided value.
            <para/>
            Expert: allows you to customize the 
            <see cref="T:Lucene.Net.Documents.FieldType"/>.
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Int32"/> value </param>
            <param name="type"> customized field type: must have <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/>
                    of <see cref="F:Lucene.Net.Documents.NumericType.INT32"/>. </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="type"/> is <see cref="F:Lucene.Net.Documents.NumericType.NONE"/> </exception>
            <exception cref="T:System.ArgumentException">if the field type does not have a 
                    <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> of <see cref="F:Lucene.Net.Documents.NumericType.INT32"/> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddInt64Field(Lucene.Net.Documents.Document,System.String,System.Int64,Lucene.Net.Documents.Field.Store)">
            <summary>
            Adds a stored or un-stored <see cref="T:Lucene.Net.Documents.Int64Field"/> with the provided value
            and default <c>precisionStep</c> 
            <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4). 
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddInt64Field(Lucene.Net.Documents.Document,System.String,System.Int64,Lucene.Net.Documents.FieldType)">
            <summary>
            Adds a stored or un-stored <see cref="T:Lucene.Net.Documents.Int64Field"/> with the provided value.
            <para/>
            Expert: allows you to customize the <see cref="T:Lucene.Net.Documents.FieldType"/>. 
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <param name="type"> customized field type: must have <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/>
                    of <see cref="F:Lucene.Net.Documents.NumericType.INT64"/>. </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="type"/> is <see cref="F:Lucene.Net.Documents.NumericType.NONE"/> </exception>
            <exception cref="T:System.ArgumentException"> if the field type does not have a 
            <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> of <see cref="F:Lucene.Net.Documents.NumericType.INT64"/> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddNumericDocValuesField(Lucene.Net.Documents.Document,System.String,System.Int64)">
            <summary>
            Adds a new <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/> field with the specified 64-bit <see cref="T:System.Int64"/> value </summary>
            <remarks>
            If you also need to store the value, you should add a
            separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
            </remarks>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddSortedDocValuesField(Lucene.Net.Documents.Document,System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Adds a new <see cref="T:Lucene.Net.Documents.SortedDocValuesField"/> field. </summary>
            <remarks>
            If you also need to store the value, you should add a
            separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
            </remarks>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddSortedSetDocValuesField(Lucene.Net.Documents.Document,System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Adds a new <see cref="T:Lucene.Net.Documents.SortedSetDocValuesField"/> field. </summary>
            <remarks>
            If you also need to store the value, you should add a
            separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
            </remarks>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddStoredField(Lucene.Net.Documents.Document,System.String,System.Byte[])">
            <summary>
            Adds a stored-only field with the given binary value.
            <para>NOTE: the provided <see cref="T:byte[]"/> is not copied so be sure
            not to change it until you're done with this field.</para>
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> byte array pointing to binary content (not copied) </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddStoredField(Lucene.Net.Documents.Document,System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds a stored-only field with the given binary value.
            <para>NOTE: the provided <see cref="T:byte[]"/> is not copied so be sure
            not to change it until you're done with this field.</para>
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Byte"/> array pointing to binary content (not copied) </param>
            <param name="offset"> starting position of the byte array </param>
            <param name="length"> valid length of the byte array </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddStoredField(Lucene.Net.Documents.Document,System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Adds a stored-only field with the given binary value.
            <para>NOTE: the provided <see cref="T:Lucene.Net.Util.BytesRef"/> is not copied so be sure
            not to change it until you're done with this field.</para>
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:Lucene.Net.Util.BytesRef"/> pointing to binary content (not copied) </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddStoredField(Lucene.Net.Documents.Document,System.String,System.String)">
            <summary>
            Adds a stored-only field with the given <see cref="T:System.String"/> value. </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.String"/> value </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="value"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddStoredField(Lucene.Net.Documents.Document,System.String,System.Int32)">
            <summary>
            Adds a stored-only field with the given <see cref="T:System.Int32"/> value. </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Int32"/> value </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddStoredField(Lucene.Net.Documents.Document,System.String,System.Single)">
            <summary>
            Adds a stored-only field with the given <see cref="T:System.Single"/> value. </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Single"/> value </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddStoredField(Lucene.Net.Documents.Document,System.String,System.Int64)">
            <summary>
            Adds a stored-only field with the given <see cref="T:System.Int64"/> value. </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Int64"/> value </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddStoredField(Lucene.Net.Documents.Document,System.String,System.Double)">
            <summary>
            Adds a stored-only field with the given <see cref="T:System.Double"/> value. </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Double"/> value </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddStringField(Lucene.Net.Documents.Document,System.String,System.String,Lucene.Net.Documents.Field.Store)">
            <summary>
            Adds a new <see cref="T:Lucene.Net.Documents.StringField"/> (a field that is indexed but not tokenized)
            </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.String"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="value"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddTextField(Lucene.Net.Documents.Document,System.String,System.IO.TextReader)">
            <summary>
            Adds a new un-stored <see cref="T:Lucene.Net.Documents.TextField"/> with <see cref="T:System.IO.TextReader"/> value. </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="reader"> <see cref="T:System.IO.TextReader"/> value </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="reader"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddTextField(Lucene.Net.Documents.Document,System.String,System.String,Lucene.Net.Documents.Field.Store)">
            <summary>
            Adds a new <see cref="T:Lucene.Net.Documents.TextField"/> with <see cref="T:System.String"/> value. </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.String"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="value"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.DocumentExtensions.AddTextField(Lucene.Net.Documents.Document,System.String,Lucene.Net.Analysis.TokenStream)">
            <summary>
            Adds a new un-stored <see cref="T:Lucene.Net.Documents.TextField"/> with <see cref="T:Lucene.Net.Analysis.TokenStream"/> value. </summary>
            <param name="document">This <see cref="T:Lucene.Net.Documents.Document"/>.</param>
            <param name="name"> field name </param>
            <param name="stream"> <see cref="T:Lucene.Net.Analysis.TokenStream"/> value </param>
            <returns>The field that was added to this <see cref="T:Lucene.Net.Documents.Document"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="stream"/> is <c>null</c>. </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Extensions.IndexableFieldExtensions">
            <summary>
            Extension methods to the <see cref="T:Lucene.Net.Index.IIndexableField"/> interface.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.IndexableFieldExtensions.GetByteValueOrDefault(Lucene.Net.Index.IIndexableField)">
            <summary>
            Returns the field value as <see cref="T:System.Byte"/> or <c>0</c> if the type
            is non-numeric.
            </summary>
            <param name="field">This <see cref="T:Lucene.Net.Index.IIndexableField"/>.</param>
            <returns>The field value or <c>0</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.IndexableFieldExtensions.GetInt16ValueOrDefault(Lucene.Net.Index.IIndexableField)">
            <summary>
            Returns the field value as <see cref="T:System.Int16"/> or <c>0</c> if the type
            is non-numeric.
            </summary>
            <param name="field">This <see cref="T:Lucene.Net.Index.IIndexableField"/>.</param>
            <returns>The field value or <c>0</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.IndexableFieldExtensions.GetInt32ValueOrDefault(Lucene.Net.Index.IIndexableField)">
            <summary>
            Returns the field value as <see cref="T:System.Int32"/> or <c>0</c> if the type
            is non-numeric.
            </summary>
            <param name="field">This <see cref="T:Lucene.Net.Index.IIndexableField"/>.</param>
            <returns>The field value or <c>0</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.IndexableFieldExtensions.GetInt64ValueOrDefault(Lucene.Net.Index.IIndexableField)">
            <summary>
            Returns the field value as <see cref="T:System.Int64"/> or <c>0</c> if the type
            is non-numeric.
            </summary>
            <param name="field">This <see cref="T:Lucene.Net.Index.IIndexableField"/>.</param>
            <returns>The field value or <c>0</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.IndexableFieldExtensions.GetSingleValueOrDefault(Lucene.Net.Index.IIndexableField)">
            <summary>
            Returns the field value as <see cref="T:System.Single"/> or <c>0</c> if the type
            is non-numeric.
            </summary>
            <param name="field">This <see cref="T:Lucene.Net.Index.IIndexableField"/>.</param>
            <returns>The field value or <c>0</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Extensions.IndexableFieldExtensions.GetDoubleValueOrDefault(Lucene.Net.Index.IIndexableField)">
            <summary>
            Returns the field value as <see cref="T:System.Double"/> or <c>0</c> if the type
            is non-numeric.
            </summary>
            <param name="field">This <see cref="T:Lucene.Net.Index.IIndexableField"/>.</param>
            <returns>The field value or <c>0</c> if the type is non-numeric.</returns>
        </member>
        <member name="T:Lucene.Net.Index.AtomicReader">
             <summary>
             <see cref="T:Lucene.Net.Index.AtomicReader"/> is an abstract class, providing an interface for accessing an
             index.  Search of an index is done entirely through this abstract interface,
             so that any subclass which implements it is searchable. <see cref="T:Lucene.Net.Index.IndexReader"/>s implemented
             by this subclass do not consist of several sub-readers,
             they are atomic. They support retrieval of stored fields, doc values, terms,
             and postings.
            
             <para/>For efficiency, in this API documents are often referred to via
             <i>document numbers</i>, non-negative integers which each name a unique
             document in the index.  These document numbers are ephemeral -- they may change
             as documents are added to and deleted from an index.  Clients should thus not
             rely on a given document having the same number between sessions.
            
             <para/>
             <b>NOTE</b>: <see cref="T:Lucene.Net.Index.IndexReader"/>
             instances are completely thread
             safe, meaning multiple threads can call any of its methods,
             concurrently.  If your application requires external
             synchronization, you should <b>not</b> synchronize on the
             <see cref="T:Lucene.Net.Index.IndexReader"/> instance; use your own
             (non-Lucene) objects instead.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReader.AtomicContext">
            <summary>
            LUCENENET specific propety that allows access to
            the context as <see cref="T:Lucene.Net.Index.AtomicReaderContext"/>,
            which prevents the need to cast.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.HasNorms(System.String)">
            <summary>
            Returns true if there are norms stored for this <paramref name="field"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReader.Fields">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.Fields"/> for this reader.
            this property may return <c>null</c> if the reader has no
            postings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.TotalTermFreq(Lucene.Net.Index.Term)">
            <summary>
            Returns the number of documents containing the <paramref name="term"/>. 
            This method returns 0 if the term or
            field does not exist. This method does not take into
            account deleted documents that have not yet been merged
            away.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetTerms(System.String)">
            <summary>
            This may return <c>null</c> if the field does not exist. </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetTermDocsEnum(Lucene.Net.Index.Term)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.DocsEnum"/> for the specified term.
            This will return <c>null</c> if either the field or
            term does not exist.
            </summary>
            <seealso cref="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum)"/>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetTermPositionsEnum(Lucene.Net.Index.Term)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> for the specified
            term. This will return <c>null</c> if the
            field or term does not exist or positions weren't indexed. </summary>
            <seealso cref="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum)"/>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetNumericDocValues(System.String)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.NumericDocValues"/> for this field, or
            null if no <see cref="T:Lucene.Net.Index.NumericDocValues"/> were indexed for
            this field. The returned instance should only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetBinaryDocValues(System.String)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.BinaryDocValues"/> for this field, or
            <c>null</c> if no <see cref="T:Lucene.Net.Index.BinaryDocValues"/> were indexed for
            this field. The returned instance should only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetSortedDocValues(System.String)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.SortedDocValues"/> for this field, or
            <c>null</c> if no <see cref="T:Lucene.Net.Index.SortedDocValues"/> were indexed for
            this field. The returned instance should only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetSortedSetDocValues(System.String)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.SortedSetDocValues"/> for this field, or
            <c>null</c> if no <see cref="T:Lucene.Net.Index.SortedSetDocValues"/> were indexed for
            this field. The returned instance should only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetDocsWithField(System.String)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Util.IBits"/> at the size of <c>reader.MaxDoc</c>,
            with turned on bits for each docid that does have a value for this field,
            or <c>null</c> if no <see cref="T:Lucene.Net.Index.DocValues"/> were indexed for this field. The
            returned instance should only be used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetNormValues(System.String)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.NumericDocValues"/> representing norms
            for this field, or <c>null</c> if no <see cref="T:Lucene.Net.Index.NumericDocValues"/>
            were indexed. The returned instance should only be
            used by a single thread.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReader.FieldInfos">
            <summary>
            Get the <see cref="T:Lucene.Net.Index.FieldInfos"/> describing all fields in
            this reader.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReader.LiveDocs">
            <summary>
            Returns the <see cref="T:Lucene.Net.Util.IBits"/> representing live (not
            deleted) docs.  A set bit indicates the doc ID has not
            been deleted.  If this method returns <c>null</c> it means
            there are no deleted documents (all documents are
            live).
            <para/>
            The returned instance has been safely published for
            use by multiple threads without additional
            synchronization.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.CheckIntegrity">
            <summary>
            Checks consistency of this reader.
            <para/>
            Note that this may be costly in terms of I/O, e.g.
            may involve computing a checksum value against large data files.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.AtomicReaderContext">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexReaderContext"/> for <see cref="T:Lucene.Net.Index.AtomicReader"/> instances.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReaderContext.Ord">
            <summary>
            The readers ord in the top-level's leaves array </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReaderContext.DocBase">
            <summary>
            The readers absolute doc base </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReaderContext.#ctor(Lucene.Net.Index.CompositeReaderContext,Lucene.Net.Index.AtomicReader,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.AtomicReaderContext"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.AutomatonTermsEnum">
            <summary>
            A <see cref="T:Lucene.Net.Index.FilteredTermsEnum"/> that enumerates terms based upon what is accepted by a
            DFA.
            <para/>
            The algorithm is such:
            <list type="number">
                <item><description>As long as matches are successful, keep reading sequentially.</description></item>
                <item><description>When a match fails, skip to the next string in lexicographic order that
                    does not enter a reject state.</description></item>
            </list>
            <para>
            The algorithm does not attempt to actually skip to the next string that is
            completely accepted. this is not possible when the language accepted by the
            FSM is not finite (i.e. * operator).
            </para>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.#ctor(Lucene.Net.Index.TermsEnum,Lucene.Net.Util.Automaton.CompiledAutomaton)">
            <summary>
            Construct an enumerator based upon an automaton, enumerating the specified
            field, working on a supplied <see cref="T:Lucene.Net.Index.TermsEnum"/>
            <para/>
            @lucene.experimental
            </summary>
            <param name="tenum"> TermsEnum </param>
            <param name="compiled"> CompiledAutomaton </param>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.Accept(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns <c>true</c> if the term matches the automaton. Also stashes away the term
            to assist with smart enumeration.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.SetLinear(System.Int32)">
            <summary>
            Sets the enum to operate in linear fashion, as we have found
            a looping transition at position: we set an upper bound and
            act like a <see cref="T:Lucene.Net.Search.TermRangeQuery"/> for this portion of the term space.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.NextString">
            <summary>
            Increments the byte buffer to the next string in binary order after s that will not put
            the machine into a reject state. If such a string does not exist, returns
            <c>false</c>.
            <para/>
            The correctness of this method depends upon the automaton being deterministic,
            and having no transitions to dead states.
            </summary>
            <returns> <c>true</c> if more possible solutions exist for the DFA </returns>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.NextString(System.Int32,System.Int32)">
            <summary>
            Returns the next string in lexicographic order that will not put
            the machine into a reject state.
            <para/>
            This method traverses the DFA from the given position in the string,
            starting at the given state.
            <para/>
            If this cannot satisfy the machine, returns <c>false</c>. This method will
            walk the minimal path, in lexicographic order, as long as possible.
            <para/>
            If this method returns <c>false</c>, then there might still be more solutions,
            it is necessary to backtrack to find out.
            </summary>
            <param name="state"> current non-reject state </param>
            <param name="position"> useful portion of the string </param>
            <returns> <c>true</c> if more possible solutions exist for the DFA from this
                    position </returns>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.Backtrack(System.Int32)">
            <summary>
            Attempts to backtrack thru the string after encountering a dead end
            at some given position. Returns <c>false</c> if no more possible strings
            can match.
            </summary>
            <param name="position"> current position in the input string </param>
            <returns> position &gt;=0 if more possible solutions exist for the DFA </returns>
        </member>
        <member name="T:Lucene.Net.Index.BaseCompositeReader`1">
             <summary>
             Base class for implementing <see cref="T:Lucene.Net.Index.CompositeReader"/>s based on an array
             of sub-readers. The implementing class has to add code for
             correctly refcounting and closing the sub-readers.
            
             <para/>User code will most likely use <see cref="T:Lucene.Net.Index.MultiReader"/> to build a
             composite reader on a set of sub-readers (like several
             <see cref="T:Lucene.Net.Index.DirectoryReader"/>s).
            
             <para/> For efficiency, in this API documents are often referred to via
             <i>document numbers</i>, non-negative integers which each name a unique
             document in the index.  These document numbers are ephemeral -- they may change
             as documents are added to and deleted from an index.  Clients should thus not
             rely on a given document having the same number between sessions.
            
             <para/><b>NOTE</b>: 
             <see cref="T:Lucene.Net.Index.IndexReader"/> instances are completely thread
             safe, meaning multiple threads can call any of its methods,
             concurrently.  If your application requires external
             synchronization, you should <b>not</b> synchronize on the
             <see cref="T:Lucene.Net.Index.IndexReader"/> instance; use your own
             (non-Lucene) objects instead.
             <para/>
             @lucene.internal
             </summary>
             <seealso cref="T:Lucene.Net.Index.MultiReader"/>
        </member>
        <member name="F:Lucene.Net.Index.BaseCompositeReader`1.subReadersList">
            <summary>
            List view solely for <see cref="M:Lucene.Net.Index.BaseCompositeReader`1.GetSequentialSubReaders"/>,
            for effectiveness the array is used internally.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BaseCompositeReader`1.#ctor(`0[])">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Index.BaseCompositeReader`1"/> on the given <paramref name="subReaders"/>. </summary>
            <param name="subReaders"> the wrapped sub-readers. This array is returned by
            <see cref="M:Lucene.Net.Index.BaseCompositeReader`1.GetSequentialSubReaders"/> and used to resolve the correct
            subreader for docID-based methods. <b>Please note:</b> this array is <b>not</b>
            cloned and not protected for modification, the subclass is responsible
            to do this. </param>
        </member>
        <member name="M:Lucene.Net.Index.BaseCompositeReader`1.ReaderIndex(System.Int32)">
            <summary>
            Helper method for subclasses to get the corresponding reader for a doc ID </summary>
        </member>
        <member name="M:Lucene.Net.Index.BaseCompositeReader`1.ReaderBase(System.Int32)">
            <summary>
            Helper method for subclasses to get the docBase of the given sub-reader index. </summary>
        </member>
        <member name="T:Lucene.Net.Index.BinaryDocValues">
            <summary>
            A per-document <see cref="T:byte[]"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BinaryDocValues.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BinaryDocValues.Get(System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Lookup the value for document. </summary>
        </member>
        <member name="T:Lucene.Net.Index.BinaryDocValuesFieldUpdates">
            <summary>
            A <see cref="T:Lucene.Net.Index.DocValuesFieldUpdates"/> which holds updates of documents, of a single
            <see cref="T:Lucene.Net.Documents.BinaryDocValuesField"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.BinaryDocValuesWriter">
            <summary>
            Buffers up pending <see cref="T:byte[]"/> per doc, then flushes when
            segment flushes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.BinaryDocValuesWriter.MAX_LENGTH">
            <summary>
            Maximum length for a binary field. </summary>
        </member>
        <member name="T:Lucene.Net.Index.BitsSlice">
            <summary>
            Exposes a slice of an existing <see cref="T:Lucene.Net.Util.IBits"/> as a new <see cref="T:Lucene.Net.Util.IBits"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.BufferedUpdates">
            <summary>
            Holds buffered deletes and updates, by docID, term or query for a
            single segment. this is used to hold buffered pending
            deletes and updates against the to-be-flushed segment.  Once the
            deletes and updates are pushed (on flush in <see cref="T:Lucene.Net.Index.DocumentsWriter"/>), they
            are converted to a FrozenDeletes instance.
            <para/>
            NOTE: instances of this class are accessed either via a private
            instance on <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>, or via sync'd code by
            <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.BufferedUpdates.MAX_INT32">
            <summary>
            NOTE: This was MAX_INT in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.BufferedUpdatesStream">
            <summary>
            Tracks the stream of BufferedDeletes.
            When <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> flushes, its buffered
            deletes and updates are appended to this stream.  We later
            apply them (resolve them to the actual
            docIDs, per segment) when a merge is started
            (only to the to-be-merged segments).  We
            also apply to all segments when NRT reader is pulled,
            commit/close is called, or when too many deletes or  updates are
            buffered and must be flushed (by RAM usage or by count).
            <para/>
            Each packet is assigned a generation, and each flushed or
            merged segment is also assigned a generation, so we can
            track which BufferedDeletes packets to apply to any given
            segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BufferedUpdatesStream.Push(Lucene.Net.Index.FrozenBufferedUpdates)">
            <summary>
            Appends a new packet of buffered deletes to the stream,
            setting its generation:
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BufferedUpdatesStream.ApplyDeletesAndUpdates(Lucene.Net.Index.IndexWriter.ReaderPool,System.Collections.Generic.IList{Lucene.Net.Index.SegmentCommitInfo})">
            <summary>
            Resolves the buffered deleted Term/Query/docIDs, into
            actual deleted docIDs in the liveDocs <see cref="T:Lucene.Net.Util.IMutableBits"/> for
            each <see cref="T:Lucene.Net.Index.SegmentReader"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BufferedUpdatesStream.Prune(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Removes any BufferedDeletes that we no longer need to
            store because all segments in the index have had the
            deletes applied.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ByteSliceReader">
            <summary>
            <see cref="T:Lucene.Net.Store.IndexInput"/> that knows how to read the byte slices written
            by Posting and PostingVector. We read the bytes in
            each slice until we hit the end of that slice at which
            point we read the forwarding address of the next slice
            and then jump to it.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ByteSliceWriter">
            <summary>
            Class to write byte streams into slices of shared
            <see cref="T:byte[]"/>.  This is used by <see cref="T:Lucene.Net.Index.DocumentsWriter"/> to hold the
            posting list for many terms in RAM.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ByteSliceWriter.Init(System.Int32)">
            <summary>
            Set up the writer to write at address.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ByteSliceWriter.WriteByte(System.Byte)">
            <summary>
            Write byte into byte slice stream </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex">
             <summary>
             Basic tool and API to check the health of an index and
             write a new segments file that removes reference to
             problematic segments.
            
             <para/>As this tool checks every byte in the index, on a large
             index it can take quite a long time to run.
            
             <para/>
             Please make a complete backup of your
             index before using this to fix your index!
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status">
            <summary>
            Returned from <see cref="M:Lucene.Net.Index.CheckIndex.DoCheckIndex"/> detailing the health and status of the index.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.Clean">
            <summary>
            True if no problems were found with the index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.MissingSegments">
            <summary>
            True if we were unable to locate and load the segments_N file. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.CantOpenSegments">
            <summary>
            True if we were unable to open the segments_N file. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.MissingSegmentVersion">
            <summary>
            True if we were unable to read the version number from segments_N file. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentsFileName">
            <summary>
            Name of latest segments_N file in the index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.NumSegments">
            <summary>
            Number of segments in the index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentsChecked">
            <summary>
            Empty unless you passed specific segments list to check as optional 3rd argument. </summary>
            <seealso cref="M:Lucene.Net.Index.CheckIndex.DoCheckIndex(System.Collections.Generic.IList{System.String})"/>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.ToolOutOfDate">
            <summary>
            True if the index was created with a newer version of Lucene than the <see cref="T:Lucene.Net.Index.CheckIndex"/> tool. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfos">
            <summary>
            List of <see cref="T:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus"/> instances, detailing status of each segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.Dir">
            <summary>
            <see cref="T:Lucene.Net.Store.Directory"/> index is in. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.NewSegments">
            <summary>
            <see cref="T:Lucene.Net.Index.SegmentInfos"/> instance containing only segments that
            had no problems (this is used with the <see cref="M:Lucene.Net.Index.CheckIndex.FixIndex(Lucene.Net.Index.CheckIndex.Status)"/>
            method to repair the index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TotLoseDocCount">
            <summary>
            How many documents will be lost to bad segments. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.NumBadSegments">
            <summary>
            How many bad segments were found. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.Partial">
            <summary>
            True if we checked only specific segments 
            (<see cref="M:Lucene.Net.Index.CheckIndex.DoCheckIndex(System.Collections.Generic.IList{System.String})"/> was called with non-null
            argument).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.MaxSegmentName">
            <summary>
            The greatest segment name. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.ValidCounter">
            <summary>
            Whether the <see cref="P:Lucene.Net.Index.SegmentInfos.Counter"/> is greater than any of the segments' names. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.UserData">
            <summary>
            Holds the userData of the last commit in the index </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus">
            <summary>
            Holds the status of each segment in the index.
            See <see cref="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfos"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.Name">
            <summary>
            Name of the segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.Codec">
            <summary>
            Codec used to read this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocCount">
            <summary>
            Document count (does not take deletions into account). </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.Compound">
            <summary>
            True if segment is compound file format. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.NumFiles">
            <summary>
            Number of files referenced by this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.SizeMB">
            <summary>
            Net size (MB) of the files referenced by this
            segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocStoreOffset">
            <summary>
            Doc store offset, if this segment shares the doc
            store files (stored fields and term vectors) with
            other segments.  This is -1 if it does not share.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocStoreSegment">
            <summary>
            String of the shared doc store segment, or <c>null</c> if
            this segment does not share the doc store files.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocStoreCompoundFile">
            <summary>
            True if the shared doc store files are compound file
            format.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.HasDeletions">
            <summary>
            True if this segment has pending deletions. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DeletionsGen">
            <summary>
            Current deletions generation. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.NumDeleted">
            <summary>
            Number of deleted documents. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.OpenReaderPassed">
            <summary>
            True if we were able to open an <see cref="T:Lucene.Net.Index.AtomicReader"/> on this
            segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.NumFields">
            <summary>
            Number of fields in this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.Diagnostics">
            <summary>
            Map that includes certain
            debugging details that <see cref="T:Lucene.Net.Index.IndexWriter"/> records into
            each segment it creates
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.FieldNormStatus">
            <summary>
            Status for testing of field norms (<c>null</c> if field norms could not be tested). </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.TermIndexStatus">
            <summary>
            Status for testing of indexed terms (<c>null</c> if indexed terms could not be tested). </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.StoredFieldStatus">
            <summary>
            Status for testing of stored fields (<c>null</c> if stored fields could not be tested). </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.TermVectorStatus">
            <summary>
            Status for testing of term vectors (<c>null</c> if term vectors could not be tested). </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocValuesStatus">
            <summary>
            Status for testing of <see cref="T:Lucene.Net.Index.DocValues"/> (<c>null</c> if <see cref="T:Lucene.Net.Index.DocValues"/> could not be tested). </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.FieldNormStatus">
            <summary>
            Status from testing field norms.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.FieldNormStatus.TotFields">
            <summary>
            Number of fields successfully tested </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.FieldNormStatus.Error">
            <summary>
            Exception thrown during term index test (<c>null</c> on success) </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus">
            <summary>
            Status from testing term index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.TermCount">
            <summary>
            Number of terms with at least one live doc. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.DelTermCount">
            <summary>
            Number of terms with zero live docs docs. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.TotFreq">
            <summary>
            Total frequency across all terms. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.TotPos">
            <summary>
            Total number of positions. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.Error">
            <summary>
            Exception thrown during term index test (<c>null</c> on success) </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.BlockTreeStats">
            <summary>
            Holds details of block allocations in the block
            tree terms dictionary (this is only set if the
            <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> for this segment uses block
            tree.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus">
            <summary>
            Status from testing stored fields.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus.DocCount">
            <summary>
            Number of documents tested. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus.TotFields">
            <summary>
            Total number of stored fields tested. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus.Error">
            <summary>
            Exception thrown during stored fields test (<c>null</c> on success) </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.TermVectorStatus">
            <summary>
            Status from testing stored fields.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermVectorStatus.DocCount">
            <summary>
            Number of documents tested. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermVectorStatus.TotVectors">
            <summary>
            Total number of term vectors tested. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermVectorStatus.Error">
            <summary>
            Exception thrown during term vector test (<c>null</c> on success) </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus">
            <summary>
            Status from testing <see cref="T:Lucene.Net.Index.DocValues"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalValueFields">
            <summary>
            Total number of docValues tested. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalNumericFields">
            <summary>
            Total number of numeric fields </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalBinaryFields">
            <summary>
            Total number of binary fields </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalSortedFields">
            <summary>
            Total number of sorted fields </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalSortedSetFields">
            <summary>
            Total number of sortedset fields </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.Error">
            <summary>
            Exception thrown during doc values test (<c>null</c> on success) </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Index.CheckIndex"/> on the directory. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.CrossCheckTermVectors">
            <summary>
            If <c>true</c>, term vectors are compared against postings to
            make sure they are the same.  This will likely
            drastically increase time it takes to run <see cref="T:Lucene.Net.Index.CheckIndex"/>!
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.InfoStream">
            <summary>
            Gets or Sets infoStream where messages should go.  If null, no
            messages are printed.  If <see cref="P:Lucene.Net.Index.CheckIndex.InfoStreamIsVerbose"/> is <c>true</c> then more
            details are printed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.InfoStreamIsVerbose">
            <summary>
            If <c>true</c>, prints more details to the <see cref="P:Lucene.Net.Index.CheckIndex.InfoStream"/>, if set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.DoCheckIndex">
             <summary>
             Returns a <see cref="T:Lucene.Net.Index.CheckIndex.Status"/> instance detailing
             the state of the index.
            
             <para/>As this method checks every byte in the index, on a large
             index it can take quite a long time to run.
            
             <para/><b>WARNING</b>: make sure
             you only call this when the index is not opened by any
             writer.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.DoCheckIndex(System.Collections.Generic.IList{System.String})">
             <summary>
             Returns a <see cref="T:Lucene.Net.Index.CheckIndex.Status"/> instance detailing
             the state of the index.
             </summary>
             <param name="onlySegments"> list of specific segment names to check
            
             <para/>As this method checks every byte in the specified
             segments, on a large index it can take quite a long
             time to run.
            
             <para/><b>WARNING</b>: make sure
             you only call this when the index is not opened by any
             writer.  </param>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestFieldNorms(Lucene.Net.Index.AtomicReader,System.IO.TextWriter)">
            <summary>
            Test field norms.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.CheckFields(Lucene.Net.Index.Fields,Lucene.Net.Util.IBits,System.Int32,Lucene.Net.Index.FieldInfos,System.Boolean,System.Boolean,System.IO.TextWriter,System.Boolean)">
            <summary>
            Checks <see cref="T:Lucene.Net.Index.Fields"/> api is consistent with itself.
            Searcher is optional, to verify with queries. Can be <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestPostings(Lucene.Net.Index.AtomicReader,System.IO.TextWriter)">
            <summary>
            Test the term index.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestPostings(Lucene.Net.Index.AtomicReader,System.IO.TextWriter,System.Boolean)">
            <summary>
            Test the term index.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestStoredFields(Lucene.Net.Index.AtomicReader,System.IO.TextWriter)">
            <summary>
            Test stored fields.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestDocValues(Lucene.Net.Index.AtomicReader,System.IO.TextWriter)">
            <summary>
            Test docvalues.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestTermVectors(Lucene.Net.Index.AtomicReader,System.IO.TextWriter)">
            <summary>
            Test term vectors.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestTermVectors(Lucene.Net.Index.AtomicReader,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Test term vectors.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.FixIndex(Lucene.Net.Index.CheckIndex.Status)">
             <summary>
             Repairs the index using previously returned result
             from <see cref="M:Lucene.Net.Index.CheckIndex.DoCheckIndex"/>.  Note that this does not
             remove any of the unreferenced files after it's done;
             you must separately open an <see cref="T:Lucene.Net.Index.IndexWriter"/>, which
             deletes unreferenced files when it's created.
            
             <para/><b>WARNING</b>: this writes a
             new segments file into the index, effectively removing
             all documents in broken segments from the index.
             BE CAREFUL.
            
             <para/><b>WARNING</b>: Make sure you only call this when the
             index is not opened by any writer.
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.CompositeReader">
             <summary>
             Instances of this reader type can only
             be used to get stored fields from the underlying <see cref="T:Lucene.Net.Index.AtomicReader"/>s,
             but it is not possible to directly retrieve postings. To do that, get
             the <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> for all sub-readers via <see cref="P:Lucene.Net.Index.AtomicReaderContext.Leaves"/>.
             Alternatively, you can mimic an <see cref="T:Lucene.Net.Index.AtomicReader"/> (with a serious slowdown),
             by wrapping composite readers with <see cref="T:Lucene.Net.Index.SlowCompositeReaderWrapper"/>.
            
             <para/><see cref="T:Lucene.Net.Index.IndexReader"/> instances for indexes on disk are usually constructed
             with a call to one of the static <c>DirectoryReader.Open()</c> methods,
             e.g. <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory)"/>. <see cref="T:Lucene.Net.Index.DirectoryReader"/> implements
             the <see cref="T:Lucene.Net.Index.CompositeReader"/> interface, it is not possible to directly get postings.
             <para/> Concrete subclasses of <see cref="T:Lucene.Net.Index.IndexReader"/> are usually constructed with a call to
             one of the static <c>Open()</c> methods, e.g. <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory)"/>.
            
             <para/> For efficiency, in this API documents are often referred to via
             <i>document numbers</i>, non-negative integers which each name a unique
             document in the index.  These document numbers are ephemeral -- they may change
             as documents are added to and deleted from an index.  Clients should thus not
             rely on a given document having the same number between sessions.
            
             <para/>
             <b>NOTE</b>: 
             <see cref="T:Lucene.Net.Index.IndexReader"/> instances are completely thread
             safe, meaning multiple threads can call any of its methods,
             concurrently.  If your application requires external
             synchronization, you should <b>not</b> synchronize on the
             <see cref="T:Lucene.Net.Index.IndexReader"/> instance; use your own
             (non-Lucene) objects instead.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompositeReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompositeReader.GetSequentialSubReaders">
             <summary>
             Expert: returns the sequential sub readers that this
             reader is logically composed of. This method may not
             return <c>null</c>.
            
             <para/><b>NOTE:</b> In contrast to previous Lucene versions this method
             is no longer public, code that wants to get all <see cref="T:Lucene.Net.Index.AtomicReader"/>s
             this composite is composed of should use <see cref="P:Lucene.Net.Index.IndexReader.Leaves"/>. </summary>
             <seealso cref="P:Lucene.Net.Index.IndexReader.Leaves"/>
        </member>
        <member name="T:Lucene.Net.Index.CompositeReaderContext">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexReaderContext"/> for <see cref="T:Lucene.Net.Index.CompositeReader"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompositeReaderContext.#ctor(Lucene.Net.Index.CompositeReaderContext,Lucene.Net.Index.CompositeReader,System.Int32,System.Int32,System.Collections.Generic.IList{Lucene.Net.Index.IndexReaderContext})">
            <summary>
            Creates a <see cref="T:Lucene.Net.Index.CompositeReaderContext"/> for intermediate readers that aren't
            not top-level readers in the current context
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompositeReaderContext.#ctor(Lucene.Net.Index.CompositeReader,System.Collections.Generic.IList{Lucene.Net.Index.IndexReaderContext},System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext})">
            <summary>
            Creates a <see cref="T:Lucene.Net.Index.CompositeReaderContext"/> for top-level readers with parent set to <c>null</c>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ConcurrentMergeScheduler">
             <summary>
             A <see cref="T:Lucene.Net.Index.MergeScheduler"/> that runs each merge using a
             separate thread.
            
             <para>Specify the max number of threads that may run at
             once, and the maximum number of simultaneous merges
             with <see cref="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMaxMergesAndThreads(System.Int32,System.Int32)"/>.</para>
            
             <para>If the number of merges exceeds the max number of threads
             then the largest merges are paused until one of the smaller
             merges completes.</para>
            
             <para>If more than <see cref="P:Lucene.Net.Index.ConcurrentMergeScheduler.MaxMergeCount"/> merges are
             requested then this class will forcefully throttle the
             incoming threads by pausing until one more more merges
             complete.</para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.m_mergeThreads">
            <summary>
            List of currently active <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/>s. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.DEFAULT_MAX_THREAD_COUNT">
            <summary>
            Default <see cref="P:Lucene.Net.Index.ConcurrentMergeScheduler.MaxThreadCount"/>.
            We default to 1: tests on spinning-magnet drives showed slower
            indexing performance if more than one merge thread runs at
            once (though on an SSD it was faster)
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.DEFAULT_MAX_MERGE_COUNT">
            <summary>
            Default <see cref="P:Lucene.Net.Index.ConcurrentMergeScheduler.MaxMergeCount"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.m_dir">
            <summary>
            <see cref="T:Lucene.Net.Store.Directory"/> that holds the index. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.m_writer">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexWriter"/> that owns this instance. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.m_mergeThreadCount">
            <summary>
            How many <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/>s have kicked off (this is use
            to name them).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.#ctor">
            <summary>
            Sole constructor, with all settings set to default
            values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMaxMergesAndThreads(System.Int32,System.Int32)">
            <summary>
            Sets the maximum number of merge threads and simultaneous merges allowed.
            </summary>
            <param name="maxMergeCount"> the max # simultaneous merges that are allowed.
                  If a merge is necessary yet we already have this many
                  threads running, the incoming thread (that is calling
                  add/updateDocument) will block until a merge thread
                  has completed.  Note that we will only run the
                  smallest <paramref name="maxThreadCount"/> merges at a time. </param>
            <param name="maxThreadCount"> The max # simultaneous merge threads that should
                  be running at once.  This must be &lt;= <paramref name="maxMergeCount"/> </param>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MaxThreadCount">
            <summary>
            Returns <see cref="F:Lucene.Net.Index.ConcurrentMergeScheduler.maxThreadCount"/>.
            </summary>
            <seealso cref="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMaxMergesAndThreads(System.Int32,System.Int32)"/>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MaxMergeCount">
            <summary>
            See <see cref="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMaxMergesAndThreads(System.Int32,System.Int32)"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThreadPriority">
            <summary>
            Return the priority that merge threads run at.  By
            default the priority is 1 plus the priority of (ie,
            slightly higher priority than) the first thread that
            calls merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMergeThreadPriority(System.Int32)">
            <summary>
            Set the base priority that merge threads run at.
            Note that CMS may increase priority of some merge
            threads beyond this base priority.  It's best not to
            set this any higher than
            <see cref="F:System.Threading.ThreadPriority.Highest"/>(4)-maxThreadCount, so that CMS has
            room to set relative priority among threads.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.compareByMergeDocCount">
            <summary>
            Sorts <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/>s; larger merges come first. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.UpdateMergeThreads">
            <summary>
            Called whenever the running merges have changed, to pause &amp; unpause
            threads. This method sorts the merge threads by their merge size in
            descending order and then pauses/unpauses threads from first to last --
            that way, smaller merges are guaranteed to run before larger ones.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.IsVerbose">
             <summary>
             Returns <c>true</c> if verbosing is enabled. This method is usually used in
             conjunction with <see cref="M:Lucene.Net.Index.ConcurrentMergeScheduler.Message(System.String)"/>, like that:
            
             <code>
             if (IsVerbose) 
             {
                 Message(&quot;your message&quot;);
             }
             </code>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.Message(System.String)">
            <summary>
            Outputs the given message - this method assumes <see cref="P:Lucene.Net.Index.ConcurrentMergeScheduler.IsVerbose"/> was
            called and returned <c>true</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.Sync">
            <summary>
            Wait for any running merge threads to finish. This call is not interruptible as used by <see cref="M:Lucene.Net.Index.ConcurrentMergeScheduler.Dispose(System.Boolean)"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThreadCount">
            <summary>
            Returns the number of merge threads that are alive. Note that this number
            is &lt;= <see cref="F:Lucene.Net.Index.ConcurrentMergeScheduler.m_mergeThreads"/> size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.DoMerge(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does the actual merge, by calling <see cref="M:Lucene.Net.Index.IndexWriter.Merge(Lucene.Net.Index.MergePolicy.OneMerge)"/> </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.GetMergeThread(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Create and return a new <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/> </summary>
        </member>
        <member name="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread">
            <summary>
            Runs a merge thread, which may run one or more merges
            in sequence.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.#ctor(Lucene.Net.Index.ConcurrentMergeScheduler,Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.RunningMerge">
            <summary>
            Record the currently running merge. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.CurrentMerge">
            <summary>
            Return the current merge, or <c>null</c> if this 
            <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/> is done.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.SetThreadPriority(System.Threading.ThreadPriority)">
            <summary>
            Set the priority of this thread. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.HandleMergeException(System.Exception)">
            <summary>
            Called when an exception is hit in a background merge
            thread
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetSuppressExceptions">
            <summary>
            Used for testing </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.ClearSuppressExceptions">
            <summary>
            Used for testing </summary>
        </member>
        <member name="T:Lucene.Net.Index.CorruptIndexException">
            <summary>
            This exception is thrown when Lucene detects
            an inconsistency in the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CorruptIndexException.#ctor(System.String)">
            <summary>
            Constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CorruptIndexException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CorruptIndexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Index.DirectoryReader">
             <summary>
             <see cref="T:Lucene.Net.Index.DirectoryReader"/> is an implementation of <see cref="T:Lucene.Net.Index.CompositeReader"/>
             that can read indexes in a <see cref="T:Lucene.Net.Store.Directory"/>.
            
             <para/><see cref="T:Lucene.Net.Index.DirectoryReader"/> instances are usually constructed with a call to
             one of the static <c>Open()</c> methods, e.g. <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory)"/>.
            
             <para/> For efficiency, in this API documents are often referred to via
             <i>document numbers</i>, non-negative integers which each name a unique
             document in the index.  These document numbers are ephemeral -- they may change
             as documents are added to and deleted from an index.  Clients should thus not
             rely on a given document having the same number between sessions.
            
             <para/><b>NOTE</b>:
             <see cref="T:Lucene.Net.Index.IndexReader"/> instances are completely thread
             safe, meaning multiple threads can call any of its methods,
             concurrently.  If your application requires external
             synchronization, you should <b>not</b> synchronize on the
             <see cref="T:Lucene.Net.Index.IndexReader"/> instance; use your own
             (non-Lucene) objects instead.
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR">
            <summary>
            Default termInfosIndexDivisor. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DirectoryReader.m_directory">
            <summary>
            The index directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Store.Directory"/> </summary>
            <param name="directory"> the index directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory,System.Int32)">
            <summary>
            Expert: Returns a <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Store.Directory"/> with the given termInfosIndexDivisor. </summary>
            <param name="directory"> the index directory </param>
            <param name="termInfosIndexDivisor"> Subsamples which indexed
            terms are loaded into RAM. this has the same effect as setting
            <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/> (on <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>) except that setting
            must be done at indexing time while this setting can be
            set per reader.  When set to N, then one in every
            N*termIndexInterval terms in the index is loaded into
            memory.  By setting this to a value &gt; 1 you can reduce
            memory usage, at the expense of higher latency when
            loading a TermInfo.  The default value is 1.  Set this
            to -1 to skip loading the terms index entirely.
            <b>NOTE:</b> divisor settings &gt; 1 do not apply to all <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>
            implementations, including the default one in this release. It only makes
            sense for terms indexes that can efficiently re-sample terms at load time. </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)">
            <summary>
            Open a near real time <see cref="T:Lucene.Net.Index.IndexReader"/> from the <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            <para/>
            @lucene.experimental 
            </summary>
            <param name="writer"> The <see cref="T:Lucene.Net.Index.IndexWriter"/> to open from </param>
            <param name="applyAllDeletes"> If <c>true</c>, all buffered deletes will
            be applied (made visible) in the returned reader.  If
            <c>false</c>, the deletes are not applied but remain buffered
            (in IndexWriter) so that they will be applied in the
            future.  Applying deletes can be costly, so if your app
            can tolerate deleted documents being returned you might
            gain some performance by passing <c>false</c>. </param>
            <returns> The new <see cref="T:Lucene.Net.Index.IndexReader"/> </returns>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error
            </exception>
            <seealso cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexWriter,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexCommit)">
            <summary>
            Expert: returns an <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Index.IndexCommit"/>. </summary>
            <param name="commit"> the commit point to open </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexCommit,System.Int32)">
            <summary>
            Expert: returns an <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <seealso cref="T:Lucene.Net.Index.IndexCommit"/> and <paramref name="termInfosIndexDivisor"/>. </summary>
            <param name="commit"> the commit point to open </param>
            <param name="termInfosIndexDivisor"> Subsamples which indexed
            terms are loaded into RAM. this has the same effect as setting
            <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/> (on <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>) except that setting
            must be done at indexing time while this setting can be
            set per reader.  When set to N, then one in every
            N*termIndexInterval terms in the index is loaded into
            memory.  By setting this to a value &gt; 1 you can reduce
            memory usage, at the expense of higher latency when
            loading a TermInfo.  The default value is 1.  Set this
            to -1 to skip loading the terms index entirely.
            <b>NOTE:</b> divisor settings &gt; 1 do not apply to all <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>
            implementations, including the default one in this release. It only makes
            sense for terms indexes that can efficiently re-sample terms at load time. </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)">
             <summary>
             If the index has changed since the provided reader was
             opened, open and return a new reader; else, return
             <c>null</c>.  The new reader, if not <c>null</c>, will be the same
             type of reader as the previous one, ie a near-real-time (NRT) reader
             will open a new NRT reader, a <see cref="T:Lucene.Net.Index.MultiReader"/> will open a
             new <see cref="T:Lucene.Net.Index.MultiReader"/>,  etc.
            
             <para/>This method is typically far less costly than opening a
             fully new <see cref="T:Lucene.Net.Index.DirectoryReader"/> as it shares
             resources (for example sub-readers) with the provided
             <see cref="T:Lucene.Net.Index.DirectoryReader"/>, when possible.
            
             <para/>The provided reader is not disposed (you are responsible
             for doing so); if a new reader is returned you also
             must eventually dispose it.  Be sure to never dispose a
             reader while other threads are still using it; see
             <see cref="T:Lucene.Net.Search.SearcherManager"/> to simplify managing this.
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
             <returns> <c>null</c> if there are no changes; else, a new
             <see cref="T:Lucene.Net.Index.DirectoryReader"/> instance which you must eventually dispose </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexCommit)">
            <summary>
            If the <see cref="T:Lucene.Net.Index.IndexCommit"/> differs from what the
            provided reader is searching, open and return a new
            reader; else, return <c>null</c>.
            </summary>
            <seealso cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)"/>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexWriter,System.Boolean)">
             <summary>
             Expert: If there changes (committed or not) in the
             <see cref="T:Lucene.Net.Index.IndexWriter"/> versus what the provided reader is
             searching, then open and return a new
             <see cref="T:Lucene.Net.Index.IndexReader"/> searching both committed and uncommitted
             changes from the writer; else, return <c>null</c> (though, the
             current implementation never returns <c>null</c>).
            
             <para/>This provides "near real-time" searching, in that
             changes made during an <see cref="T:Lucene.Net.Index.IndexWriter"/> session can be
             quickly made available for searching without closing
             the writer nor calling <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>.
            
             <para>It's <i>near</i> real-time because there is no hard
             guarantee on how quickly you can get a new reader after
             making changes with <see cref="T:Lucene.Net.Index.IndexWriter"/>.  You'll have to
             experiment in your situation to determine if it's
             fast enough.  As this is a new and experimental
             feature, please report back on your findings so we can
             learn, improve and iterate.</para>
            
             <para>The very first time this method is called, this
             writer instance will make every effort to pool the
             readers that it opens for doing merges, applying
             deletes, etc.  This means additional resources (RAM,
             file descriptors, CPU time) will be consumed.</para>
            
             <para>For lower latency on reopening a reader, you should
             call <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MergedSegmentWarmer"/> (on <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>) to
             pre-warm a newly merged segment before it's committed
             to the index.  This is important for minimizing
             index-to-search delay after a large merge.  </para>
            
             <para>If an AddIndexes* call is running in another thread,
             then this reader will only search those segments from
             the foreign index that have been successfully copied
             over, so far.</para>
            
             <para><b>NOTE</b>: Once the writer is disposed, any
             outstanding readers may continue to be used.  However,
             if you attempt to reopen any of those readers, you'll
             hit an <see cref="T:System.ObjectDisposedException"/>.</para>
             
             @lucene.experimental
             </summary>
             <returns> <see cref="T:Lucene.Net.Index.DirectoryReader"/> that covers entire index plus all
             changes made so far by this <see cref="T:Lucene.Net.Index.IndexWriter"/> instance, or
             <c>null</c> if there are no new changes
             </returns>
             <param name="writer"> The <see cref="T:Lucene.Net.Index.IndexWriter"/> to open from
             </param>
             <param name="applyAllDeletes"> If <c>true</c>, all buffered deletes will
             be applied (made visible) in the returned reader.  If
             <c>false</c>, the deletes are not applied but remain buffered
             (in <see cref="T:Lucene.Net.Index.IndexWriter"/>) so that they will be applied in the
             future.  Applying deletes can be costly, so if your app
             can tolerate deleted documents being returned you might
             gain some performance by passing <c>false</c>.
             </param>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.ListCommits(Lucene.Net.Store.Directory)">
            <summary>
            Returns all commit points that exist in the <see cref="T:Lucene.Net.Store.Directory"/>.
            Normally, because the default is 
            <see cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/>, there would be only
            one commit point.  But if you're using a custom
            <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> then there could be many commits.
            Once you have a given commit, you can open a reader on
            it by calling <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexCommit)"/>
            There must be at least one commit in
            the <see cref="T:Lucene.Net.Store.Directory"/>, else this method throws 
            <see cref="T:Lucene.Net.Index.IndexNotFoundException"/>.  Note that if a commit is in
            progress while this method is running, that commit
            may or may not be returned.
            </summary>
            <returns> a sorted list of <see cref="T:Lucene.Net.Index.IndexCommit"/>s, from oldest
            to latest. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.IndexExists(Lucene.Net.Store.Directory)">
            <summary>
            Returns <c>true</c> if an index likely exists at
            the specified directory.  Note that if a corrupt index
            exists, or if an index in the process of committing </summary>
            <param name="directory"> the directory to check for an index </param>
            <returns> <c>true</c> if an index exists; <c>false</c> otherwise </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.AtomicReader[])">
            <summary>
            Expert: Constructs a <see cref="T:Lucene.Net.Index.DirectoryReader"/> on the given <paramref name="segmentReaders"/>. </summary>
            <param name="segmentReaders"> the wrapped atomic index segment readers. This array is
            returned by <see cref="M:Lucene.Net.Index.CompositeReader.GetSequentialSubReaders"/> and used to resolve the correct
            subreader for docID-based methods. <b>Please note:</b> this array is <b>not</b>
            cloned and not protected for modification outside of this reader.
            Subclasses of <see cref="T:Lucene.Net.Index.DirectoryReader"/> should take care to not allow
            modification of this internal array, e.g. <see cref="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged"/>. </param>
        </member>
        <member name="P:Lucene.Net.Index.DirectoryReader.Directory">
            <summary>
            Returns the directory this index resides in. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged">
            <summary>
            Implement this method to support <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)"/>.
            If this reader does not support reopen, return <c>null</c>, so
            client code is happy. This should be consistent with <see cref="M:Lucene.Net.Index.DirectoryReader.IsCurrent"/>
            (should always return <c>true</c>) if reopen is not supported. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <returns> <c>null</c> if there are no changes; else, a new
            <see cref="T:Lucene.Net.Index.DirectoryReader"/> instance. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged(Lucene.Net.Index.IndexCommit)">
            <summary>
            Implement this method to support <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexCommit)"/>.
            If this reader does not support reopen from a specific <see cref="T:Lucene.Net.Index.IndexCommit"/>,
            throw <see cref="T:System.NotSupportedException"/>. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <returns> <c>null</c> if there are no changes; else, a new
            <see cref="T:Lucene.Net.Index.DirectoryReader"/> instance. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged(Lucene.Net.Index.IndexWriter,System.Boolean)">
            <summary>
            Implement this method to support <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexWriter,System.Boolean)"/>.
            If this reader does not support reopen from <see cref="T:Lucene.Net.Index.IndexWriter"/>,
            throw <see cref="T:System.NotSupportedException"/>. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <returns> <c>null</c> if there are no changes; else, a new
            <see cref="T:Lucene.Net.Index.DirectoryReader"/> instance. </returns>
        </member>
        <member name="P:Lucene.Net.Index.DirectoryReader.Version">
             <summary>
             Version number when this <see cref="T:Lucene.Net.Index.IndexReader"/> was opened.
            
             <para>This method
             returns the version recorded in the commit that the
             reader opened.  This version is advanced every time
             a change is made with <see cref="T:Lucene.Net.Index.IndexWriter"/>.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.IsCurrent">
             <summary>
             Check whether any new changes have occurred to the
             index since this reader was opened.
            
             <para>If this reader was created by calling an overload of <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory)"/>,
             then this method checks if any further commits
             (see <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>) have occurred in the
             directory.</para>
            
             <para>If instead this reader is a near real-time reader
             (ie, obtained by a call to 
             <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/>, or by calling an overload of <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)"/>
             on a near real-time reader), then this method checks if
             either a new commit has occurred, or any new
             uncommitted changes have taken place via the writer.
             Note that even if the writer has only performed
             merging, this method will still return <c>false</c>.</para>
            
             <para>In any event, if this returns <c>false</c>, you should call
             an overload of <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)"/> to get a new reader that sees the
             changes.</para>
             </summary>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="P:Lucene.Net.Index.DirectoryReader.IndexCommit">
            <summary>
            Expert: return the <see cref="T:Lucene.Net.Index.IndexCommit"/> that this reader has opened.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumer.Flush(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Index.DocFieldConsumerPerField},Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Called when <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> decides to create a new
            segment
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumer.Abort">
            <summary>
            Called when an aborting exception is hit </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumerPerField.ProcessFields(Lucene.Net.Index.IIndexableField[],System.Int32)">
            <summary>
            Processes all occurrences of a single field </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocFieldProcessor">
            <summary>
            This is a <see cref="T:Lucene.Net.Index.DocConsumer"/> that gathers all fields under the
            same name, and calls per-field consumers to process field
            by field.  This class doesn't doesn't do any "real" work
            of its own: it just forwards the fields to a
            <see cref="T:Lucene.Net.Index.DocFieldConsumer"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocFieldProcessorPerField">
            <summary>
            Holds all per thread, per field state.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocInverter">
            <summary>
            This is a <see cref="T:Lucene.Net.Index.DocFieldConsumer"/> that inverts each field,
            separately, from a <see cref="T:Lucene.Net.Documents.Document"/>, and accepts a
            <see cref="T:Lucene.Net.Index.InvertedDocConsumer"/> to process those terms.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocInverterPerField">
            <summary>
            Holds state for inverting all occurrences of a single
            field in the document.  This class doesn't do anything
            itself; instead, it forwards the tokens produced by
            analysis to its own consumer
            (<see cref="T:Lucene.Net.Index.InvertedDocConsumerPerField"/>).  It also interacts with an
            endConsumer (<see cref="T:Lucene.Net.Index.InvertedDocEndConsumerPerField"/>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsAndPositionsFlags.NONE">
            <summary>
            Flag to pass to <see cref="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum,Lucene.Net.Index.DocsAndPositionsFlags)"/> 
            if you require that no offsets and payloads will be returned.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsAndPositionsFlags.OFFSETS">
            <summary>
            Flag to pass to <see cref="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum,Lucene.Net.Index.DocsAndPositionsFlags)"/>
            if you require offsets in the returned enum.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsAndPositionsFlags.PAYLOADS">
            <summary>
            Flag to pass to  <see cref="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum,Lucene.Net.Index.DocsAndPositionsFlags)"/>
            if you require payloads in the returned enum.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocsAndPositionsEnum">
            <summary>
            Also iterates through positions. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsAndPositionsEnum.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsAndPositionsEnum.NextPosition">
            <summary>
            Returns the next position.  You should only call this
            up to <see cref="P:Lucene.Net.Index.DocsEnum.Freq"/> times else
            the behavior is not defined.  If positions were not
            indexed this will return -1; this only happens if
            offsets were indexed and you passed needsOffset=true
            when pulling the enum.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocsAndPositionsEnum.StartOffset">
            <summary>
            Returns start offset for the current position, or -1
            if offsets were not indexed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocsAndPositionsEnum.EndOffset">
            <summary>
            Returns end offset for the current position, or -1 if
            offsets were not indexed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsAndPositionsEnum.GetPayload">
            <summary>
            Returns the payload at this position, or <c>null</c> if no
            payload was indexed. You should not modify anything
            (neither members of the returned <see cref="T:Lucene.Net.Util.BytesRef"/> nor bytes
            in the <see cref="T:byte[]"/>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsFlags.NONE">
            <summary>
            Flag to pass to <see cref="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum,Lucene.Net.Index.DocsFlags)"/> if you don't
            require term frequencies in the returned enum.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsFlags.FREQS">
            <summary>
            Flag to pass to <see cref="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum,Lucene.Net.Index.DocsFlags)"/>
            if you require term frequencies in the returned enum.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocsEnum">
            <summary>
            Iterates through the documents and term freqs.
            NOTE: you must first call <see cref="M:Lucene.Net.Search.DocIdSetIterator.NextDoc"/> before using
            any of the per-doc methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsEnum.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocsEnum.Freq">
             <summary>
             Returns term frequency in the current document, or 1 if the field was
             indexed with <see cref="F:Lucene.Net.Index.IndexOptions.DOCS_ONLY"/>. Do not call this before
             <see cref="M:Lucene.Net.Search.DocIdSetIterator.NextDoc"/> is first called, nor after <see cref="M:Lucene.Net.Search.DocIdSetIterator.NextDoc"/> returns
             <see cref="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS"/>.
            
             <para/>
             <b>NOTE:</b> if the <see cref="T:Lucene.Net.Index.DocsEnum"/> was obtain with <see cref="F:Lucene.Net.Index.DocsFlags.NONE"/>,
             the result of this method is undefined.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocsEnum.Attributes">
            <summary>
            Returns the related attributes. </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocTermOrds">
            <summary>
            This class enables fast access to multiple term ords for
            a specified field across all docIDs.
            <para/>
            Like <see cref="T:Lucene.Net.Search.IFieldCache"/>, it uninverts the index and holds a
            packed data structure in RAM to enable fast access.
            Unlike <see cref="T:Lucene.Net.Search.IFieldCache"/>, it can handle multi-valued fields,
            and, it does not hold the term bytes in RAM.  Rather, you
            must obtain a <see cref="T:Lucene.Net.Index.TermsEnum"/> from the <see cref="M:Lucene.Net.Index.DocTermOrds.GetOrdTermsEnum(Lucene.Net.Index.AtomicReader)"/>
            method, and then seek-by-ord to get the term's bytes.
            <para/>
            While normally term ords are type <see cref="T:System.Int64"/>, in this API they are
            <see cref="T:System.Int32"/> as the internal representation here cannot address
            more than <see cref="F:Lucene.Net.Index.BufferedUpdates.MAX_INT32"/> unique terms.  Also, typically this
            class is used on fields with relatively few unique terms
            vs the number of documents.  In addition, there is an
            internal limit (16 MB) on how many bytes each chunk of
            documents may consume.  If you trip this limit you'll hit
            an <see cref="T:System.InvalidOperationException"/>.
            <para/>
            Deleted documents are skipped during uninversion, and if
            you look them up you'll get 0 ords.
            <para/>
            The returned per-document ords do not retain their
            original order in the document.  Instead they are returned
            in sorted (by ord, ie term's <see cref="T:Lucene.Net.Util.BytesRef"/> comparer) order.  They
            are also de-dup'd (ie if doc has same term more than once
            in this field, you'll only get that ord back once).
            <para/>
            This class tests whether the provided reader is able to
            retrieve terms by ord (ie, it's single segment, and it
            uses an ord-capable terms index).  If not, this class
            will create its own term index internally, allowing to
            create a wrapped <see cref="T:Lucene.Net.Index.TermsEnum"/> that can handle ord.  The
            <see cref="M:Lucene.Net.Index.DocTermOrds.GetOrdTermsEnum(Lucene.Net.Index.AtomicReader)"/> method then provides this
            wrapped enum, if necessary.
            <para/>
            The RAM consumption of this class can be high!
            <para/>
            @lucene.experimental
            </summary>
            <remarks>
            Final form of the un-inverted field:
            <list type="bullet">
                <item><description>Each document points to a list of term numbers that are contained in that document.</description></item>
                <item><description>
                    Term numbers are in sorted order, and are encoded as variable-length deltas from the
                    previous term number.  Real term numbers start at 2 since 0 and 1 are reserved.  A
                    term number of 0 signals the end of the termNumber list.
                </description></item>
                <item><description>
                    There is a single int[maxDoc()] which either contains a pointer into a byte[] for
                    the termNumber lists, or directly contains the termNumber list if it fits in the 4
                    bytes of an integer.  If the first byte in the integer is 1, the next 3 bytes
                    are a pointer into a byte[] where the termNumber list starts.
                </description></item>
                <item><description>
                    There are actually 256 byte arrays, to compensate for the fact that the pointers
                    into the byte arrays are only 3 bytes long.  The correct byte array for a document
                    is a function of it's id.
                </description></item>
                <item><description>
                    To save space and speed up faceting, any term that matches enough documents will
                    not be un-inverted... it will be skipped while building the un-inverted field structure,
                    and will use a set intersection method during faceting.
                </description></item>
                <item><description>
                    To further save memory, the terms (the actual string values) are not all stored in
                    memory, but a TermIndex is used to convert term numbers to term values only
                    for the terms needed after faceting has completed.  Only every 128th term value
                    is stored, along with it's corresponding term number, and this is used as an
                    index to find the closest term and iterate until the desired number is hit (very
                    much like Lucene's own internal term index).
                </description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.TNUM_OFFSET">
            <summary>
            Term ords are shifted by this, internally, to reserve
            values 0 (end term) and 1 (index is a pointer into byte array)
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.DEFAULT_INDEX_INTERVAL_BITS">
            <summary>
            Every 128th term is indexed, by default. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_maxTermDocFreq">
            <summary>
            Don't uninvert terms that exceed this count. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_field">
            <summary>
            Field we are uninverting. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_numTermsInField">
            <summary>
            Number of terms in the field. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_termInstances">
            <summary>
            Total number of references to term numbers. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_total_time">
            <summary>
            Total time to uninvert the field. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_phase1_time">
            <summary>
            Time for phase1 of the uninvert process. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_index">
            <summary>
            Holds the per-document ords or a pointer to the ords. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_tnums">
            <summary>
            Holds term ords for documents. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_sizeOfIndexedStrings">
            <summary>
            Total bytes (sum of term lengths) for all indexed terms. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_indexedTermsArray">
            <summary>
            Holds the indexed (by default every 128th) terms. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_prefix">
            <summary>
            If non-null, only terms matching this prefix were
            indexed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_ordBase">
            <summary>
            Ordinal of the first term in the field, or 0 if the
            <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> does not implement 
            <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_docsEnum">
            <summary>
            Used while uninverting. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.RamUsedInBytes">
            <summary>
            Returns total bytes used. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.IBits,System.String)">
            <summary>
            Inverts all terms </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Inverts only terms starting w/ prefix </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            Inverts only terms starting w/ prefix, and only terms
            whose docFreq (not taking deletions into account) is
            &lt;= <paramref name="maxTermDocFreq"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef,System.Int32,System.Int32)">
            <summary>
            Inverts only terms starting w/ prefix, and only terms
            whose docFreq (not taking deletions into account) is
            &lt;=  <paramref name="maxTermDocFreq"/>, with a custom indexing interval
            (default is every 128nd term).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Subclass inits w/ this, but be sure you then call
            uninvert, only once
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.GetOrdTermsEnum(Lucene.Net.Index.AtomicReader)">
             <summary>
             Returns a <see cref="T:Lucene.Net.Index.TermsEnum"/> that implements <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>.  If the
             provided <paramref name="reader"/> supports <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>, we just return its
             <see cref="T:Lucene.Net.Index.TermsEnum"/>; if it does not, we build a "private" terms
             index internally (WARNING: consumes RAM) and use that
             index to implement <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>.  This also enables <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/> on top
             of a composite reader.  The returned <see cref="T:Lucene.Net.Index.TermsEnum"/> is
             unpositioned.  This returns <c>null</c> if there are no terms.
            
             <para/><b>NOTE</b>: you must pass the same reader that was
             used when creating this class
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocTermOrds.NumTerms">
            <summary>
            Returns the number of terms in this field
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocTermOrds.IsEmpty">
            <summary>
            Returns <c>true</c> if no terms were indexed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.VisitTerm(Lucene.Net.Index.TermsEnum,System.Int32)">
            <summary>
            Subclass can override this </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.SetActualDocFreq(System.Int32,System.Int32)">
            <summary>
            Invoked during <see cref="M:Lucene.Net.Index.DocTermOrds.Uninvert(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.IBits,Lucene.Net.Util.BytesRef)"/>
            to record the document frequency for each uninverted
            term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.Uninvert(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.IBits,Lucene.Net.Util.BytesRef)">
            <summary>
            Call this only once (if you subclass!) </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.VInt32Size(System.Int32)">
            <summary>
            Number of bytes to represent an unsigned int as a vint. 
            <para/>
            NOTE: This was vIntSize() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.WriteInt32(System.Int32,System.SByte[],System.Int32)">
            <summary>
            NOTE: This was writeInt() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocTermOrds.OrdWrappedTermsEnum">
            <summary>
            Only used if original <see cref="T:Lucene.Net.Index.IndexReader"/> doesn't implement
            <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>; in this case we "wrap" our own terms index
            around it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.LookupTerm(Lucene.Net.Index.TermsEnum,System.Int32)">
            <summary>
            Returns the term (<see cref="T:Lucene.Net.Util.BytesRef"/>) corresponding to
            the provided ordinal.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.GetIterator(Lucene.Net.Index.AtomicReader)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.SortedSetDocValues"/> view of this instance </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.Iterator.Read(System.Int32[])">
            <summary>
            Buffer must be at least 5 <see cref="T:System.Int32"/>s long.  Returns number
            of term ords placed into buffer; if this count is
            less than buffer.Length then that is the end.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriter">
             <summary>
             This class accepts multiple added documents and directly
             writes segment files.
             <para/>
             Each added document is passed to the <see cref="T:Lucene.Net.Index.DocConsumer"/>,
             which in turn processes the document and interacts with
             other consumers in the indexing chain.  Certain
             consumers, like <see cref="T:Lucene.Net.Index.StoredFieldsConsumer"/> and 
             <see cref="T:Lucene.Net.Index.TermVectorsConsumer"/>, digest a document and
             immediately write bytes to the "doc store" files (ie,
             they do not consume RAM per document, except while they
             are processing the document).
             <para/>
             Other consumers, eg <see cref="T:Lucene.Net.Index.FreqProxTermsWriter"/> and
             <see cref="T:Lucene.Net.Index.NormsConsumer"/>, buffer bytes in RAM and flush only
             when a new segment is produced.
             <para/>
             Once we have used our allowed RAM buffer, or the number
             of added docs is large enough (in the case we are
             flushing by doc count instead of RAM usage), we create a
             real segment and flush it to the Directory.
             <para/>
             Threads:
             <para/>
             Multiple threads are allowed into AddDocument at once.
             There is an initial synchronized call to <see cref="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.GetThreadState(System.Int32)"/>
             which allocates a <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> for this thread.  The same
             thread will get the same <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> over time (thread
             affinity) so that if there are consistent patterns (for
             example each thread is indexing a different content
             source) then we make better use of RAM.  Then
             ProcessDocument is called on that <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> without
             synchronization (most of the "heavy lifting" is in this
             call).  Finally the synchronized "finishDocument" is
             called to flush changes to the directory.
             <para/>
             When flush is called by <see cref="T:Lucene.Net.Index.IndexWriter"/> we forcefully idle
             all threads and flush only once they are all idle.  this
             means you can call flush with a given thread even while
             other threads are actively adding/deleting documents.
             <para/>
            
             Exceptions:
             <para/>
             Because this class directly updates in-memory posting
             lists, and flushes stored fields and term vectors
             directly to files in the directory, there are certain
             limited times when an exception can corrupt this state.
             For example, a disk full while flushing stored fields
             leaves this file in a corrupt state.  Or, an OOM
             exception while appending to the in-memory posting lists
             can corrupt that posting list.  We call such exceptions
             "aborting exceptions".  In these cases we must call
             <see cref="M:Lucene.Net.Index.DocumentsWriter.Abort(Lucene.Net.Index.IndexWriter)"/> to discard all docs added since the last flush.
             <para/>
             All other exceptions ("non-aborting exceptions") can
             still partially update the index structures.  These
             updates are consistent, but, they represent only a part
             of the document seen up until the exception was hit.
             When this happens, we immediately mark the document as
             deleted so that the document is always atomically ("all
             or none") added to the index.
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocumentsWriter.pendingChangesInCurrentFullFlush">
            <summary>
            we preserve changes during a full flush since IW might not checkout before
            we release all changes. NRT Readers otherwise suddenly return true from
            IsCurrent() while there are actually changes currently committed. See also
            <see cref="M:Lucene.Net.Index.DocumentsWriter.AnyChanges"/> &amp; <see cref="M:Lucene.Net.Index.DocumentsWriter.FlushAllThreads(Lucene.Net.Index.IndexWriter)"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriter.NumDocs">
            <summary>
            Returns how many docs are currently buffered in RAM. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.Abort(Lucene.Net.Index.IndexWriter)">
            <summary>
            Called if we hit an exception at a bad time (when
             updating the index files) and must discard all
             currently buffered docs.  this resets our state,
             discarding any docs added since last flush.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterDeleteQueue">
             <summary>
             <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue"/> is a non-blocking linked pending deletes
             queue. In contrast to other queue implementation we only maintain the
             tail of the queue. A delete queue is always used in a context of a set of
             DWPTs and a global delete pool. Each of the DWPT and the global pool need to
             maintain their 'own' head of the queue (as a <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice"/> instance per DWPT).
             The difference between the DWPT and the global pool is that the DWPT starts
             maintaining a head once it has added its first document since for its segments
             private deletes only the deletes after that document are relevant. The global
             pool instead starts maintaining the head once this instance is created by
             taking the sentinel instance as its initial head.
             <para/>
             Since each <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice"/> maintains its own head and the list is only
             single linked the garbage collector takes care of pruning the list for us.
             All nodes in the list that are still relevant should be either directly or
             indirectly referenced by one of the DWPT's private <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice"/> or by
             the global <see cref="T:Lucene.Net.Index.BufferedUpdates"/> slice.
             <para/>
             Each DWPT as well as the global delete pool maintain their private
             DeleteSlice instance. In the DWPT case updating a slice is equivalent to
             atomically finishing the document. The slice update guarantees a "happens
             before" relationship to all other updates in the same indexing session. When a
             DWPT updates a document it:
            
             <list type="number">
                 <item><description>consumes a document and finishes its processing</description></item>
                 <item><description>updates its private <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice"/> either by calling
                 <see cref="M:Lucene.Net.Index.DocumentsWriterDeleteQueue.UpdateSlice(Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice)"/> or <see cref="M:Lucene.Net.Index.DocumentsWriterDeleteQueue.Add(Lucene.Net.Index.Term,Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice)"/> (if the
                     document has a delTerm)</description></item>
                 <item><description>applies all deletes in the slice to its private <see cref="T:Lucene.Net.Index.BufferedUpdates"/>
                     and resets it</description></item>
                 <item><description>increments its internal document id</description></item>
             </list>
            
             The DWPT also doesn't apply its current documents delete term until it has
             updated its delete slice which ensures the consistency of the update. If the
             update fails before the <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice"/> could have been updated the deleteTerm
             will also not be added to its private deletes neither to the global deletes.
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterDeleteQueue.Add(Lucene.Net.Index.Term,Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice)">
            <summary>
            invariant for document update
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice.IsTailItem(System.Object)">
            <summary>
            Returns <code>true</code> iff the given item is identical to the item
            hold by the slices tail, otherwise <code>false</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterFlushControl">
            <summary>
            This class controls <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> flushing during
            indexing. It tracks the memory consumption per
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> and uses a configured <see cref="F:Lucene.Net.Index.DocumentsWriterFlushControl.flushPolicy"/> to
            decide if a <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> must flush.
            <para/>
            In addition to the <see cref="F:Lucene.Net.Index.DocumentsWriterFlushControl.flushPolicy"/> the flush control might set certain
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> as flush pending iff a
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> exceeds the
            <see cref="P:Lucene.Net.Index.IndexWriterConfig.RAMPerThreadHardLimitMB"/> to prevent address
            space exhaustion.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.SetFlushPending(Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Sets flush pending state on the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>. The
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> must have indexed at least on <see cref="T:Lucene.Net.Documents.Document"/> and must not be
            already pending.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.AllActiveThreadStates">
            <summary>
            Returns an iterator that provides access to all currently active <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.NumGlobalTermDeletes">
            <summary>
            Returns the number of delete terms in the global pool
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.PruneBlockedQueue(Lucene.Net.Index.DocumentsWriterDeleteQueue)">
            <summary>
            Prunes the blockedQueue by removing all DWPT that are associated with the given flush queue.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.IsFullFlush">
            <summary>
            Returns <c>true</c> if a full flush is currently running
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.NumQueuedFlushes">
            <summary>
            Returns the number of flushes that are already checked out but not yet
            actively flushing
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.NumBlockedFlushes">
            <summary>
            Returns the number of flushes that are checked out but not yet available
            for flushing. This only applies during a full flush if a DWPT needs
            flushing but must not be flushed until the full flush has finished.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.WaitIfStalled">
            <summary>
            This method will block if too many DWPT are currently flushing and no
            checked out DWPT are available
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.AnyStalledThreads">
            <summary>
            Returns <c>true</c> iff stalled
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.InfoStream">
            <summary>
            Returns the <see cref="T:Lucene.Net.Index.IndexWriter"/> <see cref="T:Lucene.Net.Util.InfoStream"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterFlushQueue">
            <summary>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushQueue.FlushTicket.PublishFlushedSegment(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.DocumentsWriterPerThread.FlushedSegment,Lucene.Net.Index.FrozenBufferedUpdates)">
            <summary>
            Publishes the flushed segment, segment private deletes (if any) and its
            associated global delete (if present) to <see cref="T:Lucene.Net.Index.IndexWriter"/>.  The actual
            publishing operation is synced on IW -> BDS so that the <see cref="T:Lucene.Net.Index.SegmentInfo"/>'s
            delete generation is always <see cref="P:Lucene.Net.Index.FrozenBufferedUpdates.DelGen"/> (<paramref name="globalPacket"/>) + 1
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterPerThread.IndexingChain">
            <summary>
            The <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread.IndexingChain"/> must define the <see cref="M:Lucene.Net.Index.DocumentsWriterPerThread.IndexingChain.GetChain(Lucene.Net.Index.DocumentsWriterPerThread)"/> method
            which returns the <see cref="T:Lucene.Net.Index.DocConsumer"/> that the <see cref="T:Lucene.Net.Index.DocumentsWriter"/> calls to process the
            documents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.Abort(System.Collections.Generic.ISet{System.String})">
            <summary>
            Called if we hit an exception at a bad time (when
            updating the index files) and must discard all
            currently buffered docs.  this resets our state,
            discarding any docs added since last flush.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThread.NumDeleteTerms">
            <summary>
            Returns the number of delete terms in this <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThread.NumDocsInRAM">
            <summary>
            Returns the number of RAM resident documents in this <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.PrepareFlush">
            <summary>
            Prepares this DWPT for flushing. this method will freeze and return the
            <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue"/>s global buffer and apply all pending
            deletes to this DWPT.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.Flush">
            <summary>
            Flush all pending docs to a new segment </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.SealFlushedSegment(Lucene.Net.Index.DocumentsWriterPerThread.FlushedSegment)">
            <summary>
            Seals the <see cref="T:Lucene.Net.Index.SegmentInfo"/> for the new flushed segment and persists
            the deleted documents <see cref="T:Lucene.Net.Util.IMutableBits"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThread.SegmentInfo">
            <summary>
            Get current segment info we are writing. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocumentsWriterPerThread.BYTE_BLOCK_NOT_MASK">
            <summary>
            Initial chunks size of the shared byte[] blocks used to
            store postings data
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocumentsWriterPerThread.MAX_TERM_LENGTH_UTF8">
            <summary>
            if you increase this, you must fix field cache impl for
            getTerms/getTermsIndex requires &lt;= 32768
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterPerThread.Int32BlockAllocator">
            <summary>
            NOTE: This was IntBlockAllocator in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.Int32BlockAllocator.GetInt32Block">
            <summary>
            Allocate another int[] from the shared pool
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterPerThreadPool">
            <summary>
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> controls <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances
            and their thread assignments during indexing. Each <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> holds
            a reference to a <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> that is once a
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is obtained from the pool exclusively used for indexing a
            single document by the obtaining thread. Each indexing thread must obtain
            such a <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> to make progress. Depending on the
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> implementation <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            assignments might differ from document to document.
            <para/>
            Once a <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> is selected for flush the thread pool
            is reusing the flushing <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>s <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> with a
            new <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState">
            <summary>
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> references and guards a
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> instance that is used during indexing to
            build a in-memory index segment. <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> also holds all flush
            related per-thread data controlled by <see cref="T:Lucene.Net.Index.DocumentsWriterFlushControl"/>.
            <para/>
            A <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>, its methods and members should only accessed by one
            thread a time. Users must acquire the lock via <see cref="M:Lucene.Net.Support.Threading.ReentrantLock.Lock"/>
            and release the lock in a finally block via <see cref="M:Lucene.Net.Support.Threading.ReentrantLock.Unlock"/>
            (on the <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instance) before accessing the state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.Deactivate">
            <summary>
            Resets the internal <see cref="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.DocumentsWriterPerThread"/> with the given one.
            if the given DWPT is <c>null</c> this <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is marked as inactive and should not be used
            for indexing anymore. </summary>
            <seealso cref="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.IsActive"/>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.IsActive">
            <summary>
            Returns <c>true</c> if this <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is still open. This will
            only return <c>false</c> iff the DW has been disposed and this
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is already checked out for flush.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.BytesUsedPerThread">
            <summary>
            Returns the number of currently active bytes in this ThreadState's
            <see cref="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.DocumentsWriterPerThread"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.DocumentsWriterPerThread">
            <summary>
            Returns this <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s <see cref="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.DocumentsWriterPerThread"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.IsFlushPending">
            <summary>
            Returns <c>true</c> iff this <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is marked as flush
            pending otherwise <c>false</c>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> with a given maximum of <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.MaxThreadStates">
            <summary>
            Returns the max number of <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances available in this
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.NumThreadStatesActive">
            <summary>
            Returns the active number of <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.NewThreadState">
            <summary>
            Returns a new <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> iff any new state is available otherwise
            <c>null</c>.
            <para/>
            NOTE: the returned <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is already locked iff non-<c>null</c>.
            </summary>
            <returns> a new <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> iff any new state is available otherwise
                    <c>null</c> </returns>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.DeactivateUnreleasedStates">
            <summary>
            Deactivate all unreleased threadstates
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.GetThreadState(System.Int32)">
            <summary>
            Returns the <i>i</i>th active <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> where <i>i</i> is the
            given ord.
            </summary>
            <param name="ord">
                     the ordinal of the <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> </param>
            <returns> the <i>i</i>th active <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> where <i>i</i> is the
                    given ord. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.MinContendedThreadState">
            <summary>
            Returns the <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> with the minimum estimated number of threads
            waiting to acquire its lock or <c>null</c> if no <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            is yet visible to the calling thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.NumDeactivatedThreadStates">
            <summary>
            Returns the number of currently deactivated <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances.
            A deactivated <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> should not be used for indexing anymore.
            </summary>
            <returns> the number of currently deactivated <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.DeactivateThreadState(Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Deactivates an active <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>. Inactive <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> can
            not be used for indexing anymore once they are deactivated. This method should only be used
            if the parent <see cref="T:Lucene.Net.Index.DocumentsWriter"/> is closed or aborted.
            </summary>
            <param name="threadState"> the state to deactivate </param>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterStallControl">
            <summary>
            Controls the health status of a <see cref="T:Lucene.Net.Index.DocumentsWriter"/> sessions. This class
            used to block incoming indexing threads if flushing significantly slower than
            indexing to ensure the <see cref="T:Lucene.Net.Index.DocumentsWriter"/>s healthiness. If flushing is
            significantly slower than indexing the net memory used within an
            <see cref="T:Lucene.Net.Index.IndexWriter"/> session can increase very quickly and easily exceed the
            runtime's available memory.
            <para/>
            To prevent OOM Errors and ensure <see cref="T:Lucene.Net.Index.IndexWriter"/>'s stability this class blocks
            incoming threads from indexing once 2 x number of available
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is exceeded.
            Once flushing catches up and the number of flushing DWPT is equal or lower
            than the number of active <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s threads are released and can
            continue indexing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterStallControl.UpdateStalled(System.Boolean)">
            <summary>
            Update the stalled flag status. this method will set the stalled flag to
            <c>true</c> iff the number of flushing
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> is greater than the number of active
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>. Otherwise it will reset the
            <see cref="T:Lucene.Net.Index.DocumentsWriterStallControl"/> to healthy and release all threads
            waiting on <see cref="M:Lucene.Net.Index.DocumentsWriterStallControl.WaitIfStalled"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterStallControl.WaitIfStalled">
             <summary>
             Blocks if documents writing is currently in a stalled state.
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValues">
            <summary>
            This class contains utility methods and constants for <see cref="T:Lucene.Net.Index.DocValues"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValues.EMPTY_BINARY">
            <summary>
            An empty <see cref="T:Lucene.Net.Index.BinaryDocValues"/> which returns <see cref="F:Lucene.Net.Util.BytesRef.EMPTY_BYTES"/> for every document
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValues.EMPTY_NUMERIC">
            <summary>
            An empty <see cref="T:Lucene.Net.Index.NumericDocValues"/> which returns zero for every document
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValues.EMPTY_SORTED">
            <summary>
            An empty <see cref="T:Lucene.Net.Index.SortedDocValues"/> which returns <see cref="F:Lucene.Net.Util.BytesRef.EMPTY_BYTES"/> for every document
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValues.EMPTY_SORTED_SET">
            <summary>
            An empty <see cref="T:Lucene.Net.Index.SortedDocValues"/> which returns <see cref="F:Lucene.Net.Index.SortedSetDocValues.NO_MORE_ORDS"/> for every document
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValues.Singleton(Lucene.Net.Index.SortedDocValues)">
            <summary>
            Returns a multi-valued view over the provided <see cref="T:Lucene.Net.Index.SortedDocValues"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValues.UnwrapSingleton(Lucene.Net.Index.SortedSetDocValues)">
            <summary>
            Returns a single-valued view of the <see cref="T:Lucene.Net.Index.SortedSetDocValues"/>, if it was previously
            wrapped with <see cref="M:Lucene.Net.Index.DocValues.Singleton(Lucene.Net.Index.SortedDocValues)"/>, or <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValues.DocsWithValue(Lucene.Net.Index.SortedDocValues,System.Int32)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Util.IBits"/> representing all documents from <paramref name="dv"/> that have a value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValues.DocsWithValue(Lucene.Net.Index.SortedSetDocValues,System.Int32)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Util.IBits"/> representing all documents from <paramref name="dv"/> that have a value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesFieldUpdates">
            <summary>
            Holds updates of a single <see cref="T:Lucene.Net.Index.DocValues"/> field, for a set of documents.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesFieldUpdates.Iterator">
            <summary>
            An iterator over documents and their updated values. Only documents with
            updates are returned by this iterator, and the documents are returned in
            increasing order.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.NextDoc">
            <summary>
            Returns the next document which has an update, or
            <see cref="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS"/> if there are no more documents to
            return.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.Doc">
            <summary>
            Returns the current document this iterator is on. </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.Value">
            <summary>
            Returns the value of the document returned from <see cref="M:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.NextDoc"/>. A
            <c>null</c> value means that it was unset for this document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.Reset">
            <summary>
            Reset the iterator's state. Should be called before <see cref="M:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.NextDoc"/>
            and <see cref="P:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.Value"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Add(System.Int32,System.Object)">
            <summary>
            Add an update to a document. For unsetting a value you should pass
            <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.GetIterator">
            <summary>
            Returns an <see cref="T:Lucene.Net.Index.DocValuesFieldUpdates.Iterator"/> over the updated documents and their
            values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Merge(Lucene.Net.Index.DocValuesFieldUpdates)">
            <summary>
            Merge with another <see cref="T:Lucene.Net.Index.DocValuesFieldUpdates"/>. this is called for a
            segment which received updates while it was being merged. The given updates
            should override whatever updates are in that instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Any">
            <summary>
            Returns true if this instance contains any updates. </summary>
            <returns> TODO </returns>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesUpdate">
            <summary>
            An in-place update to a <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesUpdate.#ctor(Lucene.Net.Index.DocValuesFieldUpdatesType,Lucene.Net.Index.Term,System.String,System.Object)">
            <summary>
            Constructor.
            </summary>
            <param name="type"> the <see cref="T:Lucene.Net.Index.DocValuesFieldUpdatesType"/> </param>
            <param name="term"> the <see cref="T:Lucene.Net.Index.Term"/> which determines the documents that will be updated </param>
            <param name="field"> the <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/> to update </param>
            <param name="value"> the updated value </param>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesUpdate.BinaryDocValuesUpdate">
            <summary>
            An in-place update to a binary <see cref="T:Lucene.Net.Index.DocValues"/> field </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesUpdate.NumericDocValuesUpdate">
            <summary>
            An in-place update to a numeric <see cref="T:Lucene.Net.Index.DocValues"/> field </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldInfo">
            <summary>
             Access to the Field Info file that describes document fields and whether or
             not they are indexed. Each segment has a separate Field Info file. Objects
             of this class are thread-safe for multiple readers, but only one thread can
             be adding documents at a time, with no other reader or writer threads
             accessing this object.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.Name">
            <summary>
            Field's name </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.Number">
            <summary>
            Internal field number </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.#ctor(System.String,System.Boolean,System.Int32,System.Boolean,System.Boolean,System.Boolean,Lucene.Net.Index.IndexOptions,Lucene.Net.Index.DocValuesType,Lucene.Net.Index.DocValuesType,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sole Constructor.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.IndexOptions">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.IndexOptions"/> for the field, or <c>null</c> if the field is not indexed </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.HasDocValues">
            <summary>
            Returns <c>true</c> if this field has any docValues.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.DocValuesGen">
            <summary>
            Gets or Sets the docValues generation of this field, or -1 if no docValues. </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.NormType">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.DocValuesType"/> of the norm. This may be <see cref="F:Lucene.Net.Index.DocValuesType.NONE"/> if the field has no norms.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.OmitsNorms">
            <summary>
            Returns <c>true</c> if norms are explicitly omitted for this field
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.HasNorms">
            <summary>
            Returns <c>true</c> if this field actually has any norms.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.IsIndexed">
            <summary>
            Returns <c>true</c> if this field is indexed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.HasPayloads">
            <summary>
            Returns <c>true</c> if any payloads exist for this field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.HasVectors">
            <summary>
            Returns <c>true</c> if any term vectors exist for this field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.GetAttribute(System.String)">
            <summary>
            Get a codec attribute value, or <c>null</c> if it does not exist
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.PutAttribute(System.String,System.String)">
            <summary>
            Puts a codec attribute value.
            <para/>
            this is a key-value mapping for the field that the codec can use
            to store additional metadata, and will be available to the codec
            when reading the segment via <see cref="M:Lucene.Net.Index.FieldInfo.GetAttribute(System.String)"/>
            <para/>
            If a value already exists for the field, it will be replaced with
            the new value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.Attributes">
            <summary>
            Returns internal codec attributes map. May be <c>null</c> if no mappings exist.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexOptions">
            <summary>
            Controls how much information is stored in the postings lists.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexOptions.NONE">
            <summary>
            No index options will be used.
            <para/>
            NOTE: This is the same as setting to <c>null</c> in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexOptions.DOCS_ONLY">
            <summary>
            Only documents are indexed: term frequencies and positions are omitted.
            Phrase and other positional queries on the field will throw an exception, and scoring
            will behave as if any term in the document appears only once.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexOptions.DOCS_AND_FREQS">
            <summary>
            Only documents and term frequencies are indexed: positions are omitted.
            this enables normal scoring, except Phrase and other positional queries
            will throw an exception.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS">
            <summary>
            Indexes documents, frequencies and positions.
            this is a typical default for full-text search: full scoring is enabled
            and positional queries are supported.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS">
            <summary>
            Indexes documents, frequencies, positions and offsets.
            Character offsets are encoded alongside the positions.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesType">
            <summary>
            DocValues types.
            Note that DocValues is strongly typed, so a field cannot have different types
            across different documents.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValuesType.NONE">
            <summary>
            No doc values type will be used.
            <para/>
            NOTE: This is the same as setting to <c>null</c> in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValuesType.NUMERIC">
            <summary>
            A per-document numeric type
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValuesType.BINARY">
            <summary>
            A per-document <see cref="T:byte[]"/>.  Values may be larger than
            32766 bytes, but different codecs may enforce their own limits.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValuesType.SORTED">
            <summary>
            A pre-sorted <see cref="T:byte[]"/>. Fields with this type only store distinct byte values
            and store an additional offset pointer per document to dereference the shared
            byte[]. The stored byte[] is presorted and allows access via document id,
            ordinal and by-value.  Values must be &lt;= 32766 bytes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValuesType.SORTED_SET">
            <summary>
            A pre-sorted ISet&lt;byte[]&gt;. Fields with this type only store distinct byte values
            and store additional offset pointers per document to dereference the shared
            <see cref="T:byte[]"/>s. The stored <see cref="T:byte[]"/> is presorted and allows access via document id,
            ordinal and by-value.  Values must be &lt;= 32766 bytes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldInfos">
            <summary>
            Collection of <see cref="T:Lucene.Net.Index.FieldInfo"/>s (accessible by number or by name).
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.#ctor(Lucene.Net.Index.FieldInfo[])">
            <summary>
            Constructs a new <see cref="T:Lucene.Net.Index.FieldInfos"/> from an array of <see cref="T:Lucene.Net.Index.FieldInfo"/> objects
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasFreq">
            <summary>
            Returns <c>true</c> if any fields have freqs </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasProx">
            <summary>
            Returns <c>true</c> if any fields have positions </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasPayloads">
            <summary>
            Returns <c>true</c> if any fields have payloads </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasOffsets">
            <summary>
            Returns <c>true</c> if any fields have offsets </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasVectors">
            <summary>
            Returns <c>true</c> if any fields have vectors </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasNorms">
            <summary>
            Returns <c>true</c> if any fields have norms </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasDocValues">
            <summary>
            Returns <c>true</c> if any fields have <see cref="T:Lucene.Net.Index.DocValues"/> </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.Count">
            <summary>
            Returns the number of fields.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.GetEnumerator">
            <summary>
            Returns an iterator over all the fieldinfo objects present,
            ordered by ascending field number
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldInfo(System.String)">
            <summary>
            Return the <see cref="T:Lucene.Net.Index.FieldInfo"/> object referenced by the <paramref name="fieldName"/> </summary>
            <returns> the <see cref="T:Lucene.Net.Index.FieldInfo"/> object or <c>null</c> when the given <paramref name="fieldName"/>
            doesn't exist. </returns>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldInfo(System.Int32)">
            <summary>
            Return the <see cref="T:Lucene.Net.Index.FieldInfo"/> object referenced by the <paramref name="fieldNumber"/>. </summary>
            <param name="fieldNumber"> field's number. </param>
            <returns> the <see cref="T:Lucene.Net.Index.FieldInfo"/> object or null when the given <paramref name="fieldNumber"/>
            doesn't exist. </returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="fieldNumber"/> is negative </exception>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldNumbers.AddOrGet(System.String,System.Int32,Lucene.Net.Index.DocValuesType)">
            <summary>
            Returns the global field number for the given field name. If the name
            does not exist yet it tries to add it with the given preferred field
            number assigned if possible otherwise the first unassigned field number
            is used as the field number.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldNumbers.Contains(System.String,Lucene.Net.Index.DocValuesType)">
            <summary>
            Returns <c>true</c> if the <paramref name="fieldName"/> exists in the map and is of the
            same <paramref name="dvType"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Builder.#ctor(Lucene.Net.Index.FieldInfos.FieldNumbers)">
            <summary>
            Creates a new instance with the given <see cref="T:Lucene.Net.Index.FieldInfos.FieldNumbers"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Builder.AddOrUpdate(System.String,Lucene.Net.Index.IIndexableFieldType)">
            <summary>
            NOTE: this method does not carry over termVector
            booleans nor docValuesType; the indexer chain
            (TermVectorsConsumerPerField, DocFieldProcessor) must
            set these fields when they succeed in consuming
            the document
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldInvertState">
            <summary>
            This class tracks the number and position / offset parameters of terms
            being added to the index. The information collected in this class is
            also used to calculate the normalization factor for a field.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInvertState.#ctor(System.String)">
            <summary>
            Creates <see cref="T:Lucene.Net.Index.FieldInvertState"/> for the specified
            field name.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInvertState.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>
            Creates <see cref="T:Lucene.Net.Index.FieldInvertState"/> for the specified
            field name and values for all fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInvertState.Reset">
            <summary>
            Re-initialize the state
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Position">
            <summary>
            Gets the last processed term position. </summary>
            <returns> the position </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Length">
            <summary>
            Gets or Sets total number of terms in this field. </summary>
            <returns> the length </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.NumOverlap">
            <summary>
            Gets or Sets the number of terms with <c>positionIncrement == 0</c>. </summary>
            <returns> the numOverlap </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Offset">
            <summary>
            Gets end offset of the last processed term. </summary>
            <returns> the offset </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Boost">
            <summary>
            Gets or Sets boost value. This is the cumulative product of
            document boost and field boost for all field instances
            sharing the same field name. </summary>
            <returns> the boost </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.MaxTermFrequency">
            <summary>
            Get the maximum term-frequency encountered for any term in the field.  A
            field containing "the quick brown fox jumps over the lazy dog" would have
            a value of 2, because "the" appears twice.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.UniqueTermCount">
            <summary>
            Gets the number of unique terms encountered in this field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.AttributeSource">
            <summary>
            Gets the <see cref="T:Lucene.Net.Util.AttributeSource"/> from the
            <see cref="T:Lucene.Net.Analysis.TokenStream"/> that provided the indexed tokens for this
            field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Name">
            <summary>
            Gets the field's name
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.Fields">
            <summary>
            Flex API for access to fields and terms
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Fields.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Fields.GetEnumerator">
            <summary>
            Returns an enumerator that will step through all field
            names.  This will not return <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Fields.GetTerms(System.String)">
            <summary>
            Get the <see cref="T:Lucene.Net.Index.Terms"/> for this field.  This will return
            <c>null</c> if the field does not exist.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Fields.Count">
            <summary>
            Gets the number of fields or -1 if the number of
            distinct field names is unknown. If &gt;= 0,
            <see cref="M:Lucene.Net.Index.Fields.GetEnumerator"/> will return as many field names.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Fields.UniqueTermCount">
            <summary>
            Returns the number of terms for all fields, or -1 if this
            measure isn't stored by the codec. Note that, just like
            other term measures, this measure does not take deleted
            documents into account. 
            </summary>
            <seealso cref="P:Lucene.Net.Index.Terms.Count"></seealso>
        </member>
        <member name="F:Lucene.Net.Index.Fields.EMPTY_ARRAY">
            <summary>
            Zero-length <see cref="T:Lucene.Net.Index.Fields"/> array.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader">
            <summary>
            A <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> contains another <see cref="T:Lucene.Net.Index.AtomicReader"/>, which it
            uses as its basic source of data, possibly transforming the data along the
            way or providing additional functionality. The class
            <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> itself simply implements all abstract methods
            of <see cref="T:Lucene.Net.Index.IndexReader"/> with versions that pass all requests to the
            contained index reader. Subclasses of <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> may
            further override some of these methods and may also provide additional
            methods and fields.
            <para/><b>NOTE</b>: If you override <see cref="P:Lucene.Net.Index.FilterAtomicReader.LiveDocs"/>, you will likely need
            to override <see cref="P:Lucene.Net.Index.FilterAtomicReader.NumDocs"/> as well and vice-versa.
            <para/><b>NOTE</b>: If this <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> does not change the
            content the contained reader, you could consider overriding
            <see cref="P:Lucene.Net.Index.IndexReader.CoreCacheKey"/> so that <see cref="T:Lucene.Net.Search.IFieldCache"/> and
            <see cref="T:Lucene.Net.Search.CachingWrapperFilter"/> share the same entries for this atomic reader
            and the wrapped one. <see cref="P:Lucene.Net.Index.IndexReader.CombinedCoreAndDeletesKey"/> could be
            overridden as well if the <see cref="P:Lucene.Net.Index.FilterAtomicReader.LiveDocs"/> are not changed
            either.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.Unwrap(Lucene.Net.Index.AtomicReader)">
            <summary>
            Get the wrapped instance by <paramref name="reader"/> as long as this reader is
            an intance of <see cref="T:Lucene.Net.Index.FilterAtomicReader"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterFields">
            <summary>
            Base class for filtering <see cref="T:Lucene.Net.Index.Fields"/>
            implementations.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterFields.m_input">
            <summary>
            The underlying <see cref="T:Lucene.Net.Index.Fields"/> instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterFields.#ctor(Lucene.Net.Index.Fields)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.FilterAtomicReader.FilterFields"/>. </summary>
            <param name="input"> the underlying <see cref="T:Lucene.Net.Index.Fields"/> instance. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterTerms">
            <summary>
            Base class for filtering <see cref="T:Lucene.Net.Index.Terms"/> implementations.
            <para/><b>NOTE</b>: If the order of terms and documents is not changed, and if
            these terms are going to be intersected with automata, you could consider
            overriding <see cref="M:Lucene.Net.Index.Terms.Intersect(Lucene.Net.Util.Automaton.CompiledAutomaton,Lucene.Net.Util.BytesRef)"/> for better performance.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterTerms.m_input">
            <summary>
            The underlying <see cref="T:Lucene.Net.Index.Terms"/> instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterTerms.#ctor(Lucene.Net.Index.Terms)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.FilterAtomicReader.FilterTerms"/> </summary>
            <param name="input"> the underlying <see cref="T:Lucene.Net.Index.Terms"/> instance. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterTermsEnum">
            <summary>
            Base class for filtering <see cref="T:Lucene.Net.Index.TermsEnum"/> implementations. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterTermsEnum.m_input">
            <summary>
            The underlying <see cref="T:Lucene.Net.Index.TermsEnum"/> instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterTermsEnum.#ctor(Lucene.Net.Index.TermsEnum)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.FilterAtomicReader.FilterTermsEnum"/> </summary>
            <param name="input"> the underlying <see cref="T:Lucene.Net.Index.TermsEnum"/> instance. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterDocsEnum">
            <summary>
            Base class for filtering <see cref="T:Lucene.Net.Index.DocsEnum"/> implementations. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterDocsEnum.m_input">
            <summary>
            The underlying <see cref="T:Lucene.Net.Index.DocsEnum"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterDocsEnum.#ctor(Lucene.Net.Index.DocsEnum)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Index.FilterAtomicReader.FilterDocsEnum"/> </summary>
            <param name="input"> the underlying <see cref="T:Lucene.Net.Index.DocsEnum"/> instance. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterDocsAndPositionsEnum">
            <summary>
            Base class for filtering <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> implementations. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterDocsAndPositionsEnum.m_input">
            <summary>
            The underlying <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterDocsAndPositionsEnum.#ctor(Lucene.Net.Index.DocsAndPositionsEnum)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Index.FilterAtomicReader.FilterDocsAndPositionsEnum"/> </summary>
            <param name="input"> the underlying <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> instance. </param>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.m_input">
            <summary>
            The underlying <see cref="T:Lucene.Net.Index.AtomicReader"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.#ctor(Lucene.Net.Index.AtomicReader)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> based on the specified base reader.
            <para/>
            Note that base reader is closed if this <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> is closed.
            </summary>
            <param name="input"> specified base reader. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterDirectoryReader">
            <summary>
            A <see cref="T:Lucene.Net.Index.FilterDirectoryReader"/> wraps another <see cref="T:Lucene.Net.Index.DirectoryReader"/>, allowing implementations
            to transform or extend it.
            <para/>
            Subclasses should implement <see cref="M:Lucene.Net.Index.FilterDirectoryReader.DoWrapDirectoryReader(Lucene.Net.Index.DirectoryReader)"/> to return an instance of the
            subclass.
            <para/>
            If the subclass wants to wrap the <see cref="T:Lucene.Net.Index.DirectoryReader"/>'s subreaders, it should also
            implement a <see cref="T:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper"/> subclass, and pass an instance to its base
            constructor.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper">
            <summary>
            Factory class passed to <see cref="T:Lucene.Net.Index.FilterDirectoryReader"/> constructor that allows
            subclasses to wrap the filtered <see cref="T:Lucene.Net.Index.DirectoryReader"/>'s subreaders.  You
            can use this to, e.g., wrap the subreaders with specialized
            <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> implementations.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper.#ctor">
            <summary>
            Constructor </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper.Wrap(Lucene.Net.Index.AtomicReader)">
            <summary>
            Wrap one of the parent <see cref="T:Lucene.Net.Index.DirectoryReader"/>'s subreaders </summary>
            <param name="reader"> the subreader to wrap </param>
            <returns> a wrapped/filtered <see cref="T:Lucene.Net.Index.AtomicReader"/> </returns>
        </member>
        <member name="T:Lucene.Net.Index.FilterDirectoryReader.StandardReaderWrapper">
            <summary>
            A no-op <see cref="T:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper"/> that simply returns the parent
            <see cref="T:Lucene.Net.Index.DirectoryReader"/>'s original subreaders.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.StandardReaderWrapper.#ctor">
            <summary>
            Constructor </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterDirectoryReader.m_input">
            <summary>
            The filtered <see cref="T:Lucene.Net.Index.DirectoryReader"/> </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.#ctor(Lucene.Net.Index.DirectoryReader)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Index.FilterDirectoryReader"/> that filters a passed in <see cref="T:Lucene.Net.Index.DirectoryReader"/>. </summary>
            <param name="input"> the <see cref="T:Lucene.Net.Index.DirectoryReader"/> to filter </param>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.#ctor(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Index.FilterDirectoryReader"/> that filters a passed in <see cref="T:Lucene.Net.Index.DirectoryReader"/>,
            using the supplied <see cref="T:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper"/> to wrap its subreader. </summary>
            <param name="input"> the <see cref="T:Lucene.Net.Index.DirectoryReader"/> to filter </param>
            <param name="wrapper"> the <see cref="T:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper"/> to use to wrap subreaders </param>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.DoWrapDirectoryReader(Lucene.Net.Index.DirectoryReader)">
            <summary>
            Called by the <see cref="M:Lucene.Net.Index.FilterDirectoryReader.DoOpenIfChanged"/> methods to return a new wrapped <see cref="T:Lucene.Net.Index.DirectoryReader"/>.
            <para/>
            Implementations should just return an instance of themselves, wrapping the
            passed in <see cref="T:Lucene.Net.Index.DirectoryReader"/>.
            </summary>
            <param name="input"> the <see cref="T:Lucene.Net.Index.DirectoryReader"/> to wrap </param>
            <returns> the wrapped <see cref="T:Lucene.Net.Index.DirectoryReader"/> </returns>
        </member>
        <member name="T:Lucene.Net.Index.FilteredTermsEnum">
            <summary>
            Abstract class for enumerating a subset of all terms.
            <para/>
            Term enumerations are always ordered by
            <see cref="P:Lucene.Net.Index.FilteredTermsEnum.Comparer"/>.  Each term in the enumeration is
            greater than all that precede it.
            <para/><c>Please note:</c> Consumers of this enumeration cannot
            call <c>Seek()</c>, it is forward only; it throws
            <see cref="T:System.NotSupportedException"/> when a seeking method
            is called.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus">
            <summary>
            Return value, if term should be accepted or the iteration should
            <see cref="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.END"/>. The <c>*_SEEK</c> values denote, that after handling the current term
            the enum should call <see cref="M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)"/> and step forward. </summary>
            <seealso cref="M:Lucene.Net.Index.FilteredTermsEnum.Accept(Lucene.Net.Util.BytesRef)"/>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.YES">
            <summary>
            Accept the term and position the enum at the next term. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.YES_AND_SEEK">
            <summary>
            Accept the term and advance (<see cref="M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)"/>)
            to the next term.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.NO">
            <summary>
            Reject the term and position the enum at the next term. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.NO_AND_SEEK">
            <summary>
            Reject the term and advance (<see cref="M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)"/>)
            to the next term.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.END">
            <summary>
            Reject the term and stop enumerating. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.Accept(Lucene.Net.Util.BytesRef)">
            <summary>
            Return if term is accepted, not accepted or the iteration should ended
            (and possibly seek).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.#ctor(Lucene.Net.Index.TermsEnum)">
            <summary>
            Creates a filtered <see cref="T:Lucene.Net.Index.TermsEnum"/> on a terms enum. </summary>
            <param name="tenum"> the terms enumeration to filter. </param>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.#ctor(Lucene.Net.Index.TermsEnum,System.Boolean)">
            <summary>
            Creates a filtered <see cref="T:Lucene.Net.Index.TermsEnum"/> on a terms enum. </summary>
            <param name="tenum"> the terms enumeration to filter. </param>
            <param name="startWithSeek"> start with seek </param>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SetInitialSeekTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            Use this method to set the initial <see cref="T:Lucene.Net.Util.BytesRef"/>
            to seek before iterating. This is a convenience method for
            subclasses that do not override <see cref="M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)"/>.
            If the initial seek term is <c>null</c> (default),
            the enum is empty.
            <para/>You can only use this method, if you keep the default
            implementation of <see cref="M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            On the first call to <see cref="M:Lucene.Net.Index.FilteredTermsEnum.Next"/> or if <see cref="M:Lucene.Net.Index.FilteredTermsEnum.Accept(Lucene.Net.Util.BytesRef)"/> returns
            <see cref="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.YES_AND_SEEK"/> or <see cref="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.NO_AND_SEEK"/>,
            this method will be called to eventually seek the underlying <see cref="T:Lucene.Net.Index.TermsEnum"/>
            to a new position.
            On the first call, <paramref name="currentTerm"/> will be <c>null</c>, later
            calls will provide the term the underlying enum is positioned at.
            This method returns per default only one time the initial seek term
            and then <c>null</c>, so no repositioning is ever done.
            <para/>
            Override this method, if you want a more sophisticated <see cref="T:Lucene.Net.Index.TermsEnum"/>,
            that repositions the iterator during enumeration.
            If this method always returns <c>null</c> the enum is empty.
            <para/><c>Please note:</c> this method should always provide a greater term
            than the last enumerated term, else the behavior of this enum
            violates the contract for <see cref="T:Lucene.Net.Index.TermsEnum"/>s.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FilteredTermsEnum.Attributes">
            <summary>
            Returns the related attributes, the returned <see cref="T:Lucene.Net.Util.AttributeSource"/>
            is shared with the delegate <see cref="T:Lucene.Net.Index.TermsEnum"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SeekExact(Lucene.Net.Util.BytesRef)">
            <summary>
            this enum does not support seeking! </summary>
            <exception cref="T:System.NotSupportedException"> In general, subclasses do not
                    support seeking. </exception>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SeekCeil(Lucene.Net.Util.BytesRef)">
            <summary>
            this enum does not support seeking! </summary>
            <exception cref="T:System.NotSupportedException"> In general, subclasses do not
                    support seeking. </exception>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SeekExact(System.Int64)">
            <summary>
            this enum does not support seeking! </summary>
            <exception cref="T:System.NotSupportedException"> In general, subclasses do not
                    support seeking. </exception>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SeekExact(Lucene.Net.Util.BytesRef,Lucene.Net.Index.TermState)">
            <summary>
            this enum does not support seeking! </summary>
            <exception cref="T:System.NotSupportedException"> In general, subclasses do not
                    support seeking. </exception>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.GetTermState">
            <summary>
            Returns the filtered enums term state
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FlushByRamOrCountsPolicy">
             <summary>
             Default <see cref="T:Lucene.Net.Index.FlushPolicy"/> implementation that flushes new segments based on
             RAM used and document count depending on the <see cref="T:Lucene.Net.Index.IndexWriter"/>'s
             <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>. It also applies pending deletes based on the
             number of buffered delete terms.
            
             <list type="bullet">
                 <item><description>
                     <see cref="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.OnDelete(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)"/>
                     - applies pending delete operations based on the global number of buffered
                     delete terms iff <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/> is
                     enabled
                 </description></item>
                 <item><description>
                     <see cref="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.OnInsert(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)"/>
                     - flushes either on the number of documents per
                     <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> (
                     <see cref="P:Lucene.Net.Index.DocumentsWriterPerThread.NumDocsInRAM"/>) or on the global active
                     memory consumption in the current indexing session iff
                     <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/> or
                     <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/> is enabled respectively
                 </description></item>
                 <item><description>
                     <see cref="M:Lucene.Net.Index.FlushPolicy.OnUpdate(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)"/>
                     - calls
                     <see cref="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.OnInsert(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)"/>
                     and
                     <see cref="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.OnDelete(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)"/>
                     in order
                 </description></item>
             </list>
             All <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> settings are used to mark
             <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> as flush pending during indexing with
             respect to their live updates.
             <para/>
             If <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/> (setter) is enabled, the
             largest ram consuming <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> will be marked as
             pending iff the global active RAM consumption is &gt;= the configured max RAM
             buffer.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.MarkLargestWriterPending(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState,System.Int64)">
            <summary>
            Marks the most ram consuming active <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> flush
            pending
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FlushByRamOrCountsPolicy.FlushOnDocCount">
            <summary>
            Returns <c>true</c> if this <see cref="T:Lucene.Net.Index.FlushPolicy"/> flushes on
            <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/>, otherwise
            <c>false</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FlushByRamOrCountsPolicy.FlushOnDeleteTerms">
            <summary>
            Returns <c>true</c> if this <see cref="T:Lucene.Net.Index.FlushPolicy"/> flushes on
            <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>, otherwise
            <c>false</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FlushByRamOrCountsPolicy.FlushOnRAM">
            <summary>
            Returns <c>true</c> if this <see cref="T:Lucene.Net.Index.FlushPolicy"/> flushes on
            <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>, otherwise
            <c>false</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FlushPolicy">
            <summary>
            <see cref="T:Lucene.Net.Index.FlushPolicy"/> controls when segments are flushed from a RAM resident
            internal data-structure to the <see cref="T:Lucene.Net.Index.IndexWriter"/>s <see cref="T:Lucene.Net.Store.Directory"/>.
            <para/>
            Segments are traditionally flushed by:
            <list type="bullet">
                <item><description>RAM consumption - configured via
                    <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/></description></item>
                <item><description>Number of RAM resident documents - configured via
                    <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/></description></item>
            </list>
            The policy also applies pending delete operations (by term and/or query),
            given the threshold set in
            <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>.
            <para/>
            <see cref="T:Lucene.Net.Index.IndexWriter"/> consults the provided <seea cref="T:Lucene.Net.Index.FlushPolicy"/> to control the
            flushing process. The policy is informed for each added or updated document
            as well as for each delete term. Based on the <see cref="T:Lucene.Net.Index.FlushPolicy"/>, the
            information provided via <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> and
            <see cref="T:Lucene.Net.Index.DocumentsWriterFlushControl"/>, the <see cref="T:Lucene.Net.Index.FlushPolicy"/> decides if a
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> needs flushing and mark it as flush-pending
            via <see cref="M:Lucene.Net.Index.DocumentsWriterFlushControl.SetFlushPending(Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)"/>, or if deletes need
            to be applied.
            </summary>
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterFlushControl"/>
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.FlushPolicy"/>
        </member>
        <member name="M:Lucene.Net.Index.FlushPolicy.OnDelete(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Called for each delete term. If this is a delete triggered due to an update
            the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is non-null.
            <para/>
            Note: this method is called synchronized on the given
            <see cref="T:Lucene.Net.Index.DocumentsWriterFlushControl"/> and it is guaranteed that the calling
            thread holds the lock on the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushPolicy.OnUpdate(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Called for each document update on the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>'s
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>.
            <para/>
            Note: this method is called  synchronized on the given
            <see cref="T:Lucene.Net.Index.DocumentsWriterFlushControl"/> and it is guaranteed that the calling
            thread holds the lock on the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushPolicy.OnInsert(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Called for each document addition on the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>.
            <para/>
            Note: this method is synchronized by the given
            <see cref="T:Lucene.Net.Index.DocumentsWriterFlushControl"/> and it is guaranteed that the calling
            thread holds the lock on the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushPolicy.Init(Lucene.Net.Index.LiveIndexWriterConfig)">
            <summary>
            Called by <see cref="T:Lucene.Net.Index.DocumentsWriter"/> to initialize the <see cref="T:Lucene.Net.Index.FlushPolicy"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushPolicy.FindLargestNonPendingWriter(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Returns the current most RAM consuming non-pending <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> with
            at least one indexed document.
            <para/>
            This method will never return <c>null</c>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FreqProxTermsWriterPerField.Flush(System.String,Lucene.Net.Codecs.FieldsConsumer,Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Walk through all unique text tokens (Posting
            instances) found in this field and serialize them
            into a single RAM segment.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FrozenBufferedUpdates">
            <summary>
            Holds buffered deletes and updates by term or query, once pushed. Pushed
            deletes/updates are write-once, so we shift to more memory efficient data
            structure to hold them. We don't hold docIDs because these are applied on
            flush.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FrozenBufferedUpdates.BYTES_PER_DEL_QUERY">
            <summary>Query we often undercount (say 24 bytes), plus int.</summary>
        </member>
        <member name="F:Lucene.Net.Index.FrozenBufferedUpdates.terms">
            <summary>Terms, in sorted order:</summary>
        </member>
        <member name="F:Lucene.Net.Index.FrozenBufferedUpdates.queries">
            <summary>Parallel array of deleted query, and the docIDUpto for each</summary>
        </member>
        <member name="F:Lucene.Net.Index.FrozenBufferedUpdates.numericDVUpdates">
            <summary>numeric DV update term and their updates</summary>
        </member>
        <member name="F:Lucene.Net.Index.FrozenBufferedUpdates.binaryDVUpdates">
            <summary>binary DV update term and their updates</summary>
        </member>
        <member name="T:Lucene.Net.Index.IIndexableField">
            <summary>
            Represents a single field for indexing. <see cref="T:Lucene.Net.Index.IndexWriter"/>
            consumes IEnumerable&lt;IndexableField&gt; as a document.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableField.Name">
            <summary>
            Field name </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableField.IndexableFieldType">
            <summary>
            <see cref="T:Lucene.Net.Index.IIndexableFieldType"/> describing the properties
            of this field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableField.Boost">
            <summary>
            Returns the field's index-time boost.
            <para/>
            Only fields can have an index-time boost, if you want to simulate
            a "document boost", then you must pre-multiply it across all the
            relevant fields yourself.
            <para/>
            The boost is used to compute the norm factor for the field.  By
            default, in the <see cref="M:Lucene.Net.Search.Similarities.Similarity.ComputeNorm(Lucene.Net.Index.FieldInvertState)"/> method,
            the boost value is multiplied by the length normalization factor and then
            rounded by <see cref="M:Lucene.Net.Search.Similarities.DefaultSimilarity.EncodeNormValue(System.Single)"/> before it is stored in the
            index.  One should attempt to ensure that this product does not overflow
            the range of that encoding.
            <para/>
            It is illegal to return a boost other than 1.0f for a field that is not
            indexed (<see cref="P:Lucene.Net.Index.IIndexableFieldType.IsIndexed"/> is false) or omits normalization values
            (<see cref="P:Lucene.Net.Index.IIndexableFieldType.OmitNorms"/> returns true).
            </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.Similarity.ComputeNorm(Lucene.Net.Index.FieldInvertState)"/>
            <seealso cref="M:Lucene.Net.Search.Similarities.DefaultSimilarity.EncodeNormValue(System.Single)"/>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetBinaryValue">
            <summary>
            Non-null if this field has a binary value. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetStringValue">
            <summary>
            Non-null if this field has a string value. </summary>
            <returns>The string representation of the value if it is either a <see cref="T:System.String"/> or numeric type.</returns>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetStringValue(System.IFormatProvider)">
            <summary>
            The value of the field as a <see cref="T:System.String"/>, or <c>null</c>. If <c>null</c>, the <see cref="T:System.IO.TextReader"/> value or
            binary value is used. Exactly one of <see cref="M:Lucene.Net.Index.IIndexableField.GetStringValue"/>, <see cref="M:Lucene.Net.Index.IIndexableField.GetReaderValue"/>, and
            <see cref="M:Lucene.Net.Index.IIndexableField.GetBinaryValue"/> must be set.
            </summary>
            <param name="provider">An object that supplies culture-specific formatting information. This parameter has no effect if this field is non-numeric.</param>
            <returns>The string representation of the value if it is either a <see cref="T:System.String"/> or numeric type.</returns>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetStringValue(System.String)">
            <summary>
            The value of the field as a <see cref="T:System.String"/>, or <c>null</c>. If <c>null</c>, the <see cref="T:System.IO.TextReader"/> value or
            binary value is used. Exactly one of <see cref="M:Lucene.Net.Index.IIndexableField.GetStringValue"/>, <see cref="M:Lucene.Net.Index.IIndexableField.GetReaderValue"/>, and
            <see cref="M:Lucene.Net.Index.IIndexableField.GetBinaryValue"/> must be set.
            </summary>
            <param name="format">A standard or custom numeric format string. This parameter has no effect if this field is non-numeric.</param>
            <returns>The string representation of the value if it is either a <see cref="T:System.String"/> or numeric type.</returns>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetStringValue(System.String,System.IFormatProvider)">
            <summary>
            The value of the field as a <see cref="T:System.String"/>, or <c>null</c>. If <c>null</c>, the <see cref="T:System.IO.TextReader"/> value or
            binary value is used. Exactly one of <see cref="M:Lucene.Net.Index.IIndexableField.GetStringValue"/>, <see cref="M:Lucene.Net.Index.IIndexableField.GetReaderValue"/>, and
            <see cref="M:Lucene.Net.Index.IIndexableField.GetBinaryValue"/> must be set.
            </summary>
            <param name="format">A standard or custom numeric format string. This parameter has no effect if this field is non-numeric.</param>
            <param name="provider">An object that supplies culture-specific formatting information. This parameter has no effect if this field is non-numeric.</param>
            <returns>The string representation of the value if it is either a <see cref="T:System.String"/> or numeric type.</returns>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetReaderValue">
            <summary>
            Non-null if this field has a <see cref="T:System.IO.TextReader"/> value </summary>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetNumericValue">
            <summary>
            Non-null if this field has a numeric value. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableField.NumericType">
            <summary>
            Gets the <see cref="T:Lucene.Net.Documents.NumericFieldType"/> of the underlying value, or <see cref="F:Lucene.Net.Documents.NumericFieldType.NONE"/> if the value is not set or non-numeric.
            <para/>
            Expert: The difference between this property and <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> is 
            this is represents the current state of the field (whether being written or read) and the
            <see cref="T:Lucene.Net.Documents.FieldType"/> property represents instructions on how the field will be written,
            but does not re-populate when reading back from an index (it is write-only).
            <para/>
            In Java, the numeric type was determined by checking the type of  
            <see cref="M:Lucene.Net.Index.IIndexableField.GetNumericValue"/>. However, since there are no reference number
            types in .NET, using <see cref="M:Lucene.Net.Index.IIndexableField.GetNumericValue"/> so will cause boxing/unboxing. It is
            therefore recommended to use this property to check the underlying type and the corresponding 
            <c>Get*Value()</c> method to retrieve the value.
            <para/>
            NOTE: Since Lucene codecs do not support <see cref="F:Lucene.Net.Documents.NumericFieldType.BYTE"/> or <see cref="F:Lucene.Net.Documents.NumericFieldType.INT16"/>,
            fields created with these types will always be <see cref="F:Lucene.Net.Documents.NumericFieldType.INT32"/> when read back from the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetByteValue">
            <summary>
            Returns the field value as <see cref="T:System.Byte"/> or <c>null</c> if the type
            is non-numeric.
            </summary>
            <returns>The field value or <c>null</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetInt16Value">
            <summary>
            Returns the field value as <see cref="T:System.Int16"/> or <c>null</c> if the type
            is non-numeric.
            </summary>
            <returns>The field value or <c>null</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetInt32Value">
            <summary>
            Returns the field value as <see cref="T:System.Int32"/> or <c>null</c> if the type
            is non-numeric.
            </summary>
            <returns>The field value or <c>null</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetInt64Value">
            <summary>
            Returns the field value as <see cref="T:System.Int64"/> or <c>null</c> if the type
            is non-numeric.
            </summary>
            <returns>The field value or <c>null</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetSingleValue">
            <summary>
            Returns the field value as <see cref="T:System.Single"/> or <c>null</c> if the type
            is non-numeric.
            </summary>
            <returns>The field value or <c>null</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetDoubleValue">
            <summary>
            Returns the field value as <see cref="T:System.Double"/> or <c>null</c> if the type
            is non-numeric.
            </summary>
            <returns>The field value or <c>null</c> if the type is non-numeric.</returns>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetTokenStream(Lucene.Net.Analysis.Analyzer)">
            <summary>
            Creates the <see cref="T:Lucene.Net.Analysis.TokenStream"/> used for indexing this field.  If appropriate,
            implementations should use the given <see cref="T:Lucene.Net.Analysis.Analyzer"/> to create the <see cref="T:Lucene.Net.Analysis.TokenStream"/>s.
            </summary>
            <param name="analyzer"> <see cref="T:Lucene.Net.Analysis.Analyzer"/> that should be used to create the <see cref="T:Lucene.Net.Analysis.TokenStream"/>s from </param>
            <returns> <see cref="T:Lucene.Net.Analysis.TokenStream"/> value for indexing the document.  Should always return
                    a non-null value if the field is to be indexed </returns>
            <exception cref="T:System.IO.IOException"> Can be thrown while creating the <see cref="T:Lucene.Net.Analysis.TokenStream"/> </exception>
        </member>
        <member name="T:Lucene.Net.Index.IIndexableFieldType">
            <summary>
            Describes the properties of a field.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.IsIndexed">
            <summary>
            <c>true</c> if this field should be indexed (inverted) </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.IsStored">
            <summary>
            <c>true</c> if the field's value should be stored </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.IsTokenized">
            <summary>
            <c>true</c> if this field's value should be analyzed by the
            <see cref="T:Lucene.Net.Analysis.Analyzer"/>.
            <para/>
            This has no effect if <see cref="P:Lucene.Net.Index.IIndexableFieldType.IsIndexed"/> returns <c>false</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectors">
            <summary>
            <c>true</c> if this field's indexed form should be also stored
            into term vectors.
            <para/>
            this builds a miniature inverted-index for this field which
            can be accessed in a document-oriented way from
            <see cref="M:Lucene.Net.Index.IndexReader.GetTermVector(System.Int32,System.String)"/>.
            <para/>
            This option is illegal if <see cref="P:Lucene.Net.Index.IIndexableFieldType.IsIndexed"/> returns <c>false</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectorOffsets">
            <summary>
            <c>true</c> if this field's token character offsets should also
            be stored into term vectors.
            <para/>
            This option is illegal if term vectors are not enabled for the field
            (<see cref="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectors"/> is <c>false</c>)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectorPositions">
            <summary>
            <c>true</c> if this field's token positions should also be stored
            into the term vectors.
            <para/>
            This option is illegal if term vectors are not enabled for the field
            (<see cref="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectors"/> is <c>false</c>).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectorPayloads">
            <summary>
            <c>true</c> if this field's token payloads should also be stored
            into the term vectors.
            <para/>
            This option is illegal if term vector positions are not enabled
            for the field (<see cref="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectors"/> is <c>false</c>).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.OmitNorms">
            <summary>
            <c>true</c> if normalization values should be omitted for the field.
            <para/>
            This saves memory, but at the expense of scoring quality (length normalization
            will be disabled), and if you omit norms, you cannot use index-time boosts.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.IndexOptions">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexOptions"/>, describing what should be
            recorded into the inverted index
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.DocValueType">
            <summary>
            DocValues <see cref="T:Lucene.Net.Index.DocValuesType"/>: if not <see cref="F:Lucene.Net.Index.DocValuesType.NONE"/> then the field's value
            will be indexed into docValues.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexCommit">
             <summary>
             <para>Expert: represents a single commit into an index as seen by the
             <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> or <see cref="T:Lucene.Net.Index.IndexReader"/>.</para>
            
             <para> Changes to the content of an index are made visible
             only after the writer who made that change commits by
             writing a new segments file
             (<c>segments_N</c>). This point in time, when the
             action of writing of a new segments file to the directory
             is completed, is an index commit.</para>
            
             <para>Each index commit point has a unique segments file
             associated with it. The segments file associated with a
             later index commit point would have a larger N.</para>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.SegmentsFileName">
            <summary>
            Get the segments file (<c>segments_N</c>) associated
            with this commit point.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.FileNames">
            <summary>
            Returns all index files referenced by this commit point.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.Directory">
            <summary>
            Returns the <see cref="T:Lucene.Net.Store.Directory"/> for the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.Delete">
            <summary>
            Delete this commit point.  This only applies when using
            the commit point in the context of <see cref="T:Lucene.Net.Index.IndexWriter"/>'s
            <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/>.
            <para/>
            Upon calling this, the writer is notified that this commit
            point should be deleted.
            <para/>
            Decision that a commit-point should be deleted is taken by the <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> in effect
            and therefore this should only be called by its <see cref="M:Lucene.Net.Index.IndexDeletionPolicy.OnInit``1(System.Collections.Generic.IList{``0})"/> or
            <see cref="M:Lucene.Net.Index.IndexDeletionPolicy.OnCommit``1(System.Collections.Generic.IList{``0})"/> methods.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.IsDeleted">
            <summary>
            Returns <c>true</c> if this commit should be deleted; this is
            only used by <see cref="T:Lucene.Net.Index.IndexWriter"/> after invoking the
            <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.SegmentCount">
            <summary>
            Returns number of segments referenced by this commit. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.Equals(System.Object)">
            <summary>
            Two IndexCommits are equal if both their <see cref="T:Lucene.Net.Store.Directory"/> and versions are equal. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.Generation">
            <summary>
            Returns the generation (the _N in segments_N) for this
            <see cref="T:Lucene.Net.Index.IndexCommit"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.UserData">
            <summary>
            Returns userData, previously passed to 
            <see cref="M:Lucene.Net.Index.IndexWriter.SetCommitData(System.Collections.Generic.IDictionary{System.String,System.String})"/>} for this commit.  
            The dictionary is <see cref="T:System.String"/> -> <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexDeletionPolicy">
             <summary>
             <para>Expert: policy for deletion of stale <see cref="T:Lucene.Net.Index.IndexCommit"/>s.</para>
            
             <para>Implement this interface, and pass it to one
             of the <see cref="T:Lucene.Net.Index.IndexWriter"/> or <see cref="T:Lucene.Net.Index.IndexReader"/>
             constructors, to customize when older
             point-in-time commits (<see cref="T:Lucene.Net.Index.IndexCommit"/>)
             are deleted from the index directory.  The default deletion policy
             is <see cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/>, which always
             removes old commits as soon as a new commit is done (this
             matches the behavior before 2.2).</para>
            
             <para>One expected use case for this (and the reason why it
             was first created) is to work around problems with an
             index directory accessed via filesystems like NFS because
             NFS does not provide the "delete on last close" semantics
             that Lucene's "point in time" search normally relies on.
             By implementing a custom deletion policy, such as "a
             commit is only removed once it has been stale for more
             than X minutes", you can give your readers time to
             refresh to the new commit before <see cref="T:Lucene.Net.Index.IndexWriter"/>
             removes the old commits.  Note that doing so will
             increase the storage requirements of the index.  See <a
             target="top"
             href="http://issues.apache.org/jira/browse/LUCENE-710">LUCENE-710</a>
             for details.</para>
            
             <para>Implementers of sub-classes should make sure that <see cref="M:Lucene.Net.Index.IndexDeletionPolicy.Clone"/>
             returns an independent instance able to work with any other <see cref="T:Lucene.Net.Index.IndexWriter"/>
             or <see cref="T:Lucene.Net.Store.Directory"/> instance.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexDeletionPolicy.#ctor">
            <summary>
            Sole constructor, typically called by sub-classes constructors. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexDeletionPolicy.OnInit``1(System.Collections.Generic.IList{``0})">
             <summary>
             <para>this is called once when a writer is first
             instantiated to give the policy a chance to remove old
             commit points.</para>
            
             <para>The writer locates all index commits present in the
             index directory and calls this method.  The policy may
             choose to delete some of the commit points, doing so by
             calling method <see cref="M:Lucene.Net.Index.IndexCommit.Delete"/>.</para>
            
             <para><u>Note:</u> the last CommitPoint is the most recent one,
             i.e. the "front index state". Be careful not to delete it,
             unless you know for sure what you are doing, and unless
             you can afford to lose the index content while doing that.</para>
             </summary>
             <param name="commits"> List of current point-in-time commits
             (<see cref="T:Lucene.Net.Index.IndexCommit"/>),
             sorted by age (the 0th one is the oldest commit).
             Note that for a new index this method is invoked with
             an empty list. </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexDeletionPolicy.OnCommit``1(System.Collections.Generic.IList{``0})">
             <summary>
             <para>this is called each time the writer completed a commit.
             this gives the policy a chance to remove old commit points
             with each commit.</para>
            
             <para>The policy may now choose to delete old commit points
             by calling method <see cref="M:Lucene.Net.Index.IndexCommit.Delete"/>
             of <see cref="T:Lucene.Net.Index.IndexCommit"/>.</para>
            
             <para>This method is only called when
             <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>} or <see cref="M:Lucene.Net.Index.IndexWriter.Dispose"/> is
             called, or possibly not at all if the 
             <see cref="M:Lucene.Net.Index.IndexWriter.Rollback"/>} method is called.</para>
            
             <para><u>Note:</u> the last CommitPoint is the most recent one,
             i.e. the "front index state". Be careful not to delete it,
             unless you know for sure what you are doing, and unless
             you can afford to lose the index content while doing that.</para>
             </summary>
             <param name="commits"> List of <see cref="T:Lucene.Net.Index.IndexCommit"/>s,
             sorted by age (the 0th one is the oldest commit). </param>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileDeleter">
            <summary>
            This class keeps track of each SegmentInfos instance that
            is still "live", either because it corresponds to a
            segments_N file in the <see cref="T:Lucene.Net.Store.Directory"/> (a "commit", i.e. a
            committed <see cref="T:Lucene.Net.Index.SegmentInfos"/>) or because it's an in-memory
            <see cref="T:Lucene.Net.Index.SegmentInfos"/> that a writer is actively updating but has
            not yet committed.  This class uses simple reference
            counting to map the live <see cref="T:Lucene.Net.Index.SegmentInfos"/> instances to
            individual files in the <see cref="T:Lucene.Net.Store.Directory"/>.
            <para/>
            The same directory file may be referenced by more than
            one <see cref="T:Lucene.Net.Index.IndexCommit"/>, i.e. more than one <see cref="T:Lucene.Net.Index.SegmentInfos"/>.
            Therefore we count how many commits reference each file.
            When all the commits referencing a certain file have been
            deleted, the refcount for that file becomes zero, and the
            file is deleted.
            <para/>
            A separate deletion policy interface
            (<see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/>) is consulted on creation (OnInit)
            and once per commit (OnCommit), to decide when a commit
            should be removed.
            <para/>
            It is the business of the <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> to choose
            when to delete commit points.  The actual mechanics of
            file deletion, retrying, etc, derived from the deletion
            of commit points is the business of the <see cref="T:Lucene.Net.Index.IndexFileDeleter"/>.
            <para/>
            The current default deletion policy is
            <see cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/>, which removes all
            prior commits when a new commit has completed.  This
            matches the behavior before 2.2.
            <para/>
            Note that you must hold the <c>write.lock</c> before
            instantiating this class.  It opens segments_N file(s)
            directly with no retry logic.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.deletable">
            <summary>
            Files that we tried to delete but failed (likely
            because they are open and we are running on Windows),
            so we will retry them again later:
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.refCounts">
            <summary>
            Reference count for all files in the index.
            Counts how many existing commits reference a file.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.commits">
            <summary>
            Holds all commits (segments_N) currently in the index.
            this will have just 1 commit if you are using the
            default delete policy (KeepOnlyLastCommitDeletionPolicy).
            Other policies may leave commit points live for longer
            in which case this list would be longer than 1:
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.lastFiles">
            <summary>
            Holds files we had incref'd from the previous
            non-commit checkpoint:
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.commitsToDelete">
            <summary>
            Commits that the IndexDeletionPolicy have decided to delete:
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.VERBOSE_REF_COUNTS">
            <summary>
            Change to true to see details of reference counts when
            infoStream is enabled
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Index.SegmentInfos,Lucene.Net.Util.InfoStream,Lucene.Net.Index.IndexWriter,System.Boolean)">
            <summary>
            Initialize the deleter: find all previous commits in
            the <see cref="T:Lucene.Net.Store.Directory"/>, incref the files they reference, call
            the policy to let it delete commits.  this will remove
            any files not referenced by any of the commits. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.DeleteCommits">
            <summary>
            Remove the CommitPoints in the commitsToDelete List by
            DecRef'ing all files from each SegmentInfos.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.Refresh(System.String)">
            <summary>
            Writer calls this when it has hit an error and had to
            roll back, to tell us that there may now be
            unreferenced files in the filesystem.  So we re-list
            the filesystem and delete such files.  If <paramref name="segmentName"/>
            is non-null, we will only delete files corresponding to
            that segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.RevisitPolicy">
            <summary>
            Revisits the <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> by calling its
            <see cref="M:Lucene.Net.Index.IndexDeletionPolicy.OnCommit``1(System.Collections.Generic.IList{``0})"/> again with the known commits.
            this is useful in cases where a deletion policy which holds onto index
            commits is used. The application may know that some commits are not held by
            the deletion policy anymore and call
            <see cref="M:Lucene.Net.Index.IndexWriter.DeleteUnusedFiles"/>, which will attempt to delete the
            unused commits again.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.Checkpoint(Lucene.Net.Index.SegmentInfos,System.Boolean)">
            <summary>
            For definition of "check point" see <see cref="T:Lucene.Net.Index.IndexWriter"/> comments:
            "Clarification: Check Points (and commits)".
            <para/>
            Writer calls this when it has made a "consistent
            change" to the index, meaning new files are written to
            the index and the in-memory <see cref="T:Lucene.Net.Index.SegmentInfos"/> have been
            modified to point to those files.
            <para/>
            This may or may not be a commit (segments_N may or may
            not have been written).
            <para/>
            We simply incref the files referenced by the new
            <see cref="T:Lucene.Net.Index.SegmentInfos"/> and decref the files we had previously
            seen (if any).
            <para/>
            If this is a commit, we also call the policy to give it
            a chance to remove other commits.  If any commits are
            removed, we decref their files as well.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.DeleteNewFiles(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Deletes the specified files, but only if they are new
            (have not yet been incref'd).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileDeleter.RefCount">
            <summary>
            Tracks the reference count for a single index file:
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileDeleter.CommitPoint">
            <summary>
            Holds details for each commit point.  This class is
            also passed to the deletion policy.  Note: this class
            has a natural ordering that is inconsistent with
            equals.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.CommitPoint.Delete">
            <summary>
            Called only by the deletion policy, to remove this
            commit point from the index.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileNames">
             <summary>
             This class contains useful constants representing filenames and extensions
             used by lucene, as well as convenience methods for querying whether a file
             name matches an extension (<see cref="M:Lucene.Net.Index.IndexFileNames.MatchesExtension(System.String,System.String)"/>), 
             as well as generating file names from a segment name,
             generation and extension 
             (<see cref="M:Lucene.Net.Index.IndexFileNames.FileNameFromGeneration(System.String,System.String,System.Int64)"/>,
             <see cref="M:Lucene.Net.Index.IndexFileNames.SegmentFileName(System.String,System.String,System.String)"/>).
            
             <para/><b>NOTE</b>: extensions used by codecs are not
             listed here.  You must interact with the <see cref="T:Lucene.Net.Codecs.Codec"/>
             directly.
             <para/>
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.#ctor">
            <summary>
            No instance </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.SEGMENTS">
            <summary>
            Name of the index segment file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.GEN_EXTENSION">
            <summary>
            Extension of gen file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.SEGMENTS_GEN">
            <summary>
            Name of the generation reference file name </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.COMPOUND_FILE_EXTENSION">
            <summary>
            Extension of compound file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION">
            <summary>
            Extension of compound file entries </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.INDEX_EXTENSIONS">
            <summary>
            This array contains all filename extensions used by
            Lucene's index files, with one exception, namely the
            extension made up from  <c>.s</c> + a number.
            Also note that Lucene's <c>segments_N</c> files
            do not have any filename extension.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.FileNameFromGeneration(System.String,System.String,System.Int64)">
            <summary>
            Computes the full file name from base, extension and generation. If the
            generation is -1, the file name is <c>null</c>. If it's 0, the file name is
            &lt;base&gt;.&lt;ext&gt;. If it's > 0, the file name is
            &lt;base&gt;_&lt;gen&gt;.&lt;ext&gt;.
            <para/>
            <b>NOTE:</b> .&lt;ext&gt; is added to the name only if <c>ext</c> is
            not an empty string.
            </summary>
            <param name="base"> main part of the file name </param>
            <param name="ext"> extension of the filename </param>
            <param name="gen"> generation </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.SegmentFileName(System.String,System.String,System.String)">
            <summary>
            Returns a file name that includes the given segment name, your own custom
            name and extension. The format of the filename is:
            &lt;segmentName&gt;(_&lt;name&gt;)(.&lt;ext&gt;).
            <para/>
            <b>NOTE:</b> .&lt;ext&gt; is added to the result file name only if
            <code>ext</code> is not empty.
            <para/>
            <b>NOTE:</b> _&lt;segmentSuffix&gt; is added to the result file name only if
            it's not the empty string
            <para/>
            <b>NOTE:</b> all custom files should be named using this method, or
            otherwise some structures may fail to handle them properly (such as if they
            are added to compound files).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.MatchesExtension(System.String,System.String)">
            <summary>
            Returns <c>true</c> if the given filename ends with the given extension. One
            should provide a <i>pure</i> extension, without '.'.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.IndexOfSegmentName(System.String)">
            <summary>
            Locates the boundary of the segment name, or -1 </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.StripSegmentName(System.String)">
            <summary>
            Strips the segment name out of the given file name. If you used
            <see cref="M:Lucene.Net.Index.IndexFileNames.SegmentFileName(System.String,System.String,System.String)"/> or <see cref="M:Lucene.Net.Index.IndexFileNames.FileNameFromGeneration(System.String,System.String,System.Int64)"/> to create your
            files, then this method simply removes whatever comes before the first '.',
            or the second '_' (excluding both).
            </summary>
            <returns> the filename with the segment name removed, or the given filename
                    if it does not contain a '.' and '_'. </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.ParseSegmentName(System.String)">
            <summary>
            Parses the segment name out of the given file name.
            </summary>
            <returns> the segment name only, or filename
                    if it does not contain a '.' and '_'. </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.StripExtension(System.String)">
            <summary>
            Removes the extension (anything after the first '.'),
            otherwise returns the original filename.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.GetExtension(System.String)">
            <summary>
            Return the extension (anything after the first '.'),
            or null if there is no '.' in the file name.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.CODEC_FILE_PATTERN">
            <summary>
            All files created by codecs much match this pattern (checked in
            <see cref="T:Lucene.Net.Index.SegmentInfo"/>).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFormatTooNewException">
            <summary>
            This exception is thrown when Lucene detects
            an index that is newer than this Lucene version.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooNewException.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Index.IndexFormatTooNewException"/>
            <para/>
            @lucene.internal
            </summary>
            <param name="resourceDesc"> describes the file that was too old </param>
            <param name="version"> the version of the file that was too old </param>
            <param name="minVersion"> the minimum version accepted </param>
            <param name="maxVersion"> the maxium version accepted </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooNewException.#ctor(Lucene.Net.Store.DataInput,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Index.IndexFormatTooNewException"/>
            <para/>
            @lucene.internal
            </summary>
            <param name="input"> the open file that's too old </param>
            <param name="version"> the version of the file that was too old </param>
            <param name="minVersion"> the minimum version accepted </param>
            <param name="maxVersion"> the maxium version accepted </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooNewException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Index.IndexFormatTooOldException">
            <summary>
            This exception is thrown when Lucene detects
            an index that is too old for this Lucene version
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(System.String,System.String)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Index.IndexFormatTooOldException"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="resourceDesc"> describes the file that was too old </param>
            <param name="version"> the version of the file that was too old </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(Lucene.Net.Store.DataInput,System.String)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Index.IndexFormatTooOldException"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="input"> the open file that's too old </param>
            <param name="version"> the version of the file that was too old </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Index.IndexFormatTooOldException"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="resourceDesc"> describes the file that was too old </param>
            <param name="version"> the version of the file that was too old </param>
            <param name="minVersion"> the minimum version accepted </param>
            <param name="maxVersion"> the maxium version accepted </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(Lucene.Net.Store.DataInput,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Index.IndexFormatTooOldException"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="input"> the open file that's too old </param>
            <param name="version"> the version of the file that was too old </param>
            <param name="minVersion"> the minimum version accepted </param>
            <param name="maxVersion"> the maxium version accepted </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Index.IndexNotFoundException">
            <summary>
            Signals that no index was found in the <see cref="T:System.IO.Directory"/>. Possibly because the
            directory is empty, however can also indicate an index corruption.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexNotFoundException.#ctor(System.String)">
            <summary>
            Creates <see cref="T:Lucene.Net.Index.IndexNotFoundException"/> with the
            description message.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Index.IndexReader">
             <summary>
             <see cref="T:Lucene.Net.Index.IndexReader"/> is an abstract class, providing an interface for accessing an
             index.  Search of an index is done entirely through this abstract interface,
             so that any subclass which implements it is searchable.
            
             <para/>There are two different types of <see cref="T:Lucene.Net.Index.IndexReader"/>s:
             <list type="bullet">
                 <item><description><see cref="T:Lucene.Net.Index.AtomicReader"/>: These indexes do not consist of several sub-readers,
                     they are atomic. They support retrieval of stored fields, doc values, terms,
                     and postings.</description></item>
                 <item><description><see cref="T:Lucene.Net.Index.CompositeReader"/>: Instances (like <see cref="T:Lucene.Net.Index.DirectoryReader"/>)
                     of this reader can only
                     be used to get stored fields from the underlying <see cref="T:Lucene.Net.Index.AtomicReader"/>s,
                     but it is not possible to directly retrieve postings. To do that, get
                     the sub-readers via <see cref="M:Lucene.Net.Index.CompositeReader.GetSequentialSubReaders"/>.
                     Alternatively, you can mimic an <see cref="T:Lucene.Net.Index.AtomicReader"/> (with a serious slowdown),
                     by wrapping composite readers with <see cref="T:Lucene.Net.Index.SlowCompositeReaderWrapper"/>.</description></item>
             </list>
            
             <para/><see cref="T:Lucene.Net.Index.IndexReader"/> instances for indexes on disk are usually constructed
             with a call to one of the static <c>DirectoryReader.Open()</c> methods,
             e.g. <seealso cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory)"/>. <see cref="T:Lucene.Net.Index.DirectoryReader"/> inherits
             the <see cref="T:Lucene.Net.Index.CompositeReader"/> abstract class, it is not possible to directly get postings.
            
             <para/> For efficiency, in this API documents are often referred to via
             <i>document numbers</i>, non-negative integers which each name a unique
             document in the index.  These document numbers are ephemeral -- they may change
             as documents are added to and deleted from an index.  Clients should thus not
             rely on a given document having the same number between sessions.
            
             <para/>
             <b>NOTE</b>: <see cref="T:Lucene.Net.Index.IndexReader"/> instances are completely thread
             safe, meaning multiple threads can call any of its methods,
             concurrently.  If your application requires external
             synchronization, you should <b>not</b> synchronize on the
             <see cref="T:Lucene.Net.Index.IndexReader"/> instance; use your own
             (non-Lucene) objects instead.
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexReader.IReaderClosedListener">
            <summary>
            A custom listener that's invoked when the <see cref="T:Lucene.Net.Index.IndexReader"/>
            is closed.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IReaderClosedListener.OnClose(Lucene.Net.Index.IndexReader)">
            <summary>
            Invoked when the <see cref="T:Lucene.Net.Index.IndexReader"/> is closed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.AddReaderClosedListener(Lucene.Net.Index.IndexReader.IReaderClosedListener)">
            <summary>
            Expert: adds a <see cref="T:Lucene.Net.Index.IndexReader.IReaderClosedListener"/>.  The
            provided listener will be invoked when this reader is closed.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.RemoveReaderClosedListener(Lucene.Net.Index.IndexReader.IReaderClosedListener)">
            <summary>
            Expert: remove a previously added <see cref="T:Lucene.Net.Index.IndexReader.IReaderClosedListener"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.RegisterParentReader(Lucene.Net.Index.IndexReader)">
            <summary>
            Expert: this method is called by <see cref="T:Lucene.Net.Index.IndexReader"/>s which wrap other readers
            (e.g. <see cref="T:Lucene.Net.Index.CompositeReader"/> or <see cref="T:Lucene.Net.Index.FilterAtomicReader"/>) to register the parent
            at the child (this reader) on construction of the parent. When this reader is disposed,
            it will mark all registered parents as disposed, too. The references to parent readers
            are weak only, so they can be GCed once they are no longer in use.
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.RefCount">
            <summary>
            Expert: returns the current refCount for this reader </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IncRef">
            <summary>
            Expert: increments the <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/> of this <see cref="T:Lucene.Net.Index.IndexReader"/>
            instance.  <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/>s are used to determine when a
            reader can be disposed safely, i.e. as soon as there are
            no more references.  Be sure to always call a
            corresponding <see cref="M:Lucene.Net.Index.IndexReader.DecRef"/>, in a finally clause;
            otherwise the reader may never be disposed.  Note that
            <see cref="M:Lucene.Net.Index.IndexReader.Dispose(System.Boolean)"/> simply calls <see cref="M:Lucene.Net.Index.IndexReader.DecRef"/>, which means that
            the <see cref="T:Lucene.Net.Index.IndexReader"/> will not really be disposed until
            <see cref="M:Lucene.Net.Index.IndexReader.DecRef"/> has been called for all outstanding
            references.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.DecRef"/>
            <seealso cref="M:Lucene.Net.Index.IndexReader.TryIncRef"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.TryIncRef">
            <summary>
            Expert: increments the <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/> of this <see cref="T:Lucene.Net.Index.IndexReader"/>
            instance only if the <see cref="T:Lucene.Net.Index.IndexReader"/> has not been disposed yet
            and returns <c>true</c> iff the <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/> was
            successfully incremented, otherwise <c>false</c>.
            If this method returns <c>false</c> the reader is either
            already disposed or is currently being disposed. Either way this
            reader instance shouldn't be used by an application unless
            <c>true</c> is returned.
            <para/>
            <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/>s are used to determine when a
            reader can be disposed safely, i.e. as soon as there are
            no more references.  Be sure to always call a
            corresponding <see cref="M:Lucene.Net.Index.IndexReader.DecRef"/>, in a finally clause;
            otherwise the reader may never be disposed.  Note that
            <see cref="M:Lucene.Net.Index.IndexReader.Dispose(System.Boolean)"/> simply calls <see cref="M:Lucene.Net.Index.IndexReader.DecRef"/>, which means that
            the <see cref="T:Lucene.Net.Index.IndexReader"/> will not really be disposed until
            <see cref="M:Lucene.Net.Index.IndexReader.DecRef"/> has been called for all outstanding
            references.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.DecRef"/>
            <seealso cref="M:Lucene.Net.Index.IndexReader.IncRef"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DecRef">
            <summary>
            Expert: decreases the <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/> of this <see cref="T:Lucene.Net.Index.IndexReader"/>
            instance.  If the <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/> drops to 0, then this
            reader is disposed.  If an exception is hit, the <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/>
            is unchanged.
            </summary>
            <exception cref="T:System.IO.IOException"> in case an <see cref="T:System.IO.IOException"/> occurs in <see cref="M:Lucene.Net.Index.IndexReader.DoClose"/>
            </exception>
            <seealso cref="M:Lucene.Net.Index.IndexReader.IncRef"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.EnsureOpen">
            <summary>
            Throws <see cref="T:System.ObjectDisposedException"/> if this <see cref="T:Lucene.Net.Index.IndexReader"/> or any
            of its child readers is disposed, otherwise returns.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Equals(System.Object)">
            <summary>
            Determines whether two object instances are equal.
            <para/>For caching purposes, <see cref="T:Lucene.Net.Index.IndexReader"/> subclasses are not allowed
            to implement Equals/GetHashCode, so methods are declared sealed.
            To lookup instances from caches use <see cref="P:Lucene.Net.Index.IndexReader.CoreCacheKey"/> and
            <see cref="P:Lucene.Net.Index.IndexReader.CombinedCoreAndDeletesKey"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetHashCode">
            <summary>
            Serves as the default hash function.
            <para/>For caching purposes, <see cref="T:Lucene.Net.Index.IndexReader"/> subclasses are not allowed
            to implement Equals/GetHashCode, so methods are declared sealed.
            To lookup instances from caches use <see cref="P:Lucene.Net.Index.IndexReader.CoreCacheKey"/> and
            <see cref="P:Lucene.Net.Index.IndexReader.CombinedCoreAndDeletesKey"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Store.Directory"/> </summary>
            <param name="directory"> the index directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory,System.Int32)">
            <summary>
            Expert: Returns a <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Store.Directory"/> with the given <paramref name="termInfosIndexDivisor"/>. </summary>
            <param name="directory"> the index directory </param>
            <param name="termInfosIndexDivisor"> Subsamples which indexed
             terms are loaded into RAM. this has the same effect as
             <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/> 
             (which can be set on <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>) except that setting
             must be done at indexing time while this setting can be
             set per reader.  When set to <c>N</c>, then one in every
             <c>N*termIndexInterval</c> terms in the index is loaded into
             memory.  By setting this to a value <c>&gt; 1</c> you can reduce
             memory usage, at the expense of higher latency when
             loading a TermInfo.  The default value is 1.  Set this
             to -1 to skip loading the terms index entirely. </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)">
             <summary>
             Open a near real time <see cref="T:Lucene.Net.Index.IndexReader"/> from the <see cref="T:Lucene.Net.Index.IndexWriter"/>.
             </summary>
             <param name="writer"> The <see cref="T:Lucene.Net.Index.IndexWriter"/> to open from </param>
             <param name="applyAllDeletes"> If true, all buffered deletes will
             be applied (made visible) in the returned reader.  If
             false, the deletes are not applied but remain buffered
             (in <see cref="T:Lucene.Net.Index.IndexWriter"/>) so that they will be applied in the
             future.  Applying deletes can be costly, so if your app
             can tolerate deleted documents being returned you might
             gain some performance by passing false. </param>
             <returns> The new <see cref="T:Lucene.Net.Index.IndexReader"/> </returns>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error
             </exception>
             <seealso cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexWriter,System.Boolean)"/>
            
             @lucene.experimental
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Index.IndexCommit)">
            <summary>
            Expert: returns an <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Index.IndexCommit"/>. 
            </summary>
            <param name="commit"> the commit point to open </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Index.IndexCommit,System.Int32)">
            <summary>
            Expert: returns an <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Index.IndexCommit"/> and <paramref name="termInfosIndexDivisor"/>. </summary>
            <param name="commit"> the commit point to open </param>
            <param name="termInfosIndexDivisor"> Subsamples which indexed
             terms are loaded into RAM. this has the same effect as
             <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/> 
             (which can be set in <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>) except that setting
             must be done at indexing time while this setting can be
             set per reader.  When set to <c>N</c>, then one in every
             <c>N*termIndexInterval</c> terms in the index is loaded into
             memory.  By setting this to a value <c>&gt; 1</c> you can reduce
             memory usage, at the expense of higher latency when
             loading a TermInfo.  The default value is 1.  Set this
             to -1 to skip loading the terms index entirely. </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermVectors(System.Int32)">
            <summary>
            Retrieve term vectors for this document, or <c>null</c> if
            term vectors were not indexed. The returned <see cref="T:Lucene.Net.Index.Fields"/>
            instance acts like a single-document inverted index
            (the docID will be 0).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermVector(System.Int32,System.String)">
            <summary>
            Retrieve term vector for this document and field, or
            <c>null</c> if term vectors were not indexed. The returned
            <see cref="T:Lucene.Net.Index.Fields"/> instance acts like a single-document inverted
            index (the docID will be 0).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.NumDocs">
            <summary>
            Returns the number of documents in this index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.MaxDoc">
            <summary>
            Returns one greater than the largest possible document number.
            this may be used to, e.g., determine how big to allocate an array which
            will have an element for every document number in an index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.NumDeletedDocs">
            <summary>
            Returns the number of deleted documents. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32,Lucene.Net.Index.StoredFieldVisitor)">
            <summary>
            Expert: visits the fields of a stored document, for
            custom processing/loading of each field. If you
            simply want to load all fields, use
            <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/>. If you want to load a subset, use
            <see cref="T:Lucene.Net.Documents.DocumentStoredFieldVisitor"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32)">
            <summary>
            Returns the stored fields of the <c>n</c><sup>th</sup>
            <see cref="T:Lucene.Net.Documents.Document"/> in this index.  This is just
            sugar for using <see cref="T:Lucene.Net.Documents.DocumentStoredFieldVisitor"/>.
            <para/>
            <b>NOTE:</b> for performance reasons, this method does not check if the
            requested document is deleted, and therefore asking for a deleted document
            may yield unspecified results. Usually this is not required, however you
            can test if the doc is deleted by checking the 
            <see cref="T:Lucene.Net.Util.IBits"/> returned from <see cref="M:Lucene.Net.Index.MultiFields.GetLiveDocs(Lucene.Net.Index.IndexReader)"/>.
            <para/>
            <b>NOTE:</b> only the content of a field is returned,
            if that field was stored during indexing.  Metadata
            like boost, omitNorm, IndexOptions, tokenized, etc.,
            are not preserved.
            </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32,System.Collections.Generic.ISet{System.String})">
            <summary>
            Like <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/> but only loads the specified
            fields.  Note that this is simply sugar for
            <see cref="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor(System.Collections.Generic.ISet{System.String})"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.HasDeletions">
            <summary>
            Returns <c>true</c> if any documents have been deleted. Implementers should
            consider overriding this property if <see cref="P:Lucene.Net.Index.IndexReader.MaxDoc"/> or <see cref="P:Lucene.Net.Index.IndexReader.NumDocs"/>
            are not constant-time operations.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Dispose">
            <summary> Closes files associated with this index.
            Also saves any new deletions to disk.
            No other methods should be called after this has been called.
            </summary>
            <exception cref="T:System.IO.IOException">If there is a low-level IO error</exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Dispose(System.Boolean)">
            <summary>
            Closes files associated with this index.
            This method implements the disposable pattern. 
            It may be overridden to dispose any managed or unmanaged resources,
            but be sure to call <c>base.Dispose(disposing)</c> to close files associated with the
            underlying <see cref="T:Lucene.Net.Index.IndexReader"/>.
            </summary>
            <param name="disposing"><c>true</c> indicates to dispose all managed 
            and unmanaged resources, <c>false</c> indicates dispose unmanaged 
            resources only</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoClose">
            <summary>
            Implements close. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.Context">
            <summary>
            Expert: Returns the root <see cref="T:Lucene.Net.Index.IndexReaderContext"/> for this
            <see cref="T:Lucene.Net.Index.IndexReader"/>'s sub-reader tree.
            <para/>
            Iff this reader is composed of sub
            readers, i.e. this reader being a composite reader, this method returns a
            <see cref="T:Lucene.Net.Index.CompositeReaderContext"/> holding the reader's direct children as well as a
            view of the reader tree's atomic leaf contexts. All sub-
            <see cref="T:Lucene.Net.Index.IndexReaderContext"/> instances referenced from this readers top-level
            context are private to this reader and are not shared with another context
            tree. For example, <see cref="T:Lucene.Net.Search.IndexSearcher"/> uses this API to drive searching by one
            atomic leaf reader at a time. If this reader is not composed of child
            readers, this method returns an <see cref="T:Lucene.Net.Index.AtomicReaderContext"/>.
            <para/>
            Note: Any of the sub-<see cref="T:Lucene.Net.Index.CompositeReaderContext"/> instances referenced
            from this top-level context do not support <see cref="P:Lucene.Net.Index.CompositeReaderContext.Leaves"/>.
            Only the top-level context maintains the convenience leaf-view
            for performance reasons.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.Leaves">
            <summary>
            Returns the reader's leaves, or itself if this reader is atomic.
            This is a convenience method calling <c>this.Context.Leaves</c>.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexReaderContext.Leaves"/>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.CoreCacheKey">
            <summary>
            Expert: Returns a key for this <see cref="T:Lucene.Net.Index.IndexReader"/>, so 
            <see cref="T:Lucene.Net.Search.IFieldCache"/>/<see cref="T:Lucene.Net.Search.CachingWrapperFilter"/> can find
            it again.
            This key must not have Equals()/GetHashCode() methods, 
            so &quot;equals&quot; means &quot;identical&quot;.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.CombinedCoreAndDeletesKey">
            <summary>
            Expert: Returns a key for this <see cref="T:Lucene.Net.Index.IndexReader"/> that also includes deletions,
            so <see cref="T:Lucene.Net.Search.IFieldCache"/>/<see cref="T:Lucene.Net.Search.CachingWrapperFilter"/> can find it again.
            This key must not have Equals()/GetHashCode() methods, 
            so &quot;equals&quot; means &quot;identical&quot;.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DocFreq(Lucene.Net.Index.Term)">
            <summary>
            Returns the number of documents containing the
            <paramref name="term"/>.  This method returns 0 if the term or
            field does not exist.  This method does not take into
            account deleted documents that have not yet been merged
            away. </summary>
            <seealso cref="P:Lucene.Net.Index.TermsEnum.DocFreq"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.TotalTermFreq(Lucene.Net.Index.Term)">
            <summary>
            Returns the total number of occurrences of <paramref name="term"/> across all
            documents (the sum of the Freq for each doc that has this term). This
            will be -1 if the codec doesn't support this measure. Note that, like other
            term measures, this measure does not take deleted documents into account.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetSumDocFreq(System.String)">
            <summary>
            Returns the sum of <see cref="P:Lucene.Net.Index.TermsEnum.DocFreq"/> for all terms in this field,
            or -1 if this measure isn't stored by the codec. Note that, just like other
            term measures, this measure does not take deleted documents into account.
            </summary>
            <seealso cref="P:Lucene.Net.Index.Terms.SumDocFreq"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetDocCount(System.String)">
            <summary>
            Returns the number of documents that have at least one term for this field,
            or -1 if this measure isn't stored by the codec. Note that, just like other
            term measures, this measure does not take deleted documents into account.
            </summary>
            <seealso cref="P:Lucene.Net.Index.Terms.DocCount"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetSumTotalTermFreq(System.String)">
            <summary>
            Returns the sum of <see cref="P:Lucene.Net.Index.TermsEnum.TotalTermFreq"/> for all terms in this
            field, or -1 if this measure isn't stored by the codec (or if this fields
            omits term freq and positions). Note that, just like other term measures,
            this measure does not take deleted documents into account.
            </summary>
            <seealso cref="P:Lucene.Net.Index.Terms.SumTotalTermFreq"/>
        </member>
        <member name="T:Lucene.Net.Index.IndexReaderContext">
            <summary>
            A struct like class that represents a hierarchical relationship between
            <see cref="T:Lucene.Net.Index.IndexReader"/> instances.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.Parent">
            <summary>
            The reader context for this reader's immediate parent, or null if none </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.IsTopLevel">
            <summary>
            <c>true</c> if this context struct represents the top level reader within the hierarchical context </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.DocBaseInParent">
            <summary>
            the doc base for this reader in the parent, <c>0</c> if parent is <c>null</c> </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.OrdInParent">
            <summary>
            the ord for this reader in the parent, <c>0</c> if parent is <c>null</c> </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.Reader">
            <summary>
            Returns the <see cref="T:Lucene.Net.Index.IndexReader"/>, this context represents. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.Leaves">
            <summary>
            Returns the context's leaves if this context is a top-level context.
            For convenience, if this is an <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> this
            returns itself as the only leaf.
            <para/>Note: this is convenience method since leaves can always be obtained by
            walking the context tree using <see cref="P:Lucene.Net.Index.IndexReaderContext.Children"/>. </summary>
            <exception cref="T:System.InvalidOperationException"> if this is not a top-level context. </exception>
            <seealso cref="P:Lucene.Net.Index.IndexReaderContext.Children"/>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.Children">
            <summary>
            Returns the context's children iff this context is a composite context
            otherwise <c>null</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexUpgrader">
            <summary>
            This is an easy-to-use tool that upgrades all segments of an index from previous Lucene versions
            to the current segment file format. It can be used from command line:
            <code>
             java -cp lucene-core.jar Lucene.Net.Index.IndexUpgrader [-delete-prior-commits] [-verbose] indexDir
            </code>
            Alternatively this class can be instantiated and <see cref="M:Lucene.Net.Index.IndexUpgrader.Upgrade"/> invoked. It uses <see cref="T:Lucene.Net.Index.UpgradeIndexMergePolicy"/>
            and triggers the upgrade via an <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> request to <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            <para/>
            This tool keeps only the last commit in an index; for this
            reason, if the incoming index has more than one commit, the tool
            refuses to run by default. Specify <c>-delete-prior-commits</c>
            to override this, allowing the tool to delete all but the last commit.
            From .NET code this can be enabled by passing <c>true</c> to
            <see cref="M:Lucene.Net.Index.IndexUpgrader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Util.LuceneVersion,System.IO.TextWriter,System.Boolean)"/>.
            <para/>
            <b>Warning:</b> this tool may reorder documents if the index was partially
            upgraded before execution (e.g., documents were added). If your application relies
            on &quot;monotonicity&quot; of doc IDs (which means that the order in which the documents
            were added to the index is preserved), do a full ForceMerge instead.
            The <see cref="T:Lucene.Net.Index.MergePolicy"/> set by <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> may also reorder
            documents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.Main(System.String[])">
            <summary>
            Main method to run <see cref="T:Lucene.Net.Index.IndexUpgrader"/> from the
            command-line.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Util.LuceneVersion)">
            <summary>
            Creates index upgrader on the given directory, using an <see cref="T:Lucene.Net.Index.IndexWriter"/> using the given
            <paramref name="matchVersion"/>. The tool refuses to upgrade indexes with multiple commit points.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Util.LuceneVersion,System.IO.TextWriter,System.Boolean)">
            <summary>
            Creates index upgrader on the given directory, using an <see cref="T:Lucene.Net.Index.IndexWriter"/> using the given
            <paramref name="matchVersion"/>. You have the possibility to upgrade indexes with multiple commit points by removing
            all older ones. If <paramref name="infoStream"/> is not <c>null</c>, all logging output will be sent to this stream.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexWriterConfig,System.Boolean)">
            <summary>
            Creates index upgrader on the given directory, using an <see cref="T:Lucene.Net.Index.IndexWriter"/> using the given
            config. You have the possibility to upgrade indexes with multiple commit points by removing
            all older ones.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.Upgrade">
            <summary>
            Perform the upgrade. </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter">
             <summary>
             An <see cref="T:Lucene.Net.Index.IndexWriter"/> creates and maintains an index.
             </summary>
             <remarks>
             <para>The <see cref="T:Lucene.Net.Index.OpenMode"/> option on
             <see cref="P:Lucene.Net.Index.IndexWriterConfig.OpenMode"/> determines
             whether a new index is created, or whether an existing index is
             opened. Note that you can open an index with <see cref="F:Lucene.Net.Index.OpenMode.CREATE"/>
             even while readers are using the index. The old readers will
             continue to search the "point in time" snapshot they had opened,
             and won't see the newly created index until they re-open. If
             <see cref="F:Lucene.Net.Index.OpenMode.CREATE_OR_APPEND"/> is used <see cref="T:Lucene.Net.Index.IndexWriter"/> will create a
             new index if there is not already an index at the provided path
             and otherwise open the existing index.</para>
            
             <para>In either case, documents are added with <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>
             and removed with <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term)"/> or
             <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query)"/>. A document can be updated with
             <see cref="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/> (which just deletes
             and then adds the entire document). When finished adding, deleting
             and updating documents, <see cref="M:Lucene.Net.Index.IndexWriter.Dispose"/> should be called.</para>
            
             <a name="flush"></a>
             <para>These changes are buffered in memory and periodically
             flushed to the <see cref="T:Lucene.Net.Store.Directory"/> (during the above method
             calls). A flush is triggered when there are enough added documents
             since the last flush. Flushing is triggered either by RAM usage of the
             documents (see <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>) or the
             number of added documents (see <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/>).
             The default is to flush when RAM usage hits
             <see cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_RAM_BUFFER_SIZE_MB"/> MB. For
             best indexing speed you should flush by RAM usage with a
             large RAM buffer. Additionally, if <see cref="T:Lucene.Net.Index.IndexWriter"/> reaches the configured number of
             buffered deletes (see <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>)
             the deleted terms and queries are flushed and applied to existing segments.
             In contrast to the other flush options <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/> and
             <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/>, deleted terms
             won't trigger a segment flush. Note that flushing just moves the
             internal buffered state in <see cref="T:Lucene.Net.Index.IndexWriter"/> into the index, but
             these changes are not visible to <see cref="T:Lucene.Net.Index.IndexReader"/> until either
             <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> or <see cref="M:Lucene.Net.Index.IndexWriter.Dispose"/> is called.  A flush may
             also trigger one or more segment merges which by default
             run with a background thread so as not to block the
             addDocument calls (see <a href="#mergePolicy">below</a>
             for changing the <see cref="F:Lucene.Net.Index.IndexWriter.mergeScheduler"/>).</para>
            
             <para>Opening an <see cref="T:Lucene.Net.Index.IndexWriter"/> creates a lock file for the directory in use. Trying to open
             another <see cref="T:Lucene.Net.Index.IndexWriter"/> on the same directory will lead to a
             <see cref="T:Lucene.Net.Store.LockObtainFailedException"/>. The <see cref="T:Lucene.Net.Store.LockObtainFailedException"/>
             is also thrown if an <see cref="T:Lucene.Net.Index.IndexReader"/> on the same directory is used to delete documents
             from the index.</para>
            
             <a name="deletionPolicy"></a>
             <para>Expert: <see cref="T:Lucene.Net.Index.IndexWriter"/> allows an optional
             <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> implementation to be
             specified.  You can use this to control when prior commits
             are deleted from the index.  The default policy is
             <see cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/> which removes all prior
             commits as soon as a new commit is done (this matches
             behavior before 2.2).  Creating your own policy can allow
             you to explicitly keep previous "point in time" commits
             alive in the index for some time, to allow readers to
             refresh to the new commit without having the old commit
             deleted out from under them.  This is necessary on
             filesystems like NFS that do not support "delete on last
             close" semantics, which Lucene's "point in time" search
             normally relies on. </para>
            
             <a name="mergePolicy"></a> <para>Expert:
             <see cref="T:Lucene.Net.Index.IndexWriter"/> allows you to separately change
             the <see cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/> and the <see cref="F:Lucene.Net.Index.IndexWriter.mergeScheduler"/>.
             The <see cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/> is invoked whenever there are
             changes to the segments in the index.  Its role is to
             select which merges to do, if any, and return a 
             <see cref="T:Lucene.Net.Index.MergePolicy.MergeSpecification"/> describing the merges.
             The default is <see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/>.  Then, the 
             <see cref="T:Lucene.Net.Index.MergeScheduler"/> is invoked with the requested merges and
             it decides when and how to run the merges.  The default is
             <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler"/>. </para>
            
             <a name="OOME"></a><para><b>NOTE</b>: if you hit an
             <see cref="T:System.OutOfMemoryException"/> then <see cref="T:Lucene.Net.Index.IndexWriter"/> will quietly record this
             fact and block all future segment commits.  This is a
             defensive measure in case any internal state (buffered
             documents and deletions) were corrupted.  Any subsequent
             calls to <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> will throw an
             <see cref="T:System.InvalidOperationException"/>.  The only course of action is to
             call <see cref="M:Lucene.Net.Index.IndexWriter.Dispose"/>, which internally will call
             <see cref="M:Lucene.Net.Index.IndexWriter.Rollback"/>, to undo any changes to the index since the
             last commit.  You can also just call <see cref="M:Lucene.Net.Index.IndexWriter.Rollback"/>
             directly.</para>
            
             <a name="thread-safety"></a><para><b>NOTE</b>: 
             <see cref="T:Lucene.Net.Index.IndexWriter"/> instances are completely thread
             safe, meaning multiple threads can call any of its
             methods, concurrently.  If your application requires
             external synchronization, you should <b>not</b>
             synchronize on the <see cref="T:Lucene.Net.Index.IndexWriter"/> instance as
             this may cause deadlock; use your own (non-Lucene) objects
             instead. </para>
            
             <para><b>NOTE</b>: If you call
             <see cref="M:System.Threading.Thread.Interrupt"/> on a thread that's within
             <see cref="T:Lucene.Net.Index.IndexWriter"/>, <see cref="T:Lucene.Net.Index.IndexWriter"/> will try to catch this (eg, if
             it's in a Wait() or <see cref="M:System.Threading.Thread.Sleep(System.Int32)"/>), and will then throw
             the unchecked exception <see cref="T:System.Threading.ThreadInterruptedException"/>
             and <b>clear</b> the interrupt status on the thread.</para>
             </remarks>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.WRITE_LOCK_NAME">
            <summary>
            Name of the write lock in the index.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.SOURCE">
            <summary>
            Key for the source of a segment in the <see cref="P:Lucene.Net.Index.SegmentInfo.Diagnostics"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.SOURCE_MERGE">
            <summary>
            Source of a segment which results from a merge of other segments. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.SOURCE_FLUSH">
            <summary>
            Source of a segment which results from a flush. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.SOURCE_ADDINDEXES_READERS">
            <summary>
            Source of a segment which results from a call to <see cref="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.MAX_TERM_LENGTH">
            <summary>
            Absolute hard maximum length for a term, in bytes once
            encoded as UTF8.  If a term arrives from the analyzer
            longer than this length, an
            <see cref="T:System.ArgumentException"/> is thrown
            and a message is printed to <see cref="F:Lucene.Net.Index.IndexWriter.infoStream"/>, if set (see
            <see cref="M:Lucene.Net.Index.IndexWriterConfig.SetInfoStream(Lucene.Net.Util.InfoStream)"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetReader(System.Boolean)">
             <summary>
             Expert: returns a readonly reader, covering all
             committed as well as un-committed changes to the index.
             this provides "near real-time" searching, in that
             changes made during an <see cref="T:Lucene.Net.Index.IndexWriter"/> session can be
             quickly made available for searching without closing
             the writer nor calling <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>.
            
             <para>Note that this is functionally equivalent to calling
             Flush() and then opening a new reader.  But the turnaround time of this
             method should be faster since it avoids the potentially
             costly <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>.</para>
            
             <para>You must close the <see cref="T:Lucene.Net.Index.IndexReader"/> returned by
             this method once you are done using it.</para>
            
             <para>It's <i>near</i> real-time because there is no hard
             guarantee on how quickly you can get a new reader after
             making changes with <see cref="T:Lucene.Net.Index.IndexWriter"/>.  You'll have to
             experiment in your situation to determine if it's
             fast enough.  As this is a new and experimental
             feature, please report back on your findings so we can
             learn, improve and iterate.</para>
            
             <para>The resulting reader supports
             <see cref="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged"/>, but that call will simply forward
             back to this method (though this may change in the
             future).</para>
            
             <para>The very first time this method is called, this
             writer instance will make every effort to pool the
             readers that it opens for doing merges, applying
             deletes, etc.  This means additional resources (RAM,
             file descriptors, CPU time) will be consumed.</para>
            
             <para>For lower latency on reopening a reader, you should
             set <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MergedSegmentWarmer"/> to
             pre-warm a newly merged segment before it's committed
             to the index.  This is important for minimizing
             index-to-search delay after a large merge.  </para>
            
             <para>If an AddIndexes* call is running in another thread,
             then this reader will only search those segments from
             the foreign index that have been successfully copied
             over, so far.</para>
            
             <para><b>NOTE</b>: Once the writer is disposed, any
             outstanding readers may continue to be used.  However,
             if you attempt to reopen any of those readers, you'll
             hit an <see cref="T:System.ObjectDisposedException"/>.</para>
            
             @lucene.experimental
             </summary>
             <returns> <see cref="T:Lucene.Net.Index.IndexReader"/> that covers entire index plus all
             changes made so far by this <see cref="T:Lucene.Net.Index.IndexWriter"/> instance
             </returns>
             <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter.ReaderPool">
            <summary>
            Holds shared <see cref="T:Lucene.Net.Index.SegmentReader"/> instances. <see cref="T:Lucene.Net.Index.IndexWriter"/> uses
            <see cref="T:Lucene.Net.Index.SegmentReader"/>s for 1) applying deletes, 2) doing
            merges, 3) handing out a real-time reader.  This pool
            reuses instances of the <see cref="T:Lucene.Net.Index.SegmentReader"/>s in all these
            places if it is in "near real-time mode" (<see cref="M:Lucene.Net.Index.IndexWriter.GetReader"/>
            has been called on this instance).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ReaderPool.DropAll(System.Boolean)">
            <summary>
            Remove all our references to readers, and commits
            any pending changes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ReaderPool.Commit(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Commit live docs changes for the segment readers for
            the provided infos.
            </summary>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ReaderPool.Get(Lucene.Net.Index.SegmentCommitInfo,System.Boolean)">
            <summary>
            Obtain a <see cref="T:Lucene.Net.Index.ReadersAndUpdates"/> instance from the
            readerPool.  If <paramref name="create"/> is <c>true</c>, you must later call
            <see cref="M:Lucene.Net.Index.IndexWriter.ReaderPool.Release(Lucene.Net.Index.ReadersAndUpdates)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ReaderPool.NoDups">
            <summary>
            Make sure that every segment appears only once in the
            pool:
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.NumDeletedDocs(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Obtain the number of deleted docs for a pooled reader.
            If the reader isn't being pooled, the segmentInfo's
            delCount is returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.EnsureOpen(System.Boolean)">
            <summary>
            Used internally to throw an <see cref="T:System.ObjectDisposedException"/> if this
            <see cref="T:Lucene.Net.Index.IndexWriter"/> has been disposed or is in the process of diposing.
            </summary>
            <param name="failIfDisposing">
                     if <c>true</c>, also fail when <see cref="T:Lucene.Net.Index.IndexWriter"/> is in the process of
                     disposing (<c>closing=true</c>) but not yet done disposing (
                     <c>closed=false</c>) </param>
            <exception cref="T:System.ObjectDisposedException">
                      if this IndexWriter is closed or in the process of closing </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.EnsureOpen">
            <summary>
            Used internally to throw an
            <see cref="T:System.ObjectDisposedException"/> if this <see cref="T:Lucene.Net.Index.IndexWriter"/> has been
            disposed (<c>closed=true</c>) or is in the process of
            disposing (<c>closing=true</c>).
            <para/>
            Calls <see cref="M:Lucene.Net.Index.IndexWriter.EnsureOpen(System.Boolean)"/>.
            </summary>
            <exception cref="T:System.ObjectDisposedException"> if this <see cref="T:Lucene.Net.Index.IndexWriter"/> is disposed </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexWriterConfig)">
             <summary>
             Constructs a new <see cref="T:Lucene.Net.Index.IndexWriter"/> per the settings given in <paramref name="conf"/>.
             If you want to make "live" changes to this writer instance, use
             <see cref="P:Lucene.Net.Index.IndexWriter.Config"/>.
            
             <para/>
             <b>NOTE:</b> after ths writer is created, the given configuration instance
             cannot be passed to another writer. If you intend to do so, you should
             <see cref="M:Lucene.Net.Index.IndexWriterConfig.Clone"/> it beforehand.
             </summary>
             <param name="d">
                      the index directory. The index is either created or appended
                      according <see cref="P:Lucene.Net.Index.IndexWriterConfig.OpenMode"/>. </param>
             <param name="conf">
                      the configuration settings according to which <see cref="T:Lucene.Net.Index.IndexWriter"/> should
                      be initialized. </param>
             <exception cref="T:System.IO.IOException">
                       if the directory cannot be read/written to, or if it does not
                       exist and <see cref="P:Lucene.Net.Index.IndexWriterConfig.OpenMode"/> is
                       <see cref="F:Lucene.Net.Index.OpenMode.APPEND"/> or if there is any other low-level
                       IO error </exception>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.FieldNumberMap">
            <summary>
            Loads or returns the already loaded the global field number map for <see cref="F:Lucene.Net.Index.IndexWriter.segmentInfos"/>.
            If <see cref="F:Lucene.Net.Index.IndexWriter.segmentInfos"/> has no global field number map the returned instance is empty
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.Config">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/>, which can be used to query the <see cref="T:Lucene.Net.Index.IndexWriter"/>
            current settings, as well as modify "live" ones.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Dispose">
             <summary>
             Commits all changes to an index, waits for pending merges
             to complete, and closes all associated files.
             <para/>
             This is a "slow graceful shutdown" which may take a long time
             especially if a big merge is pending: If you only want to close
             resources use <see cref="M:Lucene.Net.Index.IndexWriter.Rollback"/>. If you only want to commit
             pending changes and close resources see <see cref="M:Lucene.Net.Index.IndexWriter.Dispose(System.Boolean)"/>.
             <para/>
             Note that this may be a costly
             operation, so, try to re-use a single writer instead of
             closing and opening a new one.  See <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> for
             caveats about write caching done by some IO devices.
            
             <para> If an <see cref="T:System.Exception"/> is hit during close, eg due to disk
             full or some other reason, then both the on-disk index
             and the internal state of the <see cref="T:Lucene.Net.Index.IndexWriter"/> instance will
             be consistent.  However, the close will not be complete
             even though part of it (flushing buffered documents)
             may have succeeded, so the write lock will still be
             held.</para>
            
             <para> If you can correct the underlying cause (eg free up
             some disk space) then you can call <see cref="M:Lucene.Net.Index.IndexWriter.Dispose"/> again.
             Failing that, if you want to force the write lock to be
             released (dangerous, because you may then lose buffered
             docs in the <see cref="T:Lucene.Net.Index.IndexWriter"/> instance) then you can do
             something like this:</para>
            
             <code>
             try 
             {
                 writer.Dispose();
             } 
             finally 
             {
                 if (IndexWriter.IsLocked(directory)) 
                 {
                     IndexWriter.Unlock(directory);
                 }
             }
             </code>
             
             after which, you must be certain not to use the writer
             instance anymore.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer, again.  See 
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Dispose(System.Boolean)">
             <summary>
             Closes the index with or without waiting for currently
             running merges to finish.  This is only meaningful when
             using a <see cref="T:Lucene.Net.Index.MergeScheduler"/> that runs merges in background
             threads.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer, again.  See 
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
            
             <para><b>NOTE</b>: it is dangerous to always call
             <c>Dispose(false)</c>, especially when <see cref="T:Lucene.Net.Index.IndexWriter"/> is not open
             for very long, because this can result in "merge
             starvation" whereby long merges will never have a
             chance to finish.  This will cause too many segments in
             your index over time.</para>
             </summary>
             <param name="waitForMerges"> if <c>true</c>, this call will block
             until all merges complete; else, it will ask all
             running merges to abort, wait until those merges have
             finished (which should be at most a few seconds), and
             then return. </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ShouldClose">
            <summary>
            Returns <c>true</c> if this thread should attempt to close, or
            false if IndexWriter is now closed; else, waits until
            another thread finishes closing
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.Directory">
            <summary>
            Gets the <see cref="T:Lucene.Net.Store.Directory"/> used by this index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.Analyzer">
            <summary>
            Gets the analyzer used by this index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.MaxDoc">
            <summary>
            Gets total number of docs in this index, including
            docs not yet flushed (still in the RAM buffer),
            not counting deletions.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriter.NumDocs"/>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.NumDocs">
            <summary>
            Gets total number of docs in this index, including
            docs not yet flushed (still in the RAM buffer), and
            including deletions.  <b>NOTE:</b> buffered deletions
            are not counted.  If you really need these to be
            counted you should call <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> first.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriter.MaxDoc"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.HasDeletions">
            <summary>
            Returns <c>true</c> if this index has deletions (including
            buffered deletions).  Note that this will return <c>true</c>
            if there are buffered Term/Query deletions, even if it
            turns out those buffered deletions don't match any
            documents. Also, if a merge kicked off as a result of flushing a
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})">
             <summary>
             Adds a document to this index.
            
             <para> Note that if an <see cref="T:System.Exception"/> is hit (for example disk full)
             then the index will be consistent, but this document
             may not have been added.  Furthermore, it's possible
             the index will have one segment in non-compound format
             even when using compound files (when a merge has
             partially succeeded).</para>
            
             <para>This method periodically flushes pending documents
             to the <see cref="P:Lucene.Net.Index.IndexWriter.Directory"/> (see <see cref="T:Lucene.Net.Index.IndexWriter"/>), and
             also periodically triggers segment merges in the index
             according to the <see cref="T:Lucene.Net.Index.MergePolicy"/> in use.</para>
            
             <para>Merges temporarily consume space in the
             directory. The amount of space required is up to 1X the
             size of all segments being merged, when no
             readers/searchers are open against the index, and up to
             2X the size of all segments being merged when
             readers/searchers are open against the index (see
             <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> for details). The sequence of
             primitive merge operations performed is governed by the
             merge policy.</para>
            
             <para>Note that each term in the document can be no longer
             than <see cref="F:Lucene.Net.Index.IndexWriter.MAX_TERM_LENGTH"/> in bytes, otherwise an
             <see cref="T:System.ArgumentException"/> will be thrown.</para>
            
             <para>Note that it's possible to create an invalid Unicode
             string in java if a UTF16 surrogate pair is malformed.
             In this case, the invalid characters are silently
             replaced with the Unicode replacement character
             U+FFFD.</para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See 
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField},Lucene.Net.Analysis.Analyzer)">
             <summary>
             Adds a document to this index, using the provided <paramref name="analyzer"/> instead of the
             value of <see cref="P:Lucene.Net.Index.IndexWriter.Analyzer"/>.
            
             <para>See <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/> for details on
             index and <see cref="T:Lucene.Net.Index.IndexWriter"/> state after an <see cref="T:System.Exception"/>, and
             flushing/merging temporary free space requirements.</para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})">
             <summary>
             Atomically adds a block of documents with sequentially
             assigned document IDs, such that an external reader
             will see all or none of the documents.
            
             <para><b>WARNING</b>: the index does not currently record
             which documents were added as a block.  Today this is
             fine, because merging will preserve a block. The order of
             documents within a segment will be preserved, even when child
             documents within a block are deleted. Most search features
             (like result grouping and block joining) require you to
             mark documents; when these documents are deleted these
             search features will not work as expected. Obviously adding
             documents to an existing block will require you the reindex
             the entire block.</para>
            
             <para>However it's possible that in the future Lucene may
             merge more aggressively re-order documents (for example,
             perhaps to obtain better index compression), in which case
             you may need to fully re-index your documents at that time.</para>
            
             <para>See <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/> for details on
             index and <see cref="T:Lucene.Net.Index.IndexWriter"/> state after an <see cref="T:System.Exception"/>, and
             flushing/merging temporary free space requirements.</para>
            
             <para><b>NOTE</b>: tools that do offline splitting of an index
             (for example, IndexSplitter in Lucene.Net.Misc) or
             re-sorting of documents (for example, IndexSorter in
             contrib) are not aware of these atomically added documents
             and will likely break them up.  Use such tools at your
             own risk!</para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             
             @lucene.experimental 
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Atomically adds a block of documents, analyzed using the
            provided <paramref name="analyzer"/>, with sequentially assigned document
            IDs, such that an external reader will see all or none
            of the documents.
            <para/>
            @lucene.experimental
            </summary>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})">
            <summary>
            Atomically deletes documents matching the provided
            <paramref name="delTerm"/> and adds a block of documents with sequentially
            assigned document IDs, such that an external reader
            will see all or none of the documents.
            <para/>
            @lucene.experimental
            </summary>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Atomically deletes documents matching the provided
            <paramref name="delTerm"/> and adds a block of documents, analyzed using
            the provided <paramref name="analyzer"/>, with sequentially
            assigned document IDs, such that an external reader
            will see all or none of the documents.
            <para/>
            @lucene.experimental
            </summary>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term)">
             <summary>
             Deletes the document(s) containing <paramref name="term"/>.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See 
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <param name="term"> the term to identify the documents to be deleted </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.TryDeleteDocument(Lucene.Net.Index.IndexReader,System.Int32)">
             <summary>
             Expert: attempts to delete by document ID, as long as
             the provided <paramref name="readerIn"/> is a near-real-time reader (from 
             <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/>.  If the
             provided <paramref name="readerIn"/> is an NRT reader obtained from this
             writer, and its segment has not been merged away, then
             the delete succeeds and this method returns <c>true</c>; else, it
             returns <c>false</c> the caller must then separately delete by
             Term or Query.
            
             <b>NOTE</b>: this method can only delete documents
             visible to the currently open NRT reader.  If you need
             to delete documents indexed after opening the NRT
             reader you must use the other DeleteDocument() methods
             (e.g., <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term)"/>).
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term[])">
             <summary>
             Deletes the document(s) containing any of the
             terms. All given deletes are applied and flushed atomically
             at the same time.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <param name="terms"> array of terms to identify the documents
             to be deleted </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query)">
             <summary>
             Deletes the document(s) matching the provided query.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <param name="query"> the query to identify the documents to be deleted </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query[])">
             <summary>
             Deletes the document(s) matching any of the provided queries.
             All given deletes are applied and flushed atomically at the same time.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <param name="queries"> array of queries to identify the documents
             to be deleted </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})">
             <summary>
             Updates a document by first deleting the document(s)
             containing <paramref name="term"/> and then adding the new
             document.  The delete and then add are atomic as seen
             by a reader on the same index (flush may happen only after
             the add).
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <param name="term"> the term to identify the document(s) to be
             deleted </param>
             <param name="doc"> the document to be added </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField},Lucene.Net.Analysis.Analyzer)">
             <summary>
             Updates a document by first deleting the document(s)
             containing <paramref name="term"/> and then adding the new
             document.  The delete and then add are atomic as seen
             by a reader on the same index (flush may happen only after
             the add).
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <param name="term"> the term to identify the document(s) to be
             deleted </param>
             <param name="doc"> the document to be added </param>
             <param name="analyzer"> the analyzer to use when analyzing the document </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateNumericDocValue(Lucene.Net.Index.Term,System.String,System.Nullable{System.Int64})">
             <summary>
             Updates a document's <see cref="T:Lucene.Net.Index.NumericDocValues"/> for <paramref name="field"/> to the
             given <paramref name="value"/>. This method can be used to 'unset' a document's
             value by passing <c>null</c> as the new <paramref name="value"/>. Also, you can only update
             fields that already exist in the index, not add new fields through this
             method.
            
             <para>
             <b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/> you should immediately
             dispose the writer. See <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.
             </para>
             </summary>
             <param name="term">
                      the term to identify the document(s) to be updated </param>
             <param name="field">
                      field name of the <see cref="T:Lucene.Net.Index.NumericDocValues"/> field </param>
             <param name="value">
                      new value for the field </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException">
                       if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException">
                       if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateBinaryDocValue(Lucene.Net.Index.Term,System.String,Lucene.Net.Util.BytesRef)">
             <summary>
             Updates a document's <see cref="T:Lucene.Net.Index.BinaryDocValues"/> for <paramref name="field"/> to the
             given <paramref name="value"/>. this method can be used to 'unset' a document's
             value by passing <c>null</c> as the new <paramref name="value"/>. Also, you can only update
             fields that already exist in the index, not add new fields through this
             method.
            
             <para/>
             <b>NOTE:</b> this method currently replaces the existing value of all
             affected documents with the new value.
            
             <para>
             <b>NOTE:</b> if this method hits an <see cref="T:System.OutOfMemoryException"/> you should immediately
             dispose the writer. See <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.
             </para>
             </summary>
             <param name="term">
                      the term to identify the document(s) to be updated </param>
             <param name="field">
                      field name of the <see cref="T:Lucene.Net.Index.BinaryDocValues"/> field </param>
             <param name="value">
                      new value for the field </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException">
                       if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException">
                       if there is a low-level IO error </exception>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.infoStream">
            <summary>
            If non-null, information about merges will be printed to this.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)">
             <summary>
             Forces merge policy to merge segments until there are &lt;=
             <paramref name="maxNumSegments"/>.  The actual merges to be
             executed are determined by the <see cref="T:Lucene.Net.Index.MergePolicy"/>.
            
             <para>This is a horribly costly operation, especially when
             you pass a small <paramref name="maxNumSegments"/>; usually you
             should only call this if the index is static (will no
             longer be changed).</para>
            
             <para>Note that this requires up to 2X the index size free
             space in your Directory (3X if you're using compound
             file format).  For example, if your index size is 10 MB
             then you need up to 20 MB free for this to complete (30
             MB if you're using compound file format).  Also,
             it's best to call <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> afterwards,
             to allow <see cref="T:Lucene.Net.Index.IndexWriter"/> to free up disk space.</para>
            
             <para>If some but not all readers re-open while merging
             is underway, this will cause &gt; 2X temporary
             space to be consumed as those new readers will then
             hold open the temporary segments at that time.  It is
             best not to re-open readers while merging is running.</para>
            
             <para>The actual temporary usage could be much less than
             these figures (it depends on many factors).</para>
            
             <para>In general, once this completes, the total size of the
             index will be less than the size of the starting index.
             It could be quite a bit smaller (if there were many
             pending deletes) or just slightly smaller.</para>
            
             <para>If an <see cref="T:System.Exception"/> is hit, for example
             due to disk full, the index will not be corrupted and no
             documents will be lost.  However, it may have
             been partially merged (some segments were merged but
             not all), and it's possible that one of the segments in
             the index will be in non-compound format even when
             using compound file format.  This will occur when the
             <see cref="T:System.Exception"/> is hit during conversion of the segment into
             compound format.</para>
            
             <para>This call will merge those segments present in
             the index when the call started.  If other threads are
             still adding documents and flushing segments, those
             newly created segments will not be merged unless you
             call <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> again.</para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
            
             <para><b>NOTE</b>: if you call <see cref="M:Lucene.Net.Index.IndexWriter.Dispose(System.Boolean)"/>
             with <c>false</c>, which aborts all running merges,
             then any thread still running this method might hit a
             <see cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/>.</para>
             </summary>
             <param name="maxNumSegments"> maximum number of segments left
             in the index after merging finishes
             </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
             <seealso cref="M:Lucene.Net.Index.MergePolicy.FindMerges(Lucene.Net.Index.MergeTrigger,Lucene.Net.Index.SegmentInfos)"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32,System.Boolean)">
             <summary>
             Just like <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>, except you can
             specify whether the call should block until
             all merging completes.  This is only meaningful with a
             <see cref="F:Lucene.Net.Index.IndexWriter.mergeScheduler"/> that is able to run merges in
             background threads.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MaxNumSegmentsMergesPending">
            <summary>
            Returns <c>true</c> if any merges in <see cref="F:Lucene.Net.Index.IndexWriter.pendingMerges"/> or
            <see cref="F:Lucene.Net.Index.IndexWriter.runningMerges"/> are <see cref="F:Lucene.Net.Index.IndexWriter.mergeMaxNumSegments"/> merges.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes(System.Boolean)">
             <summary>
             Just like <see cref="M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes"/>, except you can
             specify whether the call should block until the
             operation completes.  This is only meaningful with a
             <see cref="T:Lucene.Net.Index.MergeScheduler"/> that is able to run merges in
             background threads.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
            
             <para><b>NOTE</b>: if you call <see cref="M:Lucene.Net.Index.IndexWriter.Dispose(System.Boolean)"/>
             with <c>false</c>, which aborts all running merges,
             then any thread still running this method might hit a
             <see cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/>.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes">
             <summary>
             Forces merging of all segments that have deleted
             documents.  The actual merges to be executed are
             determined by the <see cref="T:Lucene.Net.Index.MergePolicy"/>.  For example,
             the default <see cref="T:Lucene.Net.Index.TieredMergePolicy"/> will only
             pick a segment if the percentage of
             deleted docs is over 10%.
            
             <para>This is often a horribly costly operation; rarely
             is it warranted.</para>
            
             <para>To see how
             many deletions you have pending in your index, call
             <see cref="P:Lucene.Net.Index.IndexReader.NumDeletedDocs"/>.</para>
            
             <para><b>NOTE</b>: this method first flushes a new
             segment (if there are indexed documents), and applies
             all buffered deletes.</para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MaybeMerge">
             <summary>
             Expert: asks the <see cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/> whether any merges are
             necessary now and if so, runs the requested merges and
             then iterate (test again if merges are needed) until no
             more merges are returned by the <see cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/>.
             <para/>
             Explicit calls to <see cref="M:Lucene.Net.Index.IndexWriter.MaybeMerge"/> are usually not
             necessary. The most common case is when merge policy
             parameters have changed.
             <para/>
             this method will call the <see cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/> with
             <see cref="F:Lucene.Net.Index.MergeTrigger.EXPLICIT"/>.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.MergingSegments">
            <summary>
            Expert: to be used by a <see cref="T:Lucene.Net.Index.MergePolicy"/> to avoid
            selecting merges for segments already being merged.
            The returned collection is not cloned, and thus is
            only safe to access if you hold <see cref="T:Lucene.Net.Index.IndexWriter"/>'s lock
            (which you do when <see cref="T:Lucene.Net.Index.IndexWriter"/> invokes the
            <see cref="T:Lucene.Net.Index.MergePolicy"/>).
            <para/>
            Do not alter the returned collection!
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.NextMerge">
            <summary>
            Expert: the <see cref="F:Lucene.Net.Index.IndexWriter.mergeScheduler"/> calls this method to retrieve the next
            merge requested by the <see cref="T:Lucene.Net.Index.MergePolicy"/>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.HasPendingMerges">
            <summary>
            Expert: returns true if there are merges waiting to be scheduled.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Rollback">
            <summary>
            Close the <see cref="T:Lucene.Net.Index.IndexWriter"/> without committing
            any changes that have occurred since the last commit
            (or since it was opened, if commit hasn't been called).
            this removes any temporary files that had been created,
            after which the state of the index will be the same as
            it was when <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> was last called or when this
            writer was first opened.  This also clears a previous
            call to <see cref="M:Lucene.Net.Index.IndexWriter.PrepareCommit"/>.
            </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteAll">
             <summary>
             Delete all documents in the index.
            
             <para>This method will drop all buffered documents and will
                remove all segments from the index. This change will not be
                visible until a <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> has been called. This method
                can be rolled back using <see cref="M:Lucene.Net.Index.IndexWriter.Rollback"/>.</para>
            
             <para>NOTE: this method is much faster than using <c>DeleteDocuments(new MatchAllDocsQuery())</c>.
                Yet, this method also has different semantics compared to <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query)"/>
                / <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query[])"/> since internal data-structures are cleared as well
                as all segment information is forcefully dropped anti-viral semantics like omitting norms
                are reset or doc value types are cleared. Essentially a call to <see cref="M:Lucene.Net.Index.IndexWriter.DeleteAll"/> is equivalent
                to creating a new <see cref="T:Lucene.Net.Index.IndexWriter"/> with <see cref="F:Lucene.Net.Index.OpenMode.CREATE"/> which a delete query only marks
                documents as deleted.</para>
            
             <para>NOTE: this method will forcefully abort all merges
                in progress.  If other threads are running 
                <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>, <see cref="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])"/> or
                <see cref="M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes"/> methods, they may receive
                <see cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/>s.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.WaitForMerges">
             <summary>
             Wait for any currently outstanding merges to finish.
            
             <para>It is guaranteed that any merges started prior to calling this method
                will have completed once this method completes.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Checkpoint">
            <summary>
            Called whenever the <see cref="T:Lucene.Net.Index.SegmentInfos"/> has been updated and
            the index files referenced exist (correctly) in the
            index directory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.CheckpointNoSIS">
            <summary>
            Checkpoints with <see cref="T:Lucene.Net.Index.IndexFileDeleter"/>, so it's aware of
            new files, and increments <see cref="F:Lucene.Net.Index.IndexWriter.changeCount"/>, so on
            close/commit we will write a new segments file, but
            does NOT bump segmentInfos.version.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Changed">
            <summary>
            Called internally if any index state has changed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.PublishFlushedSegment(Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Index.FrozenBufferedUpdates,Lucene.Net.Index.FrozenBufferedUpdates)">
            <summary>
            Atomically adds the segment private delete packet and publishes the flushed
            segments <see cref="T:Lucene.Net.Index.SegmentInfo"/> to the index writer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AcquireWriteLocks(Lucene.Net.Store.Directory[])">
            <summary>
            Acquires write locks on all the directories; be sure
            to match with a call to <see cref="M:Lucene.Net.Util.IOUtils.Dispose(System.Collections.Generic.IEnumerable{System.IDisposable})"/> in a
            finally clause.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Store.Directory[])">
             <summary>
             Adds all segments from an array of indexes into this index.
            
             <para/>This may be used to parallelize batch indexing. A large document
             collection can be broken into sub-collections. Each sub-collection can be
             indexed in parallel, on a different thread, process or machine. The
             complete index can then be created by merging sub-collection indexes
             with this method.
            
             <para/>
             <b>NOTE:</b> this method acquires the write lock in
             each directory, to ensure that no <see cref="T:Lucene.Net.Index.IndexWriter"/>
             is currently open or tries to open while this is
             running.
            
             <para/>This method is transactional in how <see cref="T:System.Exception"/>s are
             handled: it does not commit a new segments_N file until
             all indexes are added.  this means if an <see cref="T:System.Exception"/>
             occurs (for example disk full), then either no indexes
             will have been added or they all will have been.
            
             <para/>Note that this requires temporary free space in the
             <see cref="T:Lucene.Net.Store.Directory"/> up to 2X the sum of all input indexes
             (including the starting index). If readers/searchers
             are open against the starting index, then temporary
             free space required will be higher by the size of the
             starting index (see <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> for details).
            
             <para/>
             <b>NOTE:</b> this method only copies the segments of the incoming indexes
             and does not merge them. Therefore deleted documents are not removed and
             the new segments are not merged with the existing ones.
            
             <para/>This requires this index not be among those to be added.
            
             <para/>
             <b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer. See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
             <exception cref="T:Lucene.Net.Store.LockObtainFailedException"> if we were unable to
               acquire the write lock in at least one directory </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])">
             <summary>
             Merges the provided indexes into this index.
            
             <para/>
             The provided <see cref="T:Lucene.Net.Index.IndexReader"/>s are not closed.
            
             <para/>
             See <see cref="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])"/> for details on transactional semantics, temporary
             free space required in the <see cref="T:Lucene.Net.Store.Directory"/>, and non-CFS segments on an <see cref="T:System.Exception"/>.
            
             <para/>
             <b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/> you should immediately
             dispose the writer. See <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.
            
             <para/>
             <b>NOTE:</b> empty segments are dropped by this method and not added to this
             index.
            
             <para/>
             <b>NOTE:</b> this method merges all given <see cref="T:Lucene.Net.Index.IndexReader"/>s in one
             merge. If you intend to merge a large number of readers, it may be better
             to call this method multiple times, each time with a small set of readers.
             In principle, if you use a merge policy with a <c>mergeFactor</c> or
             <c>maxMergeAtOnce</c> parameter, you should pass that many readers in one
             call. Also, if the given readers are <see cref="T:Lucene.Net.Index.DirectoryReader"/>s, they can be
             opened with <c>termIndexInterval=-1</c> to save RAM, since during merge
             the in-memory structure is not used. See
             <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory,System.Int32)"/>.
            
             <para/>
             <b>NOTE</b>: if you call <see cref="M:Lucene.Net.Index.IndexWriter.Dispose(System.Boolean)"/> with <c>false</c>, which
             aborts all running merges, then any thread still running this method might
             hit a <see cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/>.
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException">
                       if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException">
                       if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.CopySegmentAsIs(Lucene.Net.Index.SegmentCommitInfo,System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.ISet{System.String},Lucene.Net.Store.IOContext,System.Collections.Generic.ISet{System.String})">
            <summary>
            Copies the segment files as-is into the <see cref="T:Lucene.Net.Index.IndexWriter"/>'s directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DoAfterFlush">
            <summary>
            A hook for extending classes to execute operations after pending added and
            deleted documents have been flushed to the <see cref="T:Lucene.Net.Store.Directory"/> but before the change
            is committed (new segments_N file written).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DoBeforeFlush">
            <summary>
            A hook for extending classes to execute operations before pending added and
            deleted documents are flushed to the <see cref="T:Lucene.Net.Store.Directory"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.PrepareCommit">
             <summary>
             <para>Expert: prepare for commit.  This does the
             first phase of 2-phase commit. this method does all
             steps necessary to commit changes since this writer
             was opened: flushes pending added and deleted docs,
             syncs the index files, writes most of next segments_N
             file.  After calling this you must call either 
             <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> to finish the commit, or 
             <see cref="M:Lucene.Net.Index.IndexWriter.Rollback"/> to revert the commit and undo all changes
             done since the writer was opened.</para>
            
             <para>You can also just call <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> directly
             without <see cref="M:Lucene.Net.Index.IndexWriter.PrepareCommit"/> first in which case that method
             will internally call <see cref="M:Lucene.Net.Index.IndexWriter.PrepareCommit"/>.</para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetCommitData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sets the commit user data map. That method is considered a transaction by
            <see cref="T:Lucene.Net.Index.IndexWriter"/> and will be committed (<see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> even if no other
            changes were made to the writer instance. Note that you must call this method
            before <see cref="M:Lucene.Net.Index.IndexWriter.PrepareCommit"/>, or otherwise it won't be included in the
            follow-on <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>.
            <para/>
            <b>NOTE:</b> the dictionary is cloned internally, therefore altering the dictionary's
            contents after calling this method has no effect.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.CommitData">
            <summary>
            Returns the commit user data map that was last committed, or the one that
            was set on <see cref="M:Lucene.Net.Index.IndexWriter.SetCommitData(System.Collections.Generic.IDictionary{System.String,System.String})"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.commitLock">
            <summary>
            Used only by commit and prepareCommit, below; lock
            order is commitLock -> IW
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Commit">
             <summary>
             <para>Commits all pending changes (added &amp; deleted
             documents, segment merges, added
             indexes, etc.) to the index, and syncs all referenced
             index files, such that a reader will see the changes
             and the index updates will survive an OS or machine
             crash or power loss.  Note that this does not wait for
             any running background merges to finish.  This may be a
             costly operation, so you should test the cost in your
             application and do it only when really necessary.</para>
            
             <para> Note that this operation calls <see cref="M:Lucene.Net.Store.Directory.Sync(System.Collections.Generic.ICollection{System.String})"/> on
             the index files.  That call should not return until the
             file contents &amp; metadata are on stable storage.  For
             <see cref="T:Lucene.Net.Store.FSDirectory"/>, this calls the OS's fsync.  But, beware:
             some hardware devices may in fact cache writes even
             during fsync, and return before the bits are actually
             on stable storage, to give the appearance of faster
             performance.  If you have such a device, and it does
             not have a battery backup (for example) then on power
             loss it may still lose data.  Lucene cannot guarantee
             consistency on such devices.  </para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.HasUncommittedChanges">
            <summary>
            Returns <c>true</c> if there may be changes that have not been
            committed.  There are cases where this may return <c>true</c>
            when there are no actual "real" changes to the index,
            for example if you've deleted by <see cref="T:Lucene.Net.Index.Term"/> or <see cref="T:Lucene.Net.Search.Query"/> but
            that <see cref="T:Lucene.Net.Index.Term"/> or <see cref="T:Lucene.Net.Search.Query"/> does not match any documents.
            Also, if a merge kicked off as a result of flushing a
            new segment during <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>, or a concurrent
            merged finished, this method may return <c>true</c> right
            after you had just called <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.fullFlushLock">
            <summary>
            Ensures only one <see cref="M:Lucene.Net.Index.IndexWriter.Flush(System.Boolean,System.Boolean)"/> is actually flushing segments
            at a time:
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Flush(System.Boolean,System.Boolean)">
            <summary>
            Flush all in-memory buffered updates (adds and deletes)
            to the <see cref="T:Lucene.Net.Store.Directory"/>. </summary>
            <param name="triggerMerge"> if <c>true</c>, we may merge segments (if
            deletes or docs were flushed) if necessary </param>
            <param name="applyAllDeletes"> whether pending deletes should also </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.RamSizeInBytes">
            <summary>
            Expert:  Return the total size of all index files currently cached in memory.
            Useful for size management with flushRamDocs()
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.NumRamDocs">
            <summary>
            Expert:  Return the number of documents currently
            buffered in RAM.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.CommitMergedDeletesAndUpdates(Lucene.Net.Index.MergePolicy.OneMerge,Lucene.Net.Index.MergeState)">
            <summary>
            Carefully merges deletes and updates for the segments we just merged. This
            is tricky because, although merging will clear all deletes (compacts the
            documents) and compact all the updates, new deletes and updates may have
            been flushed to the segments since the merge was started. This method
            "carries over" such new deletes and updates onto the newly merged segment,
            and saves the resulting deletes and updates files (incrementing the delete
            and DV generations for merge.info). If no deletes were flushed, no new
            deletes file is saved.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Merge(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Merges the indicated segments, replacing them in the stack with a
            single segment.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeSuccess(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Hook that's called when the specified merge is complete. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.RegisterMerge(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Checks whether this merge involves any segments
            already participating in a merge.  If not, this merge
            is "registered", meaning we record that its segments
            are now participating in a merge, and <c>true</c> is
            returned.  Else (the merge conflicts) <c>false</c> is
            returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeInit(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does initial setup for a merge, which is fast but holds
            the synchronized lock on <see cref="T:Lucene.Net.Index.IndexWriter"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeFinish(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does fininishing for a merge, which is fast but holds
            the synchronized lock on <see cref="T:Lucene.Net.Index.IndexWriter"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeMiddle(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does the actual (time-consuming) work of the merge,
            but without holding synchronized lock on <see cref="T:Lucene.Net.Index.IndexWriter"/>
            instance
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SegString">
            <summary>
            Returns a string description of all segments, for
            debugging.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SegString(System.Collections.Generic.IEnumerable{Lucene.Net.Index.SegmentCommitInfo})">
            <summary>
            Returns a string description of the specified
            segments, for debugging.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SegString(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Returns a string description of the specified
            segment, for debugging.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.KeepFullyDeletedSegments">
            <summary>
            Only for testing.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.StartCommit(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Walk through all files referenced by the current
            <see cref="F:Lucene.Net.Index.IndexWriter.segmentInfos"/> and ask the <see cref="T:Lucene.Net.Store.Directory"/> to sync each file,
            if it wasn't already.  If that succeeds, then we
            prepare a new segments_N file but do not fully commit
            it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.IsLocked(Lucene.Net.Store.Directory)">
            <summary>
            Returns <c>true</c> iff the index in the named directory is
            currently locked. </summary>
            <param name="directory"> the directory to check for a lock </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Unlock(Lucene.Net.Store.Directory)">
            <summary>
            Forcibly unlocks the index in the named directory.
            <para/>
            Caution: this should only be used by failure recovery code,
            when it is known that no other process nor thread is in fact
            currently accessing this index.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter.IndexReaderWarmer">
            <summary>
            If <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/> has
            been called (ie, this writer is in near real-time
            mode), then after a merge completes, this class can be
            invoked to warm the reader on the newly merged
            segment, before the merge commits.  This is not
            required for near real-time search, but will reduce
            search latency on opening a new near real-time reader
            after a merge completes.
            <para/>
            @lucene.experimental
            
            <para/><b>NOTE</b>: <see cref="M:Lucene.Net.Index.IndexWriter.IndexReaderWarmer.Warm(Lucene.Net.Index.AtomicReader)"/> is called before any deletes have
            been carried over to the merged segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.IndexReaderWarmer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.IndexReaderWarmer.Warm(Lucene.Net.Index.AtomicReader)">
            <summary>
            Invoked on the <see cref="T:Lucene.Net.Index.AtomicReader"/> for the newly
            merged segment, before that segment is made visible
            to near-real-time readers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteUnusedFiles">
             <summary>
             Expert: remove any index files that are no longer
             used.
            
             <para> <see cref="T:Lucene.Net.Index.IndexWriter"/> normally deletes unused files itself,
             during indexing.  However, on Windows, which disallows
             deletion of open files, if there is a reader open on
             the index then those files cannot be deleted.  This is
             fine, because <see cref="T:Lucene.Net.Index.IndexWriter"/> will periodically retry
             the deletion.</para>
            
             <para> However, <see cref="T:Lucene.Net.Index.IndexWriter"/> doesn't try that often: only
             on open, close, flushing a new segment, and finishing
             a merge.  If you don't do any of these actions with your
             <see cref="T:Lucene.Net.Index.IndexWriter"/>, you'll see the unused files linger.  If
             that's a problem, call this method to delete them
             (once you've closed the open readers that were
             preventing their deletion).</para>
            
             <para> In addition, you can call this method to delete
             unreferenced index commits. this might be useful if you
             are using an <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> which holds
             onto index commits until some criteria are met, but those
             commits are no longer needed. Otherwise, those commits will
             be deleted the next time <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> is called.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.CreateCompoundFile(Lucene.Net.Util.InfoStream,Lucene.Net.Store.Directory,Lucene.Net.Index.CheckAbort,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext)">
            <summary>
            NOTE: this method creates a compound file for all files returned by
            info.files(). While, generally, this may include separate norms and
            deletion files, this <see cref="T:Lucene.Net.Index.SegmentInfo"/> must not reference such files when this
            method is called, because they are not allowed within a compound file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteNewFiles(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Tries to delete the given files if unreferenced </summary>
            <param name="files"> the files to delete </param>
            <exception cref="T:System.IO.IOException"> if an <see cref="T:System.IO.IOException"/> occurs </exception>
            <seealso cref="M:Lucene.Net.Index.IndexFileDeleter.DeleteNewFiles(System.Collections.Generic.ICollection{System.String})"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.FlushFailed(Lucene.Net.Index.SegmentInfo)">
            <summary>
            Cleans up residuals from a segment that could not be entirely flushed due to an error </summary>
            <seealso cref="M:Lucene.Net.Index.IndexFileDeleter.Refresh(System.String)"/>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter.IEvent">
            <summary>
            Interface for internal atomic events. See <see cref="T:Lucene.Net.Index.DocumentsWriter"/> for details. Events are executed concurrently and no order is guaranteed.
            Each event should only rely on the serializeability within it's process method. All actions that must happen before or after a certain action must be
            encoded inside the <see cref="M:Lucene.Net.Index.IndexWriter.IEvent.Process(Lucene.Net.Index.IndexWriter,System.Boolean,System.Boolean)"/> method.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.IEvent.Process(Lucene.Net.Index.IndexWriter,System.Boolean,System.Boolean)">
            <summary>
            Processes the event. this method is called by the <see cref="T:Lucene.Net.Index.IndexWriter"/>
            passed as the first argument.
            </summary>
            <param name="writer">
                     the <see cref="T:Lucene.Net.Index.IndexWriter"/> that executes the event. </param>
            <param name="triggerMerge">
                     <c>false</c> iff this event should not trigger any segment merges </param>
            <param name="clearBuffers">
                     <c>true</c> iff this event should clear all buffers associated with the event. </param>
            <exception cref="T:System.IO.IOException">
                      if an <see cref="T:System.IO.IOException"/> occurs </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SlowFileExists(Lucene.Net.Store.Directory,System.String)">
            <summary>
            Used only by asserts: returns <c>true</c> if the file exists
            (can be opened), <c>false</c> if it cannot be opened, and
            (unlike <see cref="M:System.IO.File.Exists(System.String)"/>) throws <see cref="T:System.IO.IOException"/> if
            there's some unexpected error.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriterConfig">
             <summary>
             Holds all the configuration that is used to create an <see cref="T:Lucene.Net.Index.IndexWriter"/>.
             Once <see cref="T:Lucene.Net.Index.IndexWriter"/> has been created with this object, changes to this
             object will not affect the <see cref="T:Lucene.Net.Index.IndexWriter"/> instance. For that, use
             <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> that is returned from <see cref="P:Lucene.Net.Index.IndexWriter.Config"/>.
            
             <para/>
             LUCENENET NOTE: Unlike Lucene, we use property setters instead of setter methods.
             In C#, this allows you to initialize the <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>
             using the language features of C#, for example:
             <code>
                 IndexWriterConfig conf = new IndexWriterConfig(analyzer)
                 {
                     Codec = Lucene46Codec(),
                     OpenMode = OpenMode.CREATE
                 };
             </code>
             
             However, if you prefer to match the syntax of Lucene using chained setter methods, 
             there are extension methods in the Lucene.Net.Support namespace. Example usage:
             <code>
                 using Lucene.Net.Support;
                 
                 ..
                 
                 IndexWriterConfig conf = new IndexWriterConfig(analyzer)
                     .SetCodec(new Lucene46Codec())
                     .SetOpenMode(OpenMode.CREATE);
             </code>
             
             @since 3.1
             </summary>
             <seealso cref="P:Lucene.Net.Index.IndexWriter.Config"/>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_TERM_INDEX_INTERVAL">
            <summary>
            Default value is 32. Change using <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/> setter. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DISABLE_AUTO_FLUSH">
            <summary>
            Denotes a flush trigger is disabled. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_BUFFERED_DELETE_TERMS">
            <summary>
            Disabled by default (because IndexWriter flushes by RAM usage by default). </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_BUFFERED_DOCS">
            <summary>
            Disabled by default (because IndexWriter flushes by RAM usage by default). </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_RAM_BUFFER_SIZE_MB">
            <summary>
            Default value is 16 MB (which means flush when buffered docs consume
            approximately 16 MB RAM).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.WRITE_LOCK_TIMEOUT">
            <summary>
            Default value for the write lock timeout (1,000 ms).
            </summary>
            <see cref="P:Lucene.Net.Index.IndexWriterConfig.DefaultWriteLockTimeout"/>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_READER_POOLING">
            <summary>
            Default setting for <see cref="P:Lucene.Net.Index.IndexWriterConfig.UseReaderPooling"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_READER_TERMS_INDEX_DIVISOR">
            <summary>
            Default value is 1. Change using <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.ReaderTermsIndexDivisor"/> setter. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_RAM_PER_THREAD_HARD_LIMIT_MB">
            <summary>
            Default value is 1945. Change using <see cref="P:Lucene.Net.Index.IndexWriterConfig.RAMPerThreadHardLimitMB"/> setter. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_THREAD_STATES">
            <summary>
            The maximum number of simultaneous threads that may be
            indexing documents at once in <see cref="T:Lucene.Net.Index.IndexWriter"/>; if more
            than this many threads arrive they will wait for
            others to finish. Default value is 8.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_USE_COMPOUND_FILE_SYSTEM">
            <summary>
            Default value for compound file system for newly written segments
            (set to <c>true</c>). For batch indexing with very large
            ram buffers use <c>false</c>
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_CHECK_INTEGRITY_AT_MERGE">
            <summary>
            Default value for calling <see cref="M:Lucene.Net.Index.AtomicReader.CheckIntegrity"/> before
            merging segments (set to <c>false</c>). You can set this
            to <c>true</c> for additional safety.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.DefaultWriteLockTimeout">
            <summary>
            Gets or sets the default (for any instance) maximum time to wait for a write lock
            (in milliseconds).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriterConfig.SetIndexWriter(Lucene.Net.Index.IndexWriter)">
            <summary>
            Gets or sets the <see cref="T:Lucene.Net.Index.IndexWriter"/> this config is attached to.
            </summary>
            <exception cref="T:Lucene.Net.Util.AlreadySetException">
                      if this config is already attached to a writer. </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriterConfig.#ctor(Lucene.Net.Util.LuceneVersion,Lucene.Net.Analysis.Analyzer)">
            <summary>
            Creates a new config that with defaults that match the specified
            <see cref="T:Lucene.Net.Util.LuceneVersion"/> as well as the default 
            <see cref="T:Lucene.Net.Analysis.Analyzer"/>. If <paramref name="matchVersion"/> is &gt;= 
            <see cref="F:Lucene.Net.Util.LuceneVersion.LUCENE_32"/>, <see cref="T:Lucene.Net.Index.TieredMergePolicy"/> is used
            for merging; else <see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/>.
            Note that <see cref="T:Lucene.Net.Index.TieredMergePolicy"/> is free to select
            non-contiguous merges, which means docIDs may not
            remain monotonic over time.  If this is a problem you
            should switch to <see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/> or
            <see cref="T:Lucene.Net.Index.LogDocMergePolicy"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.OpenMode">
             <summary>
             Specifies <see cref="T:Lucene.Net.Index.OpenMode"/> of the index.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.IndexDeletionPolicy">
             <summary>
             Expert: allows an optional <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> implementation to be
             specified. You can use this to control when prior commits are deleted from
             the index. The default policy is <see cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/>
             which removes all prior commits as soon as a new commit is done (this
             matches behavior before 2.2). Creating your own policy can allow you to
             explicitly keep previous "point in time" commits alive in the index for
             some time, to allow readers to refresh to the new commit without having the
             old commit deleted out from under them. This is necessary on filesystems
             like NFS that do not support "delete on last close" semantics, which
             Lucene's "point in time" search normally relies on.
             <para/>
             <b>NOTE:</b> the deletion policy cannot be <c>null</c>.
            
             <para/>Only takes effect when IndexWriter is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.IndexCommit">
             <summary>
             Expert: allows to open a certain commit point. The default is <c>null</c> which
             opens the latest commit point.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.Similarity">
             <summary>
             Expert: set the <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> implementation used by this <see cref="T:Lucene.Net.Index.IndexWriter"/>.
             <para/>
             <b>NOTE:</b> the similarity cannot be <c>null</c>.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.MergeScheduler">
             <summary>
             Expert: Gets or sets the merge scheduler used by this writer. The default is
             <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler"/>.
             <para/>
             <b>NOTE:</b> the merge scheduler cannot be <c>null</c>.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.WriteLockTimeout">
             <summary>
             Gets or sets the maximum time to wait for a write lock (in milliseconds) for this
             instance. You can change the default value for all instances by calling the
             <see cref="P:Lucene.Net.Index.IndexWriterConfig.DefaultWriteLockTimeout"/> setter.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.Codec">
             <summary>
             Gets or sets the <see cref="T:Lucene.Net.Codecs.Codec"/>.
            
             <para/>
             Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.MergePolicy">
             <summary>
             Expert: <see cref="T:Lucene.Net.Index.MergePolicy"/> is invoked whenever there are changes to the
             segments in the index. Its role is to select which merges to do, if any,
             and return a <see cref="T:Lucene.Net.Index.MergePolicy.MergeSpecification"/> describing the merges.
             It also selects merges to do for <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.IndexerThreadPool">
            <summary>
            Expert: Gets or sets the <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> instance used by the
            <see cref="T:Lucene.Net.Index.IndexWriter"/> to assign thread-states to incoming indexing threads. If no
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> is set <see cref="T:Lucene.Net.Index.IndexWriter"/> will use
            <see cref="T:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool"/> with max number of
            thread-states set to <see cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_THREAD_STATES"/> (see
            <see cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_THREAD_STATES"/>).
            <para>
            NOTE: The given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> instance must not be used with
            other <see cref="T:Lucene.Net.Index.IndexWriter"/> instances once it has been initialized / associated with an
            <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </para>
            <para>
            NOTE: this only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.</para>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.MaxThreadStates">
             <summary>
             Gets or sets the max number of simultaneous threads that may be indexing documents
             at once in <see cref="T:Lucene.Net.Index.IndexWriter"/>. Values &lt; 1 are invalid and if passed
             <c>maxThreadStates</c> will be set to
             <see cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_THREAD_STATES"/>.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.UseReaderPooling">
             <summary>
             By default, <see cref="T:Lucene.Net.Index.IndexWriter"/> does not pool the
             <see cref="T:Lucene.Net.Index.SegmentReader"/>s it must open for deletions and
             merging, unless a near-real-time reader has been
             obtained by calling <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/>.
             this setting lets you enable pooling without getting a
             near-real-time reader.  NOTE: if you set this to
             <c>false</c>, <see cref="T:Lucene.Net.Index.IndexWriter"/> will still pool readers once
             <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/> is called.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.IndexingChain">
             <summary>
             Expert: Gets or sets the <see cref="T:Lucene.Net.Index.DocConsumer"/> chain to be used to process documents.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.RAMPerThreadHardLimitMB">
            <summary>
            Expert: Gets or sets the maximum memory consumption per thread triggering a forced
            flush if exceeded. A <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> is forcefully flushed
            once it exceeds this limit even if the <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/> has
            not been exceeded. This is a safety limit to prevent a
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> from address space exhaustion due to its
            internal 32 bit signed integer based memory addressing.
            The given value must be less that 2GB (2048MB).
            </summary>
            <seealso cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_RAM_PER_THREAD_HARD_LIMIT_MB"/>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.FlushPolicy">
            <summary>
            Expert: Controls when segments are flushed to disk during indexing.
            The <see cref="T:Lucene.Net.Index.FlushPolicy"/> initialized during <see cref="T:Lucene.Net.Index.IndexWriter"/> instantiation and once initialized
            the given instance is bound to this <see cref="T:Lucene.Net.Index.IndexWriter"/> and should not be used with another writer.
            </summary>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriterConfig.SetInfoStream(Lucene.Net.Util.InfoStream)">
            <summary>
            Information about merges, deletes and a
            message when maxFieldLength is reached will be printed
            to this. Must not be <c>null</c>, but <see cref="F:Lucene.Net.Util.InfoStream.NO_OUTPUT"/>
            may be used to supress output.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriterConfig.SetInfoStream(System.IO.TextWriter)">
            <summary>
            Convenience method that uses <see cref="T:Lucene.Net.Util.TextWriterInfoStream"/> to write to the passed in <see cref="T:System.IO.TextWriter"/>. 
            Must not be <c>null</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.OpenMode">
            <summary>
            Specifies the open mode for <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.OpenMode.CREATE">
            <summary>
            Creates a new index or overwrites an existing one.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.OpenMode.APPEND">
            <summary>
            Opens an existing index.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.OpenMode.CREATE_OR_APPEND">
            <summary>
            Creates a new index if one does not exist,
            otherwise it opens the index and documents will be appended.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.InvertedDocConsumer.Abort">
            <summary>
            Abort (called after hitting AbortException) </summary>
        </member>
        <member name="M:Lucene.Net.Index.InvertedDocConsumer.Flush(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Index.InvertedDocConsumerPerField},Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Flush a new segment </summary>
        </member>
        <member name="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy">
            <summary>
            This <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> implementation that
            keeps only the most recent commit and immediately removes
            all prior commits after a new commit is done.  This is
            the default deletion policy.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.OnInit``1(System.Collections.Generic.IList{``0})">
            <summary>
            Deletes all commits except the most recent one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.OnCommit``1(System.Collections.Generic.IList{``0})">
            <summary>
            Deletes all commits except the most recent one.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LiveIndexWriterConfig">
             <summary>
             Holds all the configuration used by <see cref="T:Lucene.Net.Index.IndexWriter"/> with few setters for
             settings that can be changed on an <see cref="T:Lucene.Net.Index.IndexWriter"/> instance "live".
            
             @since 4.0
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.delPolicy">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> controlling when commit
            points are deleted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.commit">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexCommit"/> that <see cref="T:Lucene.Net.Index.IndexWriter"/> is
            opened on.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.openMode">
            <summary>
            <see cref="T:Lucene.Net.Index.OpenMode"/> that <see cref="T:Lucene.Net.Index.IndexWriter"/> is opened
            with.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.similarity">
            <summary>
            <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> to use when encoding norms. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.mergeScheduler">
            <summary>
            <see cref="T:Lucene.Net.Index.IMergeScheduler"/> to use for running merges. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.writeLockTimeout">
            <summary>
            Timeout when trying to obtain the write lock on init. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.indexingChain">
            <summary>
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread.IndexingChain"/> that determines how documents are
            indexed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.codec">
            <summary>
            <see cref="T:Lucene.Net.Codecs.Codec"/> used to write new segments. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.infoStream">
            <summary>
            <see cref="T:Lucene.Net.Util.InfoStream"/> for debugging messages. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.mergePolicy">
            <summary>
            <see cref="T:Lucene.Net.Index.MergePolicy"/> for selecting merges. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.indexerThreadPool">
            <summary>
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> to control how
            threads are allocated to <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.readerPooling">
            <summary>
            True if readers should be pooled. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.flushPolicy">
            <summary>
            <see cref="T:Lucene.Net.Index.FlushPolicy"/> to control when segments are
            flushed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.perThreadHardLimitMB">
            <summary>
            Sets the hard upper bound on RAM usage for a single
            segment, after which the segment is forced to flush.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.matchVersion">
            <summary>
            <see cref="T:Lucene.Net.Util.LuceneVersion"/> that <see cref="T:Lucene.Net.Index.IndexWriter"/> should emulate. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.useCompoundFile">
            <summary>
            True if segment flushes should use compound file format </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.checkIntegrityAtMerge">
            <summary>
            True if merging should check integrity of segments before merge </summary>
        </member>
        <member name="M:Lucene.Net.Index.LiveIndexWriterConfig.#ctor(Lucene.Net.Index.IndexWriterConfig)">
            <summary>
            Creates a new config that that handles the live <see cref="T:Lucene.Net.Index.IndexWriter"/>
            settings.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.Analyzer">
            <summary>
            Gets the default analyzer to use for indexing documents. </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval">
             <summary>
             Expert: Gets or sets the interval between indexed terms. Large values cause less
             memory to be used by <see cref="T:Lucene.Net.Index.IndexReader"/>, but slow random-access to terms. Small
             values cause more memory to be used by an <see cref="T:Lucene.Net.Index.IndexReader"/>, and speed
             random-access to terms.
             <para/>
             This parameter determines the amount of computation required per query
             term, regardless of the number of documents that contain that term. In
             particular, it is the maximum number of other terms that must be scanned
             before a term is located and its frequency and position information may be
             processed. In a large index with user-entered query terms, query processing
             time is likely to be dominated not by term lookup but rather by the
             processing of frequency and positional data. In a small index or when many
             uncommon query terms are generated (e.g., by wildcard queries) term lookup
             may become a dominant cost.
             <para/>
             In particular, <c>numUniqueTerms/interval</c> terms are read into
             memory by an <see cref="T:Lucene.Net.Index.IndexReader"/>, and, on average, <c>interval/2</c> terms
             must be scanned for each random term access.
            
             <para/>
             Takes effect immediately, but only applies to newly flushed/merged
             segments.
            
             <para/>
             <b>NOTE:</b> this parameter does not apply to all <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> implementations,
             including the default one in this release. It only makes sense for term indexes
             that are implemented as a fixed gap between terms. For example,
             <see cref="T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat"/> implements the term index instead based upon how
             terms share prefixes. To configure its parameters (the minimum and maximum size
             for a block), you would instead use <see cref="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.#ctor(System.Int32,System.Int32)"/>.
             which can also be configured on a per-field basis:
             <code>
             public class MyLucene45Codec : Lucene45Codec
             {
                 //customize Lucene41PostingsFormat, passing minBlockSize=50, maxBlockSize=100
                 private readonly PostingsFormat tweakedPostings = new Lucene41PostingsFormat(50, 100);
             
                 public override PostingsFormat GetPostingsFormatForField(string field)
                 {
                     if (field.Equals("fieldWithTonsOfTerms", StringComparison.Ordinal))
                         return tweakedPostings;
                     else
                         return base.GetPostingsFormatForField(field);
                 }
             }
             ...
             
             iwc.Codec = new MyLucene45Codec();
             </code>
             Note that other implementations may have their own parameters, or no parameters at all.
             </summary>
             <seealso cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_TERM_INDEX_INTERVAL"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms">
             <summary>
             Gets or sets a value that determines the maximum number of delete-by-term operations that will be
             buffered before both the buffered in-memory delete terms and queries are
             applied and flushed.
             <para/>
             Disabled by default (writer flushes by RAM usage).
             <para/>
             NOTE: this setting won't trigger a segment flush.
            
             <para/>
             Takes effect immediately, but only the next time a document is added,
             updated or deleted. Also, if you only delete-by-query, this setting has no
             effect, i.e. delete queries are buffered until the next segment is flushed.
             </summary>
             <exception cref="T:System.ArgumentException">
                       if maxBufferedDeleteTerms is enabled but smaller than 1
             </exception>
             <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB">
             <summary>
             Gets or sets a value that determines the amount of RAM that may be used for buffering added documents
             and deletions before they are flushed to the <see cref="T:Lucene.Net.Store.Directory"/>. Generally for
             faster indexing performance it's best to flush by RAM usage instead of
             document count and use as large a RAM buffer as you can.
             <para/>
             When this is set, the writer will flush whenever buffered documents and
             deletions use this much RAM. Pass in
             <see cref="F:Lucene.Net.Index.IndexWriterConfig.DISABLE_AUTO_FLUSH"/> to prevent triggering a flush
             due to RAM usage. Note that if flushing by document count is also enabled,
             then the flush will be triggered by whichever comes first.
             <para/>
             The maximum RAM limit is inherently determined by the runtime's available
             memory. Yet, an <see cref="T:Lucene.Net.Index.IndexWriter"/> session can consume a significantly
             larger amount of memory than the given RAM limit since this limit is just
             an indicator when to flush memory resident documents to the <see cref="T:Lucene.Net.Store.Directory"/>.
             Flushes are likely happen concurrently while other threads adding documents
             to the writer. For application stability the available memory in the runtime
             should be significantly larger than the RAM buffer used for indexing.
             <para/>
             <b>NOTE</b>: the account of RAM usage for pending deletions is only
             approximate. Specifically, if you delete by <see cref="T:Lucene.Net.Search.Query"/>, Lucene currently has no
             way to measure the RAM usage of individual Queries so the accounting will
             under-estimate and you should compensate by either calling <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>
             periodically yourself, or by setting <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>
             to flush and apply buffered deletes by count instead of RAM usage (for each
             buffered delete <see cref="T:Lucene.Net.Search.Query"/> a constant number of bytes is used to estimate RAM
             usage). Note that enabling <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/> will not
             trigger any segment flushes.
             <para/>
             <b>NOTE</b>: It's not guaranteed that all memory resident documents are
             flushed once this limit is exceeded. Depending on the configured
             <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.FlushPolicy"/> only a subset of the buffered documents are flushed and
             therefore only parts of the RAM buffer is released.
             <para/>
            
             The default value is <see cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_RAM_BUFFER_SIZE_MB"/>.
            
             <para/>
             Takes effect immediately, but only the next time a document is added,
             updated or deleted.
             </summary>
             <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.RAMPerThreadHardLimitMB"/>
             <exception cref="T:System.ArgumentException">
                       if ramBufferSizeMB is enabled but non-positive, or it disables
                       ramBufferSizeMB when maxBufferedDocs is already disabled </exception>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs">
             <summary>
             Gets or sets a value that determines the minimal number of documents required before the buffered
             in-memory documents are flushed as a new Segment. Large values generally
             give faster indexing.
            
             <para/>
             When this is set, the writer will flush every maxBufferedDocs added
             documents. Pass in <see cref="F:Lucene.Net.Index.IndexWriterConfig.DISABLE_AUTO_FLUSH"/> to prevent
             triggering a flush due to number of buffered documents. Note that if
             flushing by RAM usage is also enabled, then the flush will be triggered by
             whichever comes first.
            
             <para/>
             Disabled by default (writer flushes by RAM usage).
            
             <para/>
             Takes effect immediately, but only the next time a document is added,
             updated or deleted.
             </summary>
             <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>
             <exception cref="T:System.ArgumentException">
                       if maxBufferedDocs is enabled but smaller than 2, or it disables
                       maxBufferedDocs when ramBufferSizeMB is already disabled </exception>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MergedSegmentWarmer">
            <summary>
            Gets or sets the merged segment warmer. See <see cref="T:Lucene.Net.Index.IndexWriter.IndexReaderWarmer"/>.
            <para/>
            Takes effect on the next merge.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.ReaderTermsIndexDivisor">
             <summary>
             Gets or sets the termsIndexDivisor passed to any readers that <see cref="T:Lucene.Net.Index.IndexWriter"/> opens,
             for example when applying deletes or creating a near-real-time reader in
             <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/>. If you pass -1, the
             terms index won't be loaded by the readers. This is only useful in advanced
             situations when you will only .Next() through all terms; attempts to seek
             will hit an exception.
            
             <para/>
             Takes effect immediately, but only applies to readers opened after this
             call
             <para/>
             <b>NOTE:</b> divisor settings &gt; 1 do not apply to all <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>
             implementations, including the default one in this release. It only makes
             sense for terms indexes that can efficiently re-sample terms at load time.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.OpenMode">
            <summary>
            Gets the <see cref="T:Lucene.Net.Index.OpenMode"/> set by <see cref="P:Lucene.Net.Index.IndexWriterConfig.OpenMode"/> setter. </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexDeletionPolicy">
            <summary>
            Gets the <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> specified in
            <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexDeletionPolicy"/> setter or
            the default <see cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexCommit">
            <summary>
            Gets the <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexCommit"/> as specified in
            <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexCommit"/> setter or the default,
            <c>null</c> which specifies to open the latest index commit point.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.Similarity">
            <summary>
            Expert: returns the <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> implementation used by this
            <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MergeScheduler">
            <summary>
            Returns the <see cref="T:Lucene.Net.Index.IMergeScheduler"/> that was set by
            <see cref="P:Lucene.Net.Index.IndexWriterConfig.MergeScheduler"/> setter.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.WriteLockTimeout">
            <summary>
            Returns allowed timeout when acquiring the write lock.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.WriteLockTimeout"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.Codec">
            <summary>
            Returns the current <see cref="T:Lucene.Net.Codecs.Codec"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MergePolicy">
            <summary>
            Returns the current <see cref="T:Lucene.Net.Index.MergePolicy"/> in use by this writer.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.MergePolicy"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexerThreadPool">
            <summary>
            Returns the configured <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> instance.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.IndexerThreadPool"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxThreadStates">
            <summary>
            Returns the max number of simultaneous threads that may be indexing
            documents at once in <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.UseReaderPooling">
            <summary>
            Returns <c>true</c> if <see cref="T:Lucene.Net.Index.IndexWriter"/> should pool readers even if
            <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/> has not been called.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexingChain">
            <summary>
            Returns the indexing chain set on
            <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexingChain"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMPerThreadHardLimitMB">
            <summary>
            Returns the max amount of memory each <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> can
            consume until forcefully flushed.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.RAMPerThreadHardLimitMB"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.FlushPolicy">
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.FlushPolicy"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.InfoStream">
            <summary>
            Returns <see cref="T:Lucene.Net.Util.InfoStream"/> used for debugging.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriterConfig.SetInfoStream(Lucene.Net.Util.InfoStream)"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.UseCompoundFile">
            <summary>
            Gets or sets if the <see cref="T:Lucene.Net.Index.IndexWriter"/> should pack newly written segments in a
            compound file. Default is <c>true</c>.
            <para>
            Use <c>false</c> for batch indexing with very large RAM buffer
            settings.
            </para>
            <para>
            <b>Note: To control compound file usage during segment merges see
            <seealso cref="P:Lucene.Net.Index.MergePolicy.NoCFSRatio"/> and
            <seealso cref="P:Lucene.Net.Index.MergePolicy.MaxCFSSegmentSizeMB"/>. This setting only
            applies to newly created segments.</b>
            </para>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.CheckIntegrityAtMerge">
            <summary>
            Gets or sets if <see cref="T:Lucene.Net.Index.IndexWriter"/> should call <see cref="M:Lucene.Net.Index.AtomicReader.CheckIntegrity"/>
            on existing segments before merging them into a new one.
            <para>
            Use <c>true</c> to enable this safety check, which can help
            reduce the risk of propagating index corruption from older segments
            into new ones, at the expense of slower merging.
            </para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LogByteSizeMergePolicy">
            <summary>
            This is a <see cref="T:Lucene.Net.Index.LogMergePolicy"/> that measures size of a
            segment as the total byte size of the segment's files.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MIN_MERGE_MB">
            <summary>Default minimum segment size. </summary>
            <seealso cref="P:Lucene.Net.Index.LogByteSizeMergePolicy.MinMergeMB"/>
        </member>
        <member name="F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MAX_MERGE_MB">
            <summary>
            Default maximum segment size.  A segment of this size 
            or larger will never be merged. </summary> 
            <seealso cref="P:Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMB"/>
        </member>
        <member name="F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MAX_MERGE_MB_FOR_FORCED_MERGE">
            <summary>
            Default maximum segment size.  A segment of this size 
            or larger will never be merged during <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>.  </summary>
            <seealso cref="P:Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMBForForcedMerge"/>
        </member>
        <member name="M:Lucene.Net.Index.LogByteSizeMergePolicy.#ctor">
            <summary>
            Sole constructor, setting all settings to their
            defaults.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMB">
             <summary>
             <para>Determines the largest segment (measured by total
             byte size of the segment's files, in MB) that may be
             merged with other segments.  Small values (e.g., less
             than 50 MB) are best for interactive indexing, as this
             limits the length of pauses while indexing to a few
             seconds.  Larger values are best for batched indexing
             and speedier searches.</para>
            
             <para>Note that <see cref="P:Lucene.Net.Index.LogMergePolicy.MaxMergeDocs"/> is also
             used to check whether a segment is too large for
             merging (it's either or).</para>
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMBForForcedMerge">
            <summary>
            Determines the largest segment (measured by total
            byte size of the segment's files, in MB) that may be
            merged with other segments during forceMerge. Setting
            it low will leave the index with more than 1 segment,
            even if <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> is called.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogByteSizeMergePolicy.MinMergeMB">
            <summary>
            Sets the minimum size for the lowest level segments.
            Any segments below this size are considered to be on
            the same level (even if they vary drastically in size)
            and will be merged whenever there are mergeFactor of
            them.  This effectively truncates the "long tail" of
            small segments that would otherwise be created into a
            single level.  If you set this too large, it could
            greatly increase the merging cost during indexing (if
            you flush many small segments).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LogDocMergePolicy">
            <summary>
            This is a <see cref="T:Lucene.Net.Index.LogMergePolicy"/> that measures size of a
            segment as the number of documents (not taking deletions
            into account).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogDocMergePolicy.DEFAULT_MIN_MERGE_DOCS">
            <summary> Default minimum segment size. </summary>
            <seealso cref="P:Lucene.Net.Index.LogDocMergePolicy.MinMergeDocs"/>
        </member>
        <member name="M:Lucene.Net.Index.LogDocMergePolicy.#ctor">
            <summary>
            Sole constructor, setting all settings to their
            defaults.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogDocMergePolicy.MinMergeDocs">
            <summary>
            Sets the minimum size for the lowest level segments.
            Any segments below this size are considered to be on
            the same level (even if they vary drastically in size)
            and will be merged whenever there are mergeFactor of
            them.  This effectively truncates the "long tail" of
            small segments that would otherwise be created into a
            single level.  If you set this too large, it could
            greatly increase the merging cost during indexing (if
            you flush many small segments).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LogMergePolicy">
             <summary>
             <para>This class implements a <see cref="T:Lucene.Net.Index.MergePolicy"/> that tries
             to merge segments into levels of exponentially
             increasing size, where each level has fewer segments than
             the value of the merge factor. Whenever extra segments
             (beyond the merge factor upper bound) are encountered,
             all segments within the level are merged. You can get or
             set the merge factor using <see cref="P:Lucene.Net.Index.LogMergePolicy.MergeFactor"/>.</para>
            
             <para>This class is abstract and requires a subclass to
             define the <see cref="M:Lucene.Net.Index.MergePolicy.Size(Lucene.Net.Index.SegmentCommitInfo)"/> method which specifies how a
             segment's size is determined.  <see cref="T:Lucene.Net.Index.LogDocMergePolicy"/>
             is one subclass that measures size by document count in
             the segment.  <see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/> is another
             subclass that measures size as the total byte size of the
             file(s) for the segment.</para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.LEVEL_LOG_SPAN">
            <summary>
            Defines the allowed range of log(size) for each
            level.  A level is computed by taking the max segment
            log size, minus LEVEL_LOG_SPAN, and finding all
            segments falling within that range.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_MERGE_FACTOR">
            <summary>
            Default merge factor, which is how many segments are
            merged at a time
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_MAX_MERGE_DOCS">
            <summary>
            Default maximum segment size.  A segment of this size 
            or larger will never be merged. </summary> 
            <seealso cref="P:Lucene.Net.Index.LogMergePolicy.MaxMergeDocs"/>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_NO_CFS_RATIO">
            <summary>
            Default noCFSRatio.  If a merge's size is >= 10% of
            the index, then we disable compound file for it. </summary>
            <seealso cref="P:Lucene.Net.Index.MergePolicy.NoCFSRatio"/>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.m_mergeFactor">
            <summary>
            How many segments to merge at a time. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.m_minMergeSize">
            <summary>
            Any segments whose size is smaller than this value
            will be rounded up to this value.  This ensures that
            tiny segments are aggressively merged.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.m_maxMergeSize">
            <summary>
            If the size of a segment exceeds this value then it
            will never be merged.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.m_maxMergeSizeForForcedMerge">
            <summary>
            If the size of a segment exceeds this value then it
            will never be merged during <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.m_maxMergeDocs">
            <summary>
            If a segment has more than this many documents then it
            will never be merged.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.m_calibrateSizeByDeletes">
            <summary>
            If true, we pro-rate a segment's size by the
            percentage of non-deleted documents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogMergePolicy.IsVerbose">
            <summary>
            Returns true if <see cref="T:Lucene.Net.Index.LogMergePolicy"/> is enabled in <see cref="F:Lucene.Net.Index.IndexWriter.infoStream"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.Message(System.String)">
            <summary>
            Print a debug message to <see cref="F:Lucene.Net.Index.IndexWriter.infoStream"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogMergePolicy.MergeFactor">
            <summary>
            Gets or Sets the number of segments that are merged at
            once and also controls the total number of segments
            allowed to accumulate in the index.
            <para/>
            This determines how often segment indices are merged by
            <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>.  With smaller values, less RAM is used
            while indexing, and searches are
            faster, but indexing speed is slower.  With larger
            values, more RAM is used during indexing, and while
            searches is slower, indexing is
            faster.  Thus larger values (> 10) are best for batch
            index creation, and smaller values (&lt; 10) for indices
            that are interactively maintained.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogMergePolicy.CalibrateSizeByDeletes">
            <summary>
            Gets or Sets whether the segment size should be calibrated by
            the number of deletes when choosing segments for merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.SizeDocs(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Return the number of documents in the provided 
            <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>, pro-rated by percentage of
            non-deleted documents if 
            <see cref="P:Lucene.Net.Index.LogMergePolicy.CalibrateSizeByDeletes"/> is set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.SizeBytes(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Return the byte size of the provided 
            <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>, pro-rated by percentage of
            non-deleted documents if 
            <see cref="P:Lucene.Net.Index.LogMergePolicy.CalibrateSizeByDeletes"/> is set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.IsMerged(Lucene.Net.Index.SegmentInfos,System.Int32,System.Collections.Generic.IDictionary{Lucene.Net.Index.SegmentCommitInfo,System.Nullable{System.Boolean}})">
            <summary>
            Returns <c>true</c> if the number of segments eligible for
            merging is less than or equal to the specified 
            <paramref name="maxNumSegments"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindForcedMergesSizeLimit(Lucene.Net.Index.SegmentInfos,System.Int32,System.Int32)">
            <summary>
            Returns the merges necessary to merge the index, taking the max merge
            size or max merge docs into consideration. this method attempts to respect
            the <paramref name="maxNumSegments"/> parameter, however it might be, due to size
            constraints, that more than that number of segments will remain in the
            index. Also, this method does not guarantee that exactly
            <paramref name="maxNumSegments"/> will remain, but &lt;= that number.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindForcedMergesMaxNumSegments(Lucene.Net.Index.SegmentInfos,System.Int32,System.Int32)">
            <summary>
            Returns the merges necessary to <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> the index. this method constraints
            the returned merges only by the <paramref name="maxNumSegments"/> parameter, and
            guaranteed that exactly that number of segments will remain in the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindForcedMerges(Lucene.Net.Index.SegmentInfos,System.Int32,System.Collections.Generic.IDictionary{Lucene.Net.Index.SegmentCommitInfo,System.Nullable{System.Boolean}})">
            <summary>
            Returns the merges necessary to merge the index down
            to a specified number of segments.
            this respects the <see cref="F:Lucene.Net.Index.LogMergePolicy.m_maxMergeSizeForForcedMerge"/> setting.
            By default, and assuming <c>maxNumSegments=1</c>, only
            one segment will be left in the index, where that segment
            has no deletions pending nor separate norms, and it is in
            compound file format if the current useCompoundFile
            setting is <c>true</c>.  This method returns multiple merges
            (mergeFactor at a time) so the <see cref="T:Lucene.Net.Index.MergeScheduler"/>
            in use may make use of concurrency.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindForcedDeletesMerges(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Finds merges necessary to force-merge all deletes from the
            index.  We simply merge adjacent segments that have
            deletes, up to mergeFactor at a time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindMerges(Lucene.Net.Index.MergeTrigger,Lucene.Net.Index.SegmentInfos)">
            <summary>
            Checks if any merges are now necessary and returns a
            <see cref="T:Lucene.Net.Index.MergePolicy.MergeSpecification"/> if so.  A merge
            is necessary when there are more than 
            <see cref="P:Lucene.Net.Index.LogMergePolicy.MergeFactor"/> segments at a given level.  When
            multiple levels have too many segments, this method
            will return multiple merges, allowing the 
            <see cref="T:Lucene.Net.Index.MergeScheduler"/> to use concurrency.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogMergePolicy.MaxMergeDocs">
             <summary>
             <para>Determines the largest segment (measured by
             document count) that may be merged with other segments.
             Small values (e.g., less than 10,000) are best for
             interactive indexing, as this limits the length of
             pauses while indexing to a few seconds.  Larger values
             are best for batched indexing and speedier
             searches.</para>
            
             <para>The default value is <see cref="F:System.Int32.MaxValue"/>.</para>
            
             <para>The default merge policy 
             (<see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/>) also allows you to set this
             limit by net size (in MB) of the segment, using 
             <see cref="P:Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMB"/>.</para>
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy">
             <summary>
             <para>Expert: a <see cref="T:Lucene.Net.Index.MergePolicy"/> determines the sequence of
             primitive merge operations.</para>
            
             <para>Whenever the segments in an index have been altered by
             <see cref="T:Lucene.Net.Index.IndexWriter"/>, either the addition of a newly
             flushed segment, addition of many segments from
             AddIndexes* calls, or a previous merge that may now need
             to cascade, <see cref="T:Lucene.Net.Index.IndexWriter"/> invokes <see cref="M:Lucene.Net.Index.MergePolicy.FindMerges(Lucene.Net.Index.MergeTrigger,Lucene.Net.Index.SegmentInfos)"/>
             to give the <see cref="T:Lucene.Net.Index.MergePolicy"/> a chance to pick
             merges that are now required.  This method returns a
             <see cref="T:Lucene.Net.Index.MergePolicy.MergeSpecification"/> instance describing the set of
             merges that should be done, or null if no merges are
             necessary.  When <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> is called, it calls
             <see cref="M:Lucene.Net.Index.MergePolicy.FindForcedMerges(Lucene.Net.Index.SegmentInfos,System.Int32,System.Collections.Generic.IDictionary{Lucene.Net.Index.SegmentCommitInfo,System.Nullable{System.Boolean}})"/> and the <see cref="T:Lucene.Net.Index.MergePolicy"/> should
             then return the necessary merges.</para>
            
             <para>Note that the policy can return more than one merge at
             a time.  In this case, if the writer is using 
             <see cref="T:Lucene.Net.Index.SerialMergeScheduler"/>, the merges will be run
             sequentially but if it is using
             <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler"/> they will be run concurrently.</para>
            
             <para>The default MergePolicy is
             <see cref="T:Lucene.Net.Index.TieredMergePolicy"/>.</para>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.DocMap">
            <summary>
            A map of doc IDs. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.DocMap.#ctor">
            <summary>
            Sole constructor, typically invoked from sub-classes constructors. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.DocMap.Map(System.Int32)">
            <summary>
            Return the new doc ID according to its old value. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.DocMap.IsConsistent(System.Int32)">
            <summary>
            Useful from an assert. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.OneMerge">
            <summary>
            OneMerge provides the information necessary to perform
             an individual primitive merge operation, resulting in
             a single new segment.  The merge spec includes the
             subset of segments to be merged as well as whether the
             new segment should use the compound file format.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.EstimatedMergeBytes">
            <summary>
            Estimated size in bytes of the merged segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.Segments">
            <summary>
            Segments to be merged. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.TotalDocCount">
            <summary>
            Number of documents in the merged segment. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.#ctor(System.Collections.Generic.IList{Lucene.Net.Index.SegmentCommitInfo})">
            <summary>
            Sole constructor. </summary>
            <param name="segments"> List of <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s
                   to be merged.  </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.GetMergeReaders">
            <summary>
            Expert: Get the list of readers to merge. Note that this list does not
             necessarily match the list of segments to merge and should only be used
             to feed SegmentMerger to initialize a merge. When a <see cref="T:Lucene.Net.Index.MergePolicy.OneMerge"/>
             reorders doc IDs, it must override <see cref="M:Lucene.Net.Index.MergePolicy.OneMerge.GetDocMap(Lucene.Net.Index.MergeState)"/> too so that
             deletes that happened during the merge can be applied to the newly
             merged segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.Info">
            <summary>
            Expert: Sets the <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/> of this <see cref="T:Lucene.Net.Index.MergePolicy.OneMerge"/>.
            Allows sub-classes to e.g. set diagnostics properties.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.GetDocMap(Lucene.Net.Index.MergeState)">
            <summary>
            Expert: If <see cref="M:Lucene.Net.Index.MergePolicy.OneMerge.GetMergeReaders"/> reorders document IDs, this method
            must be overridden to return a mapping from the <i>natural</i> doc ID
            (the doc ID that would result from a natural merge) to the actual doc
            ID. This mapping is used to apply deletions that happened during the
            merge to the new segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.Exception">
            <summary>
            Record that an exception occurred while executing
            this merge
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.Abort">
            <summary>
            Mark this merge as aborted.  If this is called
            before the merge is committed then the merge will
            not be committed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.IsAborted">
            <summary>
            Returns <c>true</c> if this merge was aborted. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.CheckAborted(Lucene.Net.Store.Directory)">
            <summary>
            Called periodically by <see cref="T:Lucene.Net.Index.IndexWriter"/> while
            merging to see if the merge is aborted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.SetPause(System.Boolean)">
            <summary>
            Set or clear whether this merge is paused paused (for example
            <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler"/> will pause merges
            if too many are running).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.IsPaused">
            <summary>
            Returns <c>true</c> if this merge is paused.
            </summary>
            <seealso cref="M:Lucene.Net.Index.MergePolicy.OneMerge.SetPause(System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.SegString(Lucene.Net.Store.Directory)">
            <summary>
            Returns a readable description of the current merge
            state.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.TotalBytesSize">
            <summary>
            Returns the total size in bytes of this merge. Note that this does not
            indicate the size of the merged segment, but the
            input total size. This is only set once the merge is
            initialized by <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.TotalNumDocs">
            <summary>
            Returns the total number of documents that are included with this merge.
            Note that this does not indicate the number of documents after the merge.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.MergeInfo">
            <summary>
            Return <see cref="T:Lucene.Net.Store.MergeInfo"/> describing this merge. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeSpecification">
            <summary>
            A <see cref="T:Lucene.Net.Index.MergePolicy.MergeSpecification"/> instance provides the information
            necessary to perform multiple merges.  It simply
            contains a list of <see cref="T:Lucene.Net.Index.MergePolicy.OneMerge"/> instances.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.MergeSpecification.Merges">
            <summary>
            The subset of segments to be included in the primitive merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeSpecification.#ctor">
            <summary>
            Sole constructor.  Use 
            <see cref="M:Lucene.Net.Index.MergePolicy.MergeSpecification.Add(Lucene.Net.Index.MergePolicy.OneMerge)"/> to add merges.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeSpecification.Add(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Adds the provided <see cref="T:Lucene.Net.Index.MergePolicy.OneMerge"/> to this
            specification.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeSpecification.SegString(Lucene.Net.Store.Directory)">
            <summary>
            Returns a description of the merges in this
            specification.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeException">
            <summary>
            Exception thrown if there are any problems while
            executing a merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeException.#ctor(System.String,Lucene.Net.Store.Directory)">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.MergePolicy.MergeException"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeException.#ctor(System.Exception,Lucene.Net.Store.Directory)">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.MergePolicy.MergeException"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.MergeException.Directory">
            <summary>
            Returns the <see cref="T:Lucene.Net.Store.Directory"/> of the index that hit
            the exception.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeAbortedException">
            <summary>
            Thrown when a merge was explicity aborted because
            <see cref="M:Lucene.Net.Index.IndexWriter.Dispose(System.Boolean)"/> was called with
            <c>false</c>.  Normally this exception is
            privately caught and suppresed by <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeAbortedException.#ctor">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeAbortedException.#ctor(System.String)">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/> with a
            specified message.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeAbortedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.DEFAULT_NO_CFS_RATIO">
            <summary>
            Default ratio for compound file system usage. Set to <c>1.0</c>, always use
            compound file system.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.DEFAULT_MAX_CFS_SEGMENT_SIZE">
            <summary>
            Default max segment size in order to use compound file system. Set to <see cref="F:System.Int64.MaxValue"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.m_writer">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexWriter"/> that contains this instance. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.m_noCFSRatio">
            <summary>
            If the size of the merge segment exceeds this ratio of
            the total index size then it will remain in
            non-compound format
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.m_maxCFSSegmentSize">
            <summary>
            If the size of the merged segment exceeds
            this value then it will not use compound file format.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.#ctor">
            <summary>
            Creates a new merge policy instance. Note that if you intend to use it
            without passing it to <see cref="T:Lucene.Net.Index.IndexWriter"/>, you should call
            <see cref="M:Lucene.Net.Index.MergePolicy.SetIndexWriter(Lucene.Net.Index.IndexWriter)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.#ctor(System.Double,System.Int64)">
            <summary>
            Creates a new merge policy instance with default settings for <see cref="F:Lucene.Net.Index.MergePolicy.m_noCFSRatio"/>
            and <see cref="F:Lucene.Net.Index.MergePolicy.m_maxCFSSegmentSize"/>. This ctor should be used by subclasses using different
            defaults than the <see cref="T:Lucene.Net.Index.MergePolicy"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.SetIndexWriter(Lucene.Net.Index.IndexWriter)">
            <summary>
            Sets the <see cref="T:Lucene.Net.Index.IndexWriter"/> to use by this merge policy. This method is
            allowed to be called only once, and is usually set by <see cref="T:Lucene.Net.Index.IndexWriter"/>. If it is
            called more than once, <see cref="T:Lucene.Net.Util.AlreadySetException"/> is thrown.
            </summary>
            <seealso cref="T:Lucene.Net.Util.SetOnce`1"/>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.FindMerges(Lucene.Net.Index.MergeTrigger,Lucene.Net.Index.SegmentInfos)">
            <summary>
            Determine what set of merge operations are now necessary on the index.
            <see cref="T:Lucene.Net.Index.IndexWriter"/> calls this whenever there is a change to the segments.
            This call is always synchronized on the <see cref="T:Lucene.Net.Index.IndexWriter"/> instance so
            only one thread at a time will call this method. </summary>
            <param name="mergeTrigger"> the event that triggered the merge </param>
            <param name="segmentInfos">
                     the total set of segments in the index </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.FindForcedMerges(Lucene.Net.Index.SegmentInfos,System.Int32,System.Collections.Generic.IDictionary{Lucene.Net.Index.SegmentCommitInfo,System.Nullable{System.Boolean}})">
            <summary>
            Determine what set of merge operations is necessary in
            order to merge to &lt;= the specified segment count. <see cref="T:Lucene.Net.Index.IndexWriter"/> calls this when its
            <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32,System.Boolean)"/> method is called. This call is always
            synchronized on the <see cref="T:Lucene.Net.Index.IndexWriter"/> instance so only one thread at a
            time will call this method.
            </summary>
            <param name="segmentInfos">
                     The total set of segments in the index </param>
            <param name="maxSegmentCount">
                     Requested maximum number of segments in the index (currently this
                     is always 1) </param>
            <param name="segmentsToMerge">
                     Contains the specific <see cref="T:Lucene.Net.Index.SegmentInfo"/> instances that must be merged
                     away. This may be a subset of all
                     SegmentInfos.  If the value is <c>true</c> for a
                     given <see cref="T:Lucene.Net.Index.SegmentInfo"/>, that means this segment was
                     an original segment present in the
                     to-be-merged index; else, it was a segment
                     produced by a cascaded merge. </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.FindForcedDeletesMerges(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Determine what set of merge operations is necessary in order to expunge all
            deletes from the index.
            </summary>
            <param name="segmentInfos">
                     the total set of segments in the index </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.Dispose">
            <summary>
            Release all resources for the policy.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.Dispose(System.Boolean)">
            <summary>
            Release all resources for the policy.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.UseCompoundFile(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Returns <c>true</c> if a new segment (regardless of its origin) should use the
            compound file format. The default implementation returns <c>true</c>
            iff the size of the given mergedInfo is less or equal to
            <see cref="P:Lucene.Net.Index.MergePolicy.MaxCFSSegmentSizeMB"/> and the size is less or equal to the
            TotalIndexSize * <see cref="P:Lucene.Net.Index.MergePolicy.NoCFSRatio"/> otherwise <code>false</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.Size(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Return the byte size of the provided 
            <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>, pro-rated by percentage of
            non-deleted documents is set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.IsMerged(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Returns <c>true</c> if this single info is already fully merged (has no
            pending deletes, is in the same dir as the
            writer, and matches the current compound file setting
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.NoCFSRatio">
            <summary>
            Gets or Sets current <see cref="F:Lucene.Net.Index.MergePolicy.m_noCFSRatio"/>.
            <para/>
            If a merged segment will be more than this percentage
            of the total size of the index, leave the segment as
            non-compound file even if compound file is enabled.
            Set to 1.0 to always use CFS regardless of merge
            size.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.MaxCFSSegmentSizeMB">
            <summary>
            Gets or Sets the largest size allowed for a compound file segment.
            <para/>
            If a merged segment will be more than this value,
            leave the segment as
            non-compound file even if compound file is enabled.
            Set this to <see cref="F:System.Double.PositiveInfinity"/> (default) and <see cref="P:Lucene.Net.Index.MergePolicy.NoCFSRatio"/> to 1.0
            to always use CFS regardless of merge size.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeScheduler">
            <summary>
            <para>Expert: <see cref="T:Lucene.Net.Index.IndexWriter"/> uses an instance
            implementing this interface to execute the merges
            selected by a <see cref="T:Lucene.Net.Index.MergePolicy"/>.  The default
            MergeScheduler is <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler"/>.</para>
            <para>Implementers of sub-classes should make sure that <see cref="M:Lucene.Net.Index.MergeScheduler.Clone"/>
            returns an independent instance able to work with any <see cref="T:Lucene.Net.Index.IndexWriter"/>
            instance.</para>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.Merge(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergeTrigger,System.Boolean)">
            <summary>
            Run the merges provided by <see cref="M:Lucene.Net.Index.IndexWriter.NextMerge"/>. </summary>
            <param name="writer"> the <see cref="T:Lucene.Net.Index.IndexWriter"/> to obtain the merges from. </param>
            <param name="trigger"> the <see cref="T:Lucene.Net.Index.MergeTrigger"/> that caused this merge to happen </param>
            <param name="newMergesFound"> <c>true</c> iff any new merges were found by the caller; otherwise <c>false</c>
             </param>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.Dispose">
            <summary>
            Dispose this MergeScheduler. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.Dispose(System.Boolean)">
            <summary>
            Dispose this MergeScheduler. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeState">
            <summary>
            Holds common state used during segment merging.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeState.DocMap">
            <summary>
            Remaps docids around deletes during merge
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeState.DocMap.Get(System.Int32)">
            <summary>
            Returns the mapped docID corresponding to the provided one. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMap.MaxDoc">
            <summary>
            Returns the total number of documents, ignoring
            deletions.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMap.NumDocs">
            <summary>
            Returns the number of not-deleted documents. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMap.NumDeletedDocs">
            <summary>
            Returns the number of deleted documents. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMap.HasDeletions">
            <summary>
            Returns <c>true</c> if there are any deletions. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeState.DocMap.Build(Lucene.Net.Index.AtomicReader)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Index.MergeState.DocMap"/> instance appropriate for
            this reader.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.SegmentInfo">
            <summary>
            <see cref="T:Lucene.Net.Index.SegmentInfo"/> of the newly merged segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.FieldInfos">
            <summary>
            <see cref="T:Lucene.Net.Index.FieldInfos"/> of the newly merged segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.Readers">
            <summary>
            Readers being merged. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMaps">
            <summary>
            Maps docIDs around deletions. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocBase">
            <summary>
            New docID base per reader. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.CheckAbort">
            <summary>
            Holds the <see cref="T:Lucene.Net.Index.CheckAbort"/> instance, which is invoked
            periodically to see if the merge has been aborted.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.InfoStream">
            <summary>
            <see cref="T:Lucene.Net.Util.InfoStream"/> for debugging messages. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.MatchingSegmentReaders">
            <summary>
            <see cref="T:Lucene.Net.Index.SegmentReader"/>s that have identical field
            name/number mapping, so their stored fields and term
            vectors may be bulk merged.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.MatchedCount">
            <summary>
            How many <see cref="P:Lucene.Net.Index.MergeState.MatchingSegmentReaders"/> are set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeState.#ctor(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReader},Lucene.Net.Index.SegmentInfo,Lucene.Net.Util.InfoStream,Lucene.Net.Index.CheckAbort)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckAbort">
            <summary>
            Class for recording units of work when merging segments.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckAbort.#ctor(Lucene.Net.Index.MergePolicy.OneMerge,Lucene.Net.Store.Directory)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Index.CheckAbort"/> instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckAbort.Work(System.Double)">
            <summary>
            Records the fact that roughly units amount of work
            have been done since this method was last called.
            When adding time-consuming code into <see cref="T:Lucene.Net.Index.SegmentMerger"/>,
            you should test different values for units to ensure
            that the time in between calls to merge.CheckAborted
            is up to ~ 1 second.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckAbort.NONE">
            <summary>
            If you use this: IW.Dispose(false) cannot abort your merge!
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeTrigger">
            <summary>
            <see cref="T:Lucene.Net.Index.MergeTrigger"/> is passed to
            <see cref="M:Lucene.Net.Index.MergePolicy.FindMerges(Lucene.Net.Index.MergeTrigger,Lucene.Net.Index.SegmentInfos)"/> to indicate the
            event that triggered the merge.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.SEGMENT_FLUSH">
            <summary>
            Merge was triggered by a segment flush.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.FULL_FLUSH">
            <summary>
            Merge was triggered by a full flush. Full flushes
            can be caused by a commit, NRT reader reopen or a <see cref="M:Lucene.Net.Index.IndexWriter.Dispose"/> call on the index writer.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.EXPLICIT">
            <summary>
            Merge has been triggered explicitly by the user.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.MERGE_FINISHED">
            <summary>
            Merge was triggered by a successfully finished merge.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.CLOSING">
            <summary>
            Merge was triggered by a disposing <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiBits">
             <summary>
             Concatenates multiple <see cref="T:Lucene.Net.Util.IBits"/> together, on every lookup.
            
             <para/><b>NOTE</b>: this is very costly, as every lookup must
             do a binary search to locate the right sub-reader.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiBits.SubResult">
            <summary>
            Represents a sub-Bits from
            <see cref="M:Lucene.Net.Index.MultiBits.GetMatchingSub(Lucene.Net.Index.ReaderSlice)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiBits.GetMatchingSub(Lucene.Net.Index.ReaderSlice)">
            <summary>
            Returns a sub-Bits matching the provided <paramref name="slice"/>
            <para/>
            Because <c>null</c> usually has a special meaning for
            <see cref="T:Lucene.Net.Util.IBits"/> (e.g. no deleted documents), you must check
            <see cref="P:Lucene.Net.Index.MultiBits.SubResult.Matches"/> instead to ensure the sub was
            actually found.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocsAndPositionsEnum">
            <summary>
            Exposes flex API, merged from flex API of sub-segments.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsAndPositionsEnum.#ctor(Lucene.Net.Index.MultiTermsEnum,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsAndPositionsEnum.CanReuse(Lucene.Net.Index.MultiTermsEnum)">
            <summary>
            Returns <c>true</c> if this instance can be reused by
            the provided <see cref="T:Lucene.Net.Index.MultiTermsEnum"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsAndPositionsEnum.Reset(Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice[],System.Int32)">
            <summary>
            Re-use and reset this instance on the provided slices. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocsAndPositionsEnum.NumSubs">
            <summary>
            How many sub-readers we are merging. </summary>
            <see cref="P:Lucene.Net.Index.MultiDocsAndPositionsEnum.Subs"/>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocsAndPositionsEnum.Subs">
            <summary>
            Returns sub-readers we are merging. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice">
            <summary>
            Holds a <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> along with the
            corresponding <see cref="T:Lucene.Net.Index.ReaderSlice"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice.DocsAndPositionsEnum">
            <summary>
            <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> for this sub-reader. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice.Slice">
            <summary>
            <see cref="T:Lucene.Net.Index.ReaderSlice"/> describing how this sub-reader
            fits into the composite reader.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocsEnum">
            <summary>
            Exposes <see cref="T:Lucene.Net.Index.DocsEnum"/>, merged from <see cref="T:Lucene.Net.Index.DocsEnum"/>
            API of sub-segments.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsEnum.#ctor(Lucene.Net.Index.MultiTermsEnum,System.Int32)">
            <summary>
            Sole constructor </summary>
            <param name="parent"> The <see cref="T:Lucene.Net.Index.MultiTermsEnum"/> that created us. </param>
            <param name="subReaderCount"> How many sub-readers are being merged.  </param>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsEnum.CanReuse(Lucene.Net.Index.MultiTermsEnum)">
            <summary>
            Returns <c>true</c> if this instance can be reused by
            the provided <see cref="T:Lucene.Net.Index.MultiTermsEnum"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocsEnum.NumSubs">
            <summary>
            How many sub-readers we are merging. </summary>
            <seealso cref="P:Lucene.Net.Index.MultiDocsEnum.Subs"/>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocsEnum.Subs">
            <summary>
            Returns sub-readers we are merging. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice">
            <summary>
            Holds a <see cref="T:Lucene.Net.Index.DocsEnum"/> along with the
            corresponding <see cref="T:Lucene.Net.Index.ReaderSlice"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice.DocsEnum">
            <summary>
            <see cref="T:Lucene.Net.Index.DocsEnum"/> of this sub-reader. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice.Slice">
            <summary>
            <see cref="T:Lucene.Net.Index.ReaderSlice"/> describing how this sub-reader
            fits into the composite reader.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocValues">
             <summary>
             A wrapper for <see cref="T:Lucene.Net.Index.CompositeReader"/> providing access to <see cref="T:Lucene.Net.Index.DocValues"/>.
            
             <para/><b>NOTE</b>: for multi readers, you'll get better
             performance by gathering the sub readers using
             <see cref="P:Lucene.Net.Index.IndexReader.Context"/> to get the
             atomic leaves and then operate per-AtomicReader,
             instead of using this class.
            
             <para/><b>NOTE</b>: this is very costly.
            
             <para/>
             @lucene.experimental
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.#ctor">
            <summary>
            No instantiation </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetNormValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.NumericDocValues"/> for a reader's norms (potentially merging on-the-fly).
            <para>
            This is a slow way to access normalization values. Instead, access them per-segment
            with <seealso cref="M:Lucene.Net.Index.AtomicReader.GetNormValues(System.String)"/>
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetNumericValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.NumericDocValues"/> for a reader's docvalues (potentially merging on-the-fly)
            <para>
            This is a slow way to access numeric values. Instead, access them per-segment
            with <see cref="M:Lucene.Net.Index.AtomicReader.GetNumericDocValues(System.String)"/>
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetDocsWithField(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Util.IBits"/> for a reader's docsWithField (potentially merging on-the-fly)
            <para>
            This is a slow way to access this bitset. Instead, access them per-segment
            with <see cref="M:Lucene.Net.Index.AtomicReader.GetDocsWithField(System.String)"/>
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetBinaryValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.BinaryDocValues"/> for a reader's docvalues (potentially merging on-the-fly)
            <para>
            This is a slow way to access binary values. Instead, access them per-segment
            with <see cref="M:Lucene.Net.Index.AtomicReader.GetBinaryDocValues(System.String)"/>
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetSortedValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.SortedDocValues"/> for a reader's docvalues (potentially doing extremely slow things).
            <para>
            this is an extremely slow way to access sorted values. Instead, access them per-segment
            with <see cref="M:Lucene.Net.Index.AtomicReader.GetSortedDocValues(System.String)"/>
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetSortedSetValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.SortedSetDocValues"/> for a reader's docvalues (potentially doing extremely slow things).
            <para>
            This is an extremely slow way to access sorted values. Instead, access them per-segment
            with <see cref="M:Lucene.Net.Index.AtomicReader.GetSortedSetDocValues(System.String)"/>
            </para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocValues.OrdinalMap">
            <summary>
            maps per-segment ordinals to/from global ordinal space </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.#ctor(System.Object,Lucene.Net.Index.TermsEnum[])">
            <summary>
            Creates an ordinal map that allows mapping ords to/from a merged
            space from <c>subs</c>. </summary>
            <param name="owner"> a cache key </param>
            <param name="subs"> <see cref="T:Lucene.Net.Index.TermsEnum"/>s that support <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>. They need
                        not be dense (e.g. can be FilteredTermsEnums). </param>
            <exception cref="T:System.IO.IOException"> if an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.GetGlobalOrd(System.Int32,System.Int64)">
            <summary>
            Given a segment number and segment ordinal, returns
            the corresponding global ordinal.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.GetFirstSegmentOrd(System.Int64)">
            <summary>
            Given global ordinal, returns the ordinal of the first segment which contains
            this ordinal (the corresponding to the segment return <see cref="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.GetFirstSegmentNumber(System.Int64)"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.GetFirstSegmentNumber(System.Int64)">
            <summary>
            Given a global ordinal, returns the index of the first
            segment that contains this term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.OrdinalMap.ValueCount">
            <summary>
            Returns the total number of unique terms in global ord space.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.RamBytesUsed">
            <summary>
            Returns total byte size used by this ordinal map.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues">
            <summary>
            Implements <see cref="T:Lucene.Net.Index.SortedDocValues"/> over n subs, using an <see cref="T:Lucene.Net.Index.MultiDocValues.OrdinalMap"/>
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.DocStarts">
            <summary>
            docbase for each leaf: parallel with <see cref="P:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.Values"/> </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.Values">
            <summary>
            leaf values </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.Mapping">
            <summary>
            ordinal map mapping ords from <c>values</c> to global ord space </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.#ctor(Lucene.Net.Index.SortedDocValues[],System.Int32[],Lucene.Net.Index.MultiDocValues.OrdinalMap)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues"/> over <paramref name="values"/> </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues">
            <summary>
            Implements <see cref="T:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues"/> over n subs, using an <see cref="T:Lucene.Net.Index.MultiDocValues.OrdinalMap"/>
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.DocStarts">
            <summary>
            docbase for each leaf: parallel with <see cref="P:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.Values"/> </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.Values">
            <summary>
            leaf values </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.Mapping">
            <summary>
            ordinal map mapping ords from <c>values</c> to global ord space </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.#ctor(Lucene.Net.Index.SortedSetDocValues[],System.Int32[],Lucene.Net.Index.MultiDocValues.OrdinalMap)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues"/> over <paramref name="values"/> </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiFields">
             <summary>
             Exposes flex API, merged from flex API of sub-segments.
             This is useful when you're interacting with an 
             <see cref="T:Lucene.Net.Index.IndexReader"/> implementation that consists of sequential
             sub-readers (eg <see cref="T:Lucene.Net.Index.DirectoryReader"/> or 
             <see cref="T:Lucene.Net.Index.MultiReader"/>).
            
             <para/><b>NOTE</b>: for composite readers, you'll get better
             performance by gathering the sub readers using
             <see cref="P:Lucene.Net.Index.IndexReader.Context"/> to get the
             atomic leaves and then operate per-AtomicReader,
             instead of using this class.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiFields.GetFields(Lucene.Net.Index.IndexReader)">
             <summary>
             Returns a single <see cref="T:Lucene.Net.Index.Fields"/> instance for this
             reader, merging fields/terms/docs/positions on the
             fly.  This method will return <c>null</c> if the reader
             has no postings.
            
             <para/><b>NOTE</b>: this is a slow way to access postings.
             It's better to get the sub-readers and iterate through them
             yourself.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiFields.GetLiveDocs(Lucene.Net.Index.IndexReader)">
             <summary>
             Returns a single <see cref="T:Lucene.Net.Util.IBits"/> instance for this
             reader, merging live Documents on the
             fly.  This method will return <c>null</c> if the reader
             has no deletions.
            
             <para/><b>NOTE</b>: this is a very slow way to access live docs.
             For example, each <see cref="T:Lucene.Net.Util.IBits"/> access will require a binary search.
             It's better to get the sub-readers and iterate through them
             yourself.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiFields.GetTerms(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            this method may return <c>null</c> if the field does not exist. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiFields.GetTermDocsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.DocsEnum"/> for the specified field &amp;
            term.  This will return <c>null</c> if the field or term does
            not exist.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiFields.GetTermDocsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Index.DocsFlags)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.DocsEnum"/> for the specified field &amp;
            term, with control over whether freqs are required.
            Some codecs may be able to optimize their
            implementation when freqs are not required.  This will
            return <c>null</c> if the field or term does not exist.  See
            <see cref="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum,Lucene.Net.Index.DocsFlags)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiFields.GetTermPositionsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> for the specified
            field &amp; term.  This will return <c>null</c> if the field or
            term does not exist or positions were not indexed. </summary>
            <seealso cref="M:Lucene.Net.Index.MultiFields.GetTermPositionsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Index.DocsAndPositionsFlags)"/>
        </member>
        <member name="M:Lucene.Net.Index.MultiFields.GetTermPositionsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Index.DocsAndPositionsFlags)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> for the specified
            field &amp; term, with control over whether offsets and payloads are
            required.  Some codecs may be able to optimize
            their implementation when offsets and/or payloads are not
            required. This will return <c>null</c> if the field or term does not
            exist or positions were not indexed. See 
            <see cref="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum,Lucene.Net.Index.DocsAndPositionsFlags)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiFields.#ctor(Lucene.Net.Index.Fields[],Lucene.Net.Index.ReaderSlice[])">
            <summary>
            Expert: construct a new <see cref="T:Lucene.Net.Index.MultiFields"/> instance directly.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiFields.GetMergedFieldInfos(Lucene.Net.Index.IndexReader)">
            <summary>
            Call this to get the (merged) <see cref="T:Lucene.Net.Index.FieldInfos"/> for a
            composite reader.
            <para/>
            NOTE: the returned field numbers will likely not
            correspond to the actual field numbers in the underlying
            readers, and codec metadata (<see cref="M:Lucene.Net.Index.FieldInfo.GetAttribute(System.String)"/>)
            will be unavailable.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiFields.GetIndexedFields(Lucene.Net.Index.IndexReader)">
            <summary>
            Call this to get the (merged) <see cref="T:Lucene.Net.Index.FieldInfos"/> representing the
            set of indexed fields <b>only</b> for a composite reader.
            <para/>
            NOTE: the returned field numbers will likely not
            correspond to the actual field numbers in the underlying
            readers, and codec metadata (<see cref="M:Lucene.Net.Index.FieldInfo.GetAttribute(System.String)"/>)
            will be unavailable.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiReader">
             <summary>
             A <see cref="T:Lucene.Net.Index.CompositeReader"/> which reads multiple indexes, appending
             their content. It can be used to create a view on several
             sub-readers (like <see cref="T:Lucene.Net.Index.DirectoryReader"/>) and execute searches on it.
            
             <para/> For efficiency, in this API documents are often referred to via
             <i>document numbers</i>, non-negative integers which each name a unique
             document in the index.  These document numbers are ephemeral -- they may change
             as documents are added to and deleted from an index.  Clients should thus not
             rely on a given document having the same number between sessions.
            
             <para/><a name="thread-safety"></a><b>NOTE</b>: 
             <see cref="T:Lucene.Net.Index.IndexReader"/> instances are completely thread
             safe, meaning multiple threads can call any of its methods,
             concurrently.  If your application requires external
             synchronization, you should <b>not</b> synchronize on the
             <see cref="T:Lucene.Net.Index.IndexReader"/> instance; use your own
             (non-Lucene) objects instead.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Index.IndexReader[])">
            <summary>
            <para>Construct a <see cref="T:Lucene.Net.Index.MultiReader"/> aggregating the named set of (sub)readers.</para>
            <para>Note that all subreaders are closed if this Multireader is closed.</para> </summary>
            <param name="subReaders"> set of (sub)readers </param>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Index.IndexReader[],System.Boolean)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Index.MultiReader"/> aggregating the named set of (sub)readers. </summary>
            <param name="subReaders"> set of (sub)readers; this array will be cloned. </param>
            <param name="closeSubReaders"> indicates whether the subreaders should be disposed
            when this <see cref="T:Lucene.Net.Index.MultiReader"/> is disposed </param>
        </member>
        <member name="T:Lucene.Net.Index.MultiTerms">
            <summary>
            Exposes flex API, merged from flex API of
            sub-segments.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiTerms.#ctor(Lucene.Net.Index.Terms[],Lucene.Net.Index.ReaderSlice[])">
            <summary>
            Sole constructor.
            </summary>
            <param name="subs"> The <see cref="T:Lucene.Net.Index.Terms"/> instances of all sub-readers. </param>
            <param name="subSlices"> A parallel array (matching 
                   <paramref name="subs"/>) describing the sub-reader slices. </param>
        </member>
        <member name="T:Lucene.Net.Index.MultiTermsEnum">
            <summary>
            Exposes <see cref="T:Lucene.Net.Index.TermsEnum"/> API, merged from <see cref="T:Lucene.Net.Index.TermsEnum"/> API of sub-segments.
            This does a merge sort, by term text, of the sub-readers.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiTermsEnum.MatchCount">
            <summary>
            Returns how many sub-reader slices contain the current 
            term.</summary> 
            <seealso cref="P:Lucene.Net.Index.MultiTermsEnum.MatchArray"/>
        </member>
        <member name="P:Lucene.Net.Index.MultiTermsEnum.MatchArray">
            <summary>
            Returns sub-reader slices positioned to the current term. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiTermsEnum.#ctor(Lucene.Net.Index.ReaderSlice[])">
            <summary>
            Sole constructor. </summary>
            <param name="slices"> Which sub-reader slices we should
            merge.</param>
        </member>
        <member name="M:Lucene.Net.Index.MultiTermsEnum.Reset(Lucene.Net.Index.MultiTermsEnum.TermsEnumIndex[])">
            <summary>
            The terms array must be newly created <see cref="T:Lucene.Net.Index.TermsEnum"/>, ie
            <see cref="M:Lucene.Net.Index.TermsEnum.Next"/> has not yet been called.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.NoDeletionPolicy">
            <summary>
            An <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> which keeps all index commits around, never
            deleting them. This class is a singleton and can be accessed by referencing
            <see cref="F:Lucene.Net.Index.NoDeletionPolicy.INSTANCE"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.NoDeletionPolicy.INSTANCE">
            <summary>
            The single instance of this class. </summary>
        </member>
        <member name="T:Lucene.Net.Index.NoMergePolicy">
            <summary>
            A <see cref="T:Lucene.Net.Index.MergePolicy"/> which never returns merges to execute (hence it's
            name). It is also a singleton and can be accessed through
            <see cref="F:Lucene.Net.Index.NoMergePolicy.NO_COMPOUND_FILES"/> if you want to indicate the index
            does not use compound files, or through <see cref="F:Lucene.Net.Index.NoMergePolicy.COMPOUND_FILES"/>
            otherwise. Use it if you want to prevent an <see cref="T:Lucene.Net.Index.IndexWriter"/> from ever
            executing merges, without going through the hassle of tweaking a merge
            policy's settings to achieve that, such as changing its merge factor.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.NoMergePolicy.NO_COMPOUND_FILES">
            <summary>
            A singleton <see cref="T:Lucene.Net.Index.NoMergePolicy"/> which indicates the index does not use
            compound files.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.NoMergePolicy.COMPOUND_FILES">
            <summary>
            A singleton <see cref="T:Lucene.Net.Index.NoMergePolicy"/> which indicates the index uses compound
            files.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.NoMergeScheduler">
            <summary>
            A <see cref="T:Lucene.Net.Index.MergeScheduler"/> which never executes any merges. It is also a
            singleton and can be accessed through <see cref="F:Lucene.Net.Index.NoMergeScheduler.INSTANCE"/>. Use
            it if you want to prevent an <see cref="T:Lucene.Net.Index.IndexWriter"/> from ever executing merges,
            regardless of the <see cref="T:Lucene.Net.Index.MergePolicy"/> used. Note that you can achieve the
            same thing by using <see cref="T:Lucene.Net.Index.NoMergePolicy"/>, however with
            <see cref="T:Lucene.Net.Index.NoMergeScheduler"/> you also ensure that no unnecessary code of any
            <see cref="T:Lucene.Net.Index.MergeScheduler"/> implementation is ever executed. Hence it is
            recommended to use both if you want to disable merges from ever happening.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.NoMergeScheduler.INSTANCE">
            <summary>
            The single instance of <see cref="T:Lucene.Net.Index.NoMergeScheduler"/> </summary>
        </member>
        <member name="T:Lucene.Net.Index.NormsConsumer">
            <summary>
            Writes norms.  Each thread X field accumulates the norms
            for the doc/fields it saw, then the flush method below
            merges all of these together into a single _X.nrm file.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.NumericDocValues">
            <summary>
            A per-document numeric value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.NumericDocValues.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.NumericDocValues.Get(System.Int32)">
            <summary>
            Returns the numeric value for the specified document ID. </summary>
            <param name="docID"> document ID to lookup </param>
            <returns> numeric value </returns>
        </member>
        <member name="T:Lucene.Net.Index.NumericDocValuesFieldUpdates">
            <summary>
            A <see cref="T:Lucene.Net.Index.DocValuesFieldUpdates"/> which holds updates of documents, of a single
            <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.NumericDocValuesWriter">
            <summary>
            Buffers up pending long per doc, then flushes when
            segment flushes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.OrdTermState">
            <summary>
            An ordinal based <see cref="T:Lucene.Net.Index.TermState"/>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.OrdTermState.Ord">
            <summary>
            Term ordinal, i.e. it's position in the full list of
            sorted terms.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.OrdTermState.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Index.ParallelAtomicReader">
             <summary>
             An <see cref="T:Lucene.Net.Index.AtomicReader"/> which reads multiple, parallel indexes.  Each index
             added must have the same number of documents, but typically each contains
             different fields. Deletions are taken from the first reader.
             Each document contains the union of the fields of all documents
             with the same document number.  When searching, matches for a
             query term are from the first index added that has the field.
            
             <para/>This is useful, e.g., with collections that have large fields which
             change rarely and small fields that change more frequently.  The smaller
             fields may be re-indexed in a new index and both indexes may be searched
             together.
            
             <para/><strong>Warning:</strong> It is up to you to make sure all indexes
             are created and modified the same way. For example, if you add
             documents to one index, you need to add the same documents in the
             same order to the other indexes. <em>Failure to do so will result in
             undefined behavior</em>.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelAtomicReader.#ctor(Lucene.Net.Index.AtomicReader[])">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.ParallelAtomicReader"/> based on the provided
            readers; auto-disposes the given <paramref name="readers"/> on <see cref="M:Lucene.Net.Index.IndexReader.Dispose"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelAtomicReader.#ctor(System.Boolean,Lucene.Net.Index.AtomicReader[])">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.ParallelAtomicReader"/> based on the provided
            <paramref name="readers"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelAtomicReader.#ctor(System.Boolean,Lucene.Net.Index.AtomicReader[],Lucene.Net.Index.AtomicReader[])">
            <summary>
            Expert: create a <see cref="T:Lucene.Net.Index.ParallelAtomicReader"/> based on the provided
            <paramref name="readers"/> and <paramref name="storedFieldsReaders"/>; when a document is
            loaded, only <paramref name="storedFieldsReaders"/> will be used.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.ParallelAtomicReader.FieldInfos">
            <summary>
            Get the <see cref="T:Lucene.Net.Index.FieldInfos"/> describing all fields in
            this reader.
            <para/>
            NOTE: the returned field numbers will likely not
            correspond to the actual field numbers in the underlying
            readers, and codec metadata (<see cref="M:Lucene.Net.Index.FieldInfo.GetAttribute(System.String)"/>
            will be unavailable.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ParallelCompositeReader">
             <summary>
             A <see cref="T:Lucene.Net.Index.CompositeReader"/> which reads multiple, parallel indexes.  Each index added
             must have the same number of documents, and exactly the same hierarchical subreader structure,
             but typically each contains different fields. Deletions are taken from the first reader.
             Each document contains the union of the fields of all
             documents with the same document number.  When searching, matches for a
             query term are from the first index added that has the field.
            
             <para/>This is useful, e.g., with collections that have large fields which
             change rarely and small fields that change more frequently.  The smaller
             fields may be re-indexed in a new index and both indexes may be searched
             together.
            
             <para/><strong>Warning:</strong> It is up to you to make sure all indexes
             are created and modified the same way. For example, if you add
             documents to one index, you need to add the same documents in the
             same order to the other indexes. <em>Failure to do so will result in
             undefined behavior</em>.
             A good strategy to create suitable indexes with <see cref="T:Lucene.Net.Index.IndexWriter"/> is to use
             <see cref="T:Lucene.Net.Index.LogDocMergePolicy"/>, as this one does not reorder documents
             during merging (like <see cref="T:Lucene.Net.Index.TieredMergePolicy"/>) and triggers merges
             by number of documents per segment. If you use different <see cref="T:Lucene.Net.Index.MergePolicy"/>s
             it might happen that the segment structure of your index is no longer predictable.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelCompositeReader.#ctor(Lucene.Net.Index.CompositeReader[])">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.ParallelCompositeReader"/> based on the provided
            readers; auto-disposes the given <paramref name="readers"/> on <see cref="M:Lucene.Net.Index.IndexReader.Dispose"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelCompositeReader.#ctor(System.Boolean,Lucene.Net.Index.CompositeReader[])">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.ParallelCompositeReader"/> based on the provided
            <paramref name="readers"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelCompositeReader.#ctor(System.Boolean,Lucene.Net.Index.CompositeReader[],Lucene.Net.Index.CompositeReader[])">
            <summary>
            Expert: create a <see cref="T:Lucene.Net.Index.ParallelCompositeReader"/> based on the provided
            <paramref name="readers"/> and <paramref name="storedFieldReaders"/>; when a document is
            loaded, only <paramref name="storedFieldReaders"/> will be used.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.PersistentSnapshotDeletionPolicy">
             <summary>
             A <see cref="T:Lucene.Net.Index.SnapshotDeletionPolicy"/> which adds a persistence layer so that
             snapshots can be maintained across the life of an application. The snapshots
             are persisted in a <see cref="T:Lucene.Net.Store.Directory"/> and are committed as soon as
             <see cref="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Snapshot"/> or <see cref="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Release(Lucene.Net.Index.IndexCommit)"/> is called.
             <para/>
             <b>NOTE:</b> Sharing <see cref="T:Lucene.Net.Index.PersistentSnapshotDeletionPolicy"/>s that write to
             the same directory across <see cref="T:Lucene.Net.Index.IndexWriter"/>s will corrupt snapshots. You
             should make sure every <see cref="T:Lucene.Net.Index.IndexWriter"/> has its own
             <see cref="T:Lucene.Net.Index.PersistentSnapshotDeletionPolicy"/> and that they all write to a
             different <see cref="T:Lucene.Net.Store.Directory"/>.  It is OK to use the same
             <see cref="T:Lucene.Net.Store.Directory"/> that holds the index.
            
             <para/> This class adds a <see cref="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Release(System.Int64)"/> method to
             release commits from a previous snapshot's <see cref="P:Lucene.Net.Index.IndexCommit.Generation"/>.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.SNAPSHOTS_PREFIX">
            <summary>
            Prefix used for the save file. </summary>
        </member>
        <member name="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.#ctor(Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Store.Directory)">
            <summary>
            <see cref="T:Lucene.Net.Index.PersistentSnapshotDeletionPolicy"/> wraps another
            <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> to enable flexible
            snapshotting, passing <see cref="F:Lucene.Net.Index.OpenMode.CREATE_OR_APPEND"/>
            by default.
            </summary>
            <param name="primary">
                     the <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> that is used on non-snapshotted
                     commits. Snapshotted commits, by definition, are not deleted until
                     explicitly released via <see cref="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Release(Lucene.Net.Index.IndexCommit)"/>. </param>
            <param name="dir">
                     the <see cref="T:Lucene.Net.Store.Directory"/> which will be used to persist the snapshots
                     information. </param>
        </member>
        <member name="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.#ctor(Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Store.Directory,Lucene.Net.Index.OpenMode)">
            <summary>
            <see cref="T:Lucene.Net.Index.PersistentSnapshotDeletionPolicy"/> wraps another
            <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> to enable flexible snapshotting.
            </summary>
            <param name="primary">
                     the <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> that is used on non-snapshotted
                     commits. Snapshotted commits, by definition, are not deleted until
                     explicitly released via <see cref="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Release(Lucene.Net.Index.IndexCommit)"/>. </param>
            <param name="dir">
                     the <see cref="T:Lucene.Net.Store.Directory"/> which will be used to persist the snapshots
                     information. </param>
            <param name="mode">
                     specifies whether a new index should be created, deleting all
                     existing snapshots information (immediately), or open an existing
                     index, initializing the class with the snapshots information. </param>
        </member>
        <member name="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Snapshot">
            <summary>
            Snapshots the last commit. Once this method returns, the
            snapshot information is persisted in the directory.
            </summary>
            <seealso cref="M:Lucene.Net.Index.SnapshotDeletionPolicy.Snapshot"/>
        </member>
        <member name="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Release(Lucene.Net.Index.IndexCommit)">
            <summary>
            Deletes a snapshotted commit. Once this method returns, the snapshot
            information is persisted in the directory.
            </summary>
            <seealso cref="M:Lucene.Net.Index.SnapshotDeletionPolicy.Release(Lucene.Net.Index.IndexCommit)"/>
        </member>
        <member name="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Release(System.Int64)">
            <summary>
            Deletes a snapshotted commit by generation. Once this method returns, the snapshot
            information is persisted in the directory.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexCommit.Generation"/>
            <seealso cref="M:Lucene.Net.Index.SnapshotDeletionPolicy.Release(Lucene.Net.Index.IndexCommit)"/>
        </member>
        <member name="P:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.LastSaveFile">
            <summary>
            Returns the file name the snapshots are currently
            saved to, or <c>null</c> if no snapshots have been saved.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.LoadPriorSnapshots">
            <summary>
            Reads the snapshots information from the given <see cref="T:Lucene.Net.Store.Directory"/>. This
            method can be used if the snapshots information is needed, however you
            cannot instantiate the deletion policy (because e.g., some other process
            keeps a lock on the snapshots directory).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.PrefixCodedTerms">
            <summary>
            Prefix codes term instances (prefixes are shared)
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.PrefixCodedTerms.GetSizeInBytes">
            <returns> size in bytes </returns>
        </member>
        <member name="M:Lucene.Net.Index.PrefixCodedTerms.GetEnumerator">
            <returns> iterator over the bytes </returns>
        </member>
        <member name="T:Lucene.Net.Index.PrefixCodedTerms.Builder">
            <summary>
            Builds a <see cref="T:Lucene.Net.Index.PrefixCodedTerms"/>: call add repeatedly, then finish. </summary>
        </member>
        <member name="M:Lucene.Net.Index.PrefixCodedTerms.Builder.Add(Lucene.Net.Index.Term)">
            <summary>
            add a term </summary>
        </member>
        <member name="M:Lucene.Net.Index.PrefixCodedTerms.Builder.Finish">
            <returns>
            finalized form </returns>
        </member>
        <member name="T:Lucene.Net.Index.RandomAccessOrds">
            <summary>
            Extension of <see cref="T:Lucene.Net.Index.SortedSetDocValues"/> that supports random access
            to the ordinals of a document.
            <para/>
            Operations via this API are independent of the iterator api (<see cref="M:Lucene.Net.Index.SortedSetDocValues.NextOrd"/>)
            and do not impact its state.
            <para/>
            Codecs can optionally extend this API if they support constant-time access
            to ordinals for the document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.RandomAccessOrds.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.RandomAccessOrds.OrdAt(System.Int32)">
            <summary>
            Retrieve the ordinal for the current document (previously
            set by <see cref="M:Lucene.Net.Index.SortedSetDocValues.SetDocument(System.Int32)"/> at the specified index.
            <para/>
            An index ranges from <c>0</c> to <c>Cardinality()-1</c>.
            The first ordinal value is at index <c>0</c>, the next at index <c>1</c>,
            and so on, as for array indexing. </summary>
            <param name="index"> index of the ordinal for the document. </param>
            <returns> ordinal for the document at the specified index. </returns>
        </member>
        <member name="M:Lucene.Net.Index.RandomAccessOrds.Cardinality">
            <summary>
            Returns the cardinality for the current document (previously
            set by <see cref="M:Lucene.Net.Index.SortedSetDocValues.SetDocument(System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ReaderManager">
            <summary>
            Utility class to safely share <see cref="T:Lucene.Net.Index.DirectoryReader"/> instances across
            multiple threads, while periodically reopening. This class ensures each
            reader is disposed only once all threads have finished using it.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Search.SearcherManager"/>
        </member>
        <member name="M:Lucene.Net.Index.ReaderManager.#ctor(Lucene.Net.Index.IndexWriter,System.Boolean)">
            <summary>
            Creates and returns a new <see cref="T:Lucene.Net.Index.ReaderManager"/> from the given
            <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
            <param name="writer">
                     the <see cref="T:Lucene.Net.Index.IndexWriter"/> to open the <see cref="T:Lucene.Net.Index.IndexReader"/> from. </param>
            <param name="applyAllDeletes">
                     If <c>true</c>, all buffered deletes will be applied (made
                     visible) in the <see cref="T:Lucene.Net.Search.IndexSearcher"/> / <see cref="T:Lucene.Net.Index.DirectoryReader"/>.
                     If <c>false</c>, the deletes may or may not be applied, but
                     remain buffered (in <see cref="T:Lucene.Net.Index.IndexWriter"/>) so that they will be applied in
                     the future. Applying deletes can be costly, so if your app can
                     tolerate deleted documents being returned you might gain some
                     performance by passing <c>false</c>. See
                     <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexWriter,System.Boolean)"/>.
            </param>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Index.ReaderManager.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Creates and returns a new <see cref="T:Lucene.Net.Index.ReaderManager"/> from the given <see cref="T:Lucene.Net.Store.Directory"/>. </summary>
            <param name="dir"> the directory to open the <see cref="T:Lucene.Net.Index.DirectoryReader"/> on.
            </param>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="T:Lucene.Net.Index.ReadersAndUpdates">
            <summary>
            Used by <see cref="T:Lucene.Net.Index.IndexWriter"/> to hold open <see cref="T:Lucene.Net.Index.SegmentReader"/>s (for
            searching or merging), plus pending deletes and updates,
            for a given segment
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.GetReader(Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.SegmentReader"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.GetReadOnlyClone(Lucene.Net.Store.IOContext)">
            <summary>
            Returns a ref to a clone. NOTE: you should <see cref="M:Lucene.Net.Index.ReadersAndUpdates.DecRef"/> the reader when you're
            done (ie do not call <see cref="M:Lucene.Net.Index.IndexReader.Dispose"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.GetInt64Enumerable(Lucene.Net.Index.SegmentReader,System.String,Lucene.Net.Index.NumericDocValuesFieldUpdates)">
            <summary>
            NOTE: This was getLongEnumerable() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.GetReaderForMerge(Lucene.Net.Store.IOContext)">
            <summary>
            Returns a reader for merge. this method applies field updates if there are
            any and marks that this segment is currently merging.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.DropMergingUpdates">
            <summary>
            Drops all merging updates. Called from IndexWriter after this segment
            finished merging (whether successfully or not).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.ReadersAndUpdates.MergingFieldUpdates">
            <summary>
            Returns updates that came in while this segment was merging. </summary>
        </member>
        <member name="T:Lucene.Net.Index.ReaderSlice">
            <summary>
            Subreader slice from a parent composite reader.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.ReaderSlice.EMPTY_ARRAY">
            <summary>
            Zero-length <see cref="T:Lucene.Net.Index.ReaderSlice"/> array. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ReaderSlice.Start">
            <summary>
            Document ID this slice starts from. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ReaderSlice.Length">
            <summary>
            Number of documents in this slice. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ReaderSlice.ReaderIndex">
            <summary>
            Sub-reader index for this slice. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderSlice.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Index.ReaderUtil">
            <summary>
            Common util methods for dealing with <see cref="T:Lucene.Net.Index.IndexReader"/>s and <see cref="T:Lucene.Net.Index.IndexReaderContext"/>s.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderUtil.GetTopLevelContext(Lucene.Net.Index.IndexReaderContext)">
            <summary>
            Walks up the reader tree and return the given context's top level reader
            context, or in other words the reader tree's root context.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderUtil.SubIndex(System.Int32,System.Int32[])">
            <summary>
            Returns index of the searcher/reader for document <c>n</c> in the
            array used to construct this searcher/reader.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderUtil.SubIndex(System.Int32,System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext})">
            <summary>
            Returns index of the searcher/reader for document <c>n</c> in the
            array used to construct this searcher/reader.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentCommitInfo">
            <summary>
            Embeds a [read-only] <see cref="T:Lucene.Net.Index.SegmentInfo"/> and adds per-commit
            fields.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.Info">
            <summary>
            The <see cref="T:Lucene.Net.Index.SegmentInfo"/> that we wrap. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.#ctor(Lucene.Net.Index.SegmentInfo,System.Int32,System.Int64,System.Int64)">
            <summary>
            Sole constructor.
            </summary>
            <param name="info">
                     <see cref="T:Lucene.Net.Index.SegmentInfo"/> that we wrap </param>
            <param name="delCount">
                     number of deleted documents in this segment </param>
            <param name="delGen">
                     deletion generation number (used to name deletion files) </param>
            <param name="fieldInfosGen">
                     <see cref="T:Lucene.Net.Index.FieldInfos"/> generation number (used to name field-infos files)
             </param>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.UpdatesFiles">
            <summary>
            Returns the per generation updates files. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.SetGenUpdatesFiles(System.Collections.Generic.IDictionary{System.Int64,System.Collections.Generic.ISet{System.String}})">
            <summary>
            Sets the updates file names per generation. Does not deep clone the map. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.AdvanceDelGen">
            <summary>
            Called when we succeed in writing deletes </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.AdvanceNextWriteDelGen">
            <summary>
            Called if there was an exception while writing
            deletes, so that we don't try to write to the same
            file more than once.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.AdvanceFieldInfosGen">
            <summary>
            Called when we succeed in writing a new <see cref="T:Lucene.Net.Index.FieldInfos"/> generation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.AdvanceNextWriteFieldInfosGen">
            <summary>
            Called if there was an exception while writing a new generation of
            <see cref="T:Lucene.Net.Index.FieldInfos"/>, so that we don't try to write to the same file more than once.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.GetSizeInBytes">
            <summary>
            Returns total size in bytes of all files for this
            segment.
            <para/><b>NOTE:</b> this value is not correct for 3.0 segments
            that have shared docstores. To get the correct value, upgrade!
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.GetFiles">
            <summary>
            Returns all files in use by this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.HasDeletions">
            <summary>
            Returns <c>true</c> if there are any deletions for the
            segment at this commit.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.HasFieldUpdates">
            <summary>
            Returns <c>true</c> if there are any field updates for the segment in this commit. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.NextFieldInfosGen">
            <summary>
            Returns the next available generation number of the <see cref="T:Lucene.Net.Index.FieldInfos"/> files. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.FieldInfosGen">
            <summary>
            Returns the generation number of the field infos file or -1 if there are no
            field updates yet.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.NextDelGen">
            <summary>
            Returns the next available generation number
            of the live docs file.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.DelGen">
            <summary>
            Returns generation number of the live docs file
            or -1 if there are no deletes yet.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.DelCount">
            <summary>
            Returns the number of deleted docs in the segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.ToString(Lucene.Net.Store.Directory,System.Int32)">
            <summary>
            Returns a description of this segment. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentCoreReaders">
            <summary>
            Holds core readers that are shared (unchanged) when
            <see cref="T:Lucene.Net.Index.SegmentReader"/> is cloned or reopened
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCoreReaders.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentDocValues">
            <summary>
            Manages the <see cref="T:Lucene.Net.Codecs.DocValuesProducer"/> held by <see cref="T:Lucene.Net.Index.SegmentReader"/> and
            keeps track of their reference counting.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentDocValues.GetDocValuesProducer(System.Nullable{System.Int64},Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Store.IOContext,Lucene.Net.Store.Directory,Lucene.Net.Codecs.DocValuesFormat,System.Collections.Generic.IList{Lucene.Net.Index.FieldInfo},System.Int32)">
            <summary>
            Returns the <see cref="T:Lucene.Net.Codecs.DocValuesProducer"/> for the given generation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentDocValues.DecRef(System.Collections.Generic.IList{System.Nullable{System.Int64}})">
            <summary>
            Decrement the reference count of the given <see cref="T:Lucene.Net.Codecs.DocValuesProducer"/>
            generations.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentInfo">
            <summary>
            Information about a segment such as it's name, directory, and files related
            to the segment.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfo.NO">
            <summary>
            Used by some member fields to mean not present (e.g.,
            norms, deletions).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfo.YES">
            <summary>
            Used by some member fields to mean present (e.g.,
            norms, deletions).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.Name">
            <summary>
            Unique segment name in the directory. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.Dir">
            <summary>
            Where this segment resides. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.Diagnostics">
            <summary>
            Gets or Sets diagnostics saved into the segment when it was written.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.#ctor(Lucene.Net.Store.Directory,System.String,System.String,System.Int32,System.Boolean,Lucene.Net.Codecs.Codec,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Construct a new complete <see cref="T:Lucene.Net.Index.SegmentInfo"/> instance from input.
            <para>Note: this is public only to allow access from
            the codecs package.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.#ctor(Lucene.Net.Store.Directory,System.String,System.String,System.Int32,System.Boolean,Lucene.Net.Codecs.Codec,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Construct a new complete <see cref="T:Lucene.Net.Index.SegmentInfo"/> instance from input.
            <para>Note: this is public only to allow access from
            the codecs package.</para>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.UseCompoundFile">
            <summary>
            Gets or Sets whether this segment is stored as a compound file.
            <c>true</c> if this is a compound file;
            else, <c>false</c>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.Codec">
            <summary>
            Gets or Sets <see cref="T:Lucene.Net.Codecs.Codec"/> that wrote this segment.
            Setter can only be called once. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.DocCount">
            <summary>
            Returns number of documents in this segment (deletions
            are not taken into account).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.GetFiles">
            <summary>
            Return all files referenced by this <see cref="T:Lucene.Net.Index.SegmentInfo"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.ToString(Lucene.Net.Store.Directory,System.Int32)">
             <summary>
             Used for debugging.  Format may suddenly change.
            
             <para>Current format looks like
             <c>_a(3.1):c45/4</c>, which means the segment's
             name is <c>_a</c>; it was created with Lucene 3.1 (or
             '?' if it's unknown); it's using compound file
             format (would be <c>C</c> if not compound); it
             has 45 documents; it has 4 deletions (this part is
             left off when there are no deletions).</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.Equals(System.Object)">
            <summary>
            We consider another <see cref="T:Lucene.Net.Index.SegmentInfo"/> instance equal if it
            has the same dir and same name.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.Version">
            <summary>
            Used by DefaultSegmentInfosReader to upgrade a 3.0 segment to record its
            version is "3.0". this method can be removed when we're not required to
            support 3x indexes anymore, e.g. in 5.0.
            <para/>
            <b>NOTE:</b> this method is used for internal purposes only - you should
            not modify the version of a <see cref="T:Lucene.Net.Index.SegmentInfo"/>, or it may result in unexpected
            exceptions thrown when you attempt to open the index.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.SetFiles(System.Collections.Generic.ISet{System.String})">
            <summary>
            Sets the files written for this segment. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.AddFiles(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Add these files to the set of files written for this
            segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.AddFile(System.String)">
            <summary>
            Add this file to the set of files written for this
            segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.GetAttribute(System.String)">
            <summary>
            Get a codec attribute value, or null if it does not exist
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.PutAttribute(System.String,System.String)">
            <summary>
            Puts a codec attribute value.
            <para/>
            This is a key-value mapping for the field that the codec can use to store
            additional metadata, and will be available to the codec when reading the
            segment via <see cref="M:Lucene.Net.Index.SegmentInfo.GetAttribute(System.String)"/>
            <para/>
            If a value already exists for the field, it will be replaced with the new
            value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.Attributes">
            <summary>
            Returns the internal codec attributes map. May be null if no mappings exist.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentInfos">
             <summary>
             A collection of segmentInfo objects with methods for operating on
             those segments in relation to the file system.
             <para>
             The active segments in the index are stored in the segment info file,
             <c>segments_N</c>. There may be one or more <c>segments_N</c> files in the
             index; however, the one with the largest generation is the active one (when
             older segments_N files are present it's because they temporarily cannot be
             deleted, or, a writer is in the process of committing, or a custom
             <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/>
             is in use). This file lists each segment by name and has details about the
             codec and generation of deletes.
             </para>
             <para>There is also a file <c>segments.gen</c>. this file contains
             the current generation (the <c>_N</c> in <c>segments_N</c>) of the index.
             This is used only as a fallback in case the current generation cannot be
             accurately determined by directory listing alone (as is the case for some NFS
             clients with time-based directory cache expiration). This file simply contains
             an <see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/> version header
             (<see cref="F:Lucene.Net.Index.SegmentInfos.FORMAT_SEGMENTS_GEN_CURRENT"/>), followed by the
             generation recorded as <see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>, written twice.</para>
             <para>
             Files:
             <list type="bullet">
               <item><description><c>segments.gen</c>: GenHeader, Generation, Generation, Footer</description></item>
               <item><description><c>segments_N</c>: Header, Version, NameCounter, SegCount,
                &lt;SegName, SegCodec, DelGen, DeletionCount, FieldInfosGen, UpdatesFiles&gt;<sup>SegCount</sup>,
                CommitUserData, Footer</description></item>
             </list>
             </para>
             Data types:
             <para>
             <list type="bullet">
               <item><description>Header --&gt; <see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/></description></item>
               <item><description>GenHeader, NameCounter, SegCount, DeletionCount --&gt; <see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/></description></item>
               <item><description>Generation, Version, DelGen, Checksum, FieldInfosGen --&gt; <see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/></description></item>
               <item><description>SegName, SegCodec --&gt; <see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/></description></item>
               <item><description>CommitUserData --&gt; <see cref="M:Lucene.Net.Store.DataOutput.WriteStringStringMap(System.Collections.Generic.IDictionary{System.String,System.String})"/></description></item>
               <item><description>UpdatesFiles --&gt; <see cref="M:Lucene.Net.Store.DataOutput.WriteStringSet(System.Collections.Generic.ISet{System.String})"/></description></item>
               <item><description>Footer --&gt; <see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/></description></item>
             </list>
             </para>
             Field Descriptions:
             <para>
             <list type="bullet">
               <item><description>Version counts how often the index has been changed by adding or deleting
                   documents.</description></item>
               <item><description>NameCounter is used to generate names for new segment files.</description></item>
               <item><description>SegName is the name of the segment, and is used as the file name prefix for
                   all of the files that compose the segment's index.</description></item>
               <item><description>DelGen is the generation count of the deletes file. If this is -1,
                   there are no deletes. Anything above zero means there are deletes
                   stored by <see cref="T:Lucene.Net.Codecs.LiveDocsFormat"/>.</description></item>
               <item><description>DeletionCount records the number of deleted documents in this segment.</description></item>
               <item><description>SegCodec is the <see cref="P:Lucene.Net.Codecs.Codec.Name"/> of the <see cref="T:Lucene.Net.Codecs.Codec"/> that encoded
                   this segment.</description></item>
               <item><description>CommitUserData stores an optional user-supplied opaque
                   <see cref="T:IDictionary{string, string}"/> that was passed to
                   <see cref="M:Lucene.Net.Index.IndexWriter.SetCommitData(System.Collections.Generic.IDictionary{System.String,System.String})"/>.</description></item>
               <item><description>FieldInfosGen is the generation count of the fieldInfos file. If this is -1,
                   there are no updates to the fieldInfos in that segment. Anything above zero
                   means there are updates to fieldInfos stored by <see cref="T:Lucene.Net.Codecs.FieldInfosFormat"/>.</description></item>
               <item><description>UpdatesFiles stores the list of files that were updated in that segment.</description></item>
             </list>
             </para>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.VERSION_40">
            <summary>
            The file format version for the segments_N codec header, up to 4.5. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.VERSION_46">
            <summary>
            The file format version for the segments_N codec header, since 4.6+. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.VERSION_48">
            <summary>
            The file format version for the segments_N codec header, since 4.8+ </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT_SEGMENTS_GEN_CURRENT">
            <summary>
            Current format of segments.gen </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.Counter">
            <summary>
            Used to name new segments. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.userData">
            <summary>
            Opaque <see cref="T:IDictionary{string, string}"/> that user can specify during <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.infoStream">
            <summary>
            If non-null, information about loading segments_N files 
            will be printed here.</summary> 
            <seealso cref="P:Lucene.Net.Index.SegmentInfos.InfoStream"/>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.#ctor">
            <summary>
            Sole constructor. Typically you call this and then
            use <see cref="M:Lucene.Net.Index.SegmentInfos.Read(Lucene.Net.Store.Directory)"/> or
            <see cref="M:Lucene.Net.Index.SegmentInfos.Read(Lucene.Net.Store.Directory,System.String)"/> to populate each
            <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>.  Alternatively, you can add/remove your
            own <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Info(System.Int32)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/> at the provided
            index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetLastCommitGeneration(System.String[])">
            <summary>
            Get the generation of the most recent commit to the
            list of index files (N in the segments_N file).
            </summary>
            <param name="files"> array of file names to check </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetLastCommitGeneration(Lucene.Net.Store.Directory)">
            <summary>
            Get the generation of the most recent commit to the
            index in this directory (N in the segments_N file).
            </summary>
            <param name="directory"> directory to search for the latest segments_N file </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetLastCommitSegmentsFileName(System.String[])">
            <summary>
            Get the filename of the segments_N file for the most
            recent commit in the list of index files.
            </summary>
            <param name="files"> array of file names to check </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetLastCommitSegmentsFileName(Lucene.Net.Store.Directory)">
            <summary>
            Get the filename of the segments_N file for the most
            recent commit to the index in this Directory.
            </summary>
            <param name="directory"> directory to search for the latest segments_N file </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetSegmentsFileName">
            <summary>
            Get the segments_N filename in use by this segment infos.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GenerationFromSegmentsFileName(System.String)">
            <summary>
            Parse the generation off the segments file name and
            return it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.WriteSegmentsGen(Lucene.Net.Store.Directory,System.Int64)">
            <summary>
            A utility for writing the <see cref="F:Lucene.Net.Index.IndexFileNames.SEGMENTS_GEN"/> file to a
            <see cref="T:Lucene.Net.Store.Directory"/>.
            <para/>
            <b>NOTE:</b> this is an internal utility which is kept public so that it's
            accessible by code from other packages. You should avoid calling this
            method unless you're absolutely sure what you're doing!
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetNextSegmentFileName">
            <summary>
            Get the next segments_N filename that will be written.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Read(Lucene.Net.Store.Directory,System.String)">
            <summary>
            Read a particular <paramref name="segmentFileName"/>.  Note that this may
            throw an <see cref="T:System.IO.IOException"/> if a commit is in process.
            </summary>
            <param name="directory"> directory containing the segments file </param>
            <param name="segmentFileName"> segment file to load </param>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Read(Lucene.Net.Store.Directory)">
            <summary>
            Find the latest commit (<c>segments_N file</c>) and
            load all <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Clone">
            <summary>
            Returns a copy of this instance, also copying each
            <see cref="T:Lucene.Net.Index.SegmentInfo"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.Version">
            <summary>
            Version number when this <see cref="T:Lucene.Net.Index.SegmentInfos"/> was generated.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.Generation">
            <summary>
            Returns current generation. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.LastGeneration">
            <summary>
            Returns last succesfully read or written generation. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.InfoStream">
            <summary>
            If non-null, information about retries when loading
            the segments file will be printed to this.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.defaultGenLookaheadCount">
            <summary>
            Advanced configuration of retry logic in loading
            segments_N file
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.DefaultGenLookaheadCount">
            <summary>
            Gets or Sets the <see cref="F:Lucene.Net.Index.SegmentInfos.defaultGenLookaheadCount"/>.
            <para/>
            Advanced: set how many times to try incrementing the
            gen when loading the segments file.  this only runs if
            the primary (listing directory) and secondary (opening
            segments.gen file) methods fail to find the segments
            file.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Message(System.String)">
            <summary>
            Prints the given message to the <see cref="P:Lucene.Net.Index.SegmentInfos.InfoStream"/>. Note, this method does not
            check for <c>null</c> <see cref="P:Lucene.Net.Index.SegmentInfos.InfoStream"/>. It assumes this check has been performed by the
            caller, which is recommended to avoid the (usually) expensive message
            creation.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentInfos.FindSegmentsFile">
            <summary>
            Utility class for executing code that needs to do
            something with the current segments file.  This is
            necessary with lock-less commits because from the time
            you locate the current segments file name, until you
            actually open it, read its contents, or check modified
            time, etc., it could have been deleted due to a writer
            commit finishing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.Run">
            <summary>
            Locate the most recent <c>segments</c> file and
            run <see cref="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.DoBody(System.String)"/> on it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.Run(Lucene.Net.Index.IndexCommit)">
            <summary>
            Run <see cref="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.DoBody(System.String)"/> on the provided commit. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.DoBody(System.String)">
            <summary>
            Subclass must implement this.  The assumption is an
            <see cref="T:System.IO.IOException"/> will be thrown if something goes wrong
            during the processing that could have been caused by
            a writer committing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.PrepareCommit(Lucene.Net.Store.Directory)">
            <summary>
            Call this to start a commit.  This writes the new
            segments file, but writes an invalid checksum at the
            end, so that it is not visible to readers.  Once this
            is called you must call <see cref="M:Lucene.Net.Index.SegmentInfos.FinishCommit(Lucene.Net.Store.Directory)"/> to complete
            the commit or <see cref="M:Lucene.Net.Index.SegmentInfos.RollbackCommit(Lucene.Net.Store.Directory)"/> to abort it.
            <para>
            Note: <see cref="M:Lucene.Net.Index.SegmentInfos.Changed"/> should be called prior to this
            method if changes have been made to this <see cref="T:Lucene.Net.Index.SegmentInfos"/> instance
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetFiles(Lucene.Net.Store.Directory,System.Boolean)">
            <summary>
            Returns all file names referenced by <see cref="T:Lucene.Net.Index.SegmentInfo"/>
            instances matching the provided <see cref="T:Lucene.Net.Store.Directory"/> (ie files
            associated with any "external" segments are skipped).
            The returned collection is recomputed on each
            invocation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Commit(Lucene.Net.Store.Directory)">
            <summary>
            Writes &amp; syncs to the Directory dir, taking care to
            remove the segments file on exception
            <para>
            Note: <see cref="M:Lucene.Net.Index.SegmentInfos.Changed"/> should be called prior to this
            method if changes have been made to this <see cref="T:Lucene.Net.Index.SegmentInfos"/> instance
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.ToString(Lucene.Net.Store.Directory)">
            <summary>
            Returns readable description of this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.UserData">
            <summary>
            Gets <see cref="F:Lucene.Net.Index.SegmentInfos.userData"/> saved with this commit.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.Commit"/>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Replace(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Replaces all segments in this instance, but keeps
            generation, version, counter so that future commits
            remain write once.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.TotalDocCount">
            <summary>
            Returns sum of all segment's docCounts.  Note that
            this does not include deletions
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Changed">
            <summary>
            Call this before committing if changes have been made to the
            segments.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.ApplyMergeChanges(Lucene.Net.Index.MergePolicy.OneMerge,System.Boolean)">
            <summary>
            applies all changes caused by committing a merge to this <see cref="T:Lucene.Net.Index.SegmentInfos"/> </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetEnumerator">
            <summary>
            Returns an <b>unmodifiable</b> <see cref="T:IEnumerator{SegmentCommitInfo}"/> of contained segments in order.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.AsList">
            <summary>
            Returns all contained segments as an <b>unmodifiable</b> <see cref="T:IList{SegmentCommitInfo}"/> view. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.Count">
            <summary>
            Returns number of <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Add(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Appends the provided <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.AddAll(System.Collections.Generic.IEnumerable{Lucene.Net.Index.SegmentCommitInfo})">
            <summary>
            Appends the provided <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Clear">
            <summary>
            Clear all <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Remove(Lucene.Net.Index.SegmentCommitInfo)">
             <summary>
             Remove the provided <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>.
            
             <para/><b>WARNING</b>: O(N) cost
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Remove(System.Int32)">
             <summary>
             Remove the <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/> at the
             provided index.
            
             <para/><b>WARNING</b>: O(N) cost
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Contains(Lucene.Net.Index.SegmentCommitInfo)">
             <summary>
             Return true if the provided 
             <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/> is contained.
            
             <para/><b>WARNING</b>: O(N) cost
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.IndexOf(Lucene.Net.Index.SegmentCommitInfo)">
             <summary>
             Returns index of the provided
             <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>.
            
             <para/><b>WARNING</b>: O(N) cost
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentMerger">
            <summary>
            The <see cref="T:Lucene.Net.Index.SegmentMerger"/> class combines two or more Segments, represented by an
            <see cref="T:Lucene.Net.Index.IndexReader"/>, into a single Segment.  Call the merge method to combine the
            segments.
            </summary>
            <seealso cref="M:Lucene.Net.Index.SegmentMerger.Merge"/>
        </member>
        <member name="P:Lucene.Net.Index.SegmentMerger.ShouldMerge">
            <summary>
            <c>True</c> if any merging should happen </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Merge">
            <summary>
            Merges the readers into the directory passed to the constructor </summary>
            <returns> The number of documents that were merged </returns>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeFields">
            
             <returns> The number of documents in all of the readers </returns>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeVectors">
            <summary>
            Merge the TermVectors from each of the segments into the new one. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="T:Lucene.Net.Index.SegmentReader">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexReader"/> implementation over a single segment.
            <para/>
            Instances pointing to the same segment (but with different deletes, etc)
            may share the same core data.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.#ctor(Lucene.Net.Index.SegmentCommitInfo,System.Int32,Lucene.Net.Store.IOContext)">
            <summary>
            Constructs a new <see cref="T:Lucene.Net.Index.SegmentReader"/> with a new core. </summary>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.#ctor(Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Index.SegmentReader)">
            <summary>
            Create new <see cref="T:Lucene.Net.Index.SegmentReader"/> sharing core from a previous
            <see cref="T:Lucene.Net.Index.SegmentReader"/> and loading new live docs from a new
            deletes file. Used by <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.#ctor(Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Index.SegmentReader,Lucene.Net.Util.IBits,System.Int32)">
            <summary>
            Create new <see cref="T:Lucene.Net.Index.SegmentReader"/> sharing core from a previous
            <see cref="T:Lucene.Net.Index.SegmentReader"/> and using the provided in-memory
            liveDocs.  Used by <see cref="T:Lucene.Net.Index.IndexWriter"/> to provide a new NRT
            reader
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.ReadFieldInfos(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Reads the most recent <see cref="T:Lucene.Net.Index.FieldInfos"/> of the given segment info.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.FieldsReader">
            <summary>
            Expert: retrieve thread-private 
            <see cref="T:Lucene.Net.Codecs.StoredFieldsReader"/>
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.TermVectorsReader">
            <summary>
            Expert: retrieve thread-private
            <see cref="T:Lucene.Net.Codecs.TermVectorsReader"/>
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.SegmentName">
            <summary>
            Return the name of the segment this reader is reading.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.SegmentInfo">
            <summary>
            Return the <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/> of the segment this reader is reading.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.Directory">
            <summary>
            Returns the directory this index resides in. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.TermInfosIndexDivisor">
            <summary>
            Returns term infos index divisor originally passed to
            <see cref="M:Lucene.Net.Index.SegmentReader.#ctor(Lucene.Net.Index.SegmentCommitInfo,System.Int32,Lucene.Net.Store.IOContext)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentReader.ICoreDisposedListener">
            <summary>
            Called when the shared core for this <see cref="T:Lucene.Net.Index.SegmentReader"/>
            is disposed.
            <para/>
            This listener is called only once all <see cref="T:Lucene.Net.Index.SegmentReader"/>s
            sharing the same core are disposed.  At this point it
            is safe for apps to evict this reader from any caches
            keyed on <see cref="P:Lucene.Net.Index.SegmentReader.CoreCacheKey"/>.  This is the same
            interface that <see cref="T:Lucene.Net.Search.IFieldCache"/> uses, internally,
            to evict entries.
            <para/>
            NOTE: This was CoreClosedListener in Lucene.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.ICoreDisposedListener.OnDispose(System.Object)">
            <summary>
            Invoked when the shared core of the original 
            <see cref="T:Lucene.Net.Index.SegmentReader"/> has disposed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.AddCoreDisposedListener(Lucene.Net.Index.SegmentReader.ICoreDisposedListener)">
            <summary>
            Expert: adds a <see cref="T:Lucene.Net.Index.SegmentReader.ICoreDisposedListener"/> to this reader's shared core </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.RemoveCoreDisposedListener(Lucene.Net.Index.SegmentReader.ICoreDisposedListener)">
            <summary>
            Expert: removes a <see cref="T:Lucene.Net.Index.SegmentReader.ICoreDisposedListener"/> from this reader's shared core </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.RamBytesUsed">
            <summary>
            Returns approximate RAM Bytes used </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentReadState">
            <summary>
            Holder class for common parameters used during read.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReadState.Directory">
            <summary>
            <see cref="T:Lucene.Net.Store.Directory"/> where this segment is read from. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReadState.SegmentInfo">
            <summary>
            <see cref="T:Lucene.Net.Index.SegmentInfo"/> describing this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReadState.FieldInfos">
            <summary>
            <see cref="T:Lucene.Net.Index.FieldInfos"/> describing all fields in this
            segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReadState.Context">
            <summary>
            <see cref="T:Lucene.Net.Store.IOContext"/> to pass to 
            <see cref="M:Lucene.Net.Store.Directory.OpenInput(System.String,Lucene.Net.Store.IOContext)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReadState.TermsIndexDivisor">
             <summary>
             The <c>termInfosIndexDivisor</c> to use, if
             appropriate (not all <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>s support
             it; in particular the current default does not).
            
             <para/>  NOTE: if this is &lt; 0, that means "defer terms index
             load until needed".  But if the codec must load the
             terms index on init (preflex is the only once currently
             that must do so), then it should negate this value to
             get the app's terms divisor
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReadState.SegmentSuffix">
            <summary>
            Unique suffix for any postings files read for this
            segment.  <see cref="T:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat"/> sets this for
            each of the postings formats it wraps.  If you create
            a new <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> then any files you
            write/read must be derived using this suffix (use
            <see cref="M:Lucene.Net.Index.IndexFileNames.SegmentFileName(System.String,System.String,System.String)"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReadState.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext,System.Int32)">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.SegmentReadState"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReadState.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext,System.Int32,System.String)">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.SegmentReadState"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReadState.#ctor(Lucene.Net.Index.SegmentReadState,System.String)">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.SegmentReadState"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentWriteState">
            <summary>
            Holder class for common parameters used during write.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.InfoStream">
            <summary>
            <see cref="T:Lucene.Net.Util.InfoStream"/> used for debugging messages. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.Directory">
            <summary>
            <see cref="T:Lucene.Net.Store.Directory"/> where this segment will be written
            to.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.SegmentInfo">
            <summary>
            <see cref="T:Lucene.Net.Index.SegmentInfo"/> describing this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.FieldInfos">
            <summary>
            <see cref="T:Lucene.Net.Index.FieldInfos"/> describing all fields in this
            segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.DelCountOnFlush">
            <summary>
            Number of deleted documents set while flushing the
            segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.SegUpdates">
            <summary>
            Deletes and updates to apply while we are flushing the segment. A <see cref="T:Lucene.Net.Index.Term"/> is
            enrolled in here if it was deleted/updated at one point, and it's mapped to
            the docIDUpto, meaning any docID &lt; docIDUpto containing this term should
            be deleted/updated.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.LiveDocs">
            <summary>
            <see cref="T:Lucene.Net.Util.IMutableBits"/> recording live documents; this is
            only set if there is one or more deleted documents.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.SegmentSuffix">
            <summary>
            Unique suffix for any postings files written for this
            segment.  <see cref="T:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat"/> sets this for
            each of the postings formats it wraps.  If you create
            a new <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> then any files you
            write/read must be derived using this suffix (use
            <see cref="M:Lucene.Net.Index.IndexFileNames.SegmentFileName(System.String,System.String,System.String)"/>).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.TermIndexInterval">
            <summary>
            Expert: The fraction of terms in the "dictionary" which should be stored
            in RAM.  Smaller values use more memory, but make searching slightly
            faster, while larger values use less memory and make searching slightly
            slower.  Searching is typically not dominated by dictionary lookup, so
            tweaking this is rarely useful.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.Context">
            <summary>
            <see cref="T:Lucene.Net.Store.IOContext"/> for all writes; you should pass this
            to <see cref="M:Lucene.Net.Store.Directory.CreateOutput(System.String,Lucene.Net.Store.IOContext)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentWriteState.#ctor(Lucene.Net.Util.InfoStream,Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,System.Int32,Lucene.Net.Index.BufferedUpdates,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentWriteState.#ctor(Lucene.Net.Util.InfoStream,Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,System.Int32,Lucene.Net.Index.BufferedUpdates,Lucene.Net.Store.IOContext,System.String)">
            <summary>
            Constructor which takes segment suffix.
            </summary>
            <seealso cref="M:Lucene.Net.Index.SegmentWriteState.#ctor(Lucene.Net.Util.InfoStream,Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,System.Int32,Lucene.Net.Index.BufferedUpdates,Lucene.Net.Store.IOContext)"/>
        </member>
        <member name="M:Lucene.Net.Index.SegmentWriteState.#ctor(Lucene.Net.Index.SegmentWriteState,System.String)">
            <summary>
            Create a shallow copy of <see cref="T:Lucene.Net.Index.SegmentWriteState"/> with a new segment suffix. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SerialMergeScheduler">
            <summary>
            A <see cref="T:Lucene.Net.Index.MergeScheduler"/> that simply does each merge
            sequentially, using the current thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SerialMergeScheduler.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SerialMergeScheduler.Merge(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergeTrigger,System.Boolean)">
            <summary>
            Just do the merges in sequence. We do this
            "synchronized" so that even if the application is using
            multiple threads, only one merge may run at a time.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SimpleMergedSegmentWarmer">
            <summary>
            A very simple merged segment warmer that just ensures
            data structures are initialized.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SimpleMergedSegmentWarmer.#ctor(Lucene.Net.Util.InfoStream)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.SimpleMergedSegmentWarmer"/> </summary>
            <param name="infoStream"> <see cref="T:Lucene.Net.Util.InfoStream"/> to log statistics about warming. </param>
        </member>
        <member name="T:Lucene.Net.Index.SingleTermsEnum">
            <summary>
            Subclass of <see cref="T:Lucene.Net.Index.FilteredTermsEnum"/> for enumerating a single term.
            <para/>
            For example, this can be used by <see cref="T:Lucene.Net.Search.MultiTermQuery"/>s
            that need only visit one term, but want to preserve
            <see cref="T:Lucene.Net.Search.MultiTermQuery"/> semantics such as <see cref="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SingleTermsEnum.#ctor(Lucene.Net.Index.TermsEnum,Lucene.Net.Util.BytesRef)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.SingleTermsEnum"/>.
            <para/>
            After calling the constructor the enumeration is already pointing to the term,
            if it exists.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SingletonSortedSetDocValues">
            <summary>
            Exposes multi-valued view over a single-valued instance.
            <para/>
            This can be used if you want to have one multi-valued implementation
            against e.g. <see cref="M:Lucene.Net.Search.IFieldCache.GetDocTermOrds(Lucene.Net.Index.AtomicReader,System.String)"/> that also works for single-valued
            fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SingletonSortedSetDocValues.#ctor(Lucene.Net.Index.SortedDocValues)">
            <summary>
            Creates a multi-valued view over the provided <see cref="T:Lucene.Net.Index.SortedDocValues"/> </summary>
        </member>
        <member name="P:Lucene.Net.Index.SingletonSortedSetDocValues.SortedDocValues">
            <summary>
            Return the wrapped <see cref="T:Lucene.Net.Index.SortedDocValues"/> </summary>
        </member>
        <member name="T:Lucene.Net.Index.SlowCompositeReaderWrapper">
             <summary>
             This class forces a composite reader (eg a 
             <see cref="T:Lucene.Net.Index.MultiReader"/> or <see cref="T:Lucene.Net.Index.DirectoryReader"/>) to emulate an
             atomic reader.  This requires implementing the postings
             APIs on-the-fly, using the static methods in 
             <see cref="T:Lucene.Net.Index.MultiFields"/>, <see cref="T:Lucene.Net.Index.MultiDocValues"/>, by stepping through
             the sub-readers to merge fields/terms, appending docs, etc.
            
             <para/><b>NOTE</b>: This class almost always results in a
             performance hit.  If this is important to your use case,
             you'll get better performance by gathering the sub readers using
             <see cref="P:Lucene.Net.Index.IndexReader.Context"/> to get the
             atomic leaves and then operate per-AtomicReader,
             instead of using this class.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SlowCompositeReaderWrapper.Wrap(Lucene.Net.Index.IndexReader)">
            <summary>
            This method is sugar for getting an <see cref="T:Lucene.Net.Index.AtomicReader"/> from
            an <see cref="T:Lucene.Net.Index.IndexReader"/> of any kind. If the reader is already atomic,
            it is returned unchanged, otherwise wrapped by this class.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SnapshotDeletionPolicy">
             <summary>
             An <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> that wraps any other
             <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> and adds the ability to hold and later release
             snapshots of an index. While a snapshot is held, the <see cref="T:Lucene.Net.Index.IndexWriter"/> will
             not remove any files associated with it even if the index is otherwise being
             actively, arbitrarily changed. Because we wrap another arbitrary
             <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/>, this gives you the freedom to continue using
             whatever <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> you would normally want to use with your
             index.
            
             <para/>
             This class maintains all snapshots in-memory, and so the information is not
             persisted and not protected against system failures. If persistence is
             important, you can use <see cref="T:Lucene.Net.Index.PersistentSnapshotDeletionPolicy"/>.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.m_refCounts">
            <summary>
            Records how many snapshots are held against each
            commit generation
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.m_indexCommits">
            <summary>
            Used to map gen to <see cref="T:Lucene.Net.Index.IndexCommit"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.primary">
            <summary>
            Wrapped <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.m_lastCommit">
            <summary>
            Most recently committed <see cref="T:Lucene.Net.Index.IndexCommit"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.initCalled">
            <summary>
            Used to detect misuse </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.#ctor(Lucene.Net.Index.IndexDeletionPolicy)">
            <summary>
            Sole constructor, taking the incoming 
            <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> to wrap.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.Release(Lucene.Net.Index.IndexCommit)">
            <summary>
            Release a snapshotted commit.
            </summary>
            <param name="commit">
                     the commit previously returned by <see cref="M:Lucene.Net.Index.SnapshotDeletionPolicy.Snapshot"/> </param>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.ReleaseGen(System.Int64)">
            <summary>
            Release a snapshot by generation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.IncRef(Lucene.Net.Index.IndexCommit)">
            <summary>
            Increments the refCount for this <see cref="T:Lucene.Net.Index.IndexCommit"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.Snapshot">
             <summary>
             Snapshots the last commit and returns it. Once a commit is 'snapshotted,' it is protected
             from deletion (as long as this <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> is used). The
             snapshot can be removed by calling <see cref="M:Lucene.Net.Index.SnapshotDeletionPolicy.Release(Lucene.Net.Index.IndexCommit)"/> followed
             by a call to <see cref="M:Lucene.Net.Index.IndexWriter.DeleteUnusedFiles"/>.
            
             <para/>
             <b>NOTE:</b> while the snapshot is held, the files it references will not
             be deleted, which will consume additional disk space in your index. If you
             take a snapshot at a particularly bad time (say just before you call
             <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>) then in the worst case this could consume an extra 1X of your
             total index size, until you release the snapshot.
             </summary>
             <exception cref="T:System.InvalidOperationException">
                       if this index does not have any commits yet </exception>
             <returns> the <see cref="T:Lucene.Net.Index.IndexCommit"/> that was snapshotted. </returns>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.GetSnapshots">
            <summary>
            Returns all <see cref="T:Lucene.Net.Index.IndexCommit"/>s held by at least one snapshot. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCount">
            <summary>
            Returns the total number of snapshots currently held. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.GetIndexCommit(System.Int64)">
            <summary>
            Retrieve an <see cref="T:Lucene.Net.Index.IndexCommit"/> from its generation;
            returns <c>null</c> if this <see cref="T:Lucene.Net.Index.IndexCommit"/> is not currently
            snapshotted
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.WrapCommits``1(System.Collections.Generic.IList{``0})">
            <summary>
            Wraps each <see cref="T:Lucene.Net.Index.IndexCommit"/> as a 
            <see cref="T:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCommitPoint"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCommitPoint">
            <summary>
            Wraps a provided <see cref="T:Lucene.Net.Index.IndexCommit"/> and prevents it
            from being deleted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCommitPoint.m_cp">
            <summary>
            The <see cref="T:Lucene.Net.Index.IndexCommit"/> we are preventing from deletion. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCommitPoint.#ctor(Lucene.Net.Index.SnapshotDeletionPolicy,Lucene.Net.Index.IndexCommit)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCommitPoint"/> wrapping the provided
            <see cref="T:Lucene.Net.Index.IndexCommit"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedDocValues">
            <summary>
            A per-document <see cref="T:byte[]"/> with presorted values.
            <para/>
            Per-Document values in a <see cref="T:Lucene.Net.Index.SortedDocValues"/> are deduplicated, dereferenced,
            and sorted into a dictionary of unique values. A pointer to the
            dictionary value (ordinal) can be retrieved for each document. Ordinals
            are dense and in increasing sorted order.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValues.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValues.GetOrd(System.Int32)">
            <summary>
            Returns the ordinal for the specified docID. </summary>
            <param name="docID"> document ID to lookup </param>
            <returns> ordinal for the document: this is dense, starts at 0, then
                    increments by 1 for the next value in sorted order. Note that
                    missing values are indicated by -1. </returns>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValues.LookupOrd(System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Retrieves the value for the specified ordinal. </summary>
            <param name="ord"> ordinal to lookup (must be &gt;= 0 and &lt; <see cref="P:Lucene.Net.Index.SortedDocValues.ValueCount"/>) </param>
            <param name="result"> will be populated with the ordinal's value </param>
            <seealso cref="M:Lucene.Net.Index.SortedDocValues.GetOrd(System.Int32)"/>
        </member>
        <member name="P:Lucene.Net.Index.SortedDocValues.ValueCount">
            <summary>
            Returns the number of unique values. </summary>
            <returns> Number of unique values in this <see cref="T:Lucene.Net.Index.SortedDocValues"/>. This is
                    also equivalent to one plus the maximum ordinal. </returns>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValues.LookupTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            If <paramref name="key"/> exists, returns its ordinal, else
            returns <c>-insertionPoint-1</c>, like 
            <see cref="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)"/>
            </summary>
            <param name="key"> Key to look up</param>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValues.GetTermsEnum">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.TermsEnum"/> over the values.
            The enum supports <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/> and <see cref="M:Lucene.Net.Index.TermsEnum.SeekExact(System.Int64)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedDocValuesTermsEnum">
            <summary>
            Implements a <see cref="T:Lucene.Net.Index.TermsEnum"/> wrapping a provided
            <see cref="T:Lucene.Net.Index.SortedDocValues"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValuesTermsEnum.#ctor(Lucene.Net.Index.SortedDocValues)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.TermsEnum"/> over the provided values </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedDocValuesWriter">
            <summary>
            Buffers up pending <see cref="T:byte[]"/> per doc, deref and sorting via
            int ord, then flushes when segment flushes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedSetDocValues">
            <summary>
            A per-document set of presorted <see cref="T:byte[]"/> values.
            <para/>
            Per-Document values in a <see cref="T:Lucene.Net.Index.SortedDocValues"/> are deduplicated, dereferenced,
            and sorted into a dictionary of unique values. A pointer to the
            dictionary value (ordinal) can be retrieved for each document. Ordinals
            are dense and in increasing sorted order.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SortedSetDocValues.NO_MORE_ORDS">
            <summary>
            When returned by <see cref="M:Lucene.Net.Index.SortedSetDocValues.NextOrd"/> it means there are no more
            ordinals for the document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.NextOrd">
            <summary>
            Returns the next ordinal for the current document (previously
            set by <see cref="M:Lucene.Net.Index.SortedSetDocValues.SetDocument(System.Int32)"/>. </summary>
            <returns> Next ordinal for the document, or <see cref="F:Lucene.Net.Index.SortedSetDocValues.NO_MORE_ORDS"/>.
                    ordinals are dense, start at 0, then increment by 1 for
                    the next value in sorted order.  </returns>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.SetDocument(System.Int32)">
            <summary>
            Sets iteration to the specified docID </summary>
            <param name="docID"> document ID  </param>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.LookupOrd(System.Int64,Lucene.Net.Util.BytesRef)">
            <summary>
            Retrieves the value for the specified ordinal. </summary>
            <param name="ord"> ordinal to lookup </param>
            <param name="result"> will be populated with the ordinal's value </param>
            <seealso cref="M:Lucene.Net.Index.SortedSetDocValues.NextOrd"/>
        </member>
        <member name="P:Lucene.Net.Index.SortedSetDocValues.ValueCount">
            <summary>
            Returns the number of unique values. </summary>
            <returns> Number of unique values in this <see cref="T:Lucene.Net.Index.SortedDocValues"/>. This is
                    also equivalent to one plus the maximum ordinal. </returns>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.LookupTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            If <paramref name="key"/> exists, returns its ordinal, else
            returns <c>-insertionPoint-1</c>, like
            <see cref="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)"/>.
            </summary>
            <param name="key"> Key to look up</param>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.GetTermsEnum">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.TermsEnum"/> over the values.
            The enum supports <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/> and <see cref="M:Lucene.Net.Index.TermsEnum.SeekExact(System.Int64)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedSetDocValuesTermsEnum">
            <summary>
            Implements a <see cref="T:Lucene.Net.Index.TermsEnum"/> wrapping a provided
            <see cref="T:Lucene.Net.Index.SortedSetDocValues"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValuesTermsEnum.#ctor(Lucene.Net.Index.SortedSetDocValues)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.TermsEnum"/> over the provided values </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedSetDocValuesWriter">
            <summary>
            Buffers up pending <see cref="T:byte[]"/>s per doc, deref and sorting via
            int ord, then flushes when segment flushes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.StandardDirectoryReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.AtomicReader[],Lucene.Net.Index.IndexWriter,Lucene.Net.Index.SegmentInfos,System.Int32,System.Boolean)">
            <summary>
            called only from static <c>Open()</c> methods </summary>
        </member>
        <member name="M:Lucene.Net.Index.StandardDirectoryReader.Open(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexCommit,System.Int32)">
            <summary>
            called from <c>DirectoryReader.Open(...)</c> methods </summary>
        </member>
        <member name="M:Lucene.Net.Index.StandardDirectoryReader.Open(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.SegmentInfos,System.Boolean)">
            <summary>
            Used by near real-time search </summary>
        </member>
        <member name="M:Lucene.Net.Index.StandardDirectoryReader.Open(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfos,System.Collections.Generic.IList{Lucene.Net.Index.IndexReader},System.Int32)">
            <summary>
            This constructor is only used for <see cref="M:Lucene.Net.Index.StandardDirectoryReader.DoOpenIfChanged(Lucene.Net.Index.SegmentInfos)"/> </summary>
        </member>
        <member name="T:Lucene.Net.Index.StoredFieldsProcessor">
            <summary>
            This is a <see cref="T:Lucene.Net.Index.StoredFieldsConsumer"/> that writes stored fields. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldsProcessor.Fill(System.Int32)">
            <summary>
            Fills in any hole in the docIDs </summary>
        </member>
        <member name="T:Lucene.Net.Index.StoredFieldVisitor">
             <summary>
             Expert: Provides a low-level means of accessing the stored field
             values in an index.  See <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32,Lucene.Net.Index.StoredFieldVisitor)"/>.
            
             <para/><b>NOTE</b>: a <see cref="T:Lucene.Net.Index.StoredFieldVisitor"/> implementation
             should not try to load or visit other stored documents in
             the same reader because the implementation of stored
             fields for most codecs is not reeentrant and you will see
             strange exceptions as a result.
            
             <para/>See <see cref="T:Lucene.Net.Documents.DocumentStoredFieldVisitor"/>, which is a
             <see cref="T:Lucene.Net.Index.StoredFieldVisitor"/> that builds the
             <see cref="T:Lucene.Net.Documents.Document"/> containing all stored fields.  This is
             used by <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/>.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.BinaryField(Lucene.Net.Index.FieldInfo,System.Byte[])">
            <summary>
            Process a binary field. </summary>
            <param name="value"> newly allocated byte array with the binary contents.  </param>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.StringField(Lucene.Net.Index.FieldInfo,System.String)">
            <summary>
            Process a <see cref="T:System.String"/> field </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.Int32Field(Lucene.Net.Index.FieldInfo,System.Int32)">
            <summary>
            Process a <see cref="T:System.Int32"/> numeric field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.Int64Field(Lucene.Net.Index.FieldInfo,System.Int64)">
            <summary>
            Process a <see cref="T:System.Int64"/> numeric field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.SingleField(Lucene.Net.Index.FieldInfo,System.Single)">
            <summary>
            Process a <see cref="T:System.Single"/> numeric field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.DoubleField(Lucene.Net.Index.FieldInfo,System.Double)">
            <summary>
            Process a <see cref="T:System.Double"/> numeric field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.NeedsField(Lucene.Net.Index.FieldInfo)">
            <summary>
            Hook before processing a field.
            Before a field is processed, this method is invoked so that
            subclasses can return a <see cref="T:Lucene.Net.Index.StoredFieldVisitor.Status"/> representing whether
            they need that particular field or not, or to stop processing
            entirely.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.StoredFieldVisitor.Status">
            <summary>
            Enumeration of possible return values for <see cref="M:Lucene.Net.Index.StoredFieldVisitor.NeedsField(Lucene.Net.Index.FieldInfo)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.StoredFieldVisitor.Status.YES">
            <summary>
            YES: the field should be visited. </summary>
        </member>
        <member name="F:Lucene.Net.Index.StoredFieldVisitor.Status.NO">
            <summary>
            NO: don't visit this field, but continue processing fields for this document. </summary>
        </member>
        <member name="F:Lucene.Net.Index.StoredFieldVisitor.Status.STOP">
            <summary>
            STOP: don't visit this field and stop processing any other fields for this document. </summary>
        </member>
        <member name="T:Lucene.Net.Index.Term">
            <summary>
            A <see cref="T:Lucene.Net.Index.Term"/> represents a word from text.  This is the unit of search.  It is
            composed of two elements, the text of the word, as a string, and the name of
            the field that the text occurred in.
            <para/>
            Note that terms may represent more than words from text fields, but also
            things like dates, email addresses, urls, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.#ctor(System.String,Lucene.Net.Util.BytesRef)">
             <summary>
             Constructs a <see cref="T:Lucene.Net.Index.Term"/> with the given field and bytes.
             <para/>Note that a null field or null bytes value results in undefined
             behavior for most Lucene APIs that accept a Term parameter.
            
             <para/>WARNING: the provided <see cref="T:Lucene.Net.Util.BytesRef"/> is not copied, but used directly.
             Therefore the bytes should not be modified after construction, for
             example, you should clone a copy by <see cref="M:Lucene.Net.Util.BytesRef.DeepCopyOf(Lucene.Net.Util.BytesRef)"/>
             rather than pass reused bytes from a <see cref="T:Lucene.Net.Index.TermsEnum"/>.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.#ctor(System.String,System.String)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Index.Term"/> with the given field and text.
            <para/>Note that a <c>null</c> field or null text value results in undefined
            behavior for most Lucene APIs that accept a <see cref="T:Lucene.Net.Index.Term"/> parameter.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.#ctor(System.String)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Index.Term"/> with the given field and empty text.
            this serves two purposes: 1) reuse of a <see cref="T:Lucene.Net.Index.Term"/> with the same field.
            2) pattern for a query.
            </summary>
            <param name="fld"> field's name </param>
        </member>
        <member name="P:Lucene.Net.Index.Term.Field">
            <summary>
            Returns the field of this term.  The field indicates
            the part of a document which this term came from.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Text">
            <summary>
            Returns the text of this term.  In the case of words, this is simply the
            text of the word.  In the case of dates and other types, this is an
            encoding of the object as a string.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.ToString(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns human-readable form of the term text. If the term is not unicode,
            the raw bytes will be printed instead.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Term.Bytes">
            <summary>
            Returns the bytes of this term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.CompareTo(Lucene.Net.Index.Term)">
            <summary>
            Compares two terms, returning a negative integer if this
            term belongs before the argument, zero if this term is equal to the
            argument, and a positive integer if this term belongs after the argument.
            <para/>
            The ordering of terms is first by field, then by text.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Set(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Resets the field and text of a <see cref="T:Lucene.Net.Index.Term"/>.
            <para/>WARNING: the provided <see cref="T:Lucene.Net.Util.BytesRef"/> is not copied, but used directly.
            Therefore the bytes should not be modified after construction, for
            example, you should clone a copy rather than pass reused bytes from
            a TermsEnum.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermContext">
            <summary>
            Maintains a <see cref="T:Lucene.Net.Index.IndexReader"/> <see cref="T:Lucene.Net.Index.TermState"/> view over
            <see cref="T:Lucene.Net.Index.IndexReader"/> instances containing a single term. The
            <see cref="T:Lucene.Net.Index.TermContext"/> doesn't track if the given <see cref="T:Lucene.Net.Index.TermState"/>
            objects are valid, neither if the <see cref="T:Lucene.Net.Index.TermState"/> instances refer to the
            same terms in the associated readers.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TermContext.TopReaderContext">
            <summary>
            Holds the <see cref="T:Lucene.Net.Index.IndexReaderContext"/> of the top-level
            <see cref="T:Lucene.Net.Index.IndexReader"/>, used internally only for
            asserting.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.#ctor(Lucene.Net.Index.IndexReaderContext)">
            <summary>
            Creates an empty <see cref="T:Lucene.Net.Index.TermContext"/> from a <see cref="T:Lucene.Net.Index.IndexReaderContext"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.#ctor(Lucene.Net.Index.IndexReaderContext,Lucene.Net.Index.TermState,System.Int32,System.Int32,System.Int64)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Index.TermContext"/> with an initial <see cref="T:Lucene.Net.Index.TermState"/>,
            <see cref="T:Lucene.Net.Index.IndexReader"/> pair.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.Build(Lucene.Net.Index.IndexReaderContext,Lucene.Net.Index.Term)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Index.TermContext"/> from a top-level <see cref="T:Lucene.Net.Index.IndexReaderContext"/> and the
            given <see cref="T:Lucene.Net.Index.Term"/>. this method will lookup the given term in all context's leaf readers
            and register each of the readers containing the term in the returned <see cref="T:Lucene.Net.Index.TermContext"/>
            using the leaf reader's ordinal.
            <para/>
            Note: the given context must be a top-level context.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.Clear">
            <summary>
            Clears the <see cref="T:Lucene.Net.Index.TermContext"/> internal state and removes all
            registered <see cref="T:Lucene.Net.Index.TermState"/>s
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.Register(Lucene.Net.Index.TermState,System.Int32,System.Int32,System.Int64)">
            <summary>
            Registers and associates a <see cref="T:Lucene.Net.Index.TermState"/> with an leaf ordinal. The leaf ordinal
            should be derived from a <see cref="T:Lucene.Net.Index.IndexReaderContext"/>'s leaf ord.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.Get(System.Int32)">
            <summary>
            Returns the <see cref="T:Lucene.Net.Index.TermState"/> for an leaf ordinal or <c>null</c> if no
            <see cref="T:Lucene.Net.Index.TermState"/> for the ordinal was registered.
            </summary>
            <param name="ord">
                     The readers leaf ordinal to get the <see cref="T:Lucene.Net.Index.TermState"/> for. </param>
            <returns> The <see cref="T:Lucene.Net.Index.TermState"/> for the given readers ord or <c>null</c> if no
                    <see cref="T:Lucene.Net.Index.TermState"/> for the reader was registered </returns>
        </member>
        <member name="P:Lucene.Net.Index.TermContext.TotalTermFreq">
            <summary>
             Returns the accumulated term frequency of all <see cref="T:Lucene.Net.Index.TermState"/>
                    instances passed to <see cref="M:Lucene.Net.Index.TermContext.Register(Lucene.Net.Index.TermState,System.Int32,System.Int32,System.Int64)"/>. </summary>
            <returns> the accumulated term frequency of all <see cref="T:Lucene.Net.Index.TermState"/>
                    instances passed to <see cref="M:Lucene.Net.Index.TermContext.Register(Lucene.Net.Index.TermState,System.Int32,System.Int32,System.Int64)"/>. </returns>
        </member>
        <member name="P:Lucene.Net.Index.TermContext.DocFreq">
            <summary>
            expert: only available for queries that want to lie about docfreq
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.Terms">
            <summary>
            Access to the terms in a specific field.  See <see cref="T:Lucene.Net.Index.Fields"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.GetIterator(Lucene.Net.Index.TermsEnum)">
            <summary>
            Returns an iterator that will step through all
            terms. This method will not return <c>null</c>.  If you have
            a previous <see cref="T:Lucene.Net.Index.TermsEnum"/>, for example from a different
            field, you can pass it for possible reuse if the
            implementation can do so.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.Intersect(Lucene.Net.Util.Automaton.CompiledAutomaton,Lucene.Net.Util.BytesRef)">
             <summary>
             Returns a <see cref="T:Lucene.Net.Index.TermsEnum"/> that iterates over all terms that
             are accepted by the provided 
             <see cref="T:Lucene.Net.Util.Automaton.CompiledAutomaton"/>.  If the <paramref name="startTerm"/> is
             provided then the returned enum will only accept terms
             &gt; <paramref name="startTerm"/>, but you still must call
             <see cref="M:Lucene.Net.Index.TermsEnum.Next"/> first to get to the first term.  Note that the
             provided <paramref name="startTerm"/> must be accepted by
             the automaton.
            
             <para><b>NOTE</b>: the returned <see cref="T:Lucene.Net.Index.TermsEnum"/> cannot
             seek</para>.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.Comparer">
            <summary>
            Return the <see cref="T:IComparer{BytesRef}"/> used to sort terms
            provided by the iterator.  This method may return <c>null</c>
            if there are no terms.  This method may be invoked
            many times; it's best to cache a single instance &amp;
            reuse it.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.Count">
            <summary>
            Returns the number of terms for this field, or -1 if this
            measure isn't stored by the codec. Note that, just like
            other term measures, this measure does not take deleted
            documents into account.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.SumTotalTermFreq">
            <summary>
            Returns the sum of <see cref="P:Lucene.Net.Index.TermsEnum.TotalTermFreq"/> for
            all terms in this field, or -1 if this measure isn't
            stored by the codec (or if this fields omits term freq
            and positions).  Note that, just like other term
            measures, this measure does not take deleted documents
            into account.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.SumDocFreq">
            <summary>
            Returns the sum of <see cref="P:Lucene.Net.Index.TermsEnum.DocFreq"/> for
            all terms in this field, or -1 if this measure isn't
            stored by the codec.  Note that, just like other term
            measures, this measure does not take deleted documents
            into account.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.DocCount">
            <summary>
            Returns the number of documents that have at least one
            term for this field, or -1 if this measure isn't
            stored by the codec.  Note that, just like other term
            measures, this measure does not take deleted documents
            into account.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.HasFreqs">
            <summary>
            Returns true if documents in this field store
            per-document term frequency (<see cref="P:Lucene.Net.Index.DocsEnum.Freq"/>).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.HasOffsets">
            <summary>
            Returns <c>true</c> if documents in this field store offsets. </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.HasPositions">
            <summary>
            Returns <c>true</c> if documents in this field store positions. </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.HasPayloads">
            <summary>
            Returns <c>true</c> if documents in this field store payloads. </summary>
        </member>
        <member name="F:Lucene.Net.Index.Terms.EMPTY_ARRAY">
            <summary>
            Zero-length array of <see cref="T:Lucene.Net.Index.Terms"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermsEnum">
             <summary>
             Iterator to seek (<see cref="M:Lucene.Net.Index.TermsEnum.SeekCeil(Lucene.Net.Util.BytesRef)"/>, 
             <see cref="M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef)"/>) or step through 
             (<see cref="M:Lucene.Net.Index.TermsEnum.Next"/> terms to obtain frequency information 
             (<see cref="P:Lucene.Net.Index.TermsEnum.DocFreq"/>), <see cref="T:Lucene.Net.Index.DocsEnum"/> or 
             <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> for the current term 
             (<see cref="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum)"/>).
            
             <para/>Term enumerations are always ordered by
             <see cref="P:Lucene.Net.Index.TermsEnum.Comparer"/>.  Each term in the enumeration is
             greater than the one before it.
            
             <para/>The <see cref="T:Lucene.Net.Index.TermsEnum"/> is unpositioned when you first obtain it
             and you must first successfully call <see cref="M:Lucene.Net.Index.TermsEnum.Next"/> or one
             of the <c>Seek</c> methods.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TermsEnum.Attributes">
            <summary>
            Returns the related attributes. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermsEnum.SeekStatus">
            <summary>
            Represents returned result from <see cref="M:Lucene.Net.Index.TermsEnum.SeekCeil(Lucene.Net.Util.BytesRef)"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermsEnum.SeekStatus.END">
            <summary>
            The term was not found, and the end of iteration was hit. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermsEnum.SeekStatus.FOUND">
            <summary>
            The precise term was found. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermsEnum.SeekStatus.NOT_FOUND">
            <summary>
            A different term was found after the requested term </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef)">
            <summary>
            Attempts to seek to the exact term, returning
            <c>true</c> if the term is found.  If this returns <c>false</c>, the
            enum is unpositioned.  For some codecs, <see cref="M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef)"/> may
            be substantially faster than <see cref="M:Lucene.Net.Index.TermsEnum.SeekCeil(Lucene.Net.Util.BytesRef)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.SeekCeil(Lucene.Net.Util.BytesRef)">
            <summary>
            Seeks to the specified term, if it exists, or to the
            next (ceiling) term.  Returns <see cref="T:Lucene.Net.Index.TermsEnum.SeekStatus"/> to
            indicate whether exact term was found, a different
            term was found, or EOF was hit.  The target term may
            be before or after the current term.  If this returns
            <see cref="F:Lucene.Net.Index.TermsEnum.SeekStatus.END"/>, the enum is unpositioned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.SeekExact(System.Int64)">
            <summary>
            Seeks to the specified term by ordinal (position) as
            previously returned by <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>. The target <paramref name="ord"/>
            may be before or after the current ord, and must be
            within bounds.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef,Lucene.Net.Index.TermState)">
            <summary>
            Expert: Seeks a specific position by <see cref="T:Lucene.Net.Index.TermState"/> previously obtained
            from <see cref="M:Lucene.Net.Index.TermsEnum.GetTermState"/>. Callers should maintain the <see cref="T:Lucene.Net.Index.TermState"/> to
            use this method. Low-level implementations may position the <see cref="T:Lucene.Net.Index.TermsEnum"/>
            without re-seeking the term dictionary.
            <para/>
            Seeking by <see cref="T:Lucene.Net.Index.TermState"/> should only be used iff the state was obtained
            from the same <see cref="T:Lucene.Net.Index.TermsEnum"/> instance.
            <para/>
            NOTE: Using this method with an incompatible <see cref="T:Lucene.Net.Index.TermState"/> might leave
            this <see cref="T:Lucene.Net.Index.TermsEnum"/> in undefined state. On a segment level
            <see cref="T:Lucene.Net.Index.TermState"/> instances are compatible only iff the source and the
            target <see cref="T:Lucene.Net.Index.TermsEnum"/> operate on the same field. If operating on segment
            level, TermState instances must not be used across segments.
            <para/>
            NOTE: A seek by <see cref="T:Lucene.Net.Index.TermState"/> might not restore the
            <see cref="T:Lucene.Net.Util.AttributeSource"/>'s state. <see cref="T:Lucene.Net.Util.AttributeSource"/> states must be
            maintained separately if this method is used. </summary>
            <param name="term"> the term the <see cref="T:Lucene.Net.Index.TermState"/> corresponds to </param>
            <param name="state"> the <see cref="T:Lucene.Net.Index.TermState"/> </param>
        </member>
        <member name="P:Lucene.Net.Index.TermsEnum.Term">
            <summary>
            Returns current term. Do not call this when the enum
            is unpositioned.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TermsEnum.Ord">
            <summary>
            Returns ordinal position for current term.  This is an
            optional property (the codec may throw <see cref="T:System.NotSupportedException"/>.
            Do not call this when the enum is unpositioned.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TermsEnum.DocFreq">
            <summary>
            Returns the number of documents containing the current
            term.  Do not call this when the enum is unpositioned.
            </summary>
            <seealso cref="F:Lucene.Net.Index.TermsEnum.SeekStatus.END"/>
        </member>
        <member name="P:Lucene.Net.Index.TermsEnum.TotalTermFreq">
            <summary>
            Returns the total number of occurrences of this term
            across all documents (the sum of the Freq for each
            doc that has this term).  This will be -1 if the
            codec doesn't support this measure.  Note that, like
            other term measures, this measure does not take
            deleted documents into account.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum)">
            <summary>
            Get <see cref="T:Lucene.Net.Index.DocsEnum"/> for the current term. Do not
            call this when the enum is unpositioned. This method
            will not return <c>null</c>.
            </summary>
            <param name="liveDocs"> Unset bits are documents that should not
            be returned </param>
            <param name="reuse"> Pass a prior <see cref="T:Lucene.Net.Index.DocsEnum"/> for possible reuse </param>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum,Lucene.Net.Index.DocsFlags)">
            <summary>
            Get <see cref="T:Lucene.Net.Index.DocsEnum"/> for the current term, with
            control over whether freqs are required. Do not
            call this when the enum is unpositioned. This method
            will not return <c>null</c>.
            </summary>
            <param name="liveDocs"> Unset bits are documents that should not
            be returned </param>
            <param name="reuse"> Pass a prior DocsEnum for possible reuse </param>
            <param name="flags"> Specifies which optional per-document values
                   you require; <see cref="T:Lucene.Net.Index.DocsFlags"/></param>
            <seealso cref="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum)"/>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum)">
            <summary>
            Get <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> for the current term.
            Do not call this when the enum is unpositioned.  This
            method will return <c>null</c> if positions were not
            indexed.
            </summary>
            <param name="liveDocs"> Unset bits are documents that should not
            be returned </param>
            <param name="reuse"> Pass a prior DocsAndPositionsEnum for possible reuse </param>
            <seealso cref="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum,Lucene.Net.Index.DocsAndPositionsFlags)"/>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum,Lucene.Net.Index.DocsAndPositionsFlags)">
            <summary>
            Get <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> for the current term,
            with control over whether offsets and payloads are
            required.  Some codecs may be able to optimize their
            implementation when offsets and/or payloads are not required.
            Do not call this when the enum is unpositioned. This
            will return <c>null</c> if positions were not indexed.
            </summary>
            <param name="liveDocs"> Unset bits are documents that should not
            be returned </param>
            <param name="reuse"> Pass a prior DocsAndPositionsEnum for possible reuse </param>
            <param name="flags"> Specifies which optional per-position values you
                    require; see <see cref="T:Lucene.Net.Index.DocsAndPositionsFlags"/>. </param>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.GetTermState">
            <summary>
            Expert: Returns the <see cref="T:Lucene.Net.Index.TermsEnum"/>s internal state to position the <see cref="T:Lucene.Net.Index.TermsEnum"/>
            without re-seeking the term dictionary.
            <para/>
            NOTE: A seek by <see cref="M:Lucene.Net.Index.TermsEnum.GetTermState"/> might not capture the
            <see cref="T:Lucene.Net.Util.AttributeSource"/>'s state. Callers must maintain the
            <see cref="T:Lucene.Net.Util.AttributeSource"/> states separately
            </summary>
            <seealso cref="T:Lucene.Net.Index.TermState"/>
            <seealso cref="M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef,Lucene.Net.Index.TermState)"/>
        </member>
        <member name="F:Lucene.Net.Index.TermsEnum.EMPTY">
            <summary>
            An empty <see cref="T:Lucene.Net.Index.TermsEnum"/> for quickly returning an empty instance e.g.
            in <see cref="T:Lucene.Net.Search.MultiTermQuery"/>
            <para/><em>Please note:</em> this enum should be unmodifiable,
            but it is currently possible to add Attributes to it.
            This should not be a problem, as the enum is always empty and
            the existence of unused Attributes does not matter.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermsHash">
            <summary>
            This class implements <see cref="T:Lucene.Net.Index.InvertedDocConsumer"/>, which
            is passed each token produced by the analyzer on each
            field.  It stores these tokens in a hash table, and
            allocates separate byte streams per token.  Consumers of
            this class, eg <see cref="T:Lucene.Net.Index.FreqProxTermsWriter"/> and 
            <see cref="T:Lucene.Net.Index.TermVectorsConsumer"/>, write their own byte streams
            under each term.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermsHashConsumerPerField">
            <summary>
            Implement this class to plug into the <see cref="T:Lucene.Net.Index.TermsHash"/>
            processor, which inverts &amp; stores <see cref="T:Lucene.Net.Analysis.Token"/>s into a hash
            table and provides an API for writing bytes into
            multiple streams for each unique <see cref="T:Lucene.Net.Analysis.Token"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsHashPerField.SortPostings(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})">
            <summary>
            Collapse the hash table &amp; sort in-place. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsHashPerField.Add(System.Int32)">
            <summary>
            Secondary entry point (for 2nd &amp; subsequent <see cref="T:Lucene.Net.Index.TermsHash"/>),
            because token text has already been "interned" into
            <paramref name="textStart"/>, so we hash by <paramref name="textStart"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsHashPerField.WriteVInt32(System.Int32,System.Int32)">
            <summary>
            NOTE: This was writeVInt() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermState">
            <summary>
            Encapsulates all required internal state to position the associated
            <see cref="T:Lucene.Net.Index.TermsEnum"/> without re-seeking.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef,Lucene.Net.Index.TermState)"/>
            <seealso cref="M:Lucene.Net.Index.TermsEnum.GetTermState"/>
        </member>
        <member name="M:Lucene.Net.Index.TermState.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermState.CopyFrom(Lucene.Net.Index.TermState)">
            <summary>
            Copies the content of the given <see cref="T:Lucene.Net.Index.TermState"/> to this instance
            </summary>
            <param name="other">
                     the <see cref="T:Lucene.Net.Index.TermState"/> to copy </param>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsConsumer.Fill(System.Int32)">
            <summary>
            Fills in no-term-vectors for all docs we haven't seen
            since the last doc that had term vectors.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsConsumerPerField.Finish">
            <summary>
            Called once per field per document if term vectors
            are enabled, to write the vectors to
            RAMOutputStream, which is then quickly flushed to
            the real term vectors files in the Directory. 	  
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool">
            <summary>
            A <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> implementation that tries to assign an
            indexing thread to the same <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> each time the thread tries to
            obtain a <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>. Once a new <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is created it is
            associated with the creating thread. Subsequently, if the threads associated
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is not in use it will be associated with the requesting
            thread. Otherwise, if the <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is used by another thread
            <see cref="T:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool"/> tries to find the currently
            minimal contended <seea cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool"/> with a given maximum of <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TieredMergePolicy">
             <summary>
             Merges segments of approximately equal size, subject to
             an allowed number of segments per tier.  This is similar
             to <see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/>, except this merge
             policy is able to merge non-adjacent segment, and
             separates how many segments are merged at once (<see cref="P:Lucene.Net.Index.TieredMergePolicy.MaxMergeAtOnce"/>) 
             from how many segments are allowed
             per tier (<see cref="P:Lucene.Net.Index.TieredMergePolicy.SegmentsPerTier"/>).  This merge
             policy also does not over-merge (i.e. cascade merges).
            
             <para/>For normal merging, this policy first computes a
             "budget" of how many segments are allowed to be in the
             index.  If the index is over-budget, then the policy
             sorts segments by decreasing size (pro-rating by percent
             deletes), and then finds the least-cost merge.  Merge
             cost is measured by a combination of the "skew" of the
             merge (size of largest segment divided by smallest segment),
             total merge size and percent deletes reclaimed,
             so that merges with lower skew, smaller size
             and those reclaiming more deletes, are
             favored.
            
             <para/>If a merge will produce a segment that's larger than
             <see cref="P:Lucene.Net.Index.TieredMergePolicy.MaxMergedSegmentMB"/>, then the policy will
             merge fewer segments (down to 1 at once, if that one has
             deletions) to keep the segment size under budget.
            
             <para/><b>NOTE</b>: This policy freely merges non-adjacent
             segments; if this is a problem, use <see cref="T:Lucene.Net.Index.LogMergePolicy"/>.
            
             <para/><b>NOTE</b>: This policy always merges by byte size
             of the segments, always pro-rates by percent deletes,
             and does not apply any maximum segment size during
             forceMerge (unlike <see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/>).
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.TieredMergePolicy.DEFAULT_NO_CFS_RATIO">
            <summary>
            Default noCFSRatio.  If a merge's size is >= 10% of
            the index, then we disable compound file for it.
            </summary>
            <seealso cref="P:Lucene.Net.Index.MergePolicy.NoCFSRatio"/>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.#ctor">
            <summary>
            Sole constructor, setting all settings to their
            defaults.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.MaxMergeAtOnce">
            <summary>
            Gets or sets maximum number of segments to be merged at a time
            during "normal" merging.  For explicit merging (eg,
            <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> or 
            <see cref="M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes"/> was called), see 
            <see cref="P:Lucene.Net.Index.TieredMergePolicy.MaxMergeAtOnceExplicit"/>.  Default is 10.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.MaxMergeAtOnceExplicit">
            <summary>
            Gets or sets maximum number of segments to be merged at a time,
            during <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> or 
            <see cref="M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes"/>. Default is 30.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.MaxMergedSegmentMB">
            <summary>
            Gets or sets maximum sized segment to produce during
            normal merging.  This setting is approximate: the
            estimate of the merged segment size is made by summing
            sizes of to-be-merged segments (compensating for
            percent deleted docs).  Default is 5 GB.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.ReclaimDeletesWeight">
            <summary>
            Controls how aggressively merges that reclaim more
            deletions are favored.  Higher values will more
            aggressively target merges that reclaim deletions, but
            be careful not to go so high that way too much merging
            takes place; a value of 3.0 is probably nearly too
            high.  A value of 0.0 means deletions don't impact
            merge selection.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.FloorSegmentMB">
            <summary>
            Segments smaller than this are "rounded up" to this
            size, ie treated as equal (floor) size for merge
            selection.  this is to prevent frequent flushing of
            tiny segments from allowing a long tail in the index.
            Default is 2 MB.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.ForceMergeDeletesPctAllowed">
            <summary>
            When forceMergeDeletes is called, we only merge away a
            segment if its delete percentage is over this
            threshold.  Default is 10%.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.SegmentsPerTier">
            <summary>
            Gets or sets the allowed number of segments per tier.  Smaller
            values mean more merging but fewer segments.
            
            <para/><b>NOTE</b>: this value should be >= the 
            <see cref="P:Lucene.Net.Index.TieredMergePolicy.MaxMergeAtOnce"/> otherwise you'll force too much
            merging to occur.
            
            <para/>Default is 10.0.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TieredMergePolicy.MergeScore">
            <summary>
            Holds score and explanation for a single candidate
            merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.MergeScore.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.MergeScore.Score">
            <summary>
            Returns the score for this merge candidate; lower
            scores are better.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.MergeScore.Explanation">
            <summary>
            Human readable explanation of how the merge got this
            score.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.Score(System.Collections.Generic.IList{Lucene.Net.Index.SegmentCommitInfo},System.Boolean,System.Int64)">
            <summary>
            Expert: scores one merge; subclasses can override. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TrackingIndexWriter">
            <summary>
            Class that tracks changes to a delegated
            <see cref="T:Lucene.Net.Index.IndexWriter"/>, used by 
            <see cref="T:Lucene.Net.Search.ControlledRealTimeReopenThread`1"/> to ensure specific
            changes are visible.   Create this class (passing your
            <see cref="T:Lucene.Net.Index.IndexWriter"/>), and then pass this class to
            <see cref="T:Lucene.Net.Search.ControlledRealTimeReopenThread`1"/>.
            Be sure to make all changes via the
            <see cref="T:Lucene.Net.Index.TrackingIndexWriter"/>, otherwise
            <see cref="T:Lucene.Net.Search.ControlledRealTimeReopenThread`1"/> won't know about the changes.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.#ctor(Lucene.Net.Index.IndexWriter)">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.TrackingIndexWriter"/> wrapping the
             provided <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls 
            <see cref="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField},Lucene.Net.Analysis.Analyzer)"/>
            and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})">
            <summary>
            Calls 
            <see cref="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/> and
            returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls 
            <see cref="M:Lucene.Net.Index.IndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}},Lucene.Net.Analysis.Analyzer)"/>
            and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})">
            <summary>
            Calls
            <see cref="M:Lucene.Net.Index.IndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})"/> and returns
            the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteDocuments(Lucene.Net.Index.Term)">
            <summary>
            Calls <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term)"/> and
            returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteDocuments(Lucene.Net.Index.Term[])">
            <summary>
            Calls <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term[])"/> and
            returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteDocuments(Lucene.Net.Search.Query)">
            <summary>
            Calls <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query)"/> and
            returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteDocuments(Lucene.Net.Search.Query[])">
            <summary>
            Calls <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query[])"/>
            and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteAll">
            <summary>
            Calls <see cref="M:Lucene.Net.Index.IndexWriter.DeleteAll"/> and returns the
            generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls 
            <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField},Lucene.Net.Analysis.Analyzer)"/> and
            returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls 
            <see cref="M:Lucene.Net.Index.IndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}},Lucene.Net.Analysis.Analyzer)"/> and
            returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})">
            <summary>
            Calls <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>
            and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})">
            <summary>
            Calls <see cref="M:Lucene.Net.Index.IndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})"/> and
            returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddIndexes(Lucene.Net.Store.Directory[])">
            <summary>
            Calls <see cref="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Store.Directory[])"/> and
            returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])">
            <summary>
            Calls <see cref="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])"/>
            and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TrackingIndexWriter.Generation">
            <summary>
            Return the current generation being indexed. </summary>
        </member>
        <member name="P:Lucene.Net.Index.TrackingIndexWriter.IndexWriter">
            <summary>
            Return the wrapped <see cref="T:Lucene.Net.Index.IndexWriter"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.GetAndIncrementGeneration">
            <summary>
            Return and increment current gen.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.TryDeleteDocument(Lucene.Net.Index.IndexReader,System.Int32)">
            <summary>
            Cals
            <see cref="M:Lucene.Net.Index.IndexWriter.TryDeleteDocument(Lucene.Net.Index.IndexReader,System.Int32)"/> and
            returns the generation that reflects this change.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ITwoPhaseCommit">
            <summary>
            An interface for implementations that support 2-phase commit. You can use
            <see cref="T:Lucene.Net.Index.TwoPhaseCommitTool"/> to execute a 2-phase commit algorithm over several
            <see cref="T:Lucene.Net.Index.ITwoPhaseCommit"/>s.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ITwoPhaseCommit.PrepareCommit">
            <summary>
            The first stage of a 2-phase commit. Implementations should do as much work
            as possible in this method, but avoid actual committing changes. If the
            2-phase commit fails, <see cref="M:Lucene.Net.Index.ITwoPhaseCommit.Rollback"/> is called to discard all changes
            since last successful commit.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ITwoPhaseCommit.Commit">
            <summary>
            The second phase of a 2-phase commit. Implementations should ideally do
            very little work in this method (following <see cref="M:Lucene.Net.Index.ITwoPhaseCommit.PrepareCommit"/>, and
            after it returns, the caller can assume that the changes were successfully
            committed to the underlying storage.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ITwoPhaseCommit.Rollback">
            <summary>
            Discards any changes that have occurred since the last commit. In a 2-phase
            commit algorithm, where one of the objects failed to <see cref="M:Lucene.Net.Index.ITwoPhaseCommit.Commit"/> or
            <see cref="M:Lucene.Net.Index.ITwoPhaseCommit.PrepareCommit"/>, this method is used to roll all other objects
            back to their previous state.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TwoPhaseCommitTool">
            <summary>
            A utility for executing 2-phase commit on several objects.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Index.ITwoPhaseCommit"/>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.#ctor">
            <summary>
            No instance </summary>
        </member>
        <member name="T:Lucene.Net.Index.TwoPhaseCommitTool.PrepareCommitFailException">
            <summary>
            Thrown by <see cref="M:Lucene.Net.Index.TwoPhaseCommitTool.Execute(Lucene.Net.Index.ITwoPhaseCommit[])"/> when an
            object fails to <see cref="M:Lucene.Net.Index.ITwoPhaseCommit.PrepareCommit"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.PrepareCommitFailException.#ctor(System.Exception,Lucene.Net.Index.ITwoPhaseCommit)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.PrepareCommitFailException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Index.TwoPhaseCommitTool.CommitFailException">
            <summary>
            Thrown by <see cref="M:Lucene.Net.Index.TwoPhaseCommitTool.Execute(Lucene.Net.Index.ITwoPhaseCommit[])"/> when an
            object fails to <see cref="M:Lucene.Net.Index.ITwoPhaseCommit.Commit"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.CommitFailException.#ctor(System.Exception,Lucene.Net.Index.ITwoPhaseCommit)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.CommitFailException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.Rollback(Lucene.Net.Index.ITwoPhaseCommit[])">
            <summary>
            Rollback all objects, discarding any exceptions that occur. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.Execute(Lucene.Net.Index.ITwoPhaseCommit[])">
            <summary>
            Executes a 2-phase commit algorithm by first
            <see cref="M:Lucene.Net.Index.ITwoPhaseCommit.PrepareCommit"/> all objects and only if all succeed,
            it proceeds with <see cref="M:Lucene.Net.Index.ITwoPhaseCommit.Commit"/>. If any of the objects
            fail on either the preparation or actual commit, it terminates and
            <see cref="M:Lucene.Net.Index.ITwoPhaseCommit.Rollback"/> all of them.
            <para/>
            <b>NOTE:</b> It may happen that an object fails to commit, after few have
            already successfully committed. This tool will still issue a rollback
            instruction on them as well, but depending on the implementation, it may
            not have any effect.
            <para/>
            <b>NOTE:</b> if any of the objects are <c>null</c>, this method simply
            skips over them.
            </summary>
            <exception cref="T:Lucene.Net.Index.TwoPhaseCommitTool.PrepareCommitFailException">
                      if any of the objects fail to
                      <see cref="M:Lucene.Net.Index.ITwoPhaseCommit.PrepareCommit"/> </exception>
            <exception cref="T:Lucene.Net.Index.TwoPhaseCommitTool.CommitFailException">
                      if any of the objects fail to <see cref="M:Lucene.Net.Index.ITwoPhaseCommit.Commit"/> </exception>
        </member>
        <member name="T:Lucene.Net.Index.TwoStoredFieldsConsumers">
            <summary>
            Just switches between two <see cref="T:Lucene.Net.Index.DocFieldConsumer"/>s. </summary>
        </member>
        <member name="T:Lucene.Net.Index.UpgradeIndexMergePolicy">
            <summary>
            This <see cref="T:Lucene.Net.Index.MergePolicy"/> is used for upgrading all existing segments of
            an index when calling <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>.
            All other methods delegate to the base <see cref="T:Lucene.Net.Index.MergePolicy"/> given to the constructor.
            This allows for an as-cheap-as possible upgrade of an older index by only upgrading segments that
            are created by previous Lucene versions. ForceMerge does no longer really merge;
            it is just used to &quot;ForceMerge&quot; older segment versions away.
            <para/>In general one would use <see cref="T:Lucene.Net.Index.IndexUpgrader"/>, but for a fully customizeable upgrade,
            you can use this like any other <see cref="T:Lucene.Net.Index.MergePolicy"/> and call <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>:
            <code>
                IndexWriterConfig iwc = new IndexWriterConfig(LuceneVersion.LUCENE_XX, new KeywordAnalyzer());
                iwc.MergePolicy = new UpgradeIndexMergePolicy(iwc.MergePolicy);
                using (IndexWriter w = new IndexWriter(dir, iwc))
                {
                    w.ForceMerge(1);
                }
            </code>
            <para/><b>Warning:</b> this merge policy may reorder documents if the index was partially
            upgraded before calling <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> (e.g., documents were added). If your application relies
            on &quot;monotonicity&quot; of doc IDs (which means that the order in which the documents
            were added to the index is preserved), do a <c>ForceMerge(1)</c> instead. Please note, the
            delegate <see cref="T:Lucene.Net.Index.MergePolicy"/> may also reorder documents.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Index.IndexUpgrader"/>
        </member>
        <member name="F:Lucene.Net.Index.UpgradeIndexMergePolicy.m_base">
            <summary>
            Wrapped <see cref="T:Lucene.Net.Index.MergePolicy"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.UpgradeIndexMergePolicy.#ctor(Lucene.Net.Index.MergePolicy)">
            <summary>
            Wrap the given <see cref="T:Lucene.Net.Index.MergePolicy"/> and intercept <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> requests to
            only upgrade segments written with previous Lucene versions.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.UpgradeIndexMergePolicy.ShouldUpgradeSegment(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Returns <c>true</c> if the given segment should be upgraded. The default implementation
            will return <c>!Constants.LUCENE_MAIN_VERSION.Equals(si.Info.Version, StringComparison.Ordinal)</c>,
            so all segments created with a different version number than this Lucene version will
            get upgraded.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions">
            <summary>
            Extension methods that can be used to provide similar
            <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> syntax as Java Lucene.
            (config.SetCheckIntegrityAtMerge(100).SetMaxBufferedDocs(1000);)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetTermIndexInterval(Lucene.Net.Index.LiveIndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="interval"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetMaxBufferedDeleteTerms(Lucene.Net.Index.LiveIndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="maxBufferedDeleteTerms"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetRAMBufferSizeMB(Lucene.Net.Index.LiveIndexWriterConfig,System.Double)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="ramBufferSizeMB"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetMaxBufferedDocs(Lucene.Net.Index.LiveIndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="maxBufferedDocs"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetMergedSegmentWarmer(Lucene.Net.Index.LiveIndexWriterConfig,Lucene.Net.Index.IndexWriter.IndexReaderWarmer)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MergedSegmentWarmer"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="mergeSegmentWarmer"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetReaderTermsIndexDivisor(Lucene.Net.Index.LiveIndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.ReaderTermsIndexDivisor"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="divisor"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetUseCompoundFile(Lucene.Net.Index.LiveIndexWriterConfig,System.Boolean)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.UseCompoundFile"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="useCompoundFile"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetCheckIntegrityAtMerge(Lucene.Net.Index.LiveIndexWriterConfig,System.Boolean)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.CheckIntegrityAtMerge"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="checkIntegrityAtMerge"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetTermIndexInterval(Lucene.Net.Index.IndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="interval"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetMaxBufferedDeleteTerms(Lucene.Net.Index.IndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="maxBufferedDeleteTerms"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetRAMBufferSizeMB(Lucene.Net.Index.IndexWriterConfig,System.Double)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="ramBufferSizeMB"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetMaxBufferedDocs(Lucene.Net.Index.IndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="maxBufferedDocs"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetMergedSegmentWarmer(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.IndexWriter.IndexReaderWarmer)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MergedSegmentWarmer"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="mergeSegmentWarmer"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetReaderTermsIndexDivisor(Lucene.Net.Index.IndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.ReaderTermsIndexDivisor"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="divisor"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetUseCompoundFile(Lucene.Net.Index.IndexWriterConfig,System.Boolean)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.UseCompoundFile"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="useCompoundFile"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetCheckIntegrityAtMerge(Lucene.Net.Index.IndexWriterConfig,System.Boolean)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.CheckIntegrityAtMerge"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="checkIntegrityAtMerge"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetDefaultWriteLockTimeout(Lucene.Net.Index.IndexWriterConfig,System.Int64)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.DefaultWriteLockTimeout"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="writeLockTimeout"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetOpenMode(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.OpenMode)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.OpenMode"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="openMode"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetIndexDeletionPolicy(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.IndexDeletionPolicy)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexDeletionPolicy"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="deletionPolicy"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetIndexCommit(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.IndexCommit)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexCommit"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="commit"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetSimilarity(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Search.Similarities.Similarity)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.Similarity"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="similarity"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetMergeScheduler(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.IMergeScheduler)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.MergeScheduler"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="mergeScheduler"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetWriteLockTimeout(Lucene.Net.Index.IndexWriterConfig,System.Int64)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.WriteLockTimeout"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="writeLockTimeout"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetMergePolicy(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.MergePolicy)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.MergePolicy"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="mergePolicy"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetCodec(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Codecs.Codec)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.Codec"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="codec"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetIndexerThreadPool(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.DocumentsWriterPerThreadPool)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexerThreadPool"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="threadPool"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetMaxThreadStates(Lucene.Net.Index.IndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.MaxThreadStates"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="maxThreadStates"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetReaderPooling(Lucene.Net.Index.IndexWriterConfig,System.Boolean)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.UseReaderPooling"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="readerPooling"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetIndexingChain(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.DocumentsWriterPerThread.IndexingChain)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexingChain"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="indexingChain"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetFlushPolicy(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.FlushPolicy)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.FlushPolicy"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="flushPolicy"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Index.Extensions.IndexWriterConfigExtensions.SetRAMPerThreadHardLimitMB(Lucene.Net.Index.IndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.RAMPerThreadHardLimitMB"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="perThreadHardLimitMB"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="T:Lucene.Net.Index.TaskMergeScheduler">
            <summary>
            A <see cref="T:Lucene.Net.Index.MergeScheduler"/> that runs each merge using
            <see cref="T:System.Threading.Tasks.Task"/>s on the default <see cref="T:System.Threading.Tasks.TaskScheduler"/>.
            
            <para>If more than <see cref="P:Lucene.Net.Index.TaskMergeScheduler.MaxMergeCount"/> merges are
            requested then this class will forcefully throttle the
            incoming threads by pausing until one more more merges
            complete.</para>
             
            LUCENENET specific
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.TaskMergeScheduler._mergeThreads">
            <summary>
            List of currently active <see cref="T:Lucene.Net.Index.TaskMergeScheduler.MergeThread"/>s.</summary>
        </member>
        <member name="F:Lucene.Net.Index.TaskMergeScheduler._mergeThreadCount">
            <summary>
            How many <see cref="T:Lucene.Net.Index.TaskMergeScheduler.MergeThread"/>s have kicked off (this is use
            to name them).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.TaskMergeScheduler._directory">
            <summary>
            <see cref="T:Lucene.Net.Store.Directory"/> that holds the index. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TaskMergeScheduler._writer">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexWriter"/> that owns this instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.#ctor">
            <summary>
            Sole constructor, with all settings set to default
            values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.SetMaxMergesAndThreads(System.Int32,System.Int32)">
            <summary>
            Sets the maximum number of merge threads and simultaneous merges allowed.
            </summary>
            <param name="maxMergeCount"> The max # simultaneous merges that are allowed.
                  If a merge is necessary yet we already have this many
                  threads running, the incoming thread (that is calling
                  add/updateDocument) will block until a merge thread
                  has completed.  Note that we will only run the
                  smallest <paramref name="maxThreadCount"/> merges at a time. </param>
            <param name="maxThreadCount"> The max # simultaneous merge threads that should
                  be running at once.  This must be &lt;= <paramref name="maxMergeCount"/> </param>
        </member>
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.MaxThreadCount">
            <summary>
            Max number of merge threads allowed to be running at
            once.  When there are more merges then this, we
            forcefully pause the larger ones, letting the smaller
            ones run, up until <see cref="P:Lucene.Net.Index.TaskMergeScheduler.MaxMergeCount"/> merges at which point
            we forcefully pause incoming threads (that presumably
            are the ones causing so much merging).
            </summary>
            <seealso cref="M:Lucene.Net.Index.TaskMergeScheduler.SetMaxMergesAndThreads(System.Int32,System.Int32)"/>
        </member>
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.MaxMergeCount">
            <summary>
            Max number of merges we accept before forcefully
            throttling the incoming threads
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.MergeThreadPriority">
            <summary>
            Return the priority that merge threads run at. This is always the same.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.SetMergeThreadPriority(System.Int32)">
            <summary>
            This method has no effect in <see cref="T:Lucene.Net.Index.TaskMergeScheduler"/> because the
            <see cref="P:Lucene.Net.Index.TaskMergeScheduler.MergeThreadPriority"/> returns a constant value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.UpdateMergeThreads">
            <summary>
            Called whenever the running merges have changed, to pause &amp; unpause
            threads. This method sorts the merge threads by their merge size in
            descending order and then pauses/unpauses threads from first to last --
            that way, smaller merges are guaranteed to run before larger ones.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.Verbose">
             <summary>
             Returns <c>true</c> if verbosing is enabled. This method is usually used in
             conjunction with <see cref="M:Lucene.Net.Index.TaskMergeScheduler.Message(System.String)"/>, like that:
            
             <code>
             if (Verbose) {
                 Message(&quot;your message&quot;);
             }
             </code>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.Message(System.String)">
            <summary>
            Outputs the given message - this method assumes <see cref="P:Lucene.Net.Index.TaskMergeScheduler.Verbose"/> was
            called and returned <c>true</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.Sync">
            <summary>
            Wait for any running merge threads to finish. 
            This call is not interruptible as used by <see cref="M:Lucene.Net.Index.MergeScheduler.Dispose"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.MergeThreadCount">
            <summary>
            Returns the number of merge threads that are alive. Note that this number
            is &lt;= <see cref="F:Lucene.Net.Index.TaskMergeScheduler._mergeThreads"/> size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.DoMerge(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does the actual merge, by calling <see cref="M:Lucene.Net.Index.IndexWriter.Merge(Lucene.Net.Index.MergePolicy.OneMerge)"/> </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.CreateTask(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Create and return a new <see cref="T:Lucene.Net.Index.TaskMergeScheduler.MergeThread"/> </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.HandleMergeException(System.Exception)">
            <summary>
            Called when an exception is hit in a background merge
            thread
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.SetSuppressExceptions">
            <summary>
            Used for testing </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.ClearSuppressExceptions">
            <summary>
            Used for testing </summary>
        </member>
        <member name="T:Lucene.Net.Index.TaskMergeScheduler.MergeThread">
            <summary>
            Runs a merge thread, which may run one or more merges
            in sequence.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.MergeThread.#ctor(System.String,Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergePolicy.OneMerge,Lucene.Net.Util.InfoStream,System.Boolean,System.Threading.ManualResetEventSlim,System.Action{System.Exception},System.Action{Lucene.Net.Index.MergePolicy.OneMerge})">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.MergeThread.RunningMerge">
            <summary>
            Record the currently running merge. </summary>
        </member>
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.MergeThread.CurrentMerge">
            <summary>
            Return the current merge, or <c>null</c> if this 
            <see cref="T:Lucene.Net.Index.TaskMergeScheduler.MergeThread"/> is done.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.AutomatonQuery">
            <summary>
            A <see cref="T:Lucene.Net.Search.Query"/> that will match terms against a finite-state machine.
            <para>
            This query will match documents that contain terms accepted by a given
            finite-state machine. The automaton can be constructed with the
            <see cref="N:Lucene.Net.Util.Automaton"/> API. Alternatively, it can be
            created from a regular expression with <see cref="T:Lucene.Net.Search.RegexpQuery"/> or from
            the standard Lucene wildcard syntax with <see cref="T:Lucene.Net.Search.WildcardQuery"/>.
            </para>
            <para>
            When the query is executed, it will create an equivalent DFA of the
            finite-state machine, and will enumerate the term dictionary in an
            intelligent way to reduce the number of comparisons. For example: the regular
            expression of <c>[dl]og?</c> will make approximately four comparisons:
            do, dog, lo, and log.
            </para>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.AutomatonQuery.m_automaton">
            <summary>
            The automaton to match index terms against </summary>
        </member>
        <member name="F:Lucene.Net.Search.AutomatonQuery.m_term">
            <summary>
            Term containing the field, and possibly some pattern structure </summary>
        </member>
        <member name="M:Lucene.Net.Search.AutomatonQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Create a new AutomatonQuery from an <see cref="P:Lucene.Net.Search.AutomatonQuery.Automaton"/>.
            </summary>
            <param name="term"> <see cref="T:Lucene.Net.Index.Term"/> containing field and possibly some pattern structure. The
                   term text is ignored. </param>
            <param name="automaton"> <see cref="P:Lucene.Net.Search.AutomatonQuery.Automaton"/> to run, terms that are accepted are considered a
                   match. </param>
        </member>
        <member name="P:Lucene.Net.Search.AutomatonQuery.Automaton">
            <summary>
            Returns the automaton used to create this query </summary>
        </member>
        <member name="T:Lucene.Net.Search.BitsFilteredDocIdSet">
            <summary>
            This implementation supplies a filtered <see cref="T:Lucene.Net.Search.DocIdSet"/>, that excludes all
            docids which are not in a <see cref="T:Lucene.Net.Util.IBits"/> instance. This is especially useful in
            <see cref="T:Lucene.Net.Search.Filter"/> to apply the <see cref="F:Lucene.Net.Search.BitsFilteredDocIdSet.acceptDocs"/>
            passed to <see cref="M:Lucene.Net.Search.Filter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)"/> before returning the final <see cref="T:Lucene.Net.Search.DocIdSet"/>.
            </summary>
            <seealso cref="T:Lucene.Net.Search.DocIdSet"/>
            <seealso cref="T:Lucene.Net.Search.Filter"/>
        </member>
        <member name="M:Lucene.Net.Search.BitsFilteredDocIdSet.Wrap(Lucene.Net.Search.DocIdSet,Lucene.Net.Util.IBits)">
            <summary>
            Convenience wrapper method: If <c>acceptDocs == null</c> it returns the original set without wrapping. </summary>
            <param name="set"> Underlying DocIdSet. If <c>null</c>, this method returns <c>null</c> </param>
            <param name="acceptDocs"> Allowed docs, all docids not in this set will not be returned by this <see cref="T:Lucene.Net.Search.DocIdSet"/>.
            If <c>null</c>, this method returns the original set without wrapping. </param>
        </member>
        <member name="M:Lucene.Net.Search.BitsFilteredDocIdSet.#ctor(Lucene.Net.Search.DocIdSet,Lucene.Net.Util.IBits)">
            <summary>
            Constructor. </summary>
            <param name="innerSet"> Underlying <see cref="T:Lucene.Net.Search.DocIdSet"/> </param>
            <param name="acceptDocs"> Allowed docs, all docids not in this set will not be returned by this <see cref="T:Lucene.Net.Search.DocIdSet"/> </param>
        </member>
        <member name="T:Lucene.Net.Search.BooleanClause">
            <summary>
            A clause in a <see cref="T:Lucene.Net.Search.BooleanQuery"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.query">
            <summary>
            The query whose matching documents are combined by the boolean query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Occur)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Search.BooleanClause"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <paramref name="o"/> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Occur">
            <summary>
            Specifies how clauses are to occur in matching documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Occur.MUST">
            <summary>
            Use this operator for clauses that <i>must</i> appear in the matching documents.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Occur.SHOULD">
            <summary>
            Use this operator for clauses that <i>should</i> appear in the
            matching documents. For a <see cref="T:Lucene.Net.Search.BooleanQuery"/> with no <see cref="F:Lucene.Net.Search.Occur.MUST"/>
            clauses one or more <see cref="F:Lucene.Net.Search.Occur.SHOULD"/> clauses must match a document
            for the <see cref="T:Lucene.Net.Search.BooleanQuery"/> to match. </summary>
            <seealso cref="P:Lucene.Net.Search.BooleanQuery.MinimumNumberShouldMatch"/>
        </member>
        <member name="F:Lucene.Net.Search.Occur.MUST_NOT">
            <summary>
            Use this operator for clauses that <i>must not</i> appear in the matching documents.
            Note that it is not possible to search for queries that only consist
            of a <see cref="F:Lucene.Net.Search.Occur.MUST_NOT"/> clause.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery">
            <summary>
            A <see cref="T:Lucene.Net.Search.Query"/> that matches documents matching boolean combinations of other
            queries, e.g. <see cref="T:Lucene.Net.Search.TermQuery"/>s, <see cref="T:Lucene.Net.Search.PhraseQuery"/>s or other
            <see cref="T:Lucene.Net.Search.BooleanQuery"/>s.
            <para/>
            Collection initializer note: To create and populate a <see cref="T:Lucene.Net.Search.BooleanQuery"/>
            in a single statement, you can use the following example as a guide:
            
            <code>
            var booleanQuery = new BooleanQuery() {
                { new WildcardQuery(new Term("field2", "foobar")), Occur.SHOULD },
                { new MultiPhraseQuery() {
                    new Term("field", "microsoft"), 
                    new Term("field", "office")
                }, Occur.SHOULD }
            };
            
            // or
            
            var booleanQuery = new BooleanQuery() {
                new BooleanClause(new WildcardQuery(new Term("field2", "foobar")), Occur.SHOULD),
                new BooleanClause(new MultiPhraseQuery() {
                    new Term("field", "microsoft"), 
                    new Term("field", "office")
                }, Occur.SHOULD)
            };
            </code>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException">
            <summary>
            Thrown when an attempt is made to add more than 
            <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. This typically happens if
            a <see cref="T:Lucene.Net.Search.PrefixQuery"/>, <see cref="T:Lucene.Net.Search.FuzzyQuery"/>, <see cref="T:Lucene.Net.Search.WildcardQuery"/>, or <see cref="T:Lucene.Net.Search.TermRangeQuery"/>
            is expanded to many terms during search.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.TooManyClausesException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount">
            <summary>
            Return the maximum number of clauses permitted, 1024 by default.
            Attempts to add more than the permitted number of clauses cause 
            <see cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"/> to be thrown. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor">
            <summary>
            Constructs an empty boolean query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor(System.Boolean)">
            <summary>
            Constructs an empty boolean query.
            <para/>
            <see cref="M:Lucene.Net.Search.Similarities.Similarity.Coord(System.Int32,System.Int32)"/> may be disabled in scoring, as
            appropriate. For example, this score factor does not make sense for most
            automatically generated queries, like <see cref="T:Lucene.Net.Search.WildcardQuery"/> and 
            <see cref="T:Lucene.Net.Search.FuzzyQuery"/>.
            </summary>
            <param name="disableCoord"> Disables <see cref="M:Lucene.Net.Search.Similarities.Similarity.Coord(System.Int32,System.Int32)"/> in scoring. </param>
        </member>
        <member name="P:Lucene.Net.Search.BooleanQuery.CoordDisabled">
            <summary>
            Returns true if <see cref="M:Lucene.Net.Search.Similarities.Similarity.Coord(System.Int32,System.Int32)"/> is disabled in
            scoring for this query instance. </summary>
            <seealso cref="M:Lucene.Net.Search.BooleanQuery.#ctor(System.Boolean)"/>
        </member>
        <member name="P:Lucene.Net.Search.BooleanQuery.MinimumNumberShouldMatch">
             <summary>
             Specifies a minimum number of the optional <see cref="T:Lucene.Net.Search.BooleanClause"/>s
             which must be satisfied.
            
             <para>
             By default no optional clauses are necessary for a match
             (unless there are no required clauses).  If this method is used,
             then the specified number of clauses is required.
             </para>
             <para>
             Use of this method is totally independent of specifying that
             any specific clauses are required (or prohibited).  This number will
             only be compared against the number of matching optional clauses.
             </para>
             </summary>
             <param name="value"> The number of optional clauses that must match </param>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.Query,Lucene.Net.Search.Occur)">
            <summary>
            Adds a clause to a boolean query.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If the new number of clauses exceeds the maximum clause number </exception>
            <seealso cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.BooleanClause)">
            <summary>
            Adds a clause to a boolean query. </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If the new number of clauses exceeds the maximum clause number </exception>
            <seealso cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetClauses">
            <summary>
            Returns the set of clauses in this query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.BooleanQuery.Clauses">
            <summary>
            Returns the list of clauses in this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetEnumerator">
            <summary>
            Returns an iterator on the clauses in this query. It implements the <see cref="T:IEnumerable{BooleanClause}"/> interface to
            make it possible to do:
            <code>foreach (BooleanClause clause in booleanQuery) {}</code>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery.BooleanWeight">
            <summary>
            Expert: the <see cref="T:Lucene.Net.Search.Weight"/> for <see cref="T:Lucene.Net.Search.BooleanQuery"/>, used to
            normalize, score and explain these queries.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanQuery.BooleanWeight.m_similarity">
            <summary>
            The <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <paramref name="o"/> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer">
            <summary>
            Description from Doug Cutting (excerpted from
            LUCENE-1483):
            <para/>
            <see cref="T:Lucene.Net.Search.BooleanScorer"/> uses an array to score windows of
            2K docs. So it scores docs 0-2K first, then docs 2K-4K,
            etc. For each window it iterates through all query terms
            and accumulates a score in table[doc%2K]. It also stores
            in the table a bitmask representing which terms
            contributed to the score. Non-zero scores are chained in
            a linked list. At the end of scoring each window it then
            iterates through the linked list and, if the bitmask
            matches the boolean constraints, collects a hit. For
            boolean queries with lots of frequent terms this can be
            much faster, since it does not need to update a priority
            queue for each posting, instead performing constant-time
            operations per posting. The only downside is that it
            results in hits being delivered out-of-order within the
            window, which means it cannot be nested within other
            scorers. But it works well as a top-level scorer.
            <para/>
            The new BooleanScorer2 implementation instead works by
            merging priority queues of postings, albeit with some
            clever tricks. For example, a pure conjunction (all terms
            required) does not require a priority queue. Instead it
            sorts the posting streams at the start, then repeatedly
            skips the first to to the last. If the first ever equals
            the last, then there's a hit. When some terms are
            required and some terms are optional, the conjunction can
            be evaluated first, then the optional terms can all skip
            to the match and be added to the score. Thus the
            conjunction can reduce the number of priority queue
            updates for the optional terms.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer.BucketTable">
            <summary>
            A simple hash table of document scores within a range. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer2">
            <summary>
            See the description in <see cref="T:Lucene.Net.Search.BooleanScorer"/> comparing
            <see cref="T:Lucene.Net.Search.BooleanScorer"/> &amp; <see cref="T:Lucene.Net.Search.BooleanScorer2"/>.
            <para/>
            An alternative to <see cref="T:Lucene.Net.Search.BooleanScorer"/> that also allows a minimum number
            of optional scorers that should match.
            <para/>Implements SkipTo(), and has no limitations on the numbers of added scorers.
            <para/>Uses <see cref="T:Lucene.Net.Search.ConjunctionScorer"/>, <see cref="T:Lucene.Net.Search.DisjunctionScorer"/>, <see cref="T:Lucene.Net.Search.ReqOptSumScorer"/> and <see cref="T:Lucene.Net.Search.ReqExclScorer"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanScorer2.countingSumScorer">
            <summary>
            The scorer to which all scoring will be delegated,
            except for computing and using the coordination factor.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanScorer2.minNrShouldMatch">
            <summary>
            The number of optionalScorers that need to match (if there are any) </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.#ctor(Lucene.Net.Search.BooleanQuery.BooleanWeight,System.Boolean,System.Int32,System.Collections.Generic.IList{Lucene.Net.Search.Scorer},System.Collections.Generic.IList{Lucene.Net.Search.Scorer},System.Collections.Generic.IList{Lucene.Net.Search.Scorer},System.Int32)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Search.Scorer"/> with the given similarity and lists of required,
            prohibited and optional scorers. In no required scorers are added, at least
            one of the optional scorers will have to match during the search.
            </summary>
            <param name="weight">
                     The <see cref="T:Lucene.Net.Search.BooleanQuery.BooleanWeight"/> to be used. </param>
            <param name="disableCoord">
                     If this parameter is <c>true</c>, coordination level matching
                     (<see cref="M:Lucene.Net.Search.Similarities.Similarity.Coord(System.Int32,System.Int32)"/>) is not used. </param>
            <param name="minNrShouldMatch">
                     The minimum number of optional added scorers that should match
                     during the search. In case no required scorers are added, at least
                     one of the optional scorers will have to match during the search. </param>
            <param name="required">
                     The list of required scorers. </param>
            <param name="prohibited">
                     The list of prohibited scorers. </param>
            <param name="optional">
                     The list of optional scorers. </param>
            <param name="maxCoord">
                     The max coord. </param>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer2.SingleMatchScorer">
            <summary>
            Count a scorer as a single match. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.MakeCountingSumScorer(System.Boolean)">
            <summary>
            Returns the scorer to be used for match counting and score summing.
            Uses requiredScorers, optionalScorers and prohibitedScorers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.AddProhibitedScorers(Lucene.Net.Search.Scorer)">
            <summary>
            Returns the scorer to be used for match counting and score summing.
            Uses the given required scorer and the prohibitedScorers. </summary>
            <param name="requiredCountingSumScorer"> A required scorer already built. </param>
        </member>
        <member name="T:Lucene.Net.Search.IBoostAttribute">
            <summary>
            Add this <see cref="T:Lucene.Net.Util.IAttribute"/> to a <see cref="T:Lucene.Net.Index.TermsEnum"/> returned by <see cref="M:Lucene.Net.Search.MultiTermQuery.GetTermsEnum(Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource)"/>
            and update the boost on each returned term. This enables to control the boost factor
            for each matching term in <see cref="F:Lucene.Net.Search.MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE"/> or
            <see cref="T:Lucene.Net.Search.TopTermsRewrite`1"/> mode.
            <see cref="T:Lucene.Net.Search.FuzzyQuery"/> is using this to take the edit distance into account.
            <para/><b>Please note:</b> this attribute is intended to be added only by the <see cref="T:Lucene.Net.Index.TermsEnum"/>
            to itself in its constructor and consumed by the <see cref="T:Lucene.Net.Search.MultiTermQuery.RewriteMethod"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.IBoostAttribute.Boost">
            <summary>
            Gets or Sets the boost in this attribute. Default is <c>1.0f</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BoostAttribute">
            <summary>
            Implementation class for <see cref="T:Lucene.Net.Search.IBoostAttribute"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.BoostAttribute.Boost">
            <summary>
            Gets or Sets the boost in this attribute. Default is <c>1.0f</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BulkScorer">
            <summary>
            This class is used to score a range of documents at
            once, and is returned by <see cref="M:Lucene.Net.Search.Weight.GetBulkScorer(Lucene.Net.Index.AtomicReaderContext,System.Boolean,Lucene.Net.Util.IBits)"/>.  Only
            queries that have a more optimized means of scoring
            across a range of documents need to override this.
            Otherwise, a default implementation is wrapped around
            the <see cref="T:Lucene.Net.Search.Scorer"/> returned by <see cref="M:Lucene.Net.Search.Weight.GetScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BulkScorer.Score(Lucene.Net.Search.ICollector)">
            <summary>
            Scores and collects all matching documents. </summary>
            <param name="collector"> The collector to which all matching documents are passed. </param>
        </member>
        <member name="M:Lucene.Net.Search.BulkScorer.Score(Lucene.Net.Search.ICollector,System.Int32)">
            <summary>
            Collects matching documents in a range.
            </summary>
            <param name="collector"> The collector to which all matching documents are passed. </param>
            <param name="max"> Score up to, but not including, this doc </param>
            <returns> <c>true</c> if more matching documents may remain. </returns>
        </member>
        <member name="T:Lucene.Net.Search.CachingCollector">
             <summary>
             Caches all docs, and optionally also scores, coming from
             a search, and is then able to replay them to another
             collector.  You specify the max RAM this class may use.
             Once the collection is done, call <see cref="P:Lucene.Net.Search.CachingCollector.IsCached"/>. If
             this returns <c>true</c>, you can use <see cref="M:Lucene.Net.Search.CachingCollector.Replay(Lucene.Net.Search.ICollector)"/>
             against a new collector.  If it returns <c>false</c>, this means
             too much RAM was required and you must instead re-run the
             original search.
            
             <para/><b>NOTE</b>: this class consumes 4 (or 8 bytes, if
             scoring is cached) per collected document.  If the result
             set is large this can easily be a very substantial amount
             of RAM!
            
             <para/><b>NOTE</b>: this class caches at least 128 documents
             before checking RAM limits.
            
             <para>See the Lucene <c>modules/grouping</c> module for more
             details including a full code example.</para>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.CachingCollector.EMPTY_INT32_ARRAY">
            <summary>
            NOTE: This was EMPTY_INT_ARRAY in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.CachingCollector.ScoreCachingCollector">
            <summary>
            A <see cref="T:Lucene.Net.Search.CachingCollector"/> which caches scores
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.CachingCollector.NoScoreCachingCollector">
            <summary>
            A <see cref="T:Lucene.Net.Search.CachingCollector"/> which does not cache scores
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Create(System.Boolean,System.Boolean,System.Double)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Search.CachingCollector"/> which does not wrap another collector.
            The cached documents and scores can later be replayed (<see cref="M:Lucene.Net.Search.CachingCollector.Replay(Lucene.Net.Search.ICollector)"/>).
            </summary>
            <param name="acceptDocsOutOfOrder">
                     whether documents are allowed to be collected out-of-order </param>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Create(Lucene.Net.Search.ICollector,System.Boolean,System.Double)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Search.CachingCollector"/> that wraps the given collector and
            caches documents and scores up to the specified RAM threshold.
            </summary>
            <param name="other">
                     The <see cref="T:Lucene.Net.Search.ICollector"/> to wrap and delegate calls to. </param>
            <param name="cacheScores">
                     Whether to cache scores in addition to document IDs. Note that
                     this increases the RAM consumed per doc. </param>
            <param name="maxRAMMB">
                     The maximum RAM in MB to consume for caching the documents and
                     scores. If the collector exceeds the threshold, no documents and
                     scores are cached. </param>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Create(Lucene.Net.Search.ICollector,System.Boolean,System.Int32)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Search.CachingCollector"/> that wraps the given collector and
            caches documents and scores up to the specified max docs threshold.
            </summary>
            <param name="other">
                     The <see cref="T:Lucene.Net.Search.ICollector"/> to wrap and delegate calls to. </param>
            <param name="cacheScores">
                     Whether to cache scores in addition to document IDs. Note that
                     this increases the RAM consumed per doc. </param>
            <param name="maxDocsToCache">
                     The maximum number of documents for caching the documents and
                     possible the scores. If the collector exceeds the threshold,
                     no documents and scores are cached. </param>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.SetScorer(Lucene.Net.Search.Scorer)">
            <summary>
            Called before successive calls to <see cref="M:Lucene.Net.Search.CachingCollector.Collect(System.Int32)"/>. Implementations
            that need the score of the current document (passed-in to
            <also cref="M:Lucene.Net.Search.CachingCollector.Collect(System.Int32)"/>), should save the passed-in <see cref="T:Lucene.Net.Search.Scorer"/> and call
            <see cref="M:Lucene.Net.Search.Scorer.GetScore"/> when needed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Collect(System.Int32)">
            <summary>
            Called once for every document matching a query, with the unbased document
            number.
            <para/>Note: The collection of the current segment can be terminated by throwing
            a <see cref="T:Lucene.Net.Search.CollectionTerminatedException"/>. In this case, the last docs of the
            current <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> will be skipped and <see cref="T:Lucene.Net.Search.IndexSearcher"/>
            will swallow the exception and continue collection with the next leaf.
            <para/>
            Note: this is called in an inner search loop. For good search performance,
            implementations of this method should not call <see cref="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)"/> or
            <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/> on every hit.
            Doing so can slow searches by an order of magnitude or more.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.ReplayInit(Lucene.Net.Search.ICollector)">
            <summary>
            Reused by the specialized inner classes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Replay(Lucene.Net.Search.ICollector)">
            <summary>
            Replays the cached doc IDs (and scores) to the given <see cref="T:Lucene.Net.Search.ICollector"/>. If this
            instance does not cache scores, then <see cref="T:Lucene.Net.Search.Scorer"/> is not set on
            <c>other.SetScorer(Scorer)</c> as well as scores are not replayed.
            </summary>
            <exception cref="T:System.InvalidOperationException">
                      If this collector is not cached (i.e., if the RAM limits were too
                      low for the number of documents + scores to cache). </exception>
            <exception cref="T:System.ArgumentException">
                      If the given Collect's does not support out-of-order collection,
                      while the collector passed to the ctor does. </exception>
        </member>
        <member name="T:Lucene.Net.Search.CachingWrapperFilter">
            <summary>
            Wraps another <see cref="T:Lucene.Net.Search.Filter"/>'s result and caches it.  The purpose is to allow
            filters to simply filter, and then wrap with this class
            to add caching.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.#ctor(Lucene.Net.Search.Filter)">
            <summary>
            Wraps another filter's result and caches it. </summary>
            <param name="filter"> Filter to cache results of </param>
        </member>
        <member name="P:Lucene.Net.Search.CachingWrapperFilter.Filter">
            <summary>
            Gets the contained filter. </summary>
            <returns> the contained filter. </returns>
        </member>
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.DocIdSetToCache(Lucene.Net.Search.DocIdSet,Lucene.Net.Index.AtomicReader)">
            <summary>
            Provide the <see cref="T:Lucene.Net.Search.DocIdSet"/> to be cached, using the <see cref="T:Lucene.Net.Search.DocIdSet"/> provided
            by the wrapped Filter. 
            <para/>This implementation returns the given <see cref="T:Lucene.Net.Search.DocIdSet"/>,
            if <see cref="P:Lucene.Net.Search.DocIdSet.IsCacheable"/> returns <c>true</c>, else it calls
            <see cref="M:Lucene.Net.Search.CachingWrapperFilter.CacheImpl(Lucene.Net.Search.DocIdSetIterator,Lucene.Net.Index.AtomicReader)"/>
            <para/>Note: this method returns <see cref="F:Lucene.Net.Search.CachingWrapperFilter.EMPTY_DOCIDSET"/> if the given <paramref name="docIdSet"/>
            is <c>null</c> or if <see cref="M:Lucene.Net.Search.DocIdSet.GetIterator"/> return <c>null</c>. The empty
            instance is use as a placeholder in the cache instead of the <c>null</c> value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.CacheImpl(Lucene.Net.Search.DocIdSetIterator,Lucene.Net.Index.AtomicReader)">
            <summary>
            Default cache implementation: uses <see cref="T:Lucene.Net.Util.WAH8DocIdSet"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.CachingWrapperFilter.EMPTY_DOCIDSET">
            <summary>
            An empty <see cref="T:Lucene.Net.Search.DocIdSet"/> instance </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.GetSizeInBytes">
            <summary>
            Returns total byte size used by cached filters. </summary>
        </member>
        <member name="T:Lucene.Net.Search.CollectionStatistics">
            <summary>
            Contains statistics for a collection (field)
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CollectionStatistics.#ctor(System.String,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Sole constructor.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.CollectionStatistics.Field">
            <summary>
            Returns the field name </summary>
        </member>
        <member name="P:Lucene.Net.Search.CollectionStatistics.MaxDoc">
            <summary>
            Returns the total number of documents, regardless of
            whether they all contain values for this field. </summary>
            <seealso cref="P:Lucene.Net.Index.IndexReader.MaxDoc"/>
        </member>
        <member name="P:Lucene.Net.Search.CollectionStatistics.DocCount">
            <summary>
            Returns the total number of documents that
            have at least one term for this field. </summary>
            <seealso cref="P:Lucene.Net.Index.Terms.DocCount"/>
        </member>
        <member name="P:Lucene.Net.Search.CollectionStatistics.SumTotalTermFreq">
            <summary>
            Returns the total number of tokens for this field </summary>
            <seealso cref="P:Lucene.Net.Index.Terms.SumTotalTermFreq"/>
        </member>
        <member name="P:Lucene.Net.Search.CollectionStatistics.SumDocFreq">
            <summary>
            Returns the total number of postings for this field </summary>
            <seealso cref="P:Lucene.Net.Index.Terms.SumDocFreq"/>
        </member>
        <member name="T:Lucene.Net.Search.CollectionTerminatedException">
            <summary>
            Throw this exception in <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/> to prematurely
            terminate collection of the current leaf.
            <para/>Note: <see cref="T:Lucene.Net.Search.IndexSearcher"/> swallows this exception and never re-throws it.
            As a consequence, you should not catch it when calling any overload of
            <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.FieldDoc,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean,System.Boolean)"/> as it is unnecessary and might hide misuse
            of this exception.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CollectionTerminatedException.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Search.CollectionTerminatedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Search.ICollector">
             <summary>
             <para>Expert: Collectors are primarily meant to be used to
             gather raw results from a search, and implement sorting
             or custom result filtering, collation, etc. </para>
            
             <para>Lucene's core collectors are derived from Collector.
             Likely your application can use one of these classes, or
             subclass <see cref="T:Lucene.Net.Search.TopDocsCollector`1"/>, instead of
             implementing <see cref="T:Lucene.Net.Search.ICollector"/> directly:
            
             <list type="bullet">
            
               <item><description><see cref="T:Lucene.Net.Search.TopDocsCollector`1"/> is an abstract base class
               that assumes you will retrieve the top N docs,
               according to some criteria, after collection is
               done.  </description></item>
            
               <item><description><see cref="T:Lucene.Net.Search.TopScoreDocCollector"/> is a concrete subclass
               <see cref="T:Lucene.Net.Search.TopDocsCollector`1"/> and sorts according to score +
               docID.  This is used internally by the 
               <see cref="T:Lucene.Net.Search.IndexSearcher"/> search methods that do not take an
               explicit <see cref="T:Lucene.Net.Search.Sort"/>. It is likely the most frequently
               used collector.</description></item>
            
               <item><description><see cref="T:Lucene.Net.Search.TopFieldCollector"/> subclasses 
               <see cref="T:Lucene.Net.Search.TopDocsCollector`1"/> and sorts according to a specified
               <see cref="T:Lucene.Net.Search.Sort"/> object (sort by field).  This is used
               internally by the <see cref="T:Lucene.Net.Search.IndexSearcher"/> search methods
               that take an explicit <see cref="T:Lucene.Net.Search.Sort"/>.</description></item>
            
               <item><description><see cref="T:Lucene.Net.Search.TimeLimitingCollector"/>, which wraps any other
               Collector and aborts the search if it's taken too much
               time.</description></item>
            
               <item><description><see cref="T:Lucene.Net.Search.PositiveScoresOnlyCollector"/> wraps any other
               <see cref="T:Lucene.Net.Search.ICollector"/> and prevents collection of hits whose score
               is &lt;= 0.0</description></item>
            
             </list>
             </para>
            
             <para><see cref="T:Lucene.Net.Search.ICollector"/> decouples the score from the collected doc:
             the score computation is skipped entirely if it's not
             needed.  Collectors that do need the score should
             implement the <see cref="M:Lucene.Net.Search.ICollector.SetScorer(Lucene.Net.Search.Scorer)"/> method, to hold onto the
             passed <see cref="T:Lucene.Net.Search.Scorer"/> instance, and call 
             <see cref="M:Lucene.Net.Search.Scorer.GetScore"/> within the collect method to compute the
             current hit's score.  If your collector may request the
             score for a single hit multiple times, you should use
             <see cref="T:Lucene.Net.Search.ScoreCachingWrappingScorer"/>. </para>
            
             <para><b>NOTE:</b> The doc that is passed to the collect
             method is relative to the current reader. If your
             collector needs to resolve this to the docID space of the
             Multi*Reader, you must re-base it by recording the
             docBase from the most recent <see cref="M:Lucene.Net.Search.ICollector.SetNextReader(Lucene.Net.Index.AtomicReaderContext)"/> call.  Here's
             a simple example showing how to collect docIDs into an
             <see cref="T:Lucene.Net.Util.OpenBitSet"/>:</para>
            
             <code>
             private class MySearchCollector : ICollector
             {
                 private readonly OpenBitSet bits;
                 private int docBase;
             
                 public MySearchCollector(OpenBitSet bits)
                 {
                     if (bits == null) throw new ArgumentNullException("bits");
                     this.bits = bits;
                 }
             
                 // ignore scorer
                 public void SetScorer(Scorer scorer)
                 { 
                 }
                 
                 // accept docs out of order (for a BitSet it doesn't matter)
                 public bool AcceptDocsOutOfOrder
                 {
                     get { return true; }
                 }
                 
                 public void Collect(int doc)
                 {
                     bits.Set(doc + docBase);
                 }
                 
                 public void SetNextReader(AtomicReaderContext context)
                 {
                     this.docBase = context.DocBase;
                 }
             }
             
             IndexSearcher searcher = new IndexSearcher(indexReader);
             OpenBitSet bits = new OpenBitSet(indexReader.MaxDoc);
             searcher.Search(query, new MySearchCollector(bits));
             </code>
            
             <para>Not all collectors will need to rebase the docID.  For
             example, a collector that simply counts the total number
             of hits would skip it.</para>
            
             <para><b>NOTE:</b> Prior to 2.9, Lucene silently filtered
             out hits with score &lt;= 0.  As of 2.9, the core <see cref="T:Lucene.Net.Search.ICollector"/>s
             no longer do that.  It's very unusual to have such hits
             (a negative query boost, or function query returning
             negative custom scores, could cause it to happen).  If
             you need that behavior, use 
             <see cref="T:Lucene.Net.Search.PositiveScoresOnlyCollector"/>.</para>
            
             @lucene.experimental
             <para/>
             @since 2.9
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.ICollector.SetScorer(Lucene.Net.Search.Scorer)">
            <summary>
            Called before successive calls to <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/>. Implementations
            that need the score of the current document (passed-in to
            <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/>), should save the passed-in <see cref="T:Lucene.Net.Search.Scorer"/> and call
            <c>scorer.GetScore()</c> when needed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ICollector.Collect(System.Int32)">
            <summary>
            Called once for every document matching a query, with the unbased document
            number.
            <para/>Note: The collection of the current segment can be terminated by throwing
            a <see cref="T:Lucene.Net.Search.CollectionTerminatedException"/>. In this case, the last docs of the
            current <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> will be skipped and <see cref="T:Lucene.Net.Search.IndexSearcher"/>
            will swallow the exception and continue collection with the next leaf.
            <para/>
            Note: this is called in an inner search loop. For good search performance,
            implementations of this method should not call <see cref="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)"/> or
            <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/> on every hit.
            Doing so can slow searches by an order of magnitude or more.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ICollector.SetNextReader(Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Called before collecting from each <see cref="T:Lucene.Net.Index.AtomicReaderContext"/>. All doc ids in
            <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/> will correspond to <see cref="P:Lucene.Net.Index.IndexReaderContext.Reader"/>.
            <para/>
            Add <see cref="P:Lucene.Net.Index.AtomicReaderContext.DocBase"/> to the current <see cref="P:Lucene.Net.Index.IndexReaderContext.Reader"/>'s
            internal document id to re-base ids in <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/>.
            </summary>
            <param name="context">next atomic reader context </param>
        </member>
        <member name="P:Lucene.Net.Search.ICollector.AcceptsDocsOutOfOrder">
             <summary>
             Return <c>true</c> if this collector does not
             require the matching docIDs to be delivered in int sort
             order (smallest to largest) to <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/>.
            
             <para> Most Lucene Query implementations will visit
             matching docIDs in order.  However, some queries
             (currently limited to certain cases of <see cref="T:Lucene.Net.Search.BooleanQuery"/>) 
             can achieve faster searching if the
             <see cref="T:Lucene.Net.Search.ICollector"/> allows them to deliver the
             docIDs out of order.</para>
            
             <para> Many collectors don't mind getting docIDs out of
             order, so it's important to return <c>true</c>
             here.</para>
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.Collector">
            <summary>
            LUCENENET specific class used to hold the 
            <see cref="M:Lucene.Net.Search.Collector.NewAnonymous(System.Action{Lucene.Net.Search.Scorer},System.Action{System.Int32},System.Action{Lucene.Net.Index.AtomicReaderContext},System.Func{System.Boolean})"/> static method.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Collector.NewAnonymous(System.Action{Lucene.Net.Search.Scorer},System.Action{System.Int32},System.Action{Lucene.Net.Index.AtomicReaderContext},System.Func{System.Boolean})">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Search.ICollector.SetScorer(Lucene.Net.Search.Scorer)"/>
            method through the <paramref name="setScorer"/> parameter, the body of the <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/>
            method through the <paramref name="collect"/> parameter, the body of the <see cref="M:Lucene.Net.Search.ICollector.SetNextReader(Lucene.Net.Index.AtomicReaderContext)"/>
            method through the <paramref name="setNextReader"/> parameter, and the body of the <see cref="P:Lucene.Net.Search.ICollector.AcceptsDocsOutOfOrder"/>
            property through the <paramref name="acceptsDocsOutOfOrder"/> parameter.
            Simple example:
            <code>
                IndexSearcher searcher = new IndexSearcher(indexReader);
                OpenBitSet bits = new OpenBitSet(indexReader.MaxDoc);
                int docBase;
                searcher.Search(query, 
                    Collector.NewAnonymous(setScorer: (scorer) =>
                    {
                        // ignore scorer
                    }, collect: (doc) =>
                    {
                        bits.Set(doc + docBase);
                    }, setNextReader: (context) =>
                    {
                        docBase = context.DocBase;
                    }, acceptsDocsOutOfOrder: () =>
                    {
                        return true;
                    })
                );
            </code>
            </summary>
            <param name="setScorer">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Search.ICollector.SetScorer(Lucene.Net.Search.Scorer)"/> 
            method. It accepts a <see cref="T:Lucene.Net.Search.Scorer"/> scorer and 
            has no return value.
            </param>
            <param name="collect">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/> 
            method. It accepts an <see cref="T:System.Int32"/> doc and 
            has no return value.
            </param>
            <param name="setNextReader">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Search.ICollector.SetNextReader(Lucene.Net.Index.AtomicReaderContext)"/> 
            method. It accepts a <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> context and 
            has no return value.
            </param>
            <param name="acceptsDocsOutOfOrder">
            A delegate method that represents (is called by) the <see cref="P:Lucene.Net.Search.ICollector.AcceptsDocsOutOfOrder"/> 
            property. It returns a <see cref="T:System.Boolean"/> value.
            </param>
            <returns> A new <see cref="T:Lucene.Net.Search.Collector.AnonymousCollector"/> instance. </returns>
        </member>
        <member name="T:Lucene.Net.Search.ComplexExplanation">
            <summary>
            Expert: Describes the score computation for document and query, and
            can distinguish a match independent of a positive value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.ComplexExplanation.Match">
            <summary>
            Gets or Sets the match status assigned to this explanation node. 
            May be <c>null</c> if match status is unknown.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.ComplexExplanation.IsMatch">
             <summary>
             Indicates whether or not this <see cref="T:Lucene.Net.Search.Explanation"/> models a good match.
            
             <para>
             If the match status is explicitly set (i.e.: not null) this method
             uses it; otherwise it defers to the superclass.
             </para> </summary>
             <seealso cref="P:Lucene.Net.Search.ComplexExplanation.Match"/>
        </member>
        <member name="T:Lucene.Net.Search.ConjunctionScorer">
            <summary>
            Scorer for conjunctions, sets of queries, all of which are required. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ConstantScoreAutoRewrite">
            <summary>
            A rewrite method that tries to pick the best
            constant-score rewrite method based on term and
            document counts from the query.  If both the number of
            terms and documents is small enough, then 
            <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE"/> is used.
            Otherwise, <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE"/> is
            used.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.ConstantScoreAutoRewrite.DEFAULT_TERM_COUNT_CUTOFF">
            <summary>
            Defaults derived from rough tests with a 20.0 million
            doc Wikipedia index.  With more than 350 terms in the
            query, the filter method is fastest:
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.ConstantScoreAutoRewrite.DEFAULT_DOC_COUNT_PERCENT">
            <summary>
            If the query will hit more than 1 in 1000 of the docs
            in the index (0.1%), the filter method is fastest:
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.ConstantScoreAutoRewrite.TermCountCutoff">
            <summary>
            If the number of terms in this query is equal to or
            larger than this setting then 
            <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE"/> is used.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.ConstantScoreAutoRewrite.DocCountPercent">
            <summary>
            If the number of documents to be visited in the
            postings exceeds this specified percentage of the
            <see cref="P:Lucene.Net.Index.IndexReader.MaxDoc"/> for the index, then
            <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE"/> is used. 
            Value may be 0.0 to 100.0.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ConstantScoreAutoRewrite.TermStateByteStart">
            <summary>
            Special implementation of <see cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/> that keeps parallel arrays for <see cref="T:Lucene.Net.Index.TermContext"/> </summary>
        </member>
        <member name="T:Lucene.Net.Search.ConstantScoreQuery">
            <summary>
            A query that wraps another query or a filter and simply returns a constant score equal to the
            query boost for every document that matches the filter or query.
            For queries it therefore simply strips of all scores and returns a constant one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.#ctor(Lucene.Net.Search.Query)">
            <summary>
            Strips off scores from the passed in <see cref="T:Lucene.Net.Search.Query"/>. The hits will get a constant score
            dependent on the boost factor of this query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.#ctor(Lucene.Net.Search.Filter)">
            <summary>
            Wraps a <see cref="T:Lucene.Net.Search.Filter"/> as a <see cref="T:Lucene.Net.Search.Query"/>. The hits will get a constant score
            dependent on the boost factor of this query.
            If you simply want to strip off scores from a <see cref="T:Lucene.Net.Search.Query"/>, no longer use
            <c>new ConstantScoreQuery(new QueryWrapperFilter(query))</c>, instead
            use <see cref="M:Lucene.Net.Search.ConstantScoreQuery.#ctor(Lucene.Net.Search.Query)"/>!
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.ConstantScoreQuery.Filter">
            <summary>
            Returns the encapsulated filter, returns <c>null</c> if a query is wrapped. </summary>
        </member>
        <member name="P:Lucene.Net.Search.ConstantScoreQuery.Query">
            <summary>
            Returns the encapsulated query, returns <c>null</c> if a filter is wrapped. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ConstantScoreQuery.ConstantBulkScorer">
            <summary>
            We return this as our <see cref="T:Lucene.Net.Search.BulkScorer"/> so that if the CSQ
            wraps a query with its own optimized top-level
            scorer (e.g. <see cref="T:Lucene.Net.Search.BooleanScorer"/>) we can use that
            top-level scorer.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ControlledRealTimeReopenThread`1">
            <summary>
            Utility class that runs a thread to manage periodic
            reopens of a <see cref="T:Lucene.Net.Search.ReferenceManager`1"/>, with methods to wait for a specific
            index changes to become visible.  To use this class you
            must first wrap your <see cref="T:Lucene.Net.Index.IndexWriter"/> with a
            <see cref="T:Lucene.Net.Index.TrackingIndexWriter"/> and always use it to make changes
            to the index, saving the returned generation.  Then,
            when a given search request needs to see a specific
            index change, call the <see cref="M:Lucene.Net.Search.ControlledRealTimeReopenThread`1.WaitForGeneration(System.Int64)"/> to wait for
            that change to be visible.  Note that this will only
            scale well if most searches do not need to wait for a
            specific index generation.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ControlledRealTimeReopenThread`1.#ctor(Lucene.Net.Index.TrackingIndexWriter,Lucene.Net.Search.ReferenceManager{`0},System.Double,System.Double)">
            <summary>
            Create <see cref="T:Lucene.Net.Search.ControlledRealTimeReopenThread`1"/>, to periodically
            reopen the a <see cref="T:Lucene.Net.Search.ReferenceManager`1"/>.
            </summary>
            <param name="targetMaxStaleSec"> Maximum time until a new
                   reader must be opened; this sets the upper bound
                   on how slowly reopens may occur, when no
                   caller is waiting for a specific generation to
                   become visible.
            </param>
            <param name="targetMinStaleSec"> Mininum time until a new
                   reader can be opened; this sets the lower bound
                   on how quickly reopens may occur, when a caller
                   is waiting for a specific generation to
                   become visible. </param>
        </member>
        <member name="M:Lucene.Net.Search.ControlledRealTimeReopenThread`1.WaitForGeneration(System.Int64)">
            <summary>
            Waits for the target generation to become visible in
            the searcher.
            If the current searcher is older than the
            target generation, this method will block
            until the searcher is reopened, by another via
            <see cref="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh"/> or until the <see cref="T:Lucene.Net.Search.ReferenceManager`1"/> is closed.
            </summary>
            <param name="targetGen"> The generation to wait for </param>
        </member>
        <member name="M:Lucene.Net.Search.ControlledRealTimeReopenThread`1.WaitForGeneration(System.Int64,System.Int32)">
            <summary>
            Waits for the target generation to become visible in
            the searcher, up to a maximum specified milli-seconds.
            If the current searcher is older than the target
            generation, this method will block until the
            searcher has been reopened by another thread via
            <see cref="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh"/>, the given waiting time has elapsed, or until
            the <see cref="T:Lucene.Net.Search.ReferenceManager`1"/> is closed.
            <para/>
            NOTE: if the waiting time elapses before the requested target generation is
            available the current <see cref="T:Lucene.Net.Search.SearcherManager"/> is returned instead.
            </summary>
            <param name="targetGen">
                     The generation to wait for </param>
            <param name="maxMS">
                     Maximum milliseconds to wait, or -1 to wait indefinitely </param>
            <returns> <c>true</c> if the <paramref name="targetGen"/> is now available,
                    or false if <paramref name="maxMS"/> wait time was exceeded </returns>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxQuery">
            <summary>
            A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum
            score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries.
            This is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be
            combined equivalently into a single search field).  We want the primary score to be the one associated with the highest boost,
            not the sum of the field scores (as <see cref="T:Lucene.Net.Search.BooleanQuery"/> would give).
            <para/>
            If the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching
            another gets a higher score than "albino" matching both fields.
            <para/>
            To get this result, use both <see cref="T:Lucene.Net.Search.BooleanQuery"/> and <see cref="T:Lucene.Net.Search.DisjunctionMaxQuery"/>:  for each term a <see cref="T:Lucene.Net.Search.DisjunctionMaxQuery"/> searches for it in
            each field, while the set of these <see cref="T:Lucene.Net.Search.DisjunctionMaxQuery"/>'s is combined into a <see cref="T:Lucene.Net.Search.BooleanQuery"/>.
            The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that
            include this term in only the best of those multiple fields, without confusing this with the better case of two different terms
            in the multiple fields.
            <para/>
            Collection initializer note: To create and populate a <see cref="T:Lucene.Net.Search.DisjunctionMaxQuery"/>
            in a single statement, you can use the following example as a guide:
            
            <code>
            var disjunctionMaxQuery = new DisjunctionMaxQuery(0.1f) {
                new TermQuery(new Term("field1", "albino")), 
                new TermQuery(new Term("field2", "elephant"))
            };
            </code>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionMaxQuery.disjuncts">
            <summary>
            The subqueries
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionMaxQuery.tieBreakerMultiplier">
            <summary>
            Multiple of the non-max disjunct scores added into our final score.  Non-zero values support tie-breaking.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.#ctor(System.Single)">
            <summary>
            Creates a new empty <see cref="T:Lucene.Net.Search.DisjunctionMaxQuery"/>.  Use <see cref="M:Lucene.Net.Search.DisjunctionMaxQuery.Add(Lucene.Net.Search.Query)"/> to add the subqueries. </summary>
            <param name="tieBreakerMultiplier"> The score of each non-maximum disjunct for a document is multiplied by this weight
                   and added into the final score.  If non-zero, the value should be small, on the order of 0.1, which says that
                   10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique
                   word in the lower scored field (i.e., one that is not in any higher scored field). </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.#ctor(System.Collections.Generic.ICollection{Lucene.Net.Search.Query},System.Single)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Search.DisjunctionMaxQuery"/> </summary>
            <param name="disjuncts"> A <see cref="T:ICollection{Query}"/> of all the disjuncts to add </param>
            <param name="tieBreakerMultiplier"> The weight to give to each matching non-maximum disjunct </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Add(Lucene.Net.Search.Query)">
            <summary>
            Add a subquery to this disjunction </summary>
            <param name="query"> The disjunct added </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Add(System.Collections.Generic.ICollection{Lucene.Net.Search.Query})">
            <summary>
            Add a collection of disjuncts to this disjunction
            via <see cref="T:IEnumerable{Query}"/> </summary>
            <param name="disjuncts"> A collection of queries to add as disjuncts. </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.GetEnumerator">
            <returns> An <see cref="T:IEnumerator{Query}"/> over the disjuncts </returns>
        </member>
        <member name="P:Lucene.Net.Search.DisjunctionMaxQuery.Disjuncts">
            <returns> The disjuncts. </returns>
        </member>
        <member name="P:Lucene.Net.Search.DisjunctionMaxQuery.TieBreakerMultiplier">
            <returns> Tie breaker value for multiple matches. </returns>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight">
             <summary>
             Expert: the Weight for DisjunctionMaxQuery, used to
             normalize, score and explain these queries.
            
             <para>NOTE: this API and implementation is subject to
             change suddenly in the next release.</para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.m_weights">
            <summary>
            The <see cref="T:Lucene.Net.Search.Weight"/>s for our subqueries, in 1-1 correspondence with disjuncts </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.#ctor(Lucene.Net.Search.DisjunctionMaxQuery,Lucene.Net.Search.IndexSearcher)">
            <summary>
            Construct the <see cref="T:Lucene.Net.Search.Weight"/> for this <see cref="T:Lucene.Net.Search.Query"/> searched by <paramref name="searcher"/>.  Recursively construct subquery weights. </summary>
        </member>
        <member name="P:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.Query">
            <summary>
            Return our associated <see cref="T:Lucene.Net.Search.DisjunctionMaxQuery"/> </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.GetValueForNormalization">
            <summary>
            Compute the sub of squared weights of us applied to our subqueries.  Used for normalization. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.Normalize(System.Single,System.Single)">
            <summary>
            Apply the computed normalization factor to our subqueries </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.GetScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            Create the scorer used to score our associated <see cref="T:Lucene.Net.Search.DisjunctionMaxQuery"/> </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.Explain(Lucene.Net.Index.AtomicReaderContext,System.Int32)">
            <summary>
            Explain the score we computed for doc </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.CreateWeight(Lucene.Net.Search.IndexSearcher)">
            <summary>
            Create the <see cref="T:Lucene.Net.Search.Weight"/> used to score us </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>
            Optimize our representation and our subqueries representations </summary>
            <param name="reader"> The <see cref="T:Lucene.Net.Index.IndexReader"/> we query </param>
            <returns> An optimized copy of us (which may not be a copy if there is nothing to optimize)  </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Clone">
            <summary>
            Create a shallow copy of us -- used in rewriting if necessary </summary>
            <returns> A copy of us (but reuse, don't copy, our subqueries)  </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.ExtractTerms(System.Collections.Generic.ISet{Lucene.Net.Index.Term})">
            <summary>
            Expert: adds all terms occurring in this query to the terms set. Only
            works if this query is in its rewritten (<see cref="M:Lucene.Net.Search.DisjunctionMaxQuery.Rewrite(Lucene.Net.Index.IndexReader)"/>) form.
            </summary>
            <exception cref="T:System.InvalidOperationException"> If this query is not yet rewritten </exception>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.ToString(System.String)">
            <summary>
            Prettyprint us. </summary>
            <param name="field"> The field to which we are applied </param>
            <returns> A string that shows what we do, of the form "(disjunct1 | disjunct2 | ... | disjunctn)^boost" </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Equals(System.Object)">
            <summary>
            Return <c>true</c> if we represent the same query as <paramref name="o"/> </summary>
            <param name="o"> Another object </param>
            <returns> <c>true</c> if <paramref name="o"/> is a <see cref="T:Lucene.Net.Search.DisjunctionMaxQuery"/> with the same boost and the same subqueries, in the same order, as us </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.GetHashCode">
            <summary>
            Compute a hash code for hashing us </summary>
            <returns> the hash code </returns>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxScorer">
            <summary>
            The <see cref="T:Lucene.Net.Search.Scorer"/> for <see cref="T:Lucene.Net.Search.DisjunctionMaxQuery"/>.  The union of all documents generated by the the subquery scorers
            is generated in document number order.  The score for each document is the maximum of the scores computed
            by the subquery scorers that generate that document, plus <see cref="F:Lucene.Net.Search.DisjunctionMaxScorer.tieBreakerMultiplier"/> times the sum of the scores
            for the other subqueries that generate the document.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionMaxScorer.tieBreakerMultiplier">
            <summary>Multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result.</summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionMaxScorer.scoreSum">
            <summary>Used when scoring currently matching doc.</summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.#ctor(Lucene.Net.Search.Weight,System.Single,Lucene.Net.Search.Scorer[])">
            <summary>
            Creates a new instance of <see cref="T:Lucene.Net.Search.DisjunctionMaxScorer"/>
            </summary>
            <param name="weight">
                     The <see cref="T:Lucene.Net.Search.Weight"/> to be used. </param>
            <param name="tieBreakerMultiplier">
                     Multiplier applied to non-maximum-scoring subqueries for a
                     document as they are summed into the result. </param>
            <param name="subScorers">
                     The sub scorers this <see cref="T:Lucene.Net.Search.Scorer"/> should iterate on </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.GetScore">
            <summary>
            Determine the current document score.  Initially invalid, until <see cref="M:Lucene.Net.Search.DocIdSetIterator.NextDoc"/> is called the first time. </summary>
            <returns> The score of the current generated document </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.ScoreAll(System.Int32)">
            <summary>
            Recursively iterate all subScorers that generated last doc computing sum and max
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionScorer">
            <summary>
            Base class for <see cref="T:Lucene.Net.Search.Scorer"/>s that score disjunctions.
            Currently this just provides helper methods to manage the heap.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionScorer.m_doc">
            <summary>
            The document number of the current match. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionScorer.Heapify">
            <summary>
            Organize subScorers into a min heap with scorers generating the earliest document on top.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionScorer.HeapAdjust(System.Int32)">
            <summary>
            The subtree of subScorers at root is a min heap except possibly for its root element.
            Bubble the root down as required to make the subtree a heap.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionScorer.HeapRemoveRoot">
            <summary>
            Remove the root <see cref="T:Lucene.Net.Search.Scorer"/> from subScorers and re-establish it as a heap
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionScorer.AfterNext">
            <summary>
            Called after <see cref="M:Lucene.Net.Search.DisjunctionScorer.NextDoc"/> or <see cref="M:Lucene.Net.Search.DisjunctionScorer.Advance(System.Int32)"/> land on a new document.
            <para/>
            <c>subScorers[0]</c> will be positioned to the new docid,
            which could be <c>NO_MORE_DOCS</c> (subclass must handle this).
            <para/>
            Implementations should assign <c>doc</c> appropriately, and do any
            other work necessary to implement <see cref="M:Lucene.Net.Search.Scorer.GetScore"/> and <see cref="P:Lucene.Net.Index.DocsEnum.Freq"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionSumScorer">
            <summary>
            A <see cref="T:Lucene.Net.Search.Scorer"/> for OR like queries, counterpart of <see cref="T:Lucene.Net.Search.ConjunctionScorer"/>.
            This <see cref="T:Lucene.Net.Search.Scorer"/> implements <see cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/> and uses Advance() on the given <see cref="T:Lucene.Net.Search.Scorer"/>s.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.m_nrMatchers">
            <summary>
            The number of subscorers that provide the current match. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.#ctor(Lucene.Net.Search.Weight,Lucene.Net.Search.Scorer[],System.Single[])">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.DisjunctionScorer"/>. </summary>
            <param name="weight"> The weight to be used. </param>
            <param name="subScorers"> Array of at least two subscorers. </param>
            <param name="coord"> Table of coordination factors </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.GetScore">
            <summary>
            Returns the score of the current document matching the query.
            Initially invalid, until <see cref="M:Lucene.Net.Search.DisjunctionScorer.NextDoc"/> is called the first time.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DocIdSet">
            <summary>
            A <see cref="T:Lucene.Net.Search.DocIdSet"/> contains a set of doc ids. Implementing classes must
            only implement <see cref="M:Lucene.Net.Search.DocIdSet.GetIterator"/> to provide access to the set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSet.GetIterator">
            <summary>
            Provides a <see cref="T:Lucene.Net.Search.DocIdSetIterator"/> to access the set.
            This implementation can return <c>null</c> if there
            are no docs that match.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocIdSet.Bits">
            <summary>
            Optionally provides a <see cref="T:Lucene.Net.Util.IBits"/> interface for random access
            to matching documents. </summary>
            <returns> <c>null</c>, if this <see cref="T:Lucene.Net.Search.DocIdSet"/> does not support random access.
            In contrast to <see cref="M:Lucene.Net.Search.DocIdSet.GetIterator"/>, a return value of <c>null</c>
            <b>does not</b> imply that no documents match the filter!
            The default implementation does not provide random access, so you
            only need to implement this method if your <see cref="T:Lucene.Net.Search.DocIdSet"/> can
            guarantee random access to every docid in O(1) time without
            external disk access (as <see cref="T:Lucene.Net.Util.IBits"/> interface cannot throw
            <see cref="T:System.IO.IOException"/>). This is generally true for bit sets
            like <see cref="T:Lucene.Net.Util.FixedBitSet"/>, which return
            itself if they are used as <see cref="T:Lucene.Net.Search.DocIdSet"/>. </returns>
        </member>
        <member name="P:Lucene.Net.Search.DocIdSet.IsCacheable">
            <summary>
            This method is a hint for <see cref="T:Lucene.Net.Search.CachingWrapperFilter"/>, if this <see cref="T:Lucene.Net.Search.DocIdSet"/>
            should be cached without copying it. The default is to return
            <c>false</c>. If you have an own <see cref="T:Lucene.Net.Search.DocIdSet"/> implementation
            that does its iteration very effective and fast without doing disk I/O,
            override this property and return <c>true</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSet.NewAnonymous(System.Func{Lucene.Net.Search.DocIdSetIterator})">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Search.DocIdSet.GetIterator"/>
            method through the <paramref name="getIterator"/> parameter.
            Simple example:
            <code>
                var docIdSet = DocIdSet.NewAnonymous(getIterator: () =>
                {
                    OpenBitSet bitset = new OpenBitSet(5);
                    bitset.Set(0, 5);
                    return new DocIdBitSet(bitset);
                });
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="getIterator">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Search.DocIdSet.GetIterator"/> 
            method. It returns the <see cref="T:Lucene.Net.Search.DocIdSetIterator"/> for this <see cref="T:Lucene.Net.Search.DocIdSet"/>.
            </param>
            <returns> A new <see cref="T:Lucene.Net.Search.DocIdSet.AnonymousDocIdSet"/> instance. </returns>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSet.NewAnonymous(System.Func{Lucene.Net.Search.DocIdSetIterator},System.Func{Lucene.Net.Util.IBits})">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Search.DocIdSet.GetIterator"/>
            method through the <paramref name="getIterator"/> parameter and the body of the <see cref="P:Lucene.Net.Search.DocIdSet.Bits"/>
            property through the <paramref name="bits"/> parameter.
            Simple example:
            <code>
                var docIdSet = DocIdSet.NewAnonymous(getIterator: () =>
                {
                    OpenBitSet bitset = new OpenBitSet(5);
                    bitset.Set(0, 5);
                    return new DocIdBitSet(bitset);
                }, bits: () => 
                {
                    return bits;
                });
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="getIterator">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Search.DocIdSet.GetIterator"/> 
            method. It returns the <see cref="T:Lucene.Net.Search.DocIdSetIterator"/> for this <see cref="T:Lucene.Net.Search.DocIdSet"/>.
            </param>
            <param name="bits">
            A delegate method that represents (is called by) the <see cref="P:Lucene.Net.Search.DocIdSet.Bits"/>
            property. It returns the <see cref="T:Lucene.Net.Util.IBits"/> instance for this <see cref="T:Lucene.Net.Search.DocIdSet"/>.
            </param>
            <returns> A new <see cref="T:Lucene.Net.Search.DocIdSet.AnonymousDocIdSet"/> instance. </returns>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSet.NewAnonymous(System.Func{Lucene.Net.Search.DocIdSetIterator},System.Func{System.Boolean})">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Search.DocIdSet.GetIterator"/>
            method through the <paramref name="getIterator"/> parameter and the body of the <see cref="P:Lucene.Net.Search.DocIdSet.IsCacheable"/>
            property through the <paramref name="isCacheable"/> parameter.
            Simple example:
            <code>
                var docIdSet = DocIdSet.NewAnonymous(getIterator: () =>
                {
                    OpenBitSet bitset = new OpenBitSet(5);
                    bitset.Set(0, 5);
                    return new DocIdBitSet(bitset);
                }, isCacheable: () =>
                {
                    return true;
                });
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="getIterator">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Search.DocIdSet.GetIterator"/> 
            method. It returns the <see cref="T:Lucene.Net.Search.DocIdSetIterator"/> for this <see cref="T:Lucene.Net.Search.DocIdSet"/>.
            </param>
            <param name="isCacheable">
            A delegate method that represents (is called by) the <see cref="P:Lucene.Net.Search.DocIdSet.IsCacheable"/>
            property. It returns a <see cref="T:System.Boolean"/> value.
            </param>
            <returns> A new <see cref="T:Lucene.Net.Search.DocIdSet.AnonymousDocIdSet"/> instance. </returns>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSet.NewAnonymous(System.Func{Lucene.Net.Search.DocIdSetIterator},System.Func{Lucene.Net.Util.IBits},System.Func{System.Boolean})">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Search.DocIdSet.GetIterator"/>
            method through the <paramref name="getIterator"/> parameter and the body of the <see cref="P:Lucene.Net.Search.DocIdSet.Bits"/>
            property through the <paramref name="bits"/> parameter.
            Simple example:
            <code>
                var docIdSet = DocIdSet.NewAnonymous(getIterator: () =>
                {
                    OpenBitSet bitset = new OpenBitSet(5);
                    bitset.Set(0, 5);
                    return new DocIdBitSet(bitset);
                }, bits: () => 
                {
                    return bits;
                }, isCacheable: () =>
                {
                    return true;
                });
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="getIterator">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Search.DocIdSet.GetIterator"/> 
            method. It returns the <see cref="T:Lucene.Net.Search.DocIdSetIterator"/> for this <see cref="T:Lucene.Net.Search.DocIdSet"/>.
            </param>
            <param name="bits">
            A delegate method that represents (is called by) the <see cref="P:Lucene.Net.Search.DocIdSet.Bits"/>
            property. It returns the <see cref="T:Lucene.Net.Util.IBits"/> instance for this <see cref="T:Lucene.Net.Search.DocIdSet"/>.
            </param>
            <param name="isCacheable">
            A delegate method that represents (is called by) the <see cref="P:Lucene.Net.Search.DocIdSet.IsCacheable"/>
            property. It returns a <see cref="T:System.Boolean"/> value.
            </param>
            <returns> A new <see cref="T:Lucene.Net.Search.DocIdSet.AnonymousDocIdSet"/> instance. </returns>
        </member>
        <member name="T:Lucene.Net.Search.DocIdSetIterator">
            <summary>
            This abstract class defines methods to iterate over a set of non-decreasing
            doc ids. Note that this class assumes it iterates on doc Ids, and therefore
            <see cref="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS"/> is set to <see cref="F:System.Int32.MaxValue"/> in order to be used as
            a sentinel object. Implementations of this class are expected to consider
            <see cref="F:System.Int32.MaxValue"/> as an invalid value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSetIterator.GetEmpty">
            <summary>
            An empty <see cref="T:Lucene.Net.Search.DocIdSetIterator"/> instance </summary>
        </member>
        <member name="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS">
            <summary>
            When returned by <see cref="M:Lucene.Net.Search.DocIdSetIterator.NextDoc"/>, <see cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/> and
            <see cref="P:Lucene.Net.Search.DocIdSetIterator.DocID"/> it means there are no more docs in the iterator.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocIdSetIterator.DocID">
             <summary>
             Returns the following:
             <list type="bullet">
             <item><description>-1 or <see cref="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS"/> if <see cref="M:Lucene.Net.Search.DocIdSetIterator.NextDoc"/> or
             <seealso cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/> were not called yet.</description></item>
             <item><description><see cref="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS"/> if the iterator has exhausted.</description></item>
             <item><description>Otherwise it should return the doc ID it is currently on.</description></item>
             </list>
             <para/>
            
             @since 2.9
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSetIterator.NextDoc">
             <summary>
             Advances to the next document in the set and returns the doc it is
             currently on, or <see cref="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS"/> if there are no more docs in the
             set.
            
             <para/><b>NOTE:</b> after the iterator has exhausted you should not call this
             method, as it may result in unpredicted behavior.
             <para/>
             @since 2.9
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)">
             <summary>
             Advances to the first beyond the current whose document number is greater
             than or equal to <i>target</i>, and returns the document number itself.
             Exhausts the iterator and returns <see cref="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS"/> if <i>target</i>
             is greater than the highest document number in the set.
             <para/>
             The behavior of this method is <b>undefined</b> when called with
             <c> target &lt;= current</c>, or after the iterator has exhausted.
             Both cases may result in unpredicted behavior.
             <para/>
             When <c> target &gt; current</c> it behaves as if written:
            
             <code>
             int Advance(int target) 
             {
                 int doc;
                 while ((doc = NextDoc()) &lt; target) 
                 {
                 }
                 return doc;
             }
             </code>
            
             Some implementations are considerably more efficient than that.
             <para/>
             <b>NOTE:</b> this method may be called with <see cref="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS"/> for
             efficiency by some <see cref="T:Lucene.Net.Search.Scorer"/>s. If your implementation cannot efficiently
             determine that it should exhaust, it is recommended that you check for that
             value in each call to this method.
             <para/>
            
             @since 2.9
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSetIterator.SlowAdvance(System.Int32)">
            <summary>
            Slow (linear) implementation of <see cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/> relying on
            <see cref="M:Lucene.Net.Search.DocIdSetIterator.NextDoc"/> to advance beyond the target position.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSetIterator.GetCost">
            <summary>
            Returns the estimated cost of this <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>.
            <para/>
            This is generally an upper bound of the number of documents this iterator
            might match, but may be a rough heuristic, hardcoded value, or otherwise
            completely inaccurate.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DocTermOrdsRangeFilter">
             <summary>
             A range filter built on top of a cached multi-valued term field (in <see cref="T:Lucene.Net.Search.IFieldCache"/>).
            
             <para>Like <see cref="T:Lucene.Net.Search.FieldCacheRangeFilter"/>, this is just a specialized range query versus
                using a <see cref="T:Lucene.Net.Search.TermRangeQuery"/> with <see cref="T:Lucene.Net.Search.DocTermOrdsRewriteMethod"/>: it will only do
                two ordinal to term lookups.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocTermOrdsRangeFilter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            This method is implemented for each data type </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocTermOrdsRangeFilter.NewBytesRefRange(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
            <summary>
            Creates a BytesRef range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetTermsIndex(Lucene.Net.Index.AtomicReader,System.String,System.Single)"/>. This works with all
            fields containing zero or one term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.Field">
            <summary>
            Returns the field name for this filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.IncludesLower">
            <summary>
            Returns <c>true</c> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.IncludesUpper">
            <summary>
            Returns <c>true</c> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.LowerVal">
            <summary>
            Returns the lower value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.UpperVal">
            <summary>
            Returns the upper value of this range filter </summary>
        </member>
        <member name="T:Lucene.Net.Search.DocTermOrdsRewriteMethod">
            <summary>
            Rewrites <see cref="T:Lucene.Net.Search.MultiTermQuery"/>s into a filter, using DocTermOrds for term enumeration.
            <para>
            This can be used to perform these queries against an unindexed docvalues field.
            </para>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocTermOrdsRewriteMethod.MultiTermQueryDocTermOrdsWrapperFilter.#ctor(Lucene.Net.Search.MultiTermQuery)">
            <summary>
            Wrap a <see cref="T:Lucene.Net.Search.MultiTermQuery"/> as a <see cref="T:Lucene.Net.Search.Filter"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRewriteMethod.MultiTermQueryDocTermOrdsWrapperFilter.Field">
            <summary>
            Returns the field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocTermOrdsRewriteMethod.MultiTermQueryDocTermOrdsWrapperFilter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Search.DocIdSet"/> with documents that should be permitted in search
            results.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Explanation">
            <summary>
            Expert: Describes the score computation for document and query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Explanation.IsMatch">
             <summary>
             Indicates whether or not this <see cref="T:Lucene.Net.Search.Explanation"/> models a good match.
            
             <para>
             By default, an Explanation represents a "match" if the value is positive.
             </para> </summary>
             <seealso cref="P:Lucene.Net.Search.Explanation.Value"/>
        </member>
        <member name="P:Lucene.Net.Search.Explanation.Value">
            <summary>
            Gets or Sets the value assigned to this explanation node. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Explanation.Description">
            <summary>
            Gets or Sets the description of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetSummary">
            <summary>
            A short one line summary which should contain all high level
            information about this <see cref="T:Lucene.Net.Search.Explanation"/>, without the "Details"
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetDetails">
            <summary>
            The sub-nodes of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.AddDetail(Lucene.Net.Search.Explanation)">
            <summary>
            Adds a sub-node to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToString">
            <summary>
            Render an explanation as text. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToHtml">
            <summary>
            Render an explanation as HTML. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FakeScorer">
            <summary>
            Used by <see cref="T:Lucene.Net.Search.BulkScorer"/>s that need to pass a
            <see cref="T:Lucene.Net.Search.Scorer"/> to <see cref="M:Lucene.Net.Search.ICollector.SetScorer(Lucene.Net.Search.Scorer)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.IFieldCache">
             <summary>
             Expert: Maintains caches of term values.
            
             <para/>Created: May 19, 2004 11:13:14 AM
             <para/>
             @lucene.internal
             <para/>
             @since   lucene 1.4 </summary>
             <seealso cref="T:Lucene.Net.Util.FieldCacheSanityChecker"/>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <paramref name="field"/> and returns a bit set at the size of
            <c>reader.MaxDoc</c>, with turned on bits for each docid that
            does have a value for this field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetBytes(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <paramref name="field"/> as a single <see cref="T:System.Byte"/> and returns an array
            of size <c>reader.MaxDoc</c> of the value each document
            has in the given field. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the single <see cref="T:System.Byte"/> values. </param>
            <param name="setDocsWithField">  If true then <see cref="M:Lucene.Net.Search.IFieldCache.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will
                   also be computed and stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetBytes(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IByteParser,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <paramref name="field"/> as bytes and returns an array of
            size <c>reader.MaxDoc</c> of the value each document has in the
            given field. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the <see cref="T:System.Byte"/>s. </param>
            <param name="parser">  Computes <see cref="T:System.Byte"/> for string values. </param>
            <param name="setDocsWithField">  If true then <see cref="M:Lucene.Net.Search.IFieldCache.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will
                   also be computed and stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetInt16s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <paramref name="field"/> as <see cref="T:System.Int16"/>s and returns an array
            of size <c>reader.MaxDoc</c> of the value each document
            has in the given field. 
            <para/>
            NOTE: this was getShorts() in Lucene
            </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the <see cref="T:System.Int16"/>s. </param>
            <param name="setDocsWithField">  If true then <see cref="M:Lucene.Net.Search.IFieldCache.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will
                   also be computed and stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetInt16s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt16Parser,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <paramref name="field"/> as shorts and returns an array of
            size <c>reader.MaxDoc</c> of the value each document has in the
            given field. 
            <para/>
            NOTE: this was getShorts() in Lucene
            </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the <see cref="T:System.Int16"/>s. </param>
            <param name="parser">  Computes <see cref="T:System.Int16"/> for string values. </param>
            <param name="setDocsWithField">  If true then <see cref="M:Lucene.Net.Search.IFieldCache.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will
                   also be computed and stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Returns an <see cref="T:Lucene.Net.Search.FieldCache.Int32s"/> over the values found in documents in the given
            field.
            <para/>
            NOTE: this was getInts() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Search.IFieldCache.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt32Parser,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt32Parser,System.Boolean)">
            <summary>
            Returns an <see cref="T:Lucene.Net.Search.FieldCache.Int32s"/> over the values found in documents in the given
            field. If the field was indexed as <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/>, it simply
            uses <see cref="M:Lucene.Net.Index.AtomicReader.GetNumericDocValues(System.String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <paramref name="field"/> as <see cref="T:System.Int32"/>s and returns
            an array of size <c>reader.MaxDoc</c> of the value each document
            has in the given field.
            <para/>
            NOTE: this was getInts() in Lucene
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the <see cref="T:System.Int32"/>s. </param>
            <param name="parser">
                     Computes <see cref="T:System.Int32"/> for string values. May be <c>null</c> if the
                     requested field was indexed as <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/> or
                     <see cref="T:Lucene.Net.Documents.Int32Field"/>. </param>
            <param name="setDocsWithField">
                     If true then <see cref="M:Lucene.Net.Search.IFieldCache.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will also be computed and
                     stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetSingles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Search.FieldCache.Singles"/> over the values found in documents in the given
            field.
            <para/>
            NOTE: this was getFloats() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Search.IFieldCache.GetSingles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.ISingleParser,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetSingles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.ISingleParser,System.Boolean)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Search.FieldCache.Singles"/> over the values found in documents in the given
            field. If the field was indexed as <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/>, it simply
            uses <see cref="M:Lucene.Net.Index.AtomicReader.GetNumericDocValues(System.String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <paramref name="field"/> as <see cref="T:System.Single"/>s and returns
            an array of size <c>reader.MaxDoc</c> of the value each document
            has in the given field.
            <para/>
            NOTE: this was getFloats() in Lucene
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the <see cref="T:System.Single"/>s. </param>
            <param name="parser">
                     Computes <see cref="T:System.Single"/> for string values. May be <c>null</c> if the
                     requested field was indexed as <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/> or
                     <see cref="T:Lucene.Net.Documents.SingleField"/>. </param>
            <param name="setDocsWithField">
                     If true then <see cref="M:Lucene.Net.Search.IFieldCache.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will also be computed and
                     stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Search.FieldCache.Int64s"/> over the values found in documents in the given
            field.
            <para/>
            NOTE: this was getLongs() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Search.IFieldCache.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt64Parser,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt64Parser,System.Boolean)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Search.FieldCache.Int64s"/> over the values found in documents in the given
            field. If the field was indexed as <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/>, it simply
            uses <see cref="M:Lucene.Net.Index.AtomicReader.GetNumericDocValues(System.String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <paramref name="field"/> as <see cref="T:System.Int64"/>s and returns
            an array of size <c>reader.MaxDoc</c> of the value each document
            has in the given field.
            <para/>
            NOTE: this was getLongs() in Lucene
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the <see cref="T:System.Int64"/>s. </param>
            <param name="parser">
                     Computes <see cref="T:System.Int64"/> for string values. May be <c>null</c> if the
                     requested field was indexed as <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/> or
                     <see cref="T:Lucene.Net.Documents.Int64Field"/>. </param>
            <param name="setDocsWithField">
                     If true then <see cref="M:Lucene.Net.Search.IFieldCache.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will also be computed and
                     stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Search.FieldCache.Doubles"/> over the values found in documents in the given
            field.
            </summary>
            <seealso cref="M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IDoubleParser,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IDoubleParser,System.Boolean)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Search.FieldCache.Doubles"/> over the values found in documents in the given
            field. If the field was indexed as <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/>, it simply
            uses <see cref="M:Lucene.Net.Index.AtomicReader.GetNumericDocValues(System.String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <paramref name="field"/> as <see cref="T:System.Double"/>s and returns
            an array of size <c>reader.MaxDoc</c> of the value each document
            has in the given field.
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the <see cref="T:System.Double"/>s. </param>
            <param name="parser">
                     Computes <see cref="T:System.Double"/> for string values. May be <c>null</c> if the
                     requested field was indexed as <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/> or
                     <see cref="T:Lucene.Net.Documents.DoubleField"/>. </param>
            <param name="setDocsWithField">
                     If true then <see cref="M:Lucene.Net.Search.IFieldCache.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will also be computed and
                     stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetTerms(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none
            is found, reads the term values in <paramref name="field"/>
            and returns a <see cref="T:Lucene.Net.Index.BinaryDocValues"/> instance, providing a
            method to retrieve the term (as a <see cref="T:Lucene.Net.Util.BytesRef"/>) per document. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the strings. </param>
            <param name="setDocsWithField">  If true then <see cref="M:Lucene.Net.Search.IFieldCache.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will
                   also be computed and stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetTerms(Lucene.Net.Index.AtomicReader,System.String,System.Boolean,System.Single)">
            <summary>
            Expert: just like <see cref="M:Lucene.Net.Search.IFieldCache.GetTerms(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)"/>,
            but you can specify whether more RAM should be consumed in exchange for
            faster lookups (default is "true").  Note that the
            first call for a given reader and field "wins",
            subsequent calls will share the same cache entry.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetTermsIndex(Lucene.Net.Index.AtomicReader,System.String)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none
            is found, reads the term values in <paramref name="field"/>
            and returns a <see cref="T:Lucene.Net.Index.SortedDocValues"/> instance,
            providing methods to retrieve sort ordinals and terms
            (as a <see cref="T:Lucene.Net.Util.BytesRef"/>) per document. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the strings. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetTermsIndex(Lucene.Net.Index.AtomicReader,System.String,System.Single)">
            <summary>
            Expert: just like 
            <see cref="M:Lucene.Net.Search.IFieldCache.GetTermsIndex(Lucene.Net.Index.AtomicReader,System.String)"/>, but you can specify
            whether more RAM should be consumed in exchange for
            faster lookups (default is "true").  Note that the
            first call for a given reader and field "wins",
            subsequent calls will share the same cache entry.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetDocTermOrds(Lucene.Net.Index.AtomicReader,System.String)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found, reads the term values
            in <paramref name="field"/> and returns a <see cref="T:Lucene.Net.Index.SortedSetDocValues"/> instance, providing a method to retrieve
            the terms (as ords) per document.
            </summary>
            <param name="reader">  Used to build a <see cref="T:Lucene.Net.Index.SortedSetDocValues"/> instance </param>
            <param name="field">   Which field contains the strings. </param>
            <returns> a <see cref="T:Lucene.Net.Index.SortedSetDocValues"/> instance </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetCacheEntries">
            <summary>
            EXPERT: Generates an array of <see cref="T:Lucene.Net.Search.FieldCache.CacheEntry"/> objects representing all items
            currently in the <see cref="T:Lucene.Net.Search.IFieldCache"/>.
            <para>
            NOTE: These <see cref="T:Lucene.Net.Search.FieldCache.CacheEntry"/> objects maintain a strong reference to the
            Cached Values.  Maintaining references to a <see cref="T:Lucene.Net.Search.FieldCache.CacheEntry"/> the <see cref="T:Lucene.Net.Index.AtomicReader"/>
            associated with it has garbage collected will prevent the Value itself
            from being garbage collected when the Cache drops the <see cref="T:System.WeakReference"/>.
            </para>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.PurgeAllCaches">
            <summary>
            <para>
            EXPERT: Instructs the FieldCache to forcibly expunge all entries
            from the underlying caches.  This is intended only to be used for
            test methods as a way to ensure a known base state of the Cache
            (with out needing to rely on GC to free <see cref="T:System.WeakReference"/>s).
            It should not be relied on for "Cache maintenance" in general
            application code.
            </para>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.PurgeByCacheKey(System.Object)">
            <summary>
            Expert: drops all cache entries associated with this
            reader <see cref="P:Lucene.Net.Index.IndexReader.CoreCacheKey"/>.  NOTE: this cache key must
            precisely match the reader that the cache entry is
            keyed on. If you pass a top-level reader, it usually
            will have no effect as Lucene now caches at the segment
            reader level.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.IFieldCache.InfoStream">
            <summary>
            If non-null, <see cref="T:Lucene.Net.Search.FieldCacheImpl"/> will warn whenever
            entries are created that are not sane according to
            <see cref="T:Lucene.Net.Util.FieldCacheSanityChecker"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Bytes">
            <summary>
            Field values as 8-bit signed bytes
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.Bytes.Get(System.Int32)">
            <summary>
            Return a single Byte representation of this field's value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.Bytes.EMPTY">
            <summary>
            Zero value for every document
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Int16s">
            <summary>
            Field values as 16-bit signed shorts
            <para/>
            NOTE: This was Shorts in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.Int16s.Get(System.Int32)">
            <summary>
            Return a <see cref="T:System.Int16"/> representation of this field's value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.Int16s.EMPTY">
            <summary>
            Zero value for every document
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Int32s">
            <summary>
            Field values as 32-bit signed integers
            <para/>
            NOTE: This was Ints in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.Int32s.Get(System.Int32)">
            <summary>
            Return an <see cref="T:System.Int32"/> representation of this field's value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.Int32s.EMPTY">
            <summary>
            Zero value for every document
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Int64s">
            <summary>
            Field values as 64-bit signed long integers
            <para/>
            NOTE: This was Longs in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.Int64s.Get(System.Int32)">
            <summary>
            Return an <see cref="T:System.Int64"/> representation of this field's value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.Int64s.EMPTY">
            <summary>
            Zero value for every document
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Singles">
            <summary>
            Field values as 32-bit floats
            <para/>
            NOTE: This was Floats in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.Singles.Get(System.Int32)">
            <summary>
            Return an <see cref="T:System.Single"/> representation of this field's value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.Singles.EMPTY">
            <summary>
            Zero value for every document
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Doubles">
            <summary>
            Field values as 64-bit doubles
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.Doubles.Get(System.Int32)">
            <summary>
            Return a <see cref="T:System.Double"/> representation of this field's value.
            </summary>
            <param name="docID"></param>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.Doubles.EMPTY">
            <summary>
            Zero value for every document
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.CreationPlaceholder">
            <summary>
            Placeholder indicating creation of this cache is currently in-progress.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.IParser">
            <summary>
            Marker interface as super-interface to all parsers. It
            is used to specify a custom parser to
            <see cref="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldCache.IParser)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.IParser.TermsEnum(Lucene.Net.Index.Terms)">
            <summary>
            Pulls a <see cref="T:Lucene.Net.Index.TermsEnum"/> from the given <see cref="T:Lucene.Net.Index.Terms"/>. This method allows certain parsers
            to filter the actual <see cref="T:Lucene.Net.Index.TermsEnum"/> before the field cache is filled.
            </summary>
            <param name="terms">The <see cref="T:Lucene.Net.Index.Terms"/> instance to create the <see cref="T:Lucene.Net.Index.TermsEnum"/> from.</param>
            <returns>A possibly filtered <see cref="T:Lucene.Net.Index.TermsEnum"/> instance, this method must not return <c>null</c>.</returns>
            <exception cref="T:System.IO.IOException">If an <see cref="T:System.IO.IOException"/> occurs</exception>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.IByteParser">
            <summary>
            Interface to parse bytes from document fields.
            </summary>
            <seealso cref="M:Lucene.Net.Search.IFieldCache.GetBytes(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IByteParser,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.IByteParser.ParseByte(Lucene.Net.Util.BytesRef)">
            <summary>
            Return a single Byte representation of this field's value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.IInt16Parser">
            <summary>
            Interface to parse <see cref="T:System.Int16"/>s from document fields.
            <para/>
            NOTE: This was ShortParser in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Search.IFieldCache.GetInt16s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt16Parser,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.IInt16Parser.ParseInt16(Lucene.Net.Util.BytesRef)">
            <summary>
            Return a <see cref="T:System.Int16"/> representation of this field's value.
            <para/>
            NOTE: This was parseShort() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.IInt32Parser">
            <summary>
            Interface to parse <see cref="T:System.Int32"/>s from document fields.
            <para/>
            NOTE: This was IntParser in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Search.IFieldCache.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt32Parser,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.IInt32Parser.ParseInt32(Lucene.Net.Util.BytesRef)">
            <summary>
            Return an <see cref="T:System.Int32"/> representation of this field's value.
            <para/>
            NOTE: This was parseInt() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.ISingleParser">
            <summary>
            Interface to parse <see cref="T:System.Single"/>s from document fields.
            <para/>
            NOTE: This was FloatParser in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.ISingleParser.ParseSingle(Lucene.Net.Util.BytesRef)">
            <summary>
            Return an <see cref="T:System.Single"/> representation of this field's value.
            <para/>
            NOTE: This was parseFloat() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.IInt64Parser">
            <summary>
            Interface to parse <see cref="T:System.Int64"/> from document fields.
            <para/>
            NOTE: This was LongParser in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Search.IFieldCache.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt64Parser,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.IInt64Parser.ParseInt64(Lucene.Net.Util.BytesRef)">
            <summary>
            Return a <see cref="T:System.Int64"/> representation of this field's value.
            <para/>
            NOTE: This was parseLong() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.IDoubleParser">
            <summary>
            Interface to parse <see cref="T:System.Double"/>s from document fields.
            </summary>
            <seealso cref="M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IDoubleParser,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.IDoubleParser.ParseDouble(Lucene.Net.Util.BytesRef)">
            <summary>
            Return an <see cref="T:System.Double"/> representation of this field's value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.DEFAULT">
            <summary>
            Expert: The cache used internally by sorting and range query classes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.DEFAULT_BYTE_PARSER">
            <summary>
            The default parser for byte values, which are encoded by <see cref="M:System.SByte.ToString(System.String,System.IFormatProvider)"/>
            using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.DEFAULT_INT16_PARSER">
            <summary>
            The default parser for <see cref="T:System.Int16"/> values, which are encoded by <see cref="M:System.Int16.ToString(System.String,System.IFormatProvider)"/>
            using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            <para/>
            NOTE: This was DEFAULT_SHORT_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.Int16Parser.ParseInt16(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseShort() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.DEFAULT_INT32_PARSER">
            <summary>
            The default parser for <see cref="T:System.Int32"/> values, which are encoded by <see cref="M:System.Int32.ToString(System.String,System.IFormatProvider)"/>
            using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            <para/>
            NOTE: This was DEFAULT_INT_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.Int32Parser.ParseInt32(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseInt() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.DEFAULT_SINGLE_PARSER">
            <summary>
            The default parser for <see cref="T:System.Single"/> values, which are encoded by <see cref="M:System.Single.ToString(System.String,System.IFormatProvider)"/>
            using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            <para/>
            NOTE: This was DEFAULT_FLOAT_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.SingleParser.ParseSingle(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseFloat() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.DEFAULT_INT64_PARSER">
            <summary>
            The default parser for <see cref="T:System.Int64"/> values, which are encoded by <see cref="M:System.Int64.ToString(System.String,System.IFormatProvider)"/>
            using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            <para/>
            NOTE: This was DEFAULT_LONG_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.Int64Parser.ParseInt64(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseLong() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.DEFAULT_DOUBLE_PARSER">
            <summary>
            The default parser for <see cref="T:System.Double"/> values, which are encoded by <see cref="M:System.Double.ToString(System.String,System.IFormatProvider)"/>
            using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.NUMERIC_UTILS_INT32_PARSER">
            <summary>
            A parser instance for <see cref="T:System.Int32"/> values encoded by <see cref="T:Lucene.Net.Util.NumericUtils"/>, e.g. when indexed
            via <see cref="T:Lucene.Net.Documents.Int32Field"/>/<see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>.
            <para/>
            NOTE: This was NUMERIC_UTILS_INT_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.NumericUtilsInt32Parser.ParseInt32(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseInt() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.NUMERIC_UTILS_SINGLE_PARSER">
            <summary>
            A parser instance for <see cref="T:System.Single"/> values encoded with <see cref="T:Lucene.Net.Util.NumericUtils"/>, e.g. when indexed
            via <see cref="T:Lucene.Net.Documents.SingleField"/>/<see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>.
            <para/>
            NOTE: This was NUMERIC_UTILS_FLOAT_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.NumericUtilsSingleParser.ParseSingle(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseFloat() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.NUMERIC_UTILS_INT64_PARSER">
            <summary>
            A parser instance for <see cref="T:System.Int64"/> values encoded by <see cref="T:Lucene.Net.Util.NumericUtils"/>, e.g. when indexed
            via <see cref="T:Lucene.Net.Documents.Int64Field"/>/<see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>.
            <para/>
            NOTE: This was NUMERIC_UTILS_LONG_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.NumericUtilsInt64Parser.ParseInt64(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseLong() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.NUMERIC_UTILS_DOUBLE_PARSER">
            <summary>
            A parser instance for <see cref="T:System.Double"/> values encoded with <see cref="T:Lucene.Net.Util.NumericUtils"/>, e.g. when indexed
            via <see cref="T:Lucene.Net.Documents.DoubleField"/>/<see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.CacheEntry">
            <summary>
            EXPERT: A unique Identifier/Description for each item in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. 
            Can be useful for logging/debugging.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.CacheEntry.EstimateSize">
            <summary>
            Computes (and stores) the estimated size of the cache <see cref="P:Lucene.Net.Search.FieldCache.CacheEntry.Value"/>
            </summary>
            <seealso cref="P:Lucene.Net.Search.FieldCache.CacheEntry.EstimatedSize"/>
        </member>
        <member name="P:Lucene.Net.Search.FieldCache.CacheEntry.EstimatedSize">
            <summary>
            The most recently estimated size of the value, <c>null</c> unless 
            <see cref="M:Lucene.Net.Search.FieldCache.CacheEntry.EstimateSize"/> has been called.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheDocIdSet">
            <summary>
            Base class for <see cref="T:Lucene.Net.Search.DocIdSet"/> to be used with <see cref="T:Lucene.Net.Search.IFieldCache"/>. The implementation
            of its iterator is very stupid and slow if the implementation of the
            <see cref="M:Lucene.Net.Search.FieldCacheDocIdSet.MatchDoc(System.Int32)"/> method is not optimized, as iterators simply increment
            the document id until <see cref="M:Lucene.Net.Search.FieldCacheDocIdSet.MatchDoc(System.Int32)"/> returns <c>true</c>. Because of this
            <see cref="M:Lucene.Net.Search.FieldCacheDocIdSet.MatchDoc(System.Int32)"/> must be as fast as possible and in no case do any
            I/O.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheDocIdSet.MatchDoc(System.Int32)">
            <summary>
            This method checks, if a doc is a hit
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheDocIdSet.IsCacheable">
            <summary>
            This DocIdSet is always cacheable (does not go back
            to the reader for iteration)
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl">
            <summary>
            Expert: The default cache implementation, storing all values in memory.
            A WeakHashMap is used for storage.
            <para/>
            @since   lucene 1.4
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Cache">
            <summary>
            Expert: Internal cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Cache.PurgeByCacheKey(System.Object)">
            <summary>
            Remove this reader from the cache, if present. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Cache.Put(Lucene.Net.Index.AtomicReader,Lucene.Net.Search.FieldCacheImpl.CacheKey,System.Object)">
            <summary>
            Sets the key to the value for the provided reader;
            if the key is already set then this doesn't change it.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.CacheKey">
            <summary>
            Expert: Every composite-key in the internal cache is of this type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.CacheKey.#ctor(System.String,System.Object)">
            <summary>
            Creates one of these objects for a custom comparer/parser. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.CacheKey.Equals(System.Object)">
            <summary>
            Two of these are equal if they reference the same field and type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.CacheKey.GetHashCode">
            <summary>
            Composes a hashcode based on the field and type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetBytes(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <paramref name="field"/> as a single <see cref="T:System.Byte"/> and returns an array
            of size <c>reader.MaxDoc</c> of the value each document
            has in the given field. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the single <see cref="T:System.Byte"/> values. </param>
            <param name="setDocsWithField">  If true then <see cref="M:Lucene.Net.Search.FieldCacheImpl.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will
                   also be computed and stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetInt16s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <paramref name="field"/> as <see cref="T:System.Int16"/>s and returns an array
            of size <c>reader.MaxDoc</c> of the value each document
            has in the given field. 
            <para/>
            NOTE: this was getShorts() in Lucene
            </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the <see cref="T:System.Int16"/>s. </param>
            <param name="setDocsWithField">  If true then <see cref="M:Lucene.Net.Search.FieldCacheImpl.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will
                   also be computed and stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetInt16s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt16Parser,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <paramref name="field"/> as shorts and returns an array of
            size <c>reader.MaxDoc</c> of the value each document has in the
            given field. 
            <para/>
            NOTE: this was getShorts() in Lucene
            </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the <see cref="T:System.Int16"/>s. </param>
            <param name="parser">  Computes <see cref="T:System.Int16"/> for string values. </param>
            <param name="setDocsWithField">  If true then <see cref="M:Lucene.Net.Search.FieldCacheImpl.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will
                   also be computed and stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Int16sFromArray">
            <summary>
            NOTE: This was ShortsFromArray in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Int16Cache">
            <summary>
            NOTE: This was ShortCache in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Returns an <see cref="T:Lucene.Net.Search.FieldCache.Int32s"/> over the values found in documents in the given
            field.
            <para/>
            NOTE: this was getInts() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Search.FieldCacheImpl.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt32Parser,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt32Parser,System.Boolean)">
            <summary>
            Returns an <see cref="T:Lucene.Net.Search.FieldCache.Int32s"/> over the values found in documents in the given
            field. If the field was indexed as <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/>, it simply
            uses <see cref="M:Lucene.Net.Index.AtomicReader.GetNumericDocValues(System.String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <paramref name="field"/> as <see cref="T:System.Int32"/>s and returns
            an array of size <c>reader.MaxDoc</c> of the value each document
            has in the given field.
            <para/>
            NOTE: this was getInts() in Lucene
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the <see cref="T:System.Int32"/>s. </param>
            <param name="parser">
                     Computes <see cref="T:System.Int32"/> for string values. May be <c>null</c> if the
                     requested field was indexed as <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/> or
                     <see cref="T:Lucene.Net.Documents.Int32Field"/>. </param>
            <param name="setDocsWithField">
                     If true then <see cref="M:Lucene.Net.Search.FieldCacheImpl.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)"/> will also be computed and
                     stored in the <see cref="T:Lucene.Net.Search.IFieldCache"/>. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Int32sFromArray">
            <summary>
            NOTE: This was IntsFromArray in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Int32Cache">
            <summary>
            NOTE: This was IntCache in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetSingles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            NOTE: this was getFloats() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetSingles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.ISingleParser,System.Boolean)">
            <summary>
            NOTE: this was getFloats() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.SinglesFromArray">
            <summary>
            NOTE: This was FloatsFromArray in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.SingleCache">
            <summary>
            NOTE: This was FloatCache in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            NOTE: this was getLongs() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt64Parser,System.Boolean)">
            <summary>
            NOTE: this was getLongs() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Int64sFromArray">
            <summary>
            NOTE: This was LongsFromArray in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Int64Cache">
            <summary>
            NOTE: This was LongCache in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheRangeFilter">
             <summary>
             A range filter built on top of a cached single term field (in <see cref="T:Lucene.Net.Search.IFieldCache"/>).
            
             <para/><see cref="T:Lucene.Net.Search.FieldCacheRangeFilter"/> builds a single cache for the field the first time it is used.
             Each subsequent <see cref="T:Lucene.Net.Search.FieldCacheRangeFilter"/> on the same field then reuses this cache,
             even if the range itself changes.
            
             <para/>this means that <see cref="T:Lucene.Net.Search.FieldCacheRangeFilter"/> is much faster (sometimes more than 100x as fast)
             as building a <see cref="T:Lucene.Net.Search.TermRangeFilter"/>, if using a <see cref="M:Lucene.Net.Search.FieldCacheRangeFilter.NewStringRange(System.String,System.String,System.String,System.Boolean,System.Boolean)"/>.
             However, if the range never changes it is slower (around 2x as slow) than building
             a <see cref="T:Lucene.Net.Search.CachingWrapperFilter"/> on top of a single <see cref="T:Lucene.Net.Search.TermRangeFilter"/>.
            
             <para/>For numeric data types, this filter may be significantly faster than <see cref="T:Lucene.Net.Search.NumericRangeFilter"/>.
             Furthermore, it does not need the numeric values encoded
             by <see cref="T:Lucene.Net.Documents.Int32Field"/>, <see cref="T:Lucene.Net.Documents.SingleField"/>,
             <see cref="T:Lucene.Net.Documents.Int64Field"/> or <see cref="T:Lucene.Net.Documents.DoubleField"/>. But
             it has the problem that it only works with exact one value/document (see below).
            
             <para/>As with all <see cref="T:Lucene.Net.Search.IFieldCache"/> based functionality, <see cref="T:Lucene.Net.Search.FieldCacheRangeFilter"/> is only valid for
             fields which exact one term for each document (except for <see cref="M:Lucene.Net.Search.FieldCacheRangeFilter.NewStringRange(System.String,System.String,System.String,System.Boolean,System.Boolean)"/>
             where 0 terms are also allowed). Due to a restriction of <see cref="T:Lucene.Net.Search.IFieldCache"/>, for numeric ranges
             all terms that do not have a numeric value, 0 is assumed.
            
             <para/>Thus it works on dates, prices and other single value fields but will not work on
             regular text fields. It is preferable to use a <see cref="F:Lucene.Net.Documents.Field.Index.NOT_ANALYZED"/> field to ensure that
             there is only a single term.
            
             <para/>This class does not have an constructor, use one of the static factory methods available,
             that create a correct instance for different data types supported by <see cref="T:Lucene.Net.Search.IFieldCache"/>.
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewStringRange(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a string range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetTermsIndex(Lucene.Net.Index.AtomicReader,System.String,System.Single)"/>. This works with all
            fields containing zero or one term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewBytesRefRange(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Util.BytesRef"/> range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetTermsIndex(Lucene.Net.Index.AtomicReader,System.String,System.Single)"/>. This works with all
            fields containing zero or one term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewByteRange(System.String,System.Nullable{System.SByte},System.Nullable{System.SByte},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetBytes(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)"/>. This works with all
            <see cref="T:System.Byte"/> fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewByteRange(System.String,Lucene.Net.Search.FieldCache.IByteParser,System.Nullable{System.SByte},System.Nullable{System.SByte},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetBytes(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IByteParser,System.Boolean)"/>. This works with all
            <see cref="T:System.Byte"/> fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewInt16Range(System.String,System.Nullable{System.Int16},System.Nullable{System.Int16},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetInt16s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)"/>. This works with all
            <see cref="T:System.Int16"/> fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            <para/>
            NOTE: this was newShortRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewInt16Range(System.String,Lucene.Net.Search.FieldCache.IInt16Parser,System.Nullable{System.Int16},System.Nullable{System.Int16},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetInt16s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt16Parser,System.Boolean)"/>. This works with all
            <see cref="T:System.Int16"/> fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            <para/>
            NOTE: this was newShortRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewInt32Range(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)"/>. This works with all
            <see cref="T:System.Int32"/> fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            <para/>
            NOTE: this was newIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewInt32Range(System.String,Lucene.Net.Search.FieldCache.IInt32Parser,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt32Parser,System.Boolean)"/>. This works with all
            <see cref="T:System.Int32"/> fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            <para/>
            NOTE: this was newIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewInt64Range(System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)"/>. This works with all
            <see cref="T:System.Int64"/> fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewInt64Range(System.String,Lucene.Net.Search.FieldCache.IInt64Parser,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt64Parser,System.Boolean)"/>. This works with all
            <see cref="T:System.Int64"/> fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            <para/>
            NOTE: this was newLongRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewSingleRange(System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetSingles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)"/>. This works with all
            <see cref="T:System.Single"/> fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            <para/>
            NOTE: this was newFloatRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewSingleRange(System.String,Lucene.Net.Search.FieldCache.ISingleParser,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetSingles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.ISingleParser,System.Boolean)"/>. This works with all
            <see cref="T:System.Single"/> fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            <para/>
            NOTE: this was newFloatRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewDoubleRange(System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)"/>. This works with all
            <see cref="T:System.Double"/> fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewDoubleRange(System.String,Lucene.Net.Search.FieldCache.IDoubleParser,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <see cref="M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IDoubleParser,System.Boolean)"/>. This works with all
            <see cref="T:System.Double"/> fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter`1.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            This method is implemented for each data type </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.Field">
            <summary>
            Returns the field name for this filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.IncludesLower">
            <summary>
            Returns <c>true</c> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.IncludesUpper">
            <summary>
            Returns <c>true</c> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.LowerVal">
            <summary>
            Returns the lower value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.UpperVal">
            <summary>
            Returns the upper value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.Parser">
            <summary>
            Returns the current numeric parser (<c>null</c> for <typeparamref name="T"/> is <see cref="T:System.String"/>) </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheRewriteMethod">
            <summary>
            Rewrites <see cref="T:Lucene.Net.Search.MultiTermQuery"/>s into a filter, using the <see cref="T:Lucene.Net.Search.IFieldCache"/> for term enumeration.
            <para/>
            This can be used to perform these queries against an unindexed docvalues field.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRewriteMethod.MultiTermQueryFieldCacheWrapperFilter.#ctor(Lucene.Net.Search.MultiTermQuery)">
            <summary>
            Wrap a <see cref="T:Lucene.Net.Search.MultiTermQuery"/> as a Filter.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRewriteMethod.MultiTermQueryFieldCacheWrapperFilter.Field">
            <summary>
            Returns the field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRewriteMethod.MultiTermQueryFieldCacheWrapperFilter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            Returns a DocIdSet with documents that should be permitted in search
            results.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheTermsFilter">
             <summary>
             A <see cref="T:Lucene.Net.Search.Filter"/> that only accepts documents whose single
             term value in the specified field is contained in the
             provided set of allowed terms.
            
             <para/>
            
             This is the same functionality as TermsFilter (from
             queries/), except this filter requires that the
             field contains only a single term for all documents.
             Because of drastically different implementations, they
             also have different performance characteristics, as
             described below.
            
             <para/>
            
             The first invocation of this filter on a given field will
             be slower, since a <see cref="T:Lucene.Net.Index.SortedDocValues"/> must be
             created.  Subsequent invocations using the same field
             will re-use this cache.  However, as with all
             functionality based on <see cref="T:Lucene.Net.Search.IFieldCache"/>, persistent RAM
             is consumed to hold the cache, and is not freed until the
             <see cref="T:Lucene.Net.Index.IndexReader"/> is disposed.  In contrast, TermsFilter
             has no persistent RAM consumption.
            
            
             <para/>
            
             With each search, this filter translates the specified
             set of <see cref="T:Lucene.Net.Index.Terms"/> into a private <see cref="T:Lucene.Net.Util.FixedBitSet"/> keyed by
             term number per unique <see cref="T:Lucene.Net.Index.IndexReader"/> (normally one
             reader per segment).  Then, during matching, the term
             number for each docID is retrieved from the cache and
             then checked for inclusion using the <see cref="T:Lucene.Net.Util.FixedBitSet"/>.
             Since all testing is done using RAM resident data
             structures, performance should be very fast, most likely
             fast enough to not require further caching of the
             <see cref="T:Lucene.Net.Search.DocIdSet"/> for each possible combination of terms.
             However, because docIDs are simply scanned linearly, an
             index with a great many small documents may find this
             linear scan too costly.
            
             <para/>
            
             In contrast, TermsFilter builds up a <see cref="T:Lucene.Net.Util.FixedBitSet"/>,
             keyed by docID, every time it's created, by enumerating
             through all matching docs using <see cref="T:Lucene.Net.Index.DocsEnum"/> to seek
             and scan through each term's docID list.  While there is
             no linear scan of all docIDs, besides the allocation of
             the underlying array in the <see cref="T:Lucene.Net.Util.FixedBitSet"/>, this
             approach requires a number of "disk seeks" in proportion
             to the number of terms, which can be exceptionally costly
             when there are cache misses in the OS's IO cache.
            
             <para/>
            
             Generally, this filter will be slower on the first
             invocation for a given field, but subsequent invocations,
             even if you change the allowed set of <see cref="T:Lucene.Net.Index.Terms"/>, should be
             faster than TermsFilter, especially as the number of
             <see cref="T:Lucene.Net.Index.Terms"/> being matched increases.  If you are matching only
             a very small number of terms, and those terms in turn
             match a very small number of documents, TermsFilter may
             perform faster.
            
             <para/>
            
             Which filter is best is very application dependent.
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer`1">
             <summary>
             Expert: a <see cref="T:Lucene.Net.Search.FieldComparer"/> compares hits so as to determine their
             sort order when collecting the top results with
             <see cref="T:Lucene.Net.Search.TopFieldCollector"/>.  The concrete public <see cref="T:Lucene.Net.Search.FieldComparer"/>
             classes here correspond to the <see cref="T:Lucene.Net.Search.SortField"/> types.
            
             <para>This API is designed to achieve high performance
             sorting, by exposing a tight interaction with 
             <see cref="T:Lucene.Net.Search.FieldValueHitQueue"/> as it visits hits.  Whenever a hit is
             competitive, it's enrolled into a virtual slot, which is
             an <see cref="T:System.Int32"/> ranging from 0 to numHits-1.  The 
             <see cref="T:Lucene.Net.Search.FieldComparer"/> is made aware of segment transitions
             during searching in case any internal state it's tracking
             needs to be recomputed during these transitions.</para>
            
             <para>A comparer must define these functions:</para>
            
             <list type="bullet">
            
              <item><term><see cref="M:Lucene.Net.Search.FieldComparer`1.Compare(System.Int32,System.Int32)"/></term> <description> Compare a hit at 'slot a'
                   with hit 'slot b'.</description></item>
            
              <item><term><see cref="M:Lucene.Net.Search.FieldComparer`1.SetBottom(System.Int32)"/></term> <description>This method is called by
                   <see cref="T:Lucene.Net.Search.FieldValueHitQueue"/> to notify the
                   <see cref="T:Lucene.Net.Search.FieldComparer"/> of the current weakest ("bottom")
                   slot.  Note that this slot may not hold the weakest
                   value according to your comparer, in cases where
                   your comparer is not the primary one (ie, is only
                   used to break ties from the comparers before it).</description></item>
            
              <item><term><see cref="M:Lucene.Net.Search.FieldComparer`1.CompareBottom(System.Int32)"/></term> <description>Compare a new hit (docID)
                   against the "weakest" (bottom) entry in the queue.</description></item>
            
              <item><term><see cref="M:Lucene.Net.Search.FieldComparer`1.SetTopValue(System.Object)"/></term> <description>This method is called by
                   <see cref="T:Lucene.Net.Search.TopFieldCollector"/> to notify the
                   <see cref="T:Lucene.Net.Search.FieldComparer"/> of the top most value, which is
                   used by future calls to <see cref="M:Lucene.Net.Search.FieldComparer`1.CompareTop(System.Int32)"/>.</description></item>
            
              <item><term><see cref="M:Lucene.Net.Search.FieldComparer`1.CompareTop(System.Int32)"/></term> <description>Compare a new hit (docID)
                   against the top value previously set by a call to
                   <see cref="M:Lucene.Net.Search.FieldComparer`1.SetTopValue(System.Object)"/>.</description></item>
            
              <item><term><see cref="M:Lucene.Net.Search.FieldComparer`1.Copy(System.Int32,System.Int32)"/></term> <description>Installs a new hit into the
                   priority queue.  The <see cref="T:Lucene.Net.Search.FieldValueHitQueue"/>
                   calls this method when a new hit is competitive.</description></item>
            
              <item><term><see cref="M:Lucene.Net.Search.FieldComparer`1.SetNextReader(Lucene.Net.Index.AtomicReaderContext)"/></term> <description>Invoked
                   when the search is switching to the next segment.
                   You may need to update internal state of the
                   comparer, for example retrieving new values from
                   the <see cref="T:Lucene.Net.Search.IFieldCache"/>.</description></item>
            
              <item><term><see cref="P:Lucene.Net.Search.FieldComparer.Item(System.Int32)"/></term> <description>Return the sort value stored in
                   the specified slot.  This is only called at the end
                   of the search, in order to populate
                   <see cref="P:Lucene.Net.Search.FieldDoc.Fields"/> when returning the top results.</description></item>
             </list>
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer`1.Compare(System.Int32,System.Int32)">
            <summary>
            Compare hit at <paramref name="slot1"/> with hit at <paramref name="slot2"/>.
            </summary>
            <param name="slot1"> first slot to compare </param>
            <param name="slot2"> second slot to compare </param>
            <returns> any N &lt; 0 if <paramref name="slot2"/>'s value is sorted after
            <paramref name="slot1"/>, any N &gt; 0 if the <paramref name="slot2"/>'s value is sorted before
            <paramref name="slot1"/> and 0 if they are equal </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer`1.SetBottom(System.Int32)">
            <summary>
            Set the bottom slot, ie the "weakest" (sorted last)
            entry in the queue.  When <see cref="M:Lucene.Net.Search.FieldComparer`1.CompareBottom(System.Int32)"/> is
            called, you should compare against this slot.  This
            will always be called before <see cref="M:Lucene.Net.Search.FieldComparer`1.CompareBottom(System.Int32)"/>.
            </summary>
            <param name="slot"> the currently weakest (sorted last) slot in the queue </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer`1.SetTopValue(System.Object)">
            <summary>
            Record the top value, for future calls to 
            <see cref="M:Lucene.Net.Search.FieldComparer`1.CompareTop(System.Int32)"/>.  This is only called for searches that
            use SearchAfter (deep paging), and is called before any
            calls to <see cref="M:Lucene.Net.Search.FieldComparer`1.SetNextReader(Lucene.Net.Index.AtomicReaderContext)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer`1.CompareBottom(System.Int32)">
             <summary>
             Compare the bottom of the queue with this doc.  This will
             only invoked after <see cref="M:Lucene.Net.Search.FieldComparer`1.SetBottom(System.Int32)"/> has been called.  This
             should return the same result as 
             <see cref="M:Lucene.Net.Search.FieldComparer`1.Compare(System.Int32,System.Int32)"/> as if bottom were slot1 and the new
             document were slot 2.
            
             <para>For a search that hits many results, this method
             will be the hotspot (invoked by far the most
             frequently).</para>
             </summary>
             <param name="doc"> Doc that was hit </param>
             <returns> Any N &lt; 0 if the doc's value is sorted after
             the bottom entry (not competitive), any N &gt; 0 if the
             doc's value is sorted before the bottom entry and 0 if
             they are equal. </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer`1.CompareTop(System.Int32)">
            <summary>
            Compare the top value with this doc.  This will
            only invoked after <see cref="M:Lucene.Net.Search.FieldComparer`1.SetTopValue(System.Object)"/> has been called.  This
            should return the same result as 
            <see cref="M:Lucene.Net.Search.FieldComparer`1.Compare(System.Int32,System.Int32)"/> as if topValue were slot1 and the new
            document were slot 2.  This is only called for searches that
            use SearchAfter (deep paging).
            </summary>
            <param name="doc"> Doc that was hit </param>
            <returns> Any N &lt; 0 if the doc's value is sorted after
            the bottom entry (not competitive), any N &gt; 0 if the
            doc's value is sorted before the bottom entry and 0 if
            they are equal. </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer`1.Copy(System.Int32,System.Int32)">
            <summary>
            This method is called when a new hit is competitive.
            You should copy any state associated with this document
            that will be required for future comparisons, into the
            specified slot.
            </summary>
            <param name="slot"> Which slot to copy the hit to </param>
            <param name="doc"> DocID relative to current reader </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer`1.SetNextReader(Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Set a new <see cref="T:Lucene.Net.Index.AtomicReaderContext"/>. All subsequent docIDs are relative to
            the current reader (you must add docBase if you need to
            map it to a top-level docID).
            </summary>
            <param name="context"> Current reader context </param>
            <returns> The comparer to use for this segment; most
              comparers can just return "this" to reuse the same
              comparer across segments </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer`1.CompareValues(`0,`0)">
            <summary>
            Returns -1 if first is less than second.  Default
            impl to assume the type implements <see cref="T:System.IComparable`1"/> and
            invoke <see cref="M:System.IComparable`1.CompareTo(`0)"/>; be sure to override this method if
            your FieldComparer's type isn't a <see cref="T:System.IComparable`1"/> or
            if your values may sometimes be <c>null</c>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer`1.CompareValues(System.Object,System.Object)">
            <summary>
            Returns -1 if first is less than second.  Default
            impl to assume the type implements <see cref="T:System.IComparable`1"/> and
            invoke <see cref="M:System.IComparable`1.CompareTo(`0)"/>; be sure to override this method if
            your FieldComparer's type isn't a <see cref="T:System.IComparable`1"/> or
            if your values may sometimes be <c>null</c>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.Compare(System.Int32,System.Int32)">
            <summary>
            Compare hit at <paramref name="slot1"/> with hit at <paramref name="slot2"/>.
            </summary>
            <param name="slot1"> first slot to compare </param>
            <param name="slot2"> second slot to compare </param>
            <returns> any N &lt; 0 if <paramref name="slot2"/>'s value is sorted after
            <paramref name="slot1"/>, any N &gt; 0 if the <paramref name="slot2"/>'s value is sorted before
            <paramref name="slot1"/> and 0 if they are equal </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.SetBottom(System.Int32)">
            <summary>
            Set the bottom slot, ie the "weakest" (sorted last)
            entry in the queue.  When <see cref="M:Lucene.Net.Search.FieldComparer.CompareBottom(System.Int32)"/> is
            called, you should compare against this slot.  This
            will always be called before <see cref="M:Lucene.Net.Search.FieldComparer.CompareBottom(System.Int32)"/>.
            </summary>
            <param name="slot"> The currently weakest (sorted last) slot in the queue </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.SetTopValue(System.Object)">
            <summary>
            Record the top value, for future calls to 
            <see cref="M:Lucene.Net.Search.FieldComparer.CompareTop(System.Int32)"/>.  This is only called for searches that
            use SearchAfter (deep paging), and is called before any
            calls to <see cref="M:Lucene.Net.Search.FieldComparer.SetNextReader(Lucene.Net.Index.AtomicReaderContext)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.CompareBottom(System.Int32)">
             <summary>
             Compare the bottom of the queue with this doc.  This will
             only invoked after setBottom has been called.  This
             should return the same result as 
             <see cref="M:Lucene.Net.Search.FieldComparer.Compare(System.Int32,System.Int32)"/> as if bottom were slot1 and the new
             document were slot 2.
            
             <para>For a search that hits many results, this method
             will be the hotspot (invoked by far the most
             frequently).</para>
             </summary>
             <param name="doc"> Doc that was hit </param>
             <returns> Any N &lt; 0 if the doc's value is sorted after
             the bottom entry (not competitive), any N &gt; 0 if the
             doc's value is sorted before the bottom entry and 0 if
             they are equal. </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.CompareTop(System.Int32)">
            <summary>
            Compare the top value with this doc.  This will
            only invoked after <see cref="M:Lucene.Net.Search.FieldComparer.SetTopValue(System.Object)"/> has been called.  This
            should return the same result as 
            <see cref="M:Lucene.Net.Search.FieldComparer.Compare(System.Int32,System.Int32)"/> as if topValue were slot1 and the new
            document were slot 2.  This is only called for searches that
            use SearchAfter (deep paging).
            </summary>
            <param name="doc"> Doc that was hit </param>
            <returns> Any N &lt; 0 if the doc's value is sorted after
            the bottom entry (not competitive), any N &gt; 0 if the
            doc's value is sorted before the bottom entry and 0 if
            they are equal. </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.Copy(System.Int32,System.Int32)">
            <summary>
            This method is called when a new hit is competitive.
            You should copy any state associated with this document
            that will be required for future comparisons, into the
            specified slot.
            </summary>
            <param name="slot"> Which slot to copy the hit to </param>
            <param name="doc"> DocID relative to current reader </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.SetNextReader(Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Set a new <see cref="T:Lucene.Net.Index.AtomicReaderContext"/>. All subsequent docIDs are relative to
            the current reader (you must add docBase if you need to
            map it to a top-level docID).
            </summary>
            <param name="context"> Current reader context </param>
            <returns> The comparer to use for this segment; most
              comparers can just return "this" to reuse the same
              comparer across segments </returns>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.SetScorer(Lucene.Net.Search.Scorer)">
            <summary>
            Sets the <see cref="T:Lucene.Net.Search.Scorer"/> to use in case a document's score is
            needed.
            </summary>
            <param name="scorer"> <see cref="T:Lucene.Net.Search.Scorer"/> instance that you should use to
            obtain the current hit's score, if necessary.  </param>
        </member>
        <member name="P:Lucene.Net.Search.FieldComparer.Item(System.Int32)">
            <summary>
            Return the actual value in the slot.
            LUCENENET NOTE: This was value(int) in Lucene.
            </summary>
            <param name="slot"> The value </param>
            <returns> Value in this slot </returns>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.NumericComparer`1">
            <summary>
            Base FieldComparer class for numeric types
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.ByteComparer">
            <summary>
            Parses field's values as <see cref="T:System.Byte"/> (using 
            <see cref="M:Lucene.Net.Search.IFieldCache.GetBytes(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IByteParser,System.Boolean)"/> and sorts by ascending value
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.DoubleComparer">
            <summary>
            Parses field's values as <see cref="T:System.Double"/> (using 
            <see cref="M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IDoubleParser,System.Boolean)"/> and sorts by ascending value
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.SingleComparer">
            <summary>
            Parses field's values as <see cref="T:System.Single"/> (using 
            <see cref="M:Lucene.Net.Search.IFieldCache.GetSingles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.ISingleParser,System.Boolean)"/>  and sorts by ascending value
            <para/>
            NOTE: This was FloatComparator in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.Int16Comparer">
            <summary>
            Parses field's values as <see cref="T:System.Int16"/> (using 
            <see cref="M:Lucene.Net.Search.IFieldCache.GetInt16s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt16Parser,System.Boolean)"/> and sorts by ascending value
            <para/>
            NOTE: This was ShortComparator in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.Int32Comparer">
            <summary>
            Parses field's values as <see cref="T:System.Int32"/> (using 
            <see cref="M:Lucene.Net.Search.IFieldCache.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt32Parser,System.Boolean)"/> and sorts by ascending value
            <para/>
            NOTE: This was IntComparator in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.Int64Comparer">
            <summary>
            Parses field's values as <see cref="T:System.Int64"/> (using
            <see cref="M:Lucene.Net.Search.IFieldCache.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt64Parser,System.Boolean)"/> and sorts by ascending value
            <para/>
            NOTE: This was LongComparator in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.RelevanceComparer">
            <summary>
            Sorts by descending relevance.  NOTE: if you are
            sorting only by descending relevance and then
            secondarily by ascending docID, performance is faster
            using <see cref="T:Lucene.Net.Search.TopScoreDocCollector"/> directly (which all overloads of
            <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32)"/> use when no <see cref="T:Lucene.Net.Search.Sort"/> is
            specified).
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.DocComparer">
            <summary>
            Sorts by ascending docID </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.TermOrdValComparer">
            <summary>
            Sorts by field's natural <see cref="T:Lucene.Net.Index.Term"/> sort order, using
            ordinals.  This is functionally equivalent to 
            <see cref="T:Lucene.Net.Search.FieldComparer.TermValComparer"/>, but it first resolves the string
            to their relative ordinal positions (using the index
            returned by <see cref="M:Lucene.Net.Search.IFieldCache.GetTermsIndex(Lucene.Net.Index.AtomicReader,System.String,System.Single)"/>), and
            does most comparisons using the ordinals.  For medium
            to large results, this comparer will be much faster
            than <see cref="T:Lucene.Net.Search.FieldComparer.TermValComparer"/>.  For very small
            result sets it may be slower.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.ords">
            <summary>
            Ords for each slot.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.values">
            <summary>
            Values for each slot.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.readerGen">
            <summary>
            Which reader last copied a value into the slot. When
            we compare two slots, we just compare-by-ord if the
            readerGen is the same; else we must compare the
            values(slower).
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.currentReaderGen">
            <summary>
            Gen of current reader we are on.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.termsIndex">
            <summary>
            Current reader's doc ord/values.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.bottomSlot">
            <summary>
            Bottom slot, or -1 if queue isn't full yet
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.bottomOrd">
            <summary>
            Bottom ord (same as ords[bottomSlot] once bottomSlot
            is set).  Cached for faster compares.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.bottomSameReader">
            <summary>
            True if current bottom slot matches the current
            reader.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.bottomValue">
            <summary>
            Bottom value (same as values[bottomSlot] once
            bottomSlot is set).  Cached for faster compares.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.topValue">
            <summary>
            Set by setTopValue. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.missingSortCmp">
            <summary>
            -1 if missing values are sorted first, 1 if they are
             sorted last
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.missingOrd">
            <summary>
            Which ordinal to use for a missing value. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.TermOrdValComparer.#ctor(System.Int32,System.String)">
            <summary>
            Creates this, sorting missing values first. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.TermOrdValComparer.#ctor(System.Int32,System.String,System.Boolean)">
            <summary>
            Creates this, with control over how missing values
            are sorted.  Pass true for <paramref name="sortMissingLast"/> to put
            missing values at the end.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.TermOrdValComparer.GetSortedDocValues(Lucene.Net.Index.AtomicReaderContext,System.String)">
            <summary>
            Retrieves the <see cref="T:Lucene.Net.Index.SortedDocValues"/> for the field in this segment </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.TermValComparer">
            <summary>
            Sorts by field's natural <see cref="T:Lucene.Net.Index.Term"/> sort order.  All
            comparisons are done using <see cref="M:Lucene.Net.Util.BytesRef.CompareTo(Lucene.Net.Util.BytesRef)"/>, which is
            slow for medium to large result sets but possibly
            very fast for very small results sets.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.TermValComparer.#ctor(System.Int32,System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparerSource">
            <summary>
            Provides a <see cref="T:Lucene.Net.Search.FieldComparer"/> for custom field sorting.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparerSource.NewComparer(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a comparer for the field in the given index.
            </summary>
            <param name="fieldname">
                     Name of the field to create comparer for. </param>
            <returns> <see cref="T:Lucene.Net.Search.FieldComparer"/>. </returns>
            <exception cref="T:System.IO.IOException">
                      If an error occurs reading the index. </exception>
        </member>
        <member name="T:Lucene.Net.Search.FieldDoc">
             <summary>
             Expert: A <see cref="T:Lucene.Net.Search.ScoreDoc"/> which also contains information about
             how to sort the referenced document.  In addition to the
             document number and score, this object contains an array
             of values for the document from the field(s) used to sort.
             For example, if the sort criteria was to sort by fields
             "a", "b" then "c", the <c>fields</c> object array
             will have three elements, corresponding respectively to
             the term values for the document in fields "a", "b" and "c".
             The class of each element in the array will be either
             <see cref="T:System.Int32"/>, <see cref="T:System.Single"/> or <see cref="T:System.String"/> depending on the type of values
             in the terms of each field.
            
             <para/>Created: Feb 11, 2004 1:23:38 PM
             <para/>
             @since   lucene 1.4 </summary>
             <seealso cref="T:Lucene.Net.Search.ScoreDoc"/>
             <seealso cref="T:Lucene.Net.Search.TopFieldDocs"/>
        </member>
        <member name="P:Lucene.Net.Search.FieldDoc.Fields">
            <summary>
            Expert: The values which are used to sort the referenced document.
            The order of these will match the original sort criteria given by a
            <see cref="T:Lucene.Net.Search.Sort"/> object.  Each Object will have been returned from
            the <see cref="P:Lucene.Net.Search.FieldComparer.Item(System.Int32)"/> method corresponding
            FieldComparer used to sort this field. </summary>
            <seealso cref="T:Lucene.Net.Search.Sort"/>
            <seealso cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)"/>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single)">
            <summary>
            Expert: Creates one of these objects with empty sort information. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single,System.Object[])">
            <summary>
            Expert: Creates one of these objects with the given sort information. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single,System.Object[],System.Int32)">
            <summary>
            Expert: Creates one of these objects with the given sort information. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.ToString">
            <summary>
            A convenience method for debugging.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldValueFilter">
            <summary>
            A <see cref="T:Lucene.Net.Search.Filter"/> that accepts all documents that have one or more values in a
            given field. this <see cref="T:Lucene.Net.Search.Filter"/> request <see cref="T:Lucene.Net.Util.IBits"/> from the
            <see cref="T:Lucene.Net.Search.IFieldCache"/> and build the bits if not present.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueFilter.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Search.FieldValueFilter"/>
            </summary>
            <param name="field">
                     The field to filter </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueFilter.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Search.FieldValueFilter"/>
            </summary>
            <param name="field">
                     The field to filter </param>
            <param name="negate">
                     If <c>true</c> all documents with no value in the given
                     field are accepted.
             </param>
        </member>
        <member name="P:Lucene.Net.Search.FieldValueFilter.Field">
            <summary>
            Returns the field this filter is applied on. </summary>
            <returns> The field this filter is applied on. </returns>
        </member>
        <member name="P:Lucene.Net.Search.FieldValueFilter.Negate">
            <summary>
            Returns <c>true</c> if this filter is negated, otherwise <c>false</c> </summary>
            <returns> <c>true</c> if this filter is negated, otherwise <c>false</c> </returns>
        </member>
        <member name="T:Lucene.Net.Search.FieldValueHitQueue.OneComparerFieldValueHitQueue`1">
            <summary> An implementation of <see cref="T:Lucene.Net.Search.FieldValueHitQueue" /> which is optimized in case
            there is just one comparer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueHitQueue.OneComparerFieldValueHitQueue`1.LessThan(`0,`0)">
            <summary> Returns whether <c>a</c> is less relevant than <c>b</c>.</summary>
            <param name="hitA">ScoreDoc</param>
            <param name="hitB">ScoreDoc</param>
            <returns><c>true</c> if document <c>a</c> should be sorted after document <c>b</c>.</returns>
        </member>
        <member name="T:Lucene.Net.Search.FieldValueHitQueue.MultiComparersFieldValueHitQueue`1">
            <summary> An implementation of <see cref="T:Lucene.Net.Search.FieldValueHitQueue" /> which is optimized in case
            there is more than one comparer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueHitQueue.Create``1(Lucene.Net.Search.SortField[],System.Int32)">
            <summary> Creates a hit queue sorted by the given list of fields.
            <para/><b>NOTE</b>: The instances returned by this method
            pre-allocate a full array of length <c>numHits</c>.
            </summary>
            <param name="fields"><see cref="T:Lucene.Net.Search.SortField"/> array we are sorting by in priority order (highest
            priority first); cannot be <c>null</c> or empty
            </param>
            <param name="size">The number of hits to retain. Must be greater than zero.
            </param>
            <exception cref="T:System.IO.IOException">If there is a low-level IO error</exception>
        </member>
        <member name="T:Lucene.Net.Search.FieldValueHitQueue`1">
            <summary>
            Expert: A hit queue for sorting by hits by terms in more than one field.
            Uses <c>FieldCache.DEFAULT</c> for maintaining
            internal term lookup tables.
            <para/>
            @lucene.experimental
            @since 2.9 </summary>
            <seealso cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)"/>
            <seealso cref="T:Lucene.Net.Search.FieldCache"/>
        </member>
        <member name="F:Lucene.Net.Search.FieldValueHitQueue`1.m_fields">
            <summary>
            Stores the sort criteria being used. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueHitQueue`1.FillFields(Lucene.Net.Search.FieldValueHitQueue.Entry)">
            <summary>
            Given a queue <see cref="T:Lucene.Net.Search.FieldValueHitQueue.Entry"/>, creates a corresponding <see cref="T:Lucene.Net.Search.FieldDoc"/>
            that contains the values used to sort the given document.
            These values are not the raw values out of the index, but the internal
            representation of them. This is so the given search hit can be collated by
            a MultiSearcher with other search hits.
            </summary>
            <param name="entry"> The <see cref="T:Lucene.Net.Search.FieldValueHitQueue.Entry"/> used to create a <see cref="T:Lucene.Net.Search.FieldDoc"/> </param>
            <returns> The newly created <see cref="T:Lucene.Net.Search.FieldDoc"/> </returns>
            <seealso cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)"/>
        </member>
        <member name="P:Lucene.Net.Search.FieldValueHitQueue`1.Fields">
            <summary>
            Returns the <see cref="T:Lucene.Net.Search.SortField"/>s being used by this hit queue. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Filter">
            <summary>
            Abstract base class for restricting which documents may
            be returned during searching.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Filter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Search.DocIdSet"/> enumerating the documents that should be
            permitted in search results. <b>NOTE:</b> <c>null</c> can be
            returned if no documents are accepted by this <see cref="T:Lucene.Net.Search.Filter"/>.
            <para/>
            Note: this method will be called once per segment in
            the index during searching.  The returned <see cref="T:Lucene.Net.Search.DocIdSet"/>
            must refer to document IDs for that segment, not for
            the top-level reader.
            </summary>
            <param name="context"> a <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> instance opened on the index currently
                    searched on. Note, it is likely that the provided reader info does not
                    represent the whole underlying index i.e. if the index has more than
                    one segment the given reader only represents a single segment.
                    The provided context is always an atomic context, so you can call
                    <see cref="P:Lucene.Net.Index.AtomicReader.Fields"/>
                    on the context's reader, for example.
            </param>
            <param name="acceptDocs">
                     <see cref="T:Lucene.Net.Util.IBits"/> that represent the allowable docs to match (typically deleted docs
                     but possibly filtering other documents)
            </param>
            <returns> A <see cref="T:Lucene.Net.Search.DocIdSet"/> that provides the documents which should be permitted or
                    prohibited in search results. <b>NOTE:</b> <c>null</c> should be returned if
                    the filter doesn't accept any documents otherwise internal optimization might not apply
                    in the case an <i>empty</i> <see cref="T:Lucene.Net.Search.DocIdSet"/> is returned. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Filter.NewAnonymous(System.Func{Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits,Lucene.Net.Search.DocIdSet})">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Search.Filter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)"/>
            method through the <paramref name="getDocIdSet"/> parameter.
            Simple example:
            <code>
                var filter = Filter.NewAnonymous(getDocIdSet: (context, acceptDocs) =>
                {
                    if (acceptDocs == null) acceptDocs = new Bits.MatchAllBits(5);
                    OpenBitSet bitset = new OpenBitSet(5);
                    if (acceptDocs.Get(1)) bitset.Set(1);
                    if (acceptDocs.Get(3)) bitset.Set(3);
                    return new DocIdBitSet(bitset);
                });
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="getDocIdSet">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Search.Filter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)"/>
            method. It accepts a <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> context and a <see cref="T:Lucene.Net.Util.IBits"/> acceptDocs and
            returns the <see cref="T:Lucene.Net.Search.DocIdSet"/> for this filter.
            </param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Search.FilteredDocIdSet">
             <summary>
             Abstract decorator class for a <see cref="T:Lucene.Net.Search.DocIdSet"/> implementation
             that provides on-demand filtering/validation
             mechanism on a given <see cref="T:Lucene.Net.Search.DocIdSet"/>.
            
             <para/>
            
             Technically, this same functionality could be achieved
             with ChainedFilter (under queries/), however the
             benefit of this class is it never materializes the full
             bitset for the filter.  Instead, the <see cref="M:Lucene.Net.Search.FilteredDocIdSet.Match(System.Int32)"/>
             method is invoked on-demand, per docID visited during
             searching.  If you know few docIDs will be visited, and
             the logic behind <see cref="M:Lucene.Net.Search.FilteredDocIdSet.Match(System.Int32)"/> is relatively costly,
             this may be a better way to filter than ChainedFilter.
             </summary>
             <seealso cref="T:Lucene.Net.Search.DocIdSet"/>
        </member>
        <member name="M:Lucene.Net.Search.FilteredDocIdSet.#ctor(Lucene.Net.Search.DocIdSet)">
            <summary>
            Constructor. </summary>
            <param name="innerSet"> Underlying <see cref="T:Lucene.Net.Search.DocIdSet"/> </param>
        </member>
        <member name="P:Lucene.Net.Search.FilteredDocIdSet.IsCacheable">
            <summary>
            This <see cref="T:Lucene.Net.Search.DocIdSet"/> implementation is cacheable if the inner set is cacheable. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredDocIdSet.Match(System.Int32)">
            <summary>
            Validation method to determine whether a docid should be in the result set. </summary>
            <param name="docid"> docid to be tested </param>
            <returns> <c>true</c> if input docid should be in the result set, false otherwise. </returns>
        </member>
        <member name="M:Lucene.Net.Search.FilteredDocIdSet.GetIterator">
            <summary>
            Implementation of the contract to build a <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>. </summary>
            <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/>
            <seealso cref="T:Lucene.Net.Search.FilteredDocIdSetIterator"/>
        </member>
        <member name="T:Lucene.Net.Search.FilteredDocIdSetIterator">
            <summary>
            Abstract decorator class of a <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>
            implementation that provides on-demand filter/validation
            mechanism on an underlying <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>.  See 
            <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredDocIdSetIterator.#ctor(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Constructor. </summary>
            <param name="innerIter"> Underlying <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>. </param>
        </member>
        <member name="M:Lucene.Net.Search.FilteredDocIdSetIterator.Match(System.Int32)">
            <summary>
            Validation method to determine whether a docid should be in the result set. </summary>
            <param name="doc"> docid to be tested </param>
            <returns> <c>true</c> if input docid should be in the result set, <c>false</c> otherwise. </returns>
            <seealso cref="M:Lucene.Net.Search.FilteredDocIdSetIterator.#ctor(Lucene.Net.Search.DocIdSetIterator)"/>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery">
             <summary>
             A query that applies a filter to the results of another query.
            
             <para/>Note: the bits are retrieved from the filter each time this
             query is used in a search - use a <see cref="T:Lucene.Net.Search.CachingWrapperFilter"/> to avoid
             regenerating the bits every time.
             <para/>
             @since   1.4 </summary>
             <seealso cref="T:Lucene.Net.Search.CachingWrapperFilter"/>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary>
            Constructs a new query which applies a filter to the results of the original query.
            <see cref="M:Lucene.Net.Search.Filter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)"/> will be called every time this query is used in a search. </summary>
            <param name="query">  Query to be filtered, cannot be <c>null</c>. </param>
            <param name="filter"> Filter to apply to query results, cannot be <c>null</c>. </param>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.FilteredQuery.FilterStrategy)">
            <summary>
            Expert: Constructs a new query which applies a filter to the results of the original query.
            <see cref="M:Lucene.Net.Search.Filter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)"/> will be called every time this query is used in a search. </summary>
            <param name="query">  Query to be filtered, cannot be <c>null</c>. </param>
            <param name="filter"> Filter to apply to query results, cannot be <c>null</c>. </param>
            <param name="strategy"> A filter strategy used to create a filtered scorer.
            </param>
            <seealso cref="T:Lucene.Net.Search.FilteredQuery.FilterStrategy"/>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.CreateWeight(Lucene.Net.Search.IndexSearcher)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Search.Weight"/> that applies the filter to the enclosed query's <see cref="T:Lucene.Net.Search.Weight"/>.
            this is accomplished by overriding the <see cref="T:Lucene.Net.Search.Scorer"/> returned by the <see cref="T:Lucene.Net.Search.Weight"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.QueryFirstScorer">
            <summary>
            A scorer that consults the filter if a document was matched by the
            delegate scorer. This is useful if the filter computation is more expensive
            than document scoring or if the filter has a linear running time to compute
            the next matching doc like exact geo distances.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.LeapFrogScorer">
            <summary>
            A <see cref="T:Lucene.Net.Search.Scorer"/> that uses a "leap-frog" approach (also called "zig-zag join"). The scorer and the filter
            take turns trying to advance to each other's next matching document, often
            jumping past the target document. When both land on the same document, it's
            collected.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>
            Rewrites the query. If the wrapped is an instance of
            <see cref="T:Lucene.Net.Search.MatchAllDocsQuery"/> it returns a <see cref="T:Lucene.Net.Search.ConstantScoreQuery"/>. Otherwise
            it returns a new <see cref="T:Lucene.Net.Search.FilteredQuery"/> wrapping the rewritten query.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FilteredQuery.Query">
            <summary>
            Returns this <see cref="T:Lucene.Net.Search.FilteredQuery"/>'s (unfiltered) <see cref="P:Lucene.Net.Search.FilteredQuery.Query"/> </summary>
        </member>
        <member name="P:Lucene.Net.Search.FilteredQuery.Filter">
            <summary>
            Returns this <see cref="T:Lucene.Net.Search.FilteredQuery"/>'s filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.FilteredQuery.Strategy">
            <summary>
            Returns this <see cref="T:Lucene.Net.Search.FilteredQuery"/>'s <seealso cref="T:Lucene.Net.Search.FilteredQuery.FilterStrategy"/> </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.ExtractTerms(System.Collections.Generic.ISet{Lucene.Net.Index.Term})">
            <summary>
            Expert: adds all terms occurring in this query to the terms set. Only
            works if this query is in its rewritten (<see cref="M:Lucene.Net.Search.FilteredQuery.Rewrite(Lucene.Net.Index.IndexReader)"/>) form.
            </summary>
            <exception cref="T:System.InvalidOperationException"> If this query is not yet rewritten </exception>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Equals(System.Object)">
            <summary>
            Returns true if <paramref name="o"/> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY">
             <summary>
             A <see cref="T:Lucene.Net.Search.FilteredQuery.FilterStrategy"/> that conditionally uses a random access filter if
             the given <see cref="T:Lucene.Net.Search.DocIdSet"/> supports random access (returns a non-null value
             from <see cref="P:Lucene.Net.Search.DocIdSet.Bits"/>) and
             <see cref="M:Lucene.Net.Search.FilteredQuery.RandomAccessFilterStrategy.UseRandomAccess(Lucene.Net.Util.IBits,System.Int32)"/> returns
             <c>true</c>. Otherwise this strategy falls back to a "zig-zag join" (
             <see cref="F:Lucene.Net.Search.FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY"/>) strategy.
            
             <para>
             Note: this strategy is the default strategy in <see cref="T:Lucene.Net.Search.FilteredQuery"/>
             </para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY">
            <summary>
            A filter strategy that uses a "leap-frog" approach (also called "zig-zag join").
            The scorer and the filter
            take turns trying to advance to each other's next matching document, often
            jumping past the target document. When both land on the same document, it's
            collected.
            <para>
            Note: this strategy uses the filter to lead the iteration.
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY">
            <summary>
            A filter strategy that uses a "leap-frog" approach (also called "zig-zag join").
            The scorer and the filter
            take turns trying to advance to each other's next matching document, often
            jumping past the target document. When both land on the same document, it's
            collected.
            <para>
            Note: this strategy uses the query to lead the iteration.
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilteredQuery.QUERY_FIRST_FILTER_STRATEGY">
            <summary>
            A filter strategy that advances the <see cref="T:Lucene.Net.Search.Query"/> or rather its <see cref="T:Lucene.Net.Search.Scorer"/> first and consults the
            filter <see cref="T:Lucene.Net.Search.DocIdSet"/> for each matched document.
            <para>
            Note: this strategy requires a <see cref="P:Lucene.Net.Search.DocIdSet.Bits"/> to return a non-null value. Otherwise
            this strategy falls back to <see cref="F:Lucene.Net.Search.FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY"/>
            </para>
            <para>
            Use this strategy if the filter computation is more expensive than document
            scoring or if the filter has a linear running time to compute the next
            matching doc like exact geo distances.
            </para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.FilterStrategy">
            <summary>
            Abstract class that defines how the filter (<see cref="T:Lucene.Net.Search.DocIdSet"/>) applied during document collection. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.FilterStrategy.FilteredScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Search.Weight,Lucene.Net.Search.DocIdSet)">
            <summary>
            Returns a filtered <see cref="T:Lucene.Net.Search.Scorer"/> based on this strategy.
            </summary>
            <param name="context">
                     the <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> for which to return the <see cref="T:Lucene.Net.Search.Scorer"/>. </param>
            <param name="weight"> the <see cref="T:Lucene.Net.Search.FilteredQuery"/> <see cref="T:Lucene.Net.Search.Weight"/> to create the filtered scorer. </param>
            <param name="docIdSet"> the filter <see cref="T:Lucene.Net.Search.DocIdSet"/> to apply </param>
            <returns> a filtered scorer
            </returns>
            <exception cref="T:System.IO.IOException"> if an <see cref="T:System.IO.IOException"/> occurs </exception>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.FilterStrategy.FilteredBulkScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Search.Weight,System.Boolean,Lucene.Net.Search.DocIdSet)">
            <summary>
            Returns a filtered <see cref="T:Lucene.Net.Search.BulkScorer"/> based on this
            strategy.  this is an optional method: the default
            implementation just calls <see cref="M:Lucene.Net.Search.FilteredQuery.FilterStrategy.FilteredScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Search.Weight,Lucene.Net.Search.DocIdSet)"/> and
            wraps that into a <see cref="T:Lucene.Net.Search.BulkScorer"/>.
            </summary>
            <param name="context">
                     the <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/> for which to return the <seealso cref="T:Lucene.Net.Search.Scorer"/>. </param>
            <param name="weight"> the <seealso cref="T:Lucene.Net.Search.FilteredQuery"/> <seealso cref="T:Lucene.Net.Search.Weight"/> to create the filtered scorer. </param>
            <param name="scoreDocsInOrder"> <c>true</c> to score docs in order </param>
            <param name="docIdSet"> the filter <seealso cref="T:Lucene.Net.Search.DocIdSet"/> to apply </param>
            <returns> a filtered top scorer </returns>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.RandomAccessFilterStrategy">
            <summary>
            A <see cref="T:Lucene.Net.Search.FilteredQuery.FilterStrategy"/> that conditionally uses a random access filter if
            the given <see cref="T:Lucene.Net.Search.DocIdSet"/> supports random access (returns a non-null value
            from <see cref="P:Lucene.Net.Search.DocIdSet.Bits"/>) and
            <see cref="M:Lucene.Net.Search.FilteredQuery.RandomAccessFilterStrategy.UseRandomAccess(Lucene.Net.Util.IBits,System.Int32)"/> returns
            <code>true</code>. Otherwise this strategy falls back to a "zig-zag join" (
            <see cref="F:Lucene.Net.Search.FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY"/>) strategy .
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.RandomAccessFilterStrategy.UseRandomAccess(Lucene.Net.Util.IBits,System.Int32)">
            <summary>
            Expert: decides if a filter should be executed as "random-access" or not.
            Random-access means the filter "filters" in a similar way as deleted docs are filtered
            in Lucene. This is faster when the filter accepts many documents.
            However, when the filter is very sparse, it can be faster to execute the query+filter
            as a conjunction in some cases.
            <para/>
            The default implementation returns <c>true</c> if the first document accepted by the
            filter is &lt; 100.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.QueryFirstFilterStrategy">
            <summary>
            A filter strategy that advances the <see cref="T:Lucene.Net.Search.Scorer"/> first and consults the
            <see cref="T:Lucene.Net.Search.DocIdSet"/> for each matched document.
            <para>
            Note: this strategy requires a <see cref="P:Lucene.Net.Search.DocIdSet.Bits"/> to return a non-null value. Otherwise
            this strategy falls back to <see cref="F:Lucene.Net.Search.FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY"/>
            </para>
            <para>
            Use this strategy if the filter computation is more expensive than document
            scoring or if the filter has a linear running time to compute the next
            matching doc like exact geo distances.
            </para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyQuery">
             <summary>
             Implements the fuzzy search query. The similarity measurement
             is based on the Damerau-Levenshtein (optimal string alignment) algorithm,
             though you can explicitly choose classic Levenshtein by passing <c>false</c>
             to the <c>transpositions</c> parameter.
            
             <para/>this query uses <see cref="T:Lucene.Net.Search.MultiTermQuery.TopTermsScoringBooleanQueryRewrite"/>
             as default. So terms will be collected and scored according to their
             edit distance. Only the top terms are used for building the <see cref="T:Lucene.Net.Search.BooleanQuery"/>.
             It is not recommended to change the rewrite mode for fuzzy queries.
            
             <para/>At most, this query will match terms up to
             <see cref="F:Lucene.Net.Util.Automaton.LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE"/> edits.
             Higher distances (especially with transpositions enabled), are generally not useful and
             will match a significant amount of the term dictionary. If you really want this, consider
             using an n-gram indexing technique (such as the SpellChecker in the
             <a href="{@docRoot}/../suggest/overview-summary.html">suggest module</a>) instead.
            
             <para/>NOTE: terms of length 1 or 2 will sometimes not match because of how the scaled
             distance between two terms is computed.  For a term to match, the edit distance between
             the terms must be less than the minimum length term (either the input term, or
             the candidate term).  For example, <see cref="T:Lucene.Net.Search.FuzzyQuery"/> on term "abcd" with maxEdits=2 will
             not match an indexed term "ab", and <see cref="T:Lucene.Net.Search.FuzzyQuery"/> on term "a" with maxEdits=2 will not
             match an indexed term "abc".
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Search.FuzzyQuery"/> that will match terms with an edit distance
            of at most <paramref name="maxEdits"/> to <paramref name="term"/>.
            If a <paramref name="prefixLength"/> &gt; 0 is specified, a common prefix
            of that length is also required.
            </summary>
            <param name="term"> The term to search for </param>
            <param name="maxEdits"> Must be &gt;= 0 and &lt;= <see cref="F:Lucene.Net.Util.Automaton.LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE"/>. </param>
            <param name="prefixLength"> Length of common (non-fuzzy) prefix </param>
            <param name="maxExpansions"> The maximum number of terms to match. If this number is
            greater than <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> when the query is rewritten,
            then the maxClauseCount will be used instead. </param>
            <param name="transpositions"> <c>true</c> if transpositions should be treated as a primitive
                   edit operation. If this is <c>false</c>, comparisons will implement the classic
                   Levenshtein algorithm. </param>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Int32,System.Int32)">
            <summary>
            Calls <see cref="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Int32,System.Int32,System.Int32,System.Boolean)">
            FuzzyQuery(term, maxEdits, prefixLength, defaultMaxExpansions, defaultTranspositions)</see>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Int32)">
            <summary>
            Calls <see cref="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Int32,System.Int32)">FuzzyQuery(term, maxEdits, defaultPrefixLength)</see>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Calls <see cref="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Int32)">FuzzyQuery(term, defaultMaxEdits)</see>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyQuery.MaxEdits">
            <returns> The maximum number of edit distances allowed for this query to match. </returns>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyQuery.PrefixLength">
            <summary>
            Returns the non-fuzzy prefix length. This is the number of characters at the start
            of a term that must be identical (not fuzzy) to the query term if the query
            is to match that term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyQuery.Transpositions">
            <summary>
            Returns <c>true</c> if transpositions should be treated as a primitive edit operation.
            If this is <c>false</c>, comparisons will implement the classic Levenshtein algorithm.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyQuery.Term">
            <summary>
            Returns the pattern term.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FuzzyQuery.DefaultMinSimilarity">
            @deprecated pass integer edit distances instead.
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.SingleToEdits(System.Single,System.Int32)">
            <summary>
            Helper function to convert from deprecated "minimumSimilarity" fractions
            to raw edit distances.
            <para/>
            NOTE: this was floatToEdits() in Lucene
            </summary>
            <param name="minimumSimilarity"> Scaled similarity </param>
            <param name="termLen"> Length (in unicode codepoints) of the term. </param>
            <returns> Equivalent number of maxEdits </returns>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyTermsEnum">
             <summary>
             Subclass of <see cref="T:Lucene.Net.Index.TermsEnum"/> for enumerating all terms that are similar
             to the specified filter term.
            
             <para>Term enumerations are always ordered by
             <see cref="P:Lucene.Net.Search.FuzzyTermsEnum.Comparer"/>.  Each term in the enumeration is
             greater than all that precede it.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.#ctor(Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource,Lucene.Net.Index.Term,System.Single,System.Int32,System.Boolean)">
            <summary>
            Constructor for enumeration of all terms from specified <c>reader</c> which share a prefix of
            length <paramref name="prefixLength"/> with <paramref name="term"/> and which have a fuzzy similarity &gt;
            <paramref name="minSimilarity"/>.
            <para/>
            After calling the constructor the enumeration is already pointing to the first
            valid term if such a term exists.
            </summary>
            <param name="terms"> Delivers terms. </param>
            <param name="atts"> <see cref="T:Lucene.Net.Util.AttributeSource"/> created by the rewrite method of <see cref="T:Lucene.Net.Search.MultiTermQuery"/>
            thats contains information about competitive boosts during rewrite. It is also used
            to cache DFAs between segment transitions. </param>
            <param name="term"> Pattern term. </param>
            <param name="minSimilarity"> Minimum required similarity for terms from the reader. Pass an integer value
                   representing edit distance. Passing a fraction is deprecated. </param>
            <param name="prefixLength"> Length of required common prefix. Default value is 0. </param>
            <param name="transpositions"> Transpositions </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.GetAutomatonEnum(System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Return an automata-based enum for matching up to <paramref name="editDistance"/> from
            <paramref name="lastTerm"/>, if possible
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.InitAutomata(System.Int32)">
            <summary>
            Initialize levenshtein DFAs up to maxDistance, if possible </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.SetEnum(Lucene.Net.Index.TermsEnum)">
            <summary>
            Swap in a new actual enum to proxy to </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.BottomChanged(Lucene.Net.Util.BytesRef,System.Boolean)">
            <summary>
            Fired when the max non-competitive boost has changed. This is the hook to
            swap in a smarter actualEnum
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyTermsEnum.AutomatonFuzzyTermsEnum">
            <summary>
            Implement fuzzy enumeration with <see cref="M:Lucene.Net.Index.Terms.Intersect(Lucene.Net.Util.Automaton.CompiledAutomaton,Lucene.Net.Util.BytesRef)"/>.
            <para/>
            This is the fastest method as opposed to LinearFuzzyTermsEnum:
            as enumeration is logarithmic to the number of terms (instead of linear)
            and comparison is linear to length of the term (rather than quadratic)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.AutomatonFuzzyTermsEnum.Accept(Lucene.Net.Util.BytesRef)">
            <summary>
            Finds the smallest Lev(n) DFA that accepts the term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.AutomatonFuzzyTermsEnum.Matches(Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            Returns <c>true</c> if <paramref name="term"/> is within <paramref name="k"/> edits of the query term </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyTermsEnum.MinSimilarity">
            <summary>
            @lucene.internal </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyTermsEnum.ScaleFactor">
            <summary>
            @lucene.internal </summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyTermsEnum.ILevenshteinAutomataAttribute">
            <summary>
            Reuses compiled automata across different segments,
            because they are independent of the index
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyTermsEnum.LevenshteinAutomataAttribute">
            <summary>
            Stores compiled automata as a list (indexed by edit distance)
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.HitQueue.#ctor(System.Int32,System.Boolean)">
             <summary>
             Creates a new instance with <paramref name="size"/> elements. If
             <paramref name="prePopulate"/> is set to <c>true</c>, the queue will pre-populate itself
             with sentinel objects and set its <see cref="P:Lucene.Net.Util.PriorityQueue`1.Count"/> to <paramref name="size"/>. In
             that case, you should not rely on <see cref="P:Lucene.Net.Util.PriorityQueue`1.Count"/> to get the number of
             actual elements that were added to the queue, but keep track yourself.
             <para/>
             <b>NOTE:</b> in case <paramref name="prePopulate"/> is <c>true</c>, you should pop
             elements from the queue using the following code example:
            
             <code>
             PriorityQueue&lt;ScoreDoc&gt; pq = new HitQueue(10, true); // pre-populate.
             ScoreDoc top = pq.Top;
            
             // Add/Update one element.
             top.Score = 1.0f;
             top.Soc = 0;
             top = (ScoreDoc) pq.UpdateTop();
             int totalHits = 1;
            
             // Now pop only the elements that were *truly* inserted.
             // First, pop all the sentinel elements (there are pq.Count - totalHits).
             for (int i = pq.Count - totalHits; i &gt; 0; i--) pq.Pop();
            
             // Now pop the truly added elements.
             ScoreDoc[] results = new ScoreDoc[totalHits];
             for (int i = totalHits - 1; i &gt;= 0; i--) 
             {
                 results[i] = (ScoreDoc)pq.Pop();
             }
             </code>
            
             <para/><b>NOTE</b>: this class pre-allocate a full array of
             length <paramref name="size"/>.
             </summary>
             <param name="size">
                      The requested size of this queue. </param>
             <param name="prePopulate">
                      Specifies whether to pre-populate the queue with sentinel values. </param>
             <seealso cref="M:Lucene.Net.Search.HitQueue.GetSentinelObject"/>
        </member>
        <member name="T:Lucene.Net.Search.IndexSearcher">
             <summary>
             Implements search over a single <see cref="T:Lucene.Net.Index.IndexReader"/>.
            
             <para/>Applications usually need only call the inherited
             <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32)"/>
             or <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)"/> methods. For
             performance reasons, if your index is unchanging, you
             should share a single <see cref="T:Lucene.Net.Search.IndexSearcher"/> instance across
             multiple searches instead of creating a new one
             per-search.  If your index has changed and you wish to
             see the changes reflected in searching, you should
             use <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)"/>
             to obtain a new reader and
             then create a new <see cref="T:Lucene.Net.Search.IndexSearcher"/> from that.  Also, for
             low-latency turnaround it's best to use a near-real-time
             reader (<see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/>).
             Once you have a new <see cref="T:Lucene.Net.Index.IndexReader"/>, it's relatively
             cheap to create a new <see cref="T:Lucene.Net.Search.IndexSearcher"/> from it.
            
             <para/><a name="thread-safety"></a><p><b>NOTE</b>: 
             <see cref="T:Lucene.Net.Search.IndexSearcher"/> instances are completely
             thread safe, meaning multiple threads can call any of its
             methods, concurrently.  If your application requires
             external synchronization, you should <b>not</b>
             synchronize on the <see cref="T:Lucene.Net.Search.IndexSearcher"/> instance;
             use your own (non-Lucene) objects instead.</p>
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.IndexSearcher.m_leafSlices">
            <summary>
            Used with executor - each slice holds a set of leafs executed within one thread </summary>
        </member>
        <member name="P:Lucene.Net.Search.IndexSearcher.DefaultSimilarity">
            <summary>
            Expert: returns a default <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> instance.
            In general, this method is only called to initialize searchers and writers.
            User code and query implementations should respect
            <see cref="P:Lucene.Net.Search.IndexSearcher.Similarity"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.IndexSearcher.similarity">
            <summary>
            The <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> implementation used by this searcher. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReader)">
            <summary>
            Creates a searcher searching the provided index. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReader,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Runs searches for each segment separately, using the
            provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>.  <see cref="T:Lucene.Net.Search.IndexSearcher"/> will not
            shutdown/awaitTermination this <see cref="T:System.Threading.Tasks.TaskScheduler"/> on
            dispose; you must do so, eventually, on your own.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReaderContext,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a searcher searching the provided top-level <see cref="T:Lucene.Net.Index.IndexReaderContext"/>.
            <para/>
            Given a non-<c>null</c> <see cref="T:System.Threading.Tasks.TaskScheduler"/> this method runs
            searches for each segment separately, using the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>.
            <see cref="T:Lucene.Net.Search.IndexSearcher"/> will not shutdown/awaitTermination this <see cref="T:System.Threading.Tasks.TaskScheduler"/> on
            close; you must do so, eventually, on your own.
            <para/>
            @lucene.experimental 
            </summary>
            <seealso cref="T:Lucene.Net.Index.IndexReaderContext"/>
            <seealso cref="P:Lucene.Net.Index.IndexReader.Context"/>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReaderContext)">
            <summary>
            Creates a searcher searching the provided top-level <see cref="T:Lucene.Net.Index.IndexReaderContext"/>.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Index.IndexReaderContext"/>
            <seealso cref="P:Lucene.Net.Index.IndexReader.Context"/>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Slices(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext})">
            <summary>
            Expert: Creates an array of leaf slices each holding a subset of the given leaves.
            Each <see cref="T:Lucene.Net.Search.IndexSearcher.LeafSlice"/> is executed in a single thread. By default there
            will be one <see cref="T:Lucene.Net.Search.IndexSearcher.LeafSlice"/> per leaf (<see cref="T:Lucene.Net.Index.AtomicReaderContext"/>).
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.IndexSearcher.IndexReader">
            <summary>
            Return the <see cref="T:Lucene.Net.Index.IndexReader"/> this searches. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)">
            <summary>
            Sugar for <code>.IndexReader.Document(docID)</code> </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32,Lucene.Net.Index.StoredFieldVisitor)">
            <summary>
            Sugar for <code>.IndexReader.Document(docID, fieldVisitor)</code> </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32,Lucene.Net.Index.StoredFieldVisitor)"/>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32,System.Collections.Generic.ISet{System.String})">
            <summary>
            Sugar for <code>.IndexReader.Document(docID, fieldsToLoad)</code> </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32,System.Collections.Generic.ISet{System.String})"/>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Document(System.Int32,System.Collections.Generic.ISet{System.String})">
            @deprecated Use <see cref="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32,System.Collections.Generic.ISet{System.String})"/> instead.
        </member>
        <member name="P:Lucene.Net.Search.IndexSearcher.Similarity">
            <summary>
            Expert: Set the <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> implementation used by this IndexSearcher.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.WrapFilter(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary>
            @lucene.internal </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,System.Int32)">
            <summary>
            Finds the top <paramref name="n"/>
            hits for top <paramref name="query"/> where all results are after a previous
            result (top <paramref name="after"/>).
            <para/>
            By passing the bottom result from a previous page as <paramref name="after"/>,
            this method can be used for efficient 'deep-paging' across potentially
            large result sets.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)">
            <summary>
            Finds the top <paramref name="n"/>
            hits for <paramref name="query"/>, applying <paramref name="filter"/> if non-null,
            where all results are after a previous result (<paramref name="after"/>).
            <para/>
            By passing the bottom result from a previous page as <paramref name="after"/>,
            this method can be used for efficient 'deep-paging' across potentially
            large result sets.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32)">
            <summary>
            Finds the top <paramref name="n"/>
            hits for <paramref name="query"/>.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)">
            <summary>
            Finds the top <paramref name="n"/>
            hits for <paramref name="query"/>, applying <paramref name="filter"/> if non-null.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.ICollector)">
             <summary>
             Lower-level search API.
            
             <para/><see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/> is called for every matching
             document.
             </summary>
             <param name="query"> To match documents </param>
             <param name="filter"> Ef non-null, used to permit documents to be collected. </param>
             <param name="results"> To receive hits </param>
             <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                     <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.ICollector)">
             <summary>
             Lower-level search API.
            
             <para/><seealso cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/> is called for every matching document.
             </summary>
             <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                     <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)">
             <summary>
             Search implementation with arbitrary sorting.  Finds
             the top <paramref name="n"/> hits for <paramref name="query"/>, applying
             <paramref name="filter"/> if non-null, and sorting the hits by the criteria in
             <paramref name="sort"/>.
            
             <para/>NOTE: this does not compute scores by default; use
             <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean)"/> to
             control scoring.
             </summary>
             <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                     <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean)">
            <summary>
            Search implementation with arbitrary sorting, plus
            control over whether hit scores and max score
            should be computed.  Finds
            the top <paramref name="n"/> hits for <paramref name="query"/>, applying
            <paramref name="filter"/> if non-null, and sorting the hits by the criteria in
            <paramref name="sort"/>.  If <paramref name="doDocScores"/> is <c>true</c>
            then the score of each hit will be computed and
            returned.  If <paramref name="doMaxScore"/> is
            <c>true</c> then the maximum score over all
            collected hits will be computed.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)">
            <summary>
            Finds the top <paramref name="n"/>
            hits for <paramref name="query"/>, applying <paramref name="filter"/> if non-null,
            where all results are after a previous result (<paramref name="after"/>).
            <para/>
            By passing the bottom result from a previous page as <paramref name="after"/>,
            this method can be used for efficient 'deep-paging' across potentially
            large result sets.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <seealso cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32,Lucene.Net.Search.Sort)">
            <summary>
            Search implementation with arbitrary sorting and no filter. </summary>
            <param name="query"> The query to search for </param>
            <param name="n"> Return only the top n results </param>
            <param name="sort"> The <see cref="T:Lucene.Net.Search.Sort"/> object </param>
            <returns> The top docs, sorted according to the supplied <see cref="T:Lucene.Net.Search.Sort"/> instance </returns>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,System.Int32,Lucene.Net.Search.Sort)">
            <summary>
            Finds the top <paramref name="n"/>
            hits for <paramref name="query"/> where all results are after a previous
            result (<paramref name="after"/>).
            <para/>
            By passing the bottom result from a previous page as <paramref name="after"/>,
            this method can be used for efficient 'deep-paging' across potentially
            large result sets.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean)">
            <summary>
            Finds the top <paramref name="n"/>
            hits for <paramref name="query"/> where all results are after a previous
            result (<paramref name="after"/>), allowing control over
            whether hit scores and max score should be computed.
            <para/>
            By passing the bottom result from a previous page as <paramref name="after"/>,
            this method can be used for efficient 'deep-paging' across potentially
            large result sets.  If <paramref name="doDocScores"/> is <c>true</c>
            then the score of each hit will be computed and
            returned.  If <paramref name="doMaxScore"/> is
            <c>true</c> then the maximum score over all
            collected hits will be computed.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.ScoreDoc,System.Int32)">
             <summary>
             Expert: Low-level search implementation.  Finds the top <paramref name="nDocs"/>
             hits for <c>query</c>, applying <c>filter</c> if non-null.
            
             <para/>Applications should usually call <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32)"/> or
             <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)"/> instead. </summary>
             <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                     <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext},Lucene.Net.Search.Weight,Lucene.Net.Search.ScoreDoc,System.Int32)">
             <summary>
             Expert: Low-level search implementation.  Finds the top <code>n</code>
             hits for <c>query</c>.
            
             <para/>Applications should usually call <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32)"/> or
             <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)"/> instead. </summary>
             <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                     <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Weight,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean)">
             <summary>
             Expert: Low-level search implementation with arbitrary
             sorting and control over whether hit scores and max
             score should be computed.  Finds
             the top <paramref name="nDocs"/> hits for <c>query</c> and sorting the hits
             by the criteria in <paramref name="sort"/>.
            
             <para/>Applications should usually call 
             <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)"/> instead.
             </summary>
             <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                     <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.FieldDoc,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Just like <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Weight,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean)"/>, but you choose
            whether or not the fields in the returned <see cref="T:Lucene.Net.Search.FieldDoc"/> instances should
            be set by specifying <paramref name="fillFields"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext},Lucene.Net.Search.Weight,Lucene.Net.Search.FieldDoc,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Just like <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Weight,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean)"/>, but you choose
            whether or not the fields in the returned <see cref="T:Lucene.Net.Search.FieldDoc"/> instances should
            be set by specifying <paramref name="fillFields"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext},Lucene.Net.Search.Weight,Lucene.Net.Search.ICollector)">
             <summary>
             Lower-level search API.
            
             <para/>
             <seealso cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/> is called for every document. 
            
             <para/>
             NOTE: this method executes the searches on all given leaves exclusively.
             To search across all the searchers leaves use <see cref="F:Lucene.Net.Search.IndexSearcher.m_leafContexts"/>.
             </summary>
             <param name="leaves">
                      The searchers leaves to execute the searches on </param>
             <param name="weight">
                      To match documents </param>
             <param name="collector">
                      To receive hits </param>
             <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                     <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Rewrite(Lucene.Net.Search.Query)">
            <summary>
            Expert: called to re-write queries into primitive queries. </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Explain(Lucene.Net.Search.Query,System.Int32)">
             <summary>
             Returns an <see cref="T:Lucene.Net.Search.Explanation"/> that describes how <paramref name="doc"/> scored against
             <paramref name="query"/>.
            
             <para/>This is intended to be used in developing <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> implementations,
             and, for good performance, should not be displayed with every hit.
             Computing an explanation is as expensive as executing the query over the
             entire index.
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Explain(Lucene.Net.Search.Weight,System.Int32)">
             <summary>
             Expert: low-level implementation method
             Returns an <see cref="T:Lucene.Net.Search.Explanation"/> that describes how <paramref name="doc"/> scored against
             <paramref name="weight"/>.
            
             <para/>This is intended to be used in developing <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> implementations,
             and, for good performance, should not be displayed with every hit.
             Computing an explanation is as expensive as executing the query over the
             entire index.
             <para/>Applications should call <see cref="M:Lucene.Net.Search.IndexSearcher.Explain(Lucene.Net.Search.Query,System.Int32)"/>. </summary>
             <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                     <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.CreateNormalizedWeight(Lucene.Net.Search.Query)">
            <summary>
            Creates a normalized weight for a top-level <see cref="T:Lucene.Net.Search.Query"/>.
            The query is rewritten by this method and <see cref="M:Lucene.Net.Search.Query.CreateWeight(Lucene.Net.Search.IndexSearcher)"/> called,
            afterwards the <see cref="T:Lucene.Net.Search.Weight"/> is normalized. The returned <see cref="T:Lucene.Net.Search.Weight"/>
            can then directly be used to get a <see cref="T:Lucene.Net.Search.Scorer"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.IndexSearcher.TopReaderContext">
            <summary>
            Returns this searchers the top-level <see cref="T:Lucene.Net.Index.IndexReaderContext"/>. </summary>
            <seealso cref="P:Lucene.Net.Index.IndexReader.Context"/>
        </member>
        <member name="T:Lucene.Net.Search.IndexSearcher.SearcherCallableNoSort">
            <summary>
            A thread subclass for searching a single searchable
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.IndexSearcher.SearcherCallableWithSort">
            <summary>
            A thread subclass for searching a single searchable
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.IndexSearcher.ExecutionHelper`1">
            <summary>
            A helper class that wraps a <see cref="T:Lucene.Net.Support.Threading.ICompletionService`1"/> and provides an
            iterable interface to the completed <see cref="T:Lucene.Net.Support.ICallable`1"/> instances.
            </summary>
            <typeparam name="T">the type of the <see cref="T:Lucene.Net.Support.ICallable`1"/> return value</typeparam>
        </member>
        <member name="T:Lucene.Net.Search.IndexSearcher.LeafSlice">
            <summary>
            A class holding a subset of the <see cref="T:Lucene.Net.Search.IndexSearcher"/>s leaf contexts to be
            executed within a single thread.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.TermStatistics(Lucene.Net.Index.Term,Lucene.Net.Index.TermContext)">
            <summary>
            Returns <see cref="T:Lucene.Net.Search.TermStatistics"/> for a term.
            <para/>
            This can be overridden for example, to return a term's statistics
            across a distributed collection.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.CollectionStatistics(System.String)">
            <summary>
            Returns <see cref="T:Lucene.Net.Search.CollectionStatistics"/> for a field.
            <para/>
            This can be overridden for example, to return a field's statistics
            across a distributed collection.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.LiveFieldValues`2">
             <summary>
             Tracks live field values across NRT reader reopens.
             This holds a map for all updated ids since
             the last reader reopen.  Once the NRT reader is reopened,
             it prunes the map.  This means you must reopen your NRT
             reader periodically otherwise the RAM consumption of
             this class will grow unbounded!
            
             <para/>NOTE: you must ensure the same id is never updated at
             the same time by two threads, because in this case you
             cannot in general know which thread "won".
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.LiveFieldValues`2.Add(System.String,`1)">
            <summary>
            Call this after you've successfully added a document
            to the index, to record what value you just set the
            field to.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.LiveFieldValues`2.Delete(System.String)">
            <summary>
            Call this after you've successfully deleted a document
            from the index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.LiveFieldValues`2.Count">
            <summary>
            Returns the [approximate] number of id/value pairs
            buffered in RAM.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.LiveFieldValues`2.Get(System.String)">
            <summary>
            Returns the current value for this id, or <c>null</c> if the
            id isn't in the index or was deleted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.LiveFieldValues`2.LookupFromSearcher(`0,System.String)">
            <summary>
            This is called when the id/value was already flushed &amp; opened
            in an NRT IndexSearcher.  You must implement this to
            go look up the value (eg, via doc values, field cache,
            stored fields, etc.).
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.MatchAllDocsQuery">
            <summary>
            A query that matches all documents.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.IMaxNonCompetitiveBoostAttribute">
            <summary>
            Add this <see cref="T:Lucene.Net.Util.IAttribute"/> to a fresh <see cref="T:Lucene.Net.Util.AttributeSource"/> before calling
            <see cref="M:Lucene.Net.Search.MultiTermQuery.GetTermsEnum(Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource)"/>.
            <see cref="T:Lucene.Net.Search.FuzzyQuery"/> is using this to control its internal behaviour
            to only return competitive terms.
            <para/><b>Please note:</b> this attribute is intended to be added by the <see cref="T:Lucene.Net.Search.MultiTermQuery.RewriteMethod"/>
            to an empty <see cref="T:Lucene.Net.Util.AttributeSource"/> that is shared for all segments
            during query rewrite. This attribute source is passed to all segment enums
            on <see cref="M:Lucene.Net.Search.MultiTermQuery.GetTermsEnum(Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource)"/>.
            <see cref="T:Lucene.Net.Search.TopTermsRewrite`1"/> uses this attribute to
            inform all enums about the current boost, that is not competitive.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.IMaxNonCompetitiveBoostAttribute.MaxNonCompetitiveBoost">
            <summary>
            This is the maximum boost that would not be competitive. </summary>
        </member>
        <member name="P:Lucene.Net.Search.IMaxNonCompetitiveBoostAttribute.CompetitiveTerm">
            <summary>
            This is the term or <c>null</c> of the term that triggered the boost change. </summary>
        </member>
        <member name="T:Lucene.Net.Search.MaxNonCompetitiveBoostAttribute">
            <summary>
            Implementation class for <see cref="T:Lucene.Net.Search.IMaxNonCompetitiveBoostAttribute"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.MinShouldMatchSumScorer">
            <summary>
            A <see cref="T:Lucene.Net.Search.Scorer"/> for OR like queries, counterpart of <see cref="T:Lucene.Net.Search.ConjunctionScorer"/>.
            This <see cref="T:Lucene.Net.Search.Scorer"/> implements <see cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/> and uses Advance() on the given <see cref="T:Lucene.Net.Search.Scorer"/>s.
            <para/>
            This implementation uses the minimumMatch constraint actively to efficiently
            prune the number of candidates, it is hence a mixture between a pure <see cref="T:Lucene.Net.Search.DisjunctionScorer"/>
            and a <see cref="T:Lucene.Net.Search.ConjunctionScorer"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.numScorers">
            <summary>
            The overall number of non-finalized scorers </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.mm">
            <summary>
            The minimum number of scorers that should match </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.sortedSubScorers">
            <summary>
            A static array of all subscorers sorted by decreasing cost </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.sortedSubScorersIdx">
            <summary>
            A monotonically increasing index into the array pointing to the next subscorer that is to be excluded </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.mmStack">
            <summary>
            mmStack is supposed to contain the most costly subScorers that still did
            not run out of docs, sorted by increasing sparsity of docs returned by that subScorer.
            For now, the cost of subscorers is assumed to be inversely correlated with sparsity.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.doc">
            <summary>
            The document number of the current match. </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.m_nrMatchers">
            <summary>
            The number of subscorers that provide the current match. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.#ctor(Lucene.Net.Search.Weight,System.Collections.Generic.IList{Lucene.Net.Search.Scorer},System.Int32)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.MinShouldMatchSumScorer"/>.
            </summary>
            <param name="weight"> The weight to be used. </param>
            <param name="subScorers"> A collection of at least two subscorers. </param>
            <param name="minimumNrMatchers"> The positive minimum number of subscorers that should
            match to match this query.
            <para/>When <paramref name="minimumNrMatchers"/> is bigger than
            the number of <paramref name="subScorers"/>, no matches will be produced.
            <para/>When <paramref name="minimumNrMatchers"/> equals the number of <paramref name="subScorers"/>,
            it is more efficient to use <see cref="T:Lucene.Net.Search.ConjunctionScorer"/>. </param>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.#ctor(Lucene.Net.Search.Weight,System.Collections.Generic.IList{Lucene.Net.Search.Scorer})">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.DisjunctionScorer"/>, using one as the minimum number
            of matching <paramref name="subScorers"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.GetScore">
            <summary>
            Returns the score of the current document matching the query. Initially
            invalid, until <see cref="M:Lucene.Net.Search.MinShouldMatchSumScorer.NextDoc"/> is called the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.Advance(System.Int32)">
            <summary>
            Advances to the first match beyond the current whose document number is
            greater than or equal to a given target.
            <para/>
            The implementation uses the Advance() method on the subscorers.
            </summary>
            <param name="target"> The target document number. </param>
            <returns> The document whose number is greater than or equal to the given
                    target, or -1 if none exist. </returns>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.MinheapHeapify">
            <summary>
            Organize <see cref="F:Lucene.Net.Search.MinShouldMatchSumScorer.subScorers"/> into a min heap with scorers generating the earliest document on top.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.MinheapSiftDown(System.Int32)">
            <summary>
            The subtree of <see cref="F:Lucene.Net.Search.MinShouldMatchSumScorer.subScorers"/> at root is a min heap except possibly for its root element.
            Bubble the root down as required to make the subtree a heap.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.MinheapRemoveRoot">
            <summary>
            Remove the root <see cref="T:Lucene.Net.Search.Scorer"/> from <see cref="F:Lucene.Net.Search.MinShouldMatchSumScorer.subScorers"/> and re-establish it as a heap
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.MinheapRemove(Lucene.Net.Search.Scorer)">
            <summary>
            Removes a given <see cref="T:Lucene.Net.Search.Scorer"/> from the heap by placing end of heap at that
            position and bubbling it either up or down
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.MultiCollector">
            <summary>
            A <see cref="T:Lucene.Net.Search.ICollector"/> which allows running a search with several
            <see cref="T:Lucene.Net.Search.ICollector"/>s. It offers a static <see cref="M:Lucene.Net.Search.MultiCollector.Wrap(Lucene.Net.Search.ICollector[])"/> method which accepts a
            list of collectors and wraps them with <see cref="T:Lucene.Net.Search.MultiCollector"/>, while
            filtering out the <c>null</c> ones.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiCollector.Wrap(Lucene.Net.Search.ICollector[])">
            <summary>
            Wraps a list of <see cref="T:Lucene.Net.Search.ICollector"/>s with a <see cref="T:Lucene.Net.Search.MultiCollector"/>. This
            method works as follows:
            <list type="bullet">
            <item><description>Filters out the <c>null</c> collectors, so they are not used
            during search time.</description></item>
            <item><description>If the input contains 1 real collector (i.e. non-<c>null</c> ),
            it is returned.</description></item>
            <item><description>Otherwise the method returns a <see cref="T:Lucene.Net.Search.MultiCollector"/> which wraps the
            non-<code>null</code> ones.</description></item>
            </list>
            </summary>
            <exception cref="T:System.ArgumentException">
                      if either 0 collectors were input, or all collectors are
                      <c>null</c>. </exception>
        </member>
        <member name="T:Lucene.Net.Search.MultiPhraseQuery">
            <summary>
            <see cref="T:Lucene.Net.Search.MultiPhraseQuery"/> is a generalized version of <see cref="T:Lucene.Net.Search.PhraseQuery"/>, with an added
            method <see cref="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[])"/>.
            <para/>
            To use this class, to search for the phrase "Microsoft app*" first use
            <see cref="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term)"/> on the term "Microsoft", then find all terms that have "app" as
            prefix using <c>MultiFields.GetFields(IndexReader).GetTerms(string)</c>, and use <see cref="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[])"/>
            to add them to the query.
            <para/>
            Collection initializer note: To create and populate a <see cref="T:Lucene.Net.Search.MultiPhraseQuery"/>
            in a single statement, you can use the following example as a guide:
            
            <code>
            var multiPhraseQuery = new MultiPhraseQuery() {
                new Term("field", "microsoft"), 
                new Term("field", "office")
            };
            </code>
            Note that as long as you specify all of the parameters, you can use either
            <see cref="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term)"/>, <see cref="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[])"/>, or <see cref="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[],System.Int32)"/>
            as the method to use to initialize. If there are multiple parameters, each parameter set
            must be surrounded by curly braces.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.MultiPhraseQuery.Slop">
            <summary>
            Sets the phrase slop for this query. </summary>
            <seealso cref="P:Lucene.Net.Search.PhraseQuery.Slop"/>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term)">
            <summary>
            Add a single term at the next position in the phrase. </summary>
            <seealso cref="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term)"/>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[])">
            <summary>
            Add multiple terms at the next position in the phrase.  Any of the terms
            may match.
            </summary>
            <seealso cref="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term)"/>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[],System.Int32)">
            <summary>
            Allows to specify the relative position of terms within the phrase.
            </summary>
            <seealso cref="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetTermArrays">
            <summary>
            Returns a List of the terms in the multiphrase.
            Do not modify the List or its contents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetPositions">
            <summary>
            Returns the relative positions of terms in this phrase.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.ExtractTerms(System.Collections.Generic.ISet{Lucene.Net.Index.Term})">
            <summary>
            Expert: adds all terms occurring in this query to the terms set. Only
            works if this query is in its rewritten (<see cref="M:Lucene.Net.Search.MultiPhraseQuery.Rewrite(Lucene.Net.Index.IndexReader)"/>) form.
            </summary>
            <exception cref="T:System.InvalidOperationException"> If this query is not yet rewritten </exception>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <paramref name="o"/> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="F:Lucene.Net.Search.MultiPhraseQuery.termArrays"/> collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the <see cref="F:Lucene.Net.Search.MultiPhraseQuery.termArrays"/> collection.</returns>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="F:Lucene.Net.Search.MultiPhraseQuery.termArrays"/>.
            </summary>
            <returns>An enumerator that can be used to iterate through the <see cref="F:Lucene.Net.Search.MultiPhraseQuery.termArrays"/> collection.</returns>
        </member>
        <member name="T:Lucene.Net.Search.UnionDocsAndPositionsEnum">
            <summary>
            Takes the logical union of multiple <see cref="T:Lucene.Net.Index.DocsEnum"/> iterators.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.UnionDocsAndPositionsEnum.Int32Queue">
            <summary>
            NOTE: This was IntQueue in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.MultiTermQuery">
             <summary>
             An abstract <see cref="T:Lucene.Net.Search.Query"/> that matches documents
             containing a subset of terms provided by a 
             <see cref="T:Lucene.Net.Index.FilteredTermsEnum"/> enumeration.
            
             <para/>This query cannot be used directly; you must subclass
             it and define <see cref="M:Lucene.Net.Search.MultiTermQuery.GetTermsEnum(Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource)"/> to provide a 
             <see cref="T:Lucene.Net.Index.FilteredTermsEnum"/> that iterates through the terms to be
             matched.
            
             <para/><b>NOTE</b>: if <see cref="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod"/> is either
             <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE"/> or
             <see cref="F:Lucene.Net.Search.MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE"/>, you may encounter a
             <see cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"/> exception during
             searching, which happens when the number of terms to be
             searched exceeds 
             <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/>.  Setting 
             <see cref="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod"/> to <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE"/>
             prevents this.
            
             <para/>The recommended rewrite method is 
             <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT"/>: it doesn't spend CPU
             computing unhelpful scores, and it tries to pick the most
             performant rewrite method given the query. If you
             need scoring (like <seea cref="T:Lucene.Net.Search.FuzzyQuery"/>, use
             <see cref="T:Lucene.Net.Search.MultiTermQuery.TopTermsScoringBooleanQueryRewrite"/> which uses
             a priority queue to only collect competitive terms
             and not hit this limitation.
            
             <para/>Note that QueryParsers.Classic.QueryParser produces
             <see cref="T:Lucene.Net.Search.MultiTermQuery"/>s using 
             <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT"/> by default.
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.MultiTermQuery.RewriteMethod">
            <summary>
            Abstract class that defines how the query is rewritten. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.RewriteMethod.GetTermsEnum(Lucene.Net.Search.MultiTermQuery,Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource)">
            <summary>
            Returns the <see cref="T:Lucene.Net.Search.MultiTermQuery"/>s <see cref="T:Lucene.Net.Index.TermsEnum"/> </summary>
            <seealso cref="M:Lucene.Net.Search.MultiTermQuery.GetTermsEnum(Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource)"/>
        </member>
        <member name="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE">
             <summary>
             A rewrite method that first creates a private <see cref="T:Lucene.Net.Search.Filter"/>,
             by visiting each term in sequence and marking all docs
             for that term.  Matching documents are assigned a
             constant score equal to the query's boost.
            
             <para/> This method is faster than the <see cref="T:Lucene.Net.Search.BooleanQuery"/>
             rewrite methods when the number of matched terms or
             matched documents is non-trivial. Also, it will never
             hit an errant <see cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"/>
             exception.
             </summary>
             <seealso cref="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod"/>
        </member>
        <member name="F:Lucene.Net.Search.MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE">
             <summary>
             A rewrite method that first translates each term into
             <see cref="F:Lucene.Net.Search.Occur.SHOULD"/> clause in a
             <see cref="T:Lucene.Net.Search.BooleanQuery"/>, and keeps the scores as computed by the
             query.  Note that typically such scores are
             meaningless to the user, and require non-trivial CPU
             to compute, so it's almost always better to use 
             <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT"/> instead.
            
             <para/><b>NOTE</b>: this rewrite method will hit 
             <see cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"/> if the number of terms
             exceeds <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/>.
             </summary>
             <seealso cref="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod"/>
        </member>
        <member name="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE">
             <summary>
             Like <see cref="F:Lucene.Net.Search.MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE"/> except
             scores are not computed.  Instead, each matching
             document receives a constant score equal to the
             query's boost.
            
             <para/><b>NOTE</b>: this rewrite method will hit 
             <see cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"/> if the number of terms
             exceeds <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/>.
             </summary>
             <seealso cref="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod"/>
        </member>
        <member name="T:Lucene.Net.Search.MultiTermQuery.TopTermsScoringBooleanQueryRewrite">
             <summary>
             A rewrite method that first translates each term into
             <see cref="F:Lucene.Net.Search.Occur.SHOULD"/> clause in a <see cref="T:Lucene.Net.Search.BooleanQuery"/>, and keeps the
             scores as computed by the query.
            
             <para/>
             This rewrite method only uses the top scoring terms so it will not overflow
             the boolean max clause count. It is the default rewrite method for
             <see cref="T:Lucene.Net.Search.FuzzyQuery"/>.
             </summary>
             <seealso cref="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod"/>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.TopTermsScoringBooleanQueryRewrite.#ctor(System.Int32)">
            <summary>
            Create a <see cref="T:Lucene.Net.Search.MultiTermQuery.TopTermsScoringBooleanQueryRewrite"/> for
            at most <paramref name="size"/> terms.
            <para/>
            NOTE: if <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> is smaller than
            <paramref name="size"/>, then it will be used instead.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite">
            <summary>
            A rewrite method that first translates each term into
            <see cref="F:Lucene.Net.Search.Occur.SHOULD"/> clause in a <see cref="T:Lucene.Net.Search.BooleanQuery"/>, but the scores
            are only computed as the boost.
            <para/>
            This rewrite method only uses the top scoring terms so it will not overflow
            the boolean max clause count.
            </summary>
            <seealso cref="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod"/>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite.#ctor(System.Int32)">
            <summary>
            Create a <see cref="T:Lucene.Net.Search.MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite"/> for
            at most <paramref name="size"/> terms.
            <para/>
            NOTE: if <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> is smaller than
            <paramref name="size"/>, then it will be used instead.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT">
            <summary>
            Read-only default instance of
            <see cref="T:Lucene.Net.Search.ConstantScoreAutoRewrite"/>, with 
            <see cref="P:Lucene.Net.Search.ConstantScoreAutoRewrite.TermCountCutoff"/> set to
            <see cref="F:Lucene.Net.Search.ConstantScoreAutoRewrite.DEFAULT_TERM_COUNT_CUTOFF"/>
            and 
            <see cref="P:Lucene.Net.Search.ConstantScoreAutoRewrite.DocCountPercent"/> set to
            <see cref="F:Lucene.Net.Search.ConstantScoreAutoRewrite.DEFAULT_DOC_COUNT_PERCENT"/>.
            Note that you cannot alter the configuration of this
            instance; you'll need to create a private instance
            instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.#ctor(System.String)">
            <summary>
            Constructs a query matching terms that cannot be represented with a single
            <see cref="T:Lucene.Net.Index.Term"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.MultiTermQuery.Field">
            <summary>
            Returns the field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetTermsEnum(Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource)">
            <summary>
            Construct the enumeration to be used, expanding the
            pattern term.  this method should only be called if
            the field exists (ie, implementations can assume the
            field does exist).  this method should not return null
            (should instead return <see cref="F:Lucene.Net.Index.TermsEnum.EMPTY"/> if no
            terms match).  The <see cref="T:Lucene.Net.Index.TermsEnum"/> must already be
            positioned to the first matching term.
            The given <see cref="T:Lucene.Net.Util.AttributeSource"/> is passed by the <see cref="T:Lucene.Net.Search.MultiTermQuery.RewriteMethod"/> to
            provide attributes, the rewrite method uses to inform about e.g. maximum competitive boosts.
            this is currently only used by <see cref="T:Lucene.Net.Search.TopTermsRewrite`1"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetTermsEnum(Lucene.Net.Index.Terms)">
            <summary>
            Convenience method, if no attributes are needed:
            this simply passes empty attributes and is equal to:
            <code>GetTermsEnum(terms, new AttributeSource())</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>
            To rewrite to a simpler form, instead return a simpler
            enum from <see cref="M:Lucene.Net.Search.MultiTermQuery.GetTermsEnum(Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource)"/>.  For example,
            to rewrite to a single term, return a <see cref="T:Lucene.Net.Index.SingleTermsEnum"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod">
            <summary>
            Gets or Sets the rewrite method to be used when executing the
            query.  You can use one of the four core methods, or
            implement your own subclass of <see cref="T:Lucene.Net.Search.MultiTermQuery.RewriteMethod"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.MultiTermQueryWrapperFilter`1">
            <summary>
            A wrapper for <see cref="T:Lucene.Net.Search.MultiTermQuery"/>, that exposes its
            functionality as a <see cref="T:Lucene.Net.Search.Filter"/>.
            <para/>
            <see cref="T:Lucene.Net.Search.MultiTermQueryWrapperFilter`1"/> is not designed to
            be used by itself. Normally you subclass it to provide a <see cref="T:Lucene.Net.Search.Filter"/>
            counterpart for a <see cref="T:Lucene.Net.Search.MultiTermQuery"/> subclass.
            <para/>
            For example, <see cref="T:Lucene.Net.Search.TermRangeFilter"/> and <see cref="T:Lucene.Net.Search.PrefixFilter"/> extend
            <see cref="T:Lucene.Net.Search.MultiTermQueryWrapperFilter`1"/>.
            This class also provides the functionality behind
            <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE"/>;
            this is why it is not abstract.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQueryWrapperFilter`1.#ctor(`0)">
            <summary>
            Wrap a <see cref="T:Lucene.Net.Search.MultiTermQuery"/> as a <see cref="T:Lucene.Net.Search.Filter"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.MultiTermQueryWrapperFilter`1.Field">
            <summary>
            Returns the field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQueryWrapperFilter`1.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Search.DocIdSet"/> with documents that should be permitted in search
            results.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.NGramPhraseQuery">
            <summary>
            This is a <see cref="T:Lucene.Net.Search.PhraseQuery"/> which is optimized for n-gram phrase query.
            For example, when you query "ABCD" on a 2-gram field, you may want to use
            <see cref="T:Lucene.Net.Search.NGramPhraseQuery"/> rather than <see cref="T:Lucene.Net.Search.PhraseQuery"/>, because <see cref="T:Lucene.Net.Search.NGramPhraseQuery"/>
            will <see cref="M:Lucene.Net.Search.NGramPhraseQuery.Rewrite(Lucene.Net.Index.IndexReader)"/> the query to "AB/0 CD/2", while <see cref="T:Lucene.Net.Search.PhraseQuery"/>
            will query "AB/0 BC/1 CD/2" (where term/position).
            <para/>
            Collection initializer note: To create and populate a <see cref="T:Lucene.Net.Search.PhraseQuery"/>
            in a single statement, you can use the following example as a guide:
            
            <code>
            var phraseQuery = new NGramPhraseQuery(2) {
                new Term("field", "ABCD"), 
                new Term("field", "EFGH")
            };
            </code>
            Note that as long as you specify all of the parameters, you can use either
            <see cref="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term)"/> or <see cref="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term,System.Int32)"/>
            as the method to use to initialize. If there are multiple parameters, each parameter set
            must be surrounded by curly braces.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NGramPhraseQuery.#ctor(System.Int32)">
            <summary>
            Constructor that takes gram size. </summary>
            <param name="n"> n-gram size </param>
        </member>
        <member name="M:Lucene.Net.Search.NGramPhraseQuery.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <paramref name="o"/> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.NGramPhraseQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Search.NumericRangeFilter`1">
             <summary>
             A <see cref="T:Lucene.Net.Search.Filter"/> that only accepts numeric values within
             a specified range. To use this, you must first index the
             numeric values using <see cref="T:Lucene.Net.Documents.Int32Field"/>, 
             <see cref="T:Lucene.Net.Documents.SingleField"/>, <see cref="T:Lucene.Net.Documents.Int64Field"/> or <see cref="T:Lucene.Net.Documents.DoubleField"/> (expert:
             <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>).
            
             <para/>You create a new <see cref="T:Lucene.Net.Search.NumericRangeFilter"/> with the static
             factory methods, eg:
            
             <code>
             Filter f = NumericRangeFilter.NewFloatRange("weight", 0.03f, 0.10f, true, true);
             </code>
            
             Accepts all documents whose float valued "weight" field
             ranges from 0.03 to 0.10, inclusive.
             See <see cref="T:Lucene.Net.Search.NumericRangeQuery"/> for details on how Lucene
             indexes and searches numeric valued fields.
             <para/>
             @since 2.9
             </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.IncludesMin">
            <summary>
            Returns <c>true</c> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.IncludesMax">
            <summary>
            Returns <c>true</c> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.Min">
            <summary>
            Returns the lower value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.Max">
            <summary>
            Returns the upper value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.PrecisionStep">
            <summary>
            Returns the precision step. </summary>
        </member>
        <member name="T:Lucene.Net.Search.NumericRangeFilter">
            <summary>
            LUCENENET specific static class to provide access to static methods without referring to the
            <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>'s generic closing type.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewInt64Range(System.String,System.Int32,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeFilter"/>, that filters a <see cref="T:System.Int64"/>
            range using the given <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>. By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newLongRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewInt64Range(System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeFilter"/>, that queries a <see cref="T:System.Int64"/>
            range using the default <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/> <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>. By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newLongRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewInt32Range(System.String,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeFilter"/>, that filters a <see cref="T:System.Int32"/>
            range using the given <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>. By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewInt32Range(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeFilter"/>, that queries a <see cref="T:System.Int32"/>
            range using the default <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/> <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>. By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewDoubleRange(System.String,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeFilter"/>, that filters a <see cref="T:System.Double"/>
            range using the given <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>.
            <see cref="F:System.Double.NaN"/> will never match a half-open range, to hit <c>NaN</c> use a query
            with <c>min == max == System.Double.NaN</c>. By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewDoubleRange(System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeFilter"/>, that queries a <see cref="T:System.Double"/>
            range using the default <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/> <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>.
            <see cref="F:System.Double.NaN"/> will never match a half-open range, to hit <c>NaN</c> use a query
            with <c>min == max == System.Double.NaN</c>. By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewSingleRange(System.String,System.Int32,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeFilter"/>, that filters a <see cref="T:System.Single"/>
            range using the given <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>.
            <see cref="F:System.Single.NaN"/> will never match a half-open range, to hit <c>NaN</c> use a query
            with <c>min == max == System.Single.NaN</c>. By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newFloatRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewSingleRange(System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeFilter"/>, that queries a <see cref="T:System.Single"/>
            range using the default <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/> <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>.
            <see cref="F:System.Single.NaN"/> will never match a half-open range, to hit <c>NaN</c> use a query
            with <c>min == max == System.Single.NaN</c>. By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newFloatRange() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.NumericRangeQuery`1">
             <summary>
             <para>A <see cref="T:Lucene.Net.Search.Query"/> that matches numeric values within a
             specified range.  To use this, you must first index the
             numeric values using <see cref="T:Lucene.Net.Documents.Int32Field"/>, 
             <see cref="T:Lucene.Net.Documents.SingleField"/>, <see cref="T:Lucene.Net.Documents.Int64Field"/> or <see cref="T:Lucene.Net.Documents.DoubleField"/> (expert: 
             <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>).  If your terms are instead textual,
             you should use <see cref="T:Lucene.Net.Search.TermRangeQuery"/>.  
             <see cref="T:Lucene.Net.Search.NumericRangeFilter"/> is the filter equivalent of this
             query.</para>
            
             <para>You create a new <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> with the static
             factory methods, eg:
            
             <code>
             Query q = NumericRangeQuery.NewFloatRange("weight", 0.03f, 0.10f, true, true);
             </code>
            
             matches all documents whose <see cref="T:System.Single"/> valued "weight" field
             ranges from 0.03 to 0.10, inclusive.</para>
            
             <para>The performance of <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> is much better
             than the corresponding <see cref="T:Lucene.Net.Search.TermRangeQuery"/> because the
             number of terms that must be searched is usually far
             fewer, thanks to trie indexing, described below.</para>
            
             <para>You can optionally specify a <a
             href="#precisionStepDesc"><see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/></a>
             when creating this query.  This is necessary if you've
             changed this configuration from its default (4) during
             indexing.  Lower values consume more disk space but speed
             up searching.  Suitable values are between <b>1</b> and
             <b>8</b>. A good starting point to test is <b>4</b>,
             which is the default value for all <c>Numeric*</c>
             classes.  See <a href="#precisionStepDesc">below</a> for
             details.</para>
            
             <para>This query defaults to 
             <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT"/>.
             With precision steps of &lt;=4, this query can be run with
             one of the <see cref="T:Lucene.Net.Search.BooleanQuery"/> rewrite methods without changing
             <see cref="T:Lucene.Net.Search.BooleanQuery"/>'s default max clause count.</para>
            
             <para/><h3>How it works</h3>
            
             <para>See the publication about <a target="_blank" href="http://www.panfmp.org">panFMP</a>,
             where this algorithm was described (referred to as <c>TrieRangeQuery</c>):
             </para>
             <blockquote><strong>Schindler, U, Diepenbroek, M</strong>, 2008.
             <em>Generic XML-based Framework for Metadata Portals.</em>
             Computers &amp; Geosciences 34 (12), 1947-1955.
             <a href="http://dx.doi.org/10.1016/j.cageo.2008.02.023"
             target="_blank">doi:10.1016/j.cageo.2008.02.023</a></blockquote>
            
             <para><em>A quote from this paper:</em> Because Apache Lucene is a full-text
             search engine and not a conventional database, it cannot handle numerical ranges
             (e.g., field value is inside user defined bounds, even dates are numerical values).
             We have developed an extension to Apache Lucene that stores
             the numerical values in a special string-encoded format with variable precision
             (all numerical values like <see cref="T:System.Double"/>s, <see cref="T:System.Int64"/>s, <see cref="T:System.Single"/>s, and <see cref="T:System.Int32"/>s are converted to
             lexicographic sortable string representations and stored with different precisions
             (for a more detailed description of how the values are stored,
             see <see cref="T:Lucene.Net.Util.NumericUtils"/>). A range is then divided recursively into multiple intervals for searching:
             The center of the range is searched only with the lowest possible precision in the <em>trie</em>,
             while the boundaries are matched more exactly. This reduces the number of terms dramatically.</para>
            
             <para>For the variant that stores long values in 8 different precisions (each reduced by 8 bits) that
             uses a lowest precision of 1 byte, the index contains only a maximum of 256 distinct values in the
             lowest precision. Overall, a range could consist of a theoretical maximum of
             <code>7*255*2 + 255 = 3825</code> distinct terms (when there is a term for every distinct value of an
             8-byte-number in the index and the range covers almost all of them; a maximum of 255 distinct values is used
             because it would always be possible to reduce the full 256 values to one term with degraded precision).
             In practice, we have seen up to 300 terms in most cases (index with 500,000 metadata records
             and a uniform value distribution).</para>
            
             <a name="precisionStepDesc"><h3>Precision Step</h3></a>
             <para/>You can choose any <see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/> when encoding values.
             Lower step values mean more precisions and so more terms in index (and index gets larger). The number
             of indexed terms per value is (those are generated by <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>):
             <para>
             &#160;&#160;indexedTermsPerValue = <b>ceil</b><big>(</big>bitsPerValue / precisionStep<big>)</big>
             </para>
             As the lower precision terms are shared by many values, the additional terms only
             slightly grow the term dictionary (approx. 7% for <c>precisionStep=4</c>), but have a larger
             impact on the postings (the postings file will have  more entries, as every document is linked to
             <c>indexedTermsPerValue</c> terms instead of one). The formula to estimate the growth
             of the term dictionary in comparison to one term per value:
             <para>
             <!-- the formula in the alt attribute was transformed from latex to PNG with http://1.618034.com/latex.php (with 110 dpi): -->
             &#160;&#160;<img src="doc-files/nrq-formula-1.png" alt="\mathrm{termDictOverhead} = \sum\limits_{i=0}^{\mathrm{indexedTermsPerValue}-1} \frac{1}{2^{\mathrm{precisionStep}\cdot i}}" />
             </para>
             <para>On the other hand, if the <see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/> is smaller, the maximum number of terms to match reduces,
             which optimizes query speed. The formula to calculate the maximum number of terms that will be visited while
             executing the query is:
             </para>
             <para>
             <!-- the formula in the alt attribute was transformed from latex to PNG with http://1.618034.com/latex.php (with 110 dpi): -->
             &#160;&#160;<img src="doc-files/nrq-formula-2.png" alt="\mathrm{maxQueryTerms} = \left[ \left( \mathrm{indexedTermsPerValue} - 1 \right) \cdot \left(2^\mathrm{precisionStep} - 1 \right) \cdot 2 \right] + \left( 2^\mathrm{precisionStep} - 1 \right)" />
             </para>
             <para>For longs stored using a precision step of 4, <c>maxQueryTerms = 15*15*2 + 15 = 465</c>, and for a precision
             step of 2, <c>maxQueryTerms = 31*3*2 + 3 = 189</c>. But the faster search speed is reduced by more seeking
             in the term enum of the index. Because of this, the ideal <see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/> value can only
             be found out by testing. <b>Important:</b> You can index with a lower precision step value and test search speed
             using a multiple of the original step value.</para>
            
             <para>Good values for <see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/> are depending on usage and data type:</para>
             <list type="bullet">
              <item><description>The default for all data types is <b>4</b>, which is used, when no <code>precisionStep</code> is given.</description></item>
              <item><description>Ideal value in most cases for <em>64 bit</em> data types <em>(long, double)</em> is <b>6</b> or <b>8</b>.</description></item>
              <item><description>Ideal value in most cases for <em>32 bit</em> data types <em>(int, float)</em> is <b>4</b>.</description></item>
              <item><description>For low cardinality fields larger precision steps are good. If the cardinality is &lt; 100, it is
              fair to use <see cref="F:System.Int32.MaxValue"/> (see below).</description></item>
              <item><description>Steps <b>&gt;=64</b> for <em>long/double</em> and <b>&gt;=32</b> for <em>int/float</em> produces one token
              per value in the index and querying is as slow as a conventional <see cref="T:Lucene.Net.Search.TermRangeQuery"/>. But it can be used
              to produce fields, that are solely used for sorting (in this case simply use <see cref="F:System.Int32.MaxValue"/> as
              <see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/>). Using <see cref="T:Lucene.Net.Documents.Int32Field"/>,
              <see cref="T:Lucene.Net.Documents.Int64Field"/>, <see cref="T:Lucene.Net.Documents.SingleField"/> or <see cref="T:Lucene.Net.Documents.DoubleField"/> for sorting
              is ideal, because building the field cache is much faster than with text-only numbers.
              These fields have one term per value and therefore also work with term enumeration for building distinct lists
              (e.g. facets / preselected values to search for).
              Sorting is also possible with range query optimized fields using one of the above <see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/>s.</description></item>
             </list>
            
             <para>Comparisons of the different types of RangeQueries on an index with about 500,000 docs showed
             that <see cref="T:Lucene.Net.Search.TermRangeQuery"/> in boolean rewrite mode (with raised <see cref="T:Lucene.Net.Search.BooleanQuery"/> clause count)
             took about 30-40 secs to complete, <see cref="T:Lucene.Net.Search.TermRangeQuery"/> in constant score filter rewrite mode took 5 secs
             and executing this class took &lt;100ms to complete (on an Opteron64 machine, Java 1.5, 8 bit
             precision step). This query type was developed for a geographic portal, where the performance for
             e.g. bounding boxes or exact date/time stamps is important.</para>
            
             @since 2.9
             </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.IncludesMin">
            <summary>
            Returns <c>true</c> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.IncludesMax">
            <summary>
            Returns <c>true</c> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.Min">
            <summary>
            Returns the lower value of this range query </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.Max">
            <summary>
            Returns the upper value of this range query </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep">
            <summary>
            Returns the precision step. </summary>
        </member>
        <member name="F:Lucene.Net.Search.NumericRangeQuery`1.INT64_NEGATIVE_INFINITY">
            <summary>
            NOTE: This was LONG_NEGATIVE_INFINITY in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.NumericRangeQuery`1.INT64_POSITIVE_INFINITY">
            <summary>
            NOTE: This was LONG_NEGATIVE_INFINITY in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.NumericRangeQuery`1.INT32_NEGATIVE_INFINITY">
            <summary>
            NOTE: This was INT_NEGATIVE_INFINITY in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.NumericRangeQuery`1.INT32_POSITIVE_INFINITY">
            <summary>
            NOTE: This was INT_POSITIVE_INFINITY in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.NumericRangeQuery`1.NumericRangeTermsEnum">
            <summary>
            Subclass of <see cref="T:Lucene.Net.Index.FilteredTermsEnum"/> for enumerating all terms that match the
            sub-ranges for trie range queries, using flex API.
            <para/>
            WARNING: this term enumeration is not guaranteed to be always ordered by
            <see cref="M:Lucene.Net.Index.Term.CompareTo(Lucene.Net.Index.Term)"/>.
            The ordering depends on how <see cref="M:Lucene.Net.Util.NumericUtils.SplitInt64Range(Lucene.Net.Util.NumericUtils.Int64RangeBuilder,System.Int32,System.Int64,System.Int64)"/> and
            <see cref="M:Lucene.Net.Util.NumericUtils.SplitInt32Range(Lucene.Net.Util.NumericUtils.Int32RangeBuilder,System.Int32,System.Int32,System.Int32)"/> generates the sub-ranges. For
            <see cref="T:Lucene.Net.Search.MultiTermQuery"/> ordering is not relevant.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.NumericRangeQuery">
            <summary>
            LUCENENET specific class to provide access to static factory metods of <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>
            without referring to its genereic closing type.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewInt64Range(System.String,System.Int32,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>, that queries a <see cref="T:System.Int64"/>
            range using the given <a href="#precisionStepDesc"><see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>. By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newLongRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewInt64Range(System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>, that queries a <see cref="T:System.Int64"/>
            range using the default <see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/> <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>. By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newLongRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewInt32Range(System.String,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>, that queries a <see cref="T:System.Int32"/>
            range using the given <a href="#precisionStepDesc"><see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>. By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewInt32Range(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>, that queries a <see cref="T:System.Int32"/>
            range using the default <see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/> <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>. By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewDoubleRange(System.String,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>, that queries a <see cref="T:System.Double"/>
            range using the given <a href="#precisionStepDesc"><see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>.
            <see cref="F:System.Double.NaN"/> will never match a half-open range, to hit <c>NaN</c> use a query
            with <c>min == max == System.Double.NaN</c>.  By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewDoubleRange(System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>, that queries a <see cref="T:System.Double"/>
            range using the default <see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/> <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>.
            <see cref="F:System.Double.NaN"/> will never match a half-open range, to hit <c>NaN</c> use a query
            with <c>min == max == System.Double.NaN</c>.  By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewSingleRange(System.String,System.Int32,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>, that queries a <see cref="T:System.Single"/>
            range using the given <a href="#precisionStepDesc"><see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>.
            <see cref="F:System.Single.NaN"/> will never match a half-open range, to hit <c>NaN</c> use a query
            with <c>min == max == System.Single.NaN</c>.  By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newFloatRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewSingleRange(System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>, that queries a <see cref="T:System.Single"/>
            range using the default <see cref="F:Lucene.Net.Search.NumericRangeQuery`1.precisionStep"/> <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <c>null</c>.
            <see cref="F:System.Single.NaN"/> will never match a half-open range, to hit <c>NaN</c> use a query
            with <c>min == max == System.Single.NaN</c>.  By setting inclusive to <c>false</c>, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newFloatRange() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.AveragePayloadFunction">
            <summary>
            Calculate the final score as the average score of all payloads seen.
            <para/>
            Is thread safe and completely reusable.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.MaxPayloadFunction">
            <summary>
            Returns the maximum payload score seen, else 1 if there are no payloads on the doc.
            <para/>
            Is thread safe and completely reusable.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.MinPayloadFunction">
            <summary>
            Calculates the minimum payload seen
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.PayloadFunction">
            <summary>
            An abstract class that defines a way for Payload*Query instances to transform
            the cumulative effects of payload scores for a document.
            <para/>
            @lucene.experimental this class and its derivations are experimental and subject to
            change
            </summary>
            <seealso cref="T:Lucene.Net.Search.Payloads.PayloadTermQuery"/>
        </member>
        <member name="M:Lucene.Net.Search.Payloads.PayloadFunction.CurrentScore(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Calculate the score up to this point for this doc and field </summary>
            <param name="docId"> The current doc </param>
            <param name="field"> The field </param>
            <param name="start"> The start position of the matching Span </param>
            <param name="end"> The end position of the matching Span </param>
            <param name="numPayloadsSeen"> The number of payloads seen so far </param>
            <param name="currentScore"> The current score so far </param>
            <param name="currentPayloadScore"> The score for the current payload </param>
            <returns> The new current Score
            </returns>
            <seealso cref="T:Lucene.Net.Search.Spans.Spans"/>
        </member>
        <member name="M:Lucene.Net.Search.Payloads.PayloadFunction.DocScore(System.Int32,System.String,System.Int32,System.Single)">
            <summary>
            Calculate the final score for all the payloads seen so far for this doc/field </summary>
            <param name="docId"> The current doc </param>
            <param name="field"> The current field </param>
            <param name="numPayloadsSeen"> The total number of payloads seen on this document </param>
            <param name="payloadScore"> The raw score for those payloads </param>
            <returns> The final score for the payloads </returns>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.PayloadNearQuery">
            <summary>
            This class is very similar to
            <see cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/> except that it factors
            in the value of the payloads located at each of the positions where the
            <see cref="T:Lucene.Net.Search.Spans.TermSpans"/> occurs.
            <para/>
            NOTE: In order to take advantage of this with the default scoring implementation
            (<see cref="T:Lucene.Net.Search.Similarities.DefaultSimilarity"/>), you must override <see cref="M:Lucene.Net.Search.Similarities.DefaultSimilarity.ScorePayload(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)"/>,
            which returns 1 by default.
            <para/>
            Payload scores are aggregated using a pluggable <see cref="T:Lucene.Net.Search.Payloads.PayloadFunction"/>.
            </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.ComputePayloadFactor(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)"/>
        </member>
        <member name="M:Lucene.Net.Search.Payloads.PayloadNearQuery.PayloadNearSpanScorer.ProcessPayloads(System.Collections.Generic.ICollection{System.Byte[]},System.Int32,System.Int32)">
            <summary>
            By default, uses the <see cref="T:Lucene.Net.Search.Payloads.PayloadFunction"/> to score the payloads, but
            can be overridden to do other things.
            </summary>
            <param name="payLoads"> The payloads </param>
            <param name="start"> The start position of the span being scored </param>
            <param name="end"> The end position of the span being scored
            </param>
            <seealso cref="M:Lucene.Net.Search.Spans.Spans.#ctor"/>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.PayloadSpanUtil">
            <summary>
            Experimental class to get set of payloads for most standard Lucene queries.
            Operates like Highlighter - <see cref="T:Lucene.Net.Index.IndexReader"/> should only contain doc of interest,
            best to use MemoryIndex.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Payloads.PayloadSpanUtil.#ctor(Lucene.Net.Index.IndexReaderContext)">
            <param name="context">
                     that contains doc with payloads to extract
            </param>
            <seealso cref="P:Lucene.Net.Index.IndexReader.Context"/>
        </member>
        <member name="M:Lucene.Net.Search.Payloads.PayloadSpanUtil.GetPayloadsForQuery(Lucene.Net.Search.Query)">
            <summary>
            Query should be rewritten for wild/fuzzy support.
            </summary>
            <param name="query"> rewritten query </param>
            <returns> payloads Collection </returns>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.PayloadTermQuery">
            <summary>
            This class is very similar to
            <see cref="T:Lucene.Net.Search.Spans.SpanTermQuery"/> except that it factors
            in the value of the payload located at each of the positions where the
            <see cref="T:Lucene.Net.Index.Term"/> occurs.
            <para/>
            NOTE: In order to take advantage of this with the default scoring implementation
            (<see cref="T:Lucene.Net.Search.Similarities.DefaultSimilarity"/>), you must override <see cref="M:Lucene.Net.Search.Similarities.DefaultSimilarity.ScorePayload(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)"/>,
            which returns 1 by default.
            <para/>
            Payload scores are aggregated using a pluggable <see cref="T:Lucene.Net.Search.Payloads.PayloadFunction"/>. </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.ComputePayloadFactor(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)"/>
        </member>
        <member name="M:Lucene.Net.Search.Payloads.PayloadTermQuery.PayloadTermWeight.PayloadTermSpanScorer.GetScore">
            
             <returns> <see cref="M:Lucene.Net.Search.Payloads.PayloadTermQuery.PayloadTermWeight.PayloadTermSpanScorer.GetSpanScore"/> * <see cref="M:Lucene.Net.Search.Payloads.PayloadTermQuery.PayloadTermWeight.PayloadTermSpanScorer.GetPayloadScore"/> </returns>
             <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Search.Payloads.PayloadTermQuery.PayloadTermWeight.PayloadTermSpanScorer.GetSpanScore">
            <summary>
            Returns the <see cref="T:Lucene.Net.Search.Spans.SpanScorer"/> score only.
            <para/>
            Should not be overridden without good cause!
            </summary>
            <returns> the score for just the Span part w/o the payload </returns>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error
            </exception>
            <seealso cref="M:Lucene.Net.Search.Payloads.PayloadTermQuery.PayloadTermWeight.PayloadTermSpanScorer.GetScore"/>
        </member>
        <member name="M:Lucene.Net.Search.Payloads.PayloadTermQuery.PayloadTermWeight.PayloadTermSpanScorer.GetPayloadScore">
            <summary>
            The score for the payload
            </summary>
            <returns> The score, as calculated by
                    <see cref="M:Lucene.Net.Search.Payloads.PayloadFunction.DocScore(System.Int32,System.String,System.Int32,System.Single)"/> </returns>
        </member>
        <member name="T:Lucene.Net.Search.PhrasePositions">
            <summary>
            Position of a term in a document that takes into account the term offset within the phrase.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePositions.NextPosition">
            <summary>
            Go to next location of this term current document, and set
            <c>position</c> as <c>location - offset</c>, so that a
            matching exact phrase is easily identified when all <see cref="T:Lucene.Net.Search.PhrasePositions"/>
            have exactly the same <c>position</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePositions.ToString">
            <summary>
            For debug purposes </summary>
        </member>
        <member name="T:Lucene.Net.Search.PhraseQuery">
             <summary>
             A <see cref="T:Lucene.Net.Search.Query"/> that matches documents containing a particular sequence of terms.
             A <see cref="T:Lucene.Net.Search.PhraseQuery"/> is built by QueryParser for input like <c>"new york"</c>.
            
             <para/>This query may be combined with other terms or queries with a <see cref="T:Lucene.Net.Search.BooleanQuery"/>.
             <para/>
             Collection initializer note: To create and populate a <see cref="T:Lucene.Net.Search.PhraseQuery"/>
             in a single statement, you can use the following example as a guide:
             
             <code>
             var phraseQuery = new PhraseQuery() {
                 new Term("field", "microsoft"), 
                 new Term("field", "office")
             };
             </code>
             Note that as long as you specify all of the parameters, you can use either
             <see cref="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term)"/> or <see cref="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term,System.Int32)"/>
             as the method to use to initialize. If there are multiple parameters, each parameter set
             must be surrounded by curly braces.
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.#ctor">
            <summary>
            Constructs an empty phrase query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.PhraseQuery.Slop">
             <summary>
             Sets the number of other words permitted between words in query phrase.
             If zero, then this is an exact phrase search.  For larger values this works
             like a <c>WITHIN</c> or <c>NEAR</c> operator.
            
             <para/>The slop is in fact an edit-distance, where the units correspond to
             moves of terms in the query phrase out of position.  For example, to switch
             the order of two words requires two moves (the first move places the words
             atop one another), so to permit re-orderings of phrases, the slop must be
             at least two.
            
             <para/>More exact matches are scored higher than sloppier matches, thus search
             results are sorted by exactness.
            
             <para/>The slop is zero by default, requiring exact matches.
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term)">
            <summary>
            Adds a term to the end of the query phrase.
            The relative position of the term is the one immediately after the last term added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term,System.Int32)">
            <summary>
            Adds a term to the end of the query phrase.
            The relative position of the term within the phrase is specified explicitly.
            this allows e.g. phrases with more than one term at the same position
            or phrases with gaps (e.g. in connection with stopwords).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetTerms">
            <summary>
            Returns the set of terms in this phrase. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetPositions">
            <summary>
            Returns the relative positions of terms in this phrase.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.ExtractTerms(System.Collections.Generic.ISet{Lucene.Net.Index.Term})">
            <seealso cref="M:Lucene.Net.Search.Query.ExtractTerms(System.Collections.Generic.ISet{Lucene.Net.Index.Term})"/>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <paramref name="o"/> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="F:Lucene.Net.Search.PhraseQuery.terms"/> collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the <see cref="F:Lucene.Net.Search.PhraseQuery.terms"/> collection.</returns>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="F:Lucene.Net.Search.PhraseQuery.terms"/> collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the <see cref="F:Lucene.Net.Search.PhraseQuery.terms"/> collection.</returns>
        </member>
        <member name="T:Lucene.Net.Search.PositiveScoresOnlyCollector">
            <summary>
            A <see cref="T:Lucene.Net.Search.ICollector"/> implementation which wraps another
            <see cref="T:Lucene.Net.Search.ICollector"/> and makes sure only documents with
            scores &gt; 0 are collected.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.PrefixFilter">
            <summary>
            A <see cref="T:Lucene.Net.Search.Filter"/> that restricts search results to values that have a matching prefix in a given
            field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixFilter.ToString">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.PrefixQuery">
             <summary>
             A <see cref="T:Lucene.Net.Search.Query"/> that matches documents containing terms with a specified prefix. A <see cref="T:Lucene.Net.Search.PrefixQuery"/>
             is built by QueryParser for input like <c>app*</c>.
            
             <para/>This query uses the
             <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT"/>
             rewrite method.
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Constructs a query for terms starting with <paramref name="prefix"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Search.PrefixQuery.Prefix">
            <summary>
            Returns the prefix of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.PrefixTermsEnum">
            <summary>
            Subclass of <see cref="T:Lucene.Net.Index.FilteredTermsEnum"/> for enumerating all terms that match the
            specified prefix filter term.
            <para>Term enumerations are always ordered by
            <see cref="P:Lucene.Net.Index.TermsEnum.Comparer"/>.  Each term in the enumeration is
            greater than all that precede it.</para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Query">
            <summary>
            The abstract base class for queries.
               <para/>Instantiable subclasses are:
               <list type="bullet">
               <item><description> <seealso cref="T:Lucene.Net.Search.TermQuery"/> </description></item>
               <item><description> <seealso cref="T:Lucene.Net.Search.BooleanQuery"/> </description></item>
               <item><description> <seealso cref="T:Lucene.Net.Search.WildcardQuery"/> </description></item>
               <item><description> <seealso cref="T:Lucene.Net.Search.PhraseQuery"/> </description></item>
               <item><description> <seealso cref="T:Lucene.Net.Search.PrefixQuery"/> </description></item>
               <item><description> <seealso cref="T:Lucene.Net.Search.MultiPhraseQuery"/> </description></item>
               <item><description> <seealso cref="T:Lucene.Net.Search.FuzzyQuery"/> </description></item>
               <item><description> <seealso cref="T:Lucene.Net.Search.RegexpQuery"/> </description></item>
               <item><description> <seealso cref="T:Lucene.Net.Search.TermRangeQuery"/> </description></item>
               <item><description> <seealso cref="T:Lucene.Net.Search.NumericRangeQuery"/> </description></item>
               <item><description> <seealso cref="T:Lucene.Net.Search.ConstantScoreQuery"/> </description></item>
               <item><description> <seealso cref="T:Lucene.Net.Search.DisjunctionMaxQuery"/> </description></item>
               <item><description> <seealso cref="T:Lucene.Net.Search.MatchAllDocsQuery"/> </description></item>
               </list>
               <para/>See also the family of Span Queries (<see cref="N:Lucene.Net.Search.Spans"/>)
                  and additional queries available in the <a href="{@docRoot}/../queries/overview-summary.html">Queries module</a>
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Query.Boost">
            <summary>
            Gets or Sets the boost for this query clause.  Documents
            matching this clause will (in addition to the normal weightings) have
            their score multiplied by <see cref="P:Lucene.Net.Search.Query.Boost"/>. The boost is 1.0 by default.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.ToString(System.String)">
            <summary>
            Prints a query to a string, with <paramref name="field"/> assumed to be the
            default field and omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.ToString">
            <summary>
            Prints a query to a string. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.CreateWeight(Lucene.Net.Search.IndexSearcher)">
             <summary>
             Expert: Constructs an appropriate <see cref="T:Lucene.Net.Search.Weight"/> implementation for this query.
            
             <para/>
             Only implemented by primitive queries, which re-write to themselves.
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>
            Expert: called to re-write queries into primitive queries. For example,
            a <see cref="T:Lucene.Net.Search.PrefixQuery"/> will be rewritten into a <see cref="T:Lucene.Net.Search.BooleanQuery"/> that consists
            of <see cref="T:Lucene.Net.Search.TermQuery"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.ExtractTerms(System.Collections.Generic.ISet{Lucene.Net.Index.Term})">
            <summary>
            Expert: adds all terms occurring in this query to the terms set. Only
            works if this query is in its rewritten (<see cref="M:Lucene.Net.Search.Query.Rewrite(Lucene.Net.Index.IndexReader)"/>) form.
            </summary>
            <exception cref="T:System.InvalidOperationException"> If this query is not yet rewritten </exception>
        </member>
        <member name="M:Lucene.Net.Search.Query.Clone">
            <summary>
            Returns a clone of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.QueryRescorer">
            <summary>
            A <see cref="T:Lucene.Net.Search.Rescorer"/> that uses a provided <see cref="T:Lucene.Net.Search.Query"/> to assign
            scores to the first-pass hits.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryRescorer.#ctor(Lucene.Net.Search.Query)">
            <summary>
            Sole constructor, passing the 2nd pass query to
            assign scores to the 1st pass hits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryRescorer.Combine(System.Single,System.Boolean,System.Single)">
            <summary>
            Implement this in a subclass to combine the first pass and
            second pass scores.  If <paramref name="secondPassMatches"/> is <c>false</c> then
            the second pass query failed to match a hit from the
            first pass query, and you should ignore the
            <paramref name="secondPassScore"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryRescorer.Rescore(Lucene.Net.Search.IndexSearcher,Lucene.Net.Search.TopDocs,Lucene.Net.Search.Query,System.Double,System.Int32)">
            <summary>
            Sugar API, calling <see cref="M:Lucene.Net.Search.QueryRescorer.Rescore(Lucene.Net.Search.IndexSearcher,Lucene.Net.Search.TopDocs,System.Int32)"/> using a simple linear
            combination of firstPassScore + <paramref name="weight"/> * secondPassScore
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.QueryWrapperFilter">
             <summary>
             Constrains search results to only match those which also match a provided
             query.
            
             <para/> This could be used, for example, with a <see cref="T:Lucene.Net.Search.NumericRangeQuery"/> on a suitably
             formatted date field to implement date filtering.  One could re-use a single
             <c>CachingWrapperFilter(QueryWrapperFilter)</c> that matches, e.g., only documents modified
             within the last week.  This would only need to be reconstructed once per day.
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryWrapperFilter.#ctor(Lucene.Net.Search.Query)">
            <summary>
            Constructs a filter which only matches documents matching
            <paramref name="query"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.QueryWrapperFilter.Query">
            <summary>
            Returns the inner Query </summary>
        </member>
        <member name="T:Lucene.Net.Search.ReferenceManager`1">
            <summary>
            Utility class to safely share instances of a certain type across multiple
            threads, while periodically refreshing them. This class ensures each
            reference is closed only once all threads have finished using it. It is
            recommended to consult the documentation of <see cref="T:Lucene.Net.Search.ReferenceManager`1"/>
            implementations for their <see cref="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh"/> semantics.
            <para/>
            @lucene.experimental
            </summary>
            <typeparam name="G">The concrete type that will be <see cref="M:Lucene.Net.Search.ReferenceManager`1.Acquire"/>d and
                     <see cref="M:Lucene.Net.Search.ReferenceManager`1.Release(`0)"/>d.</typeparam>
        </member>
        <member name="P:Lucene.Net.Search.ReferenceManager`1.Current">
            <summary>
            The current reference
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.DecRef(`0)">
            <summary>
            Decrement reference counting on the given reference. </summary>
            <exception cref="T:System.IO.IOException"> If reference decrement on the given resource failed.</exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.RefreshIfNeeded(`0)">
            <summary>
            Refresh the given reference if needed. Returns <c>null</c> if no refresh
            was needed, otherwise a new refreshed reference. </summary>
            <exception cref="T:System.ObjectDisposedException"> If the reference manager has been <see cref="M:Lucene.Net.Search.ReferenceManager`1.Dispose"/>d. </exception>
            <exception cref="T:System.IO.IOException"> If the refresh operation failed </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.TryIncRef(`0)">
            <summary>
            Try to increment reference counting on the given reference. Returns <c>true</c> if
            the operation was successful. </summary>
            <exception cref="T:System.ObjectDisposedException"> if the reference manager has been <see cref="M:Lucene.Net.Search.ReferenceManager`1.Dispose"/>d.  </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.Acquire">
            <summary>
            Obtain the current reference. You must match every call to acquire with one
            call to <see cref="M:Lucene.Net.Search.ReferenceManager`1.Release(`0)"/>; it's best to do so in a finally clause, and set
            the reference to <c>null</c> to prevent accidental usage after it has been
            released. </summary>
            <exception cref="T:System.ObjectDisposedException"> If the reference manager has been <see cref="M:Lucene.Net.Search.ReferenceManager`1.Dispose"/>d.  </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.Dispose">
            <summary>
            <para>
            Closes this ReferenceManager to prevent future <see cref="M:Lucene.Net.Search.ReferenceManager`1.Acquire"/>ing. A
            reference manager should be disposed if the reference to the managed resource
            should be disposed or the application using the <see cref="T:Lucene.Net.Search.ReferenceManager`1"/>
            is shutting down. The managed resource might not be released immediately,
            if the <see cref="T:Lucene.Net.Search.ReferenceManager`1"/> user is holding on to a previously
            <see cref="M:Lucene.Net.Search.ReferenceManager`1.Acquire"/>d reference. The resource will be released once
            when the last reference is <see cref="M:Lucene.Net.Search.ReferenceManager`1.Release(`0)"/>d. Those
            references can still be used as if the manager was still active.
            </para>
            <para>
            Applications should not <see cref="M:Lucene.Net.Search.ReferenceManager`1.Acquire"/> new references from this
            manager once this method has been called. <see cref="M:Lucene.Net.Search.ReferenceManager`1.Acquire"/>ing a
            resource on a disposed <see cref="T:Lucene.Net.Search.ReferenceManager`1"/> will throw an
            <seealso cref="T:System.ObjectDisposedException"/>.
            </para>
            </summary>
            <exception cref="T:System.IO.IOException">
                      If the underlying reader of the current reference could not be disposed </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.GetRefCount(`0)">
            <summary>
            Returns the current reference count of the given reference.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.Dispose(System.Boolean)">
            <summary>
            Called after <see cref="M:Lucene.Net.Search.ReferenceManager`1.Dispose"/>, so subclass can free any resources. </summary>
            <exception cref="T:System.IO.IOException"> if the after dispose operation in a sub-class throws an <see cref="T:System.IO.IOException"/>
            </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh">
             <summary>
             You must call this (or <see cref="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefreshBlocking"/>), periodically, if
             you want that <see cref="M:Lucene.Net.Search.ReferenceManager`1.Acquire"/> will return refreshed instances.
            
             <para>
             <b>Threads</b>: it's fine for more than one thread to call this at once.
             Only the first thread will attempt the refresh; subsequent threads will see
             that another thread is already handling refresh and will return
             immediately. Note that this means if another thread is already refreshing
             then subsequent threads will return right away without waiting for the
             refresh to complete.
             </para>
             <para>
             If this method returns <c>true</c> it means the calling thread either refreshed or
             that there were no changes to refresh. If it returns <c>false</c> it means another
             thread is currently refreshing.
             </para> </summary>
             <exception cref="T:System.IO.IOException"> If refreshing the resource causes an <see cref="T:System.IO.IOException"/> </exception>
             <exception cref="T:System.ObjectDisposedException"> If the reference manager has been <see cref="M:Lucene.Net.Search.ReferenceManager`1.Dispose"/>d.  </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefreshBlocking">
             <summary>
             You must call this (or <see cref="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh"/>), periodically, if you want
             that <see cref="M:Lucene.Net.Search.ReferenceManager`1.Acquire"/> will return refreshed instances.
            
             <para/>
             <b>Threads</b>: unlike <see cref="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh"/>, if another thread is
             currently refreshing, this method blocks until that thread completes. It is
             useful if you want to guarantee that the next call to <see cref="M:Lucene.Net.Search.ReferenceManager`1.Acquire"/>
             will return a refreshed instance. Otherwise, consider using the
             non-blocking <see cref="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh"/>. </summary>
             <exception cref="T:System.IO.IOException"> If refreshing the resource causes an <see cref="T:System.IO.IOException"/> </exception>
             <exception cref="T:System.ObjectDisposedException"> If the reference manager has been <see cref="M:Lucene.Net.Search.ReferenceManager`1.Dispose"/>d.  </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.AfterMaybeRefresh">
            <summary>
            Called after a refresh was attempted, regardless of
            whether a new reference was in fact created. </summary>
            <exception cref="T:System.IO.IOException"> if a low level I/O exception occurs</exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.Release(`0)">
            <summary>
            Release the reference previously obtained via <see cref="M:Lucene.Net.Search.ReferenceManager`1.Acquire"/>.
            <para/>
            <b>NOTE:</b> it's safe to call this after <see cref="M:Lucene.Net.Search.ReferenceManager`1.Dispose"/>. </summary>
            <exception cref="T:System.IO.IOException"> If the release operation on the given resource throws an <see cref="T:System.IO.IOException"/> </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.AddListener(Lucene.Net.Search.ReferenceManager.IRefreshListener)">
            <summary>
            Adds a listener, to be notified when a reference is refreshed/swapped.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.RemoveListener(Lucene.Net.Search.ReferenceManager.IRefreshListener)">
            <summary>
            Remove a listener added with <see cref="M:Lucene.Net.Search.ReferenceManager`1.AddListener(Lucene.Net.Search.ReferenceManager.IRefreshListener)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ReferenceManager">
            <summary>
            LUCENENET specific class used to provide static access to <see cref="T:Lucene.Net.Search.ReferenceManager.IRefreshListener"/>
            without having to specifiy the generic closing type of <see cref="T:Lucene.Net.Search.ReferenceManager`1"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ReferenceManager.IRefreshListener">
            <summary>
            Use to receive notification when a refresh has
            finished.  See <see cref="M:Lucene.Net.Search.ReferenceManager`1.AddListener(Lucene.Net.Search.ReferenceManager.IRefreshListener)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager.IRefreshListener.BeforeRefresh">
            <summary>
            Called right before a refresh attempt starts. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager.IRefreshListener.AfterRefresh(System.Boolean)">
            <summary>
            Called after the attempted refresh; if the refresh
            did open a new reference then didRefresh will be <c>true</c>
            and <see cref="M:Lucene.Net.Search.ReferenceManager`1.Acquire"/> is guaranteed to return the new
            reference.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.RegexpQuery">
            <summary>
            A fast regular expression query based on the
            <see cref="N:Lucene.Net.Util.Automaton"/> package.
            <list type="bullet">
                <item><description>Comparisons are <a
                    href="http://tusker.org/regex/regex_benchmark.html">fast</a></description></item>
                <item><description>The term dictionary is enumerated in an intelligent way, to avoid
                    comparisons. See <see cref="T:Lucene.Net.Search.AutomatonQuery"/> for more details.</description></item>
            </list>
            <para>
            The supported syntax is documented in the <see cref="T:Lucene.Net.Util.Automaton.RegExp"/> class.
            Note this might be different than other regular expression implementations.
            For some alternatives with different syntax, look under the sandbox.
            </para>
            <para>
            Note this query can be slow, as it needs to iterate over many terms. In order
            to prevent extremely slow <see cref="T:Lucene.Net.Search.RegexpQuery"/>s, a <see cref="T:Lucene.Net.Util.Automaton.RegExp"/> term should not start with
            the expression <c>.*</c>
            </para>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Util.Automaton.RegExp"/>
        </member>
        <member name="F:Lucene.Net.Search.RegexpQuery.defaultProvider">
            <summary>
            A provider that provides no named automata
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RegexpQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Constructs a query for terms matching <paramref name="term"/>.
            <para>
            By default, all regular expression features are enabled.
            </para>
            </summary>
            <param name="term"> Regular expression. </param>
        </member>
        <member name="M:Lucene.Net.Search.RegexpQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Util.Automaton.RegExpSyntax)">
            <summary>
            Constructs a query for terms matching <paramref name="term"/>.
            </summary>
            <param name="term"> Regular expression. </param>
            <param name="flags"> Optional <see cref="T:Lucene.Net.Util.Automaton.RegExp"/> features from <see cref="T:Lucene.Net.Util.Automaton.RegExpSyntax"/> </param>
        </member>
        <member name="M:Lucene.Net.Search.RegexpQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Util.Automaton.RegExpSyntax,Lucene.Net.Util.Automaton.IAutomatonProvider)">
            <summary>
            Constructs a query for terms matching <paramref name="term"/>.
            </summary>
            <param name="term"> Regular expression. </param>
            <param name="flags"> Optional <see cref="T:Lucene.Net.Util.Automaton.RegExp"/> features from <see cref="T:Lucene.Net.Util.Automaton.RegExpSyntax"/> </param>
            <param name="provider"> Custom <see cref="T:Lucene.Net.Util.Automaton.IAutomatonProvider"/> for named automata </param>
        </member>
        <member name="M:Lucene.Net.Search.RegexpQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ReqExclScorer">
            <summary>
            A <see cref="T:Lucene.Net.Search.Scorer"/> for queries with a required subscorer
            and an excluding (prohibited) sub <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>.
            <para/>
            This <see cref="T:Lucene.Net.Search.Scorer"/> implements <see cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/>,
            and it uses the SkipTo() on the given scorers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReqExclScorer.#ctor(Lucene.Net.Search.Scorer,Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.ReqExclScorer"/>. </summary>
            <param name="reqScorer"> The scorer that must match, except where </param>
            <param name="exclDisi"> Indicates exclusion. </param>
        </member>
        <member name="M:Lucene.Net.Search.ReqExclScorer.ToNonExcluded">
            <summary>
            Advance to non excluded doc.
            <para/>On entry:
            <list type="bullet">
            <item><description>reqScorer != null,</description></item>
            <item><description>exclScorer != null,</description></item>
            <item><description>reqScorer was advanced once via Next() or SkipTo()
                 and reqScorer.Doc may still be excluded.</description></item>
            </list>
            Advances reqScorer a non excluded required doc, if any. </summary>
            <returns> <c>true</c> if there is a non excluded required doc. </returns>
        </member>
        <member name="M:Lucene.Net.Search.ReqExclScorer.GetScore">
            <summary>
            Returns the score of the current document matching the query.
            Initially invalid, until <see cref="M:Lucene.Net.Search.ReqExclScorer.NextDoc"/> is called the first time. </summary>
            <returns> The score of the required scorer. </returns>
        </member>
        <member name="T:Lucene.Net.Search.ReqOptSumScorer">
            <summary>
            A <see cref="T:Lucene.Net.Search.Scorer"/> for queries with a required part and an optional part.
            Delays SkipTo() on the optional part until a GetScore() is needed.
            <para/>
            This <see cref="T:Lucene.Net.Search.Scorer"/> implements <see cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.ReqOptSumScorer.reqScorer">
            <summary>
            The scorers passed from the constructor.
            These are set to <c>null</c> as soon as their Next() or SkipTo() returns <c>false</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.#ctor(Lucene.Net.Search.Scorer,Lucene.Net.Search.Scorer)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.ReqOptSumScorer"/>. </summary>
            <param name="reqScorer"> The required scorer. This must match. </param>
            <param name="optScorer"> The optional scorer. This is used for scoring only. </param>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.GetScore">
            <summary>
            Returns the score of the current document matching the query.
            Initially invalid, until <see cref="M:Lucene.Net.Search.ReqOptSumScorer.NextDoc"/> is called the first time. </summary>
            <returns> The score of the required scorer, eventually increased by the score
            of the optional scorer when it also matches the current document. </returns>
        </member>
        <member name="T:Lucene.Net.Search.Rescorer">
             <summary>
             Re-scores the topN results (<see cref="T:Lucene.Net.Search.TopDocs"/>) from an original
             query.  See <see cref="T:Lucene.Net.Search.QueryRescorer"/> for an actual
             implementation.  Typically, you run a low-cost
             first-pass query across the entire index, collecting the
             top few hundred hits perhaps, and then use this class to
             mix in a more costly second pass scoring.
            
             <para/>See 
             <see cref="M:Lucene.Net.Search.QueryRescorer.Rescore(Lucene.Net.Search.IndexSearcher,Lucene.Net.Search.TopDocs,Lucene.Net.Search.Query,System.Double,System.Int32)"/>
             for a simple static method to call to rescore using a 2nd
             pass <see cref="T:Lucene.Net.Search.Query"/>.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.Rescorer.Rescore(Lucene.Net.Search.IndexSearcher,Lucene.Net.Search.TopDocs,System.Int32)">
            <summary>
            Rescore an initial first-pass <see cref="T:Lucene.Net.Search.TopDocs"/>.
            </summary>
            <param name="searcher"> <see cref="T:Lucene.Net.Search.IndexSearcher"/> used to produce the
              first pass topDocs </param>
            <param name="firstPassTopDocs"> Hits from the first pass
              search.  It's very important that these hits were
              produced by the provided searcher; otherwise the doc
              IDs will not match! </param>
            <param name="topN"> How many re-scored hits to return </param>
        </member>
        <member name="M:Lucene.Net.Search.Rescorer.Explain(Lucene.Net.Search.IndexSearcher,Lucene.Net.Search.Explanation,System.Int32)">
            <summary>
            Explains how the score for the specified document was
            computed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ScoreCachingWrappingScorer">
            <summary>
            A <see cref="T:Lucene.Net.Search.Scorer"/> which wraps another scorer and caches the score of the
            current document. Successive calls to <see cref="M:Lucene.Net.Search.ScoreCachingWrappingScorer.GetScore"/> will return the same
            result and will not invoke the wrapped Scorer's GetScore() method, unless the
            current document has changed.
            <para/>
            This class might be useful due to the changes done to the <see cref="T:Lucene.Net.Search.ICollector"/>
            interface, in which the score is not computed for a document by default, only
            if the collector requests it. Some collectors may need to use the score in
            several places, however all they have in hand is a <see cref="T:Lucene.Net.Search.Scorer"/> object, and
            might end up computing the score of a document more than once.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ScoreCachingWrappingScorer.#ctor(Lucene.Net.Search.Scorer)">
            <summary>
            Creates a new instance by wrapping the given scorer. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ScoreDoc">
            <summary>
            Holds one hit in <see cref="T:Lucene.Net.Search.TopDocs"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Search.ScoreDoc.Score">
            <summary>
            The score of this document for the query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.ScoreDoc.Doc">
            <summary>
            A hit document's number. </summary>
            <seealso cref="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)"/>
        </member>
        <member name="P:Lucene.Net.Search.ScoreDoc.ShardIndex">
            <summary>
            Only set by <see cref="M:Lucene.Net.Search.TopDocs.Merge(Lucene.Net.Search.Sort,System.Int32,System.Int32,Lucene.Net.Search.TopDocs[])"/> </summary>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDoc.#ctor(System.Int32,System.Single)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Search.ScoreDoc"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDoc.#ctor(System.Int32,System.Single,System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Search.ScoreDoc"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDoc.ToString">
            <summary>
            A convenience method for debugging.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Scorer">
             <summary>
             Expert: Common scoring functionality for different types of queries.
            
             <para>
             A <see cref="T:Lucene.Net.Search.Scorer"/> iterates over documents matching a
             query in increasing order of doc Id.
             </para>
             <para>
             Document scores are computed using a given <see cref="T:Lucene.Net.Search.Similarities.Similarity"/>
             implementation.
             </para>
            
             <para><b>NOTE</b>: The values <see cref="F:System.Single.NaN"/>,
             <see cref="F:System.Single.NegativeInfinity"/> and <see cref="F:System.Single.PositiveInfinity"/> are
             not valid scores.  Certain collectors (eg 
             <see cref="T:Lucene.Net.Search.TopScoreDocCollector"/>) will not properly collect hits
             with these scores.
             </para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.Scorer.m_weight">
            <summary>
            The <see cref="T:Lucene.Net.Search.Scorer"/>'s parent <see cref="P:Lucene.Net.Search.Scorer.Weight"/>. In some cases this may be <c>null</c>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.#ctor(Lucene.Net.Search.Weight)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Search.Scorer"/> </summary>
            <param name="weight"> The scorers <see cref="P:Lucene.Net.Search.Scorer.Weight"/>. </param>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.GetScore">
            <summary>
            Returns the score of the current document matching the query.
            Initially invalid, until <see cref="M:Lucene.Net.Search.DocIdSetIterator.NextDoc"/> or <see cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/>
            is called the first time, or when called from within
            <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Scorer.Weight">
            <summary>
            returns parent <see cref="P:Lucene.Net.Search.Scorer.Weight"/>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.GetChildren">
            <summary>
            Returns child sub-scorers
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Scorer.ChildScorer">
            <summary>
            A child <see cref="T:Lucene.Net.Search.Scorer"/> and its relationship to its parent.
            The meaning of the relationship depends upon the parent query.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Scorer.ChildScorer.Child">
            <summary>
            Child <see cref="T:Lucene.Net.Search.Scorer"/>. (note this is typically a direct child, and may
            itself also have children).
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Scorer.ChildScorer.Relationship">
            <summary>
            An arbitrary string relating this scorer to the parent.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.ChildScorer.#ctor(Lucene.Net.Search.Scorer,System.String)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Search.Scorer.ChildScorer"/> node with the specified relationship.
            <para/>
            The relationship can be any be any string that makes sense to
            the parent <see cref="T:Lucene.Net.Search.Scorer"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ScoringRewrite`1">
            <summary>
            Base rewrite method that translates each term into a query, and keeps
            the scores as computed by the query.
            <para/>
            @lucene.internal - Only public to be accessible by spans package.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.ScoringRewrite`1.SCORING_BOOLEAN_QUERY_REWRITE">
             <summary>
             A rewrite method that first translates each term into
             <see cref="F:Lucene.Net.Search.Occur.SHOULD"/> clause in a
             <see cref="T:Lucene.Net.Search.BooleanQuery"/>, and keeps the scores as computed by the
             query.  Note that typically such scores are
             meaningless to the user, and require non-trivial CPU
             to compute, so it's almost always better to use 
             <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT"/> instead.
            
             <para/><b>NOTE</b>: this rewrite method will hit 
             <see cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"/> if the number of terms
             exceeds <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/>.
             </summary>
              <seealso cref="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod"/>
        </member>
        <member name="F:Lucene.Net.Search.ScoringRewrite`1.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE">
             <summary>
             Like <see cref="F:Lucene.Net.Search.ScoringRewrite`1.SCORING_BOOLEAN_QUERY_REWRITE"/> except
             scores are not computed.  Instead, each matching
             document receives a constant score equal to the
             query's boost.
            
             <para/><b>NOTE</b>: this rewrite method will hit 
             <see cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"/> if the number of terms
             exceeds <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/>.
             </summary>
             <seealso cref="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod"/>
        </member>
        <member name="M:Lucene.Net.Search.ScoringRewrite`1.CheckMaxClauseCount(System.Int32)">
            <summary>
            This method is called after every new term to check if the number of max clauses
            (e.g. in <see cref="T:Lucene.Net.Search.BooleanQuery"/>) is not exceeded. Throws the corresponding <see cref="T:System.Exception"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ScoringRewrite`1.TermFreqBoostByteStart">
            <summary>
            Special implementation of <see cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/> that keeps parallel arrays for boost and docFreq </summary>
        </member>
        <member name="T:Lucene.Net.Search.SearcherFactory">
             <summary>
             Factory class used by <see cref="T:Lucene.Net.Search.SearcherManager"/> to
             create new <see cref="T:Lucene.Net.Search.IndexSearcher"/>s. The default implementation just creates
             an <see cref="T:Lucene.Net.Search.IndexSearcher"/> with no custom behavior:
            
             <code>
                 public IndexSearcher NewSearcher(IndexReader r)
                 {
                     return new IndexSearcher(r);
                 }
             </code>
            
             You can pass your own factory instead if you want custom behavior, such as:
             <list type="bullet">
               <item><description>Setting a custom scoring model: <see cref="P:Lucene.Net.Search.IndexSearcher.Similarity"/></description></item>
               <item><description>Parallel per-segment search: <see cref="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReader,System.Threading.Tasks.TaskScheduler)"/></description></item>
               <item><description>Return custom subclasses of <see cref="T:Lucene.Net.Search.IndexSearcher"/> (for example that implement distributed scoring)</description></item>
               <item><description>Run queries to warm your <see cref="T:Lucene.Net.Search.IndexSearcher"/> before it is used. Note: when using near-realtime search
                   you may want to also set <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MergedSegmentWarmer"/> to warm
                   newly merged segments in the background, outside of the reopen path.</description></item>
             </list>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherFactory.NewSearcher(Lucene.Net.Index.IndexReader)">
            <summary>
            Returns a new <see cref="T:Lucene.Net.Search.IndexSearcher"/> over the given reader.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.SearcherLifetimeManager">
             <summary>
             Keeps track of current plus old <see cref="T:Lucene.Net.Search.IndexSearcher"/>s, disposing
             the old ones once they have timed out.
            
             Use it like this:
            
             <code>
                 SearcherLifetimeManager mgr = new SearcherLifetimeManager();
             </code>
            
             Per search-request, if it's a "new" search request, then
             obtain the latest searcher you have (for example, by
             using <see cref="T:Lucene.Net.Search.SearcherManager"/>), and then record this
             searcher:
            
             <code>
                 // Record the current searcher, and save the returend
                 // token into user's search results (eg as a  hidden
                 // HTML form field):
                 long token = mgr.Record(searcher);
             </code>
            
             When a follow-up search arrives, for example the user
             clicks next page, drills down/up, etc., take the token
             that you saved from the previous search and:
            
             <code>
                 // If possible, obtain the same searcher as the last
                 // search:
                 IndexSearcher searcher = mgr.Acquire(token);
                 if (searcher != null) 
                 {
                     // Searcher is still here
                     try 
                     {
                         // do searching...
                     } 
                     finally 
                     {
                         mgr.Release(searcher);
                         // Do not use searcher after this!
                         searcher = null;
                     }
                 } 
                 else 
                 {
                     // Searcher was pruned -- notify user session timed
                     // out, or, pull fresh searcher again
                 }
             </code>
            
             Finally, in a separate thread, ideally the same thread
             that's periodically reopening your searchers, you should
             periodically prune old searchers:
            
             <code>
                 mgr.Prune(new PruneByAge(600.0));
             </code>
            
             <para><b>NOTE</b>: keeping many searchers around means
             you'll use more resources (open files, RAM) than a single
             searcher.  However, as long as you are using 
             <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)"/>, the searchers
             will usually share almost all segments and the added resource usage
             is contained.  When a large merge has completed, and
             you reopen, because that is a large change, the new
             searcher will use higher additional RAM than other
             searchers; but large merges don't complete very often and
             it's unlikely you'll hit two of them in your expiration
             window.  Still you should budget plenty of heap in the
             runtime to have a good safety margin.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherLifetimeManager.Record(Lucene.Net.Search.IndexSearcher)">
             <summary>
             Records that you are now using this <see cref="T:Lucene.Net.Search.IndexSearcher"/>.
             Always call this when you've obtained a possibly new
             <see cref="T:Lucene.Net.Search.IndexSearcher"/>, for example from 
             <see cref="T:Lucene.Net.Search.SearcherManager"/>.  It's fine if you already passed the
             same searcher to this method before.
            
             <para>This returns the <see cref="T:System.Int64"/> token that you can later pass
             to <see cref="M:Lucene.Net.Search.SearcherLifetimeManager.Acquire(System.Int64)"/> to retrieve the same <see cref="T:Lucene.Net.Search.IndexSearcher"/>.
             You should record this <see cref="T:System.Int64"/> token in the search results
             sent to your user, such that if the user performs a
             follow-on action (clicks next page, drills down, etc.)
             the token is returned.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherLifetimeManager.Acquire(System.Int64)">
             <summary>
             Retrieve a previously recorded <see cref="T:Lucene.Net.Search.IndexSearcher"/>, if it
             has not yet been closed.
            
             <para><b>NOTE</b>: this may return <c>null</c> when the
             requested searcher has already timed out.  When this
             happens you should notify your user that their session
             timed out and that they'll have to restart their
             search.</para>
            
             <para>If this returns a non-null result, you must match
             later call <see cref="M:Lucene.Net.Search.SearcherLifetimeManager.Release(Lucene.Net.Search.IndexSearcher)"/> on this searcher, best
             from a finally clause.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherLifetimeManager.Release(Lucene.Net.Search.IndexSearcher)">
             <summary>
             Release a searcher previously obtained from 
             <see cref="M:Lucene.Net.Search.SearcherLifetimeManager.Acquire(System.Int64)"/>.
            
             <para/><b>NOTE</b>: it's fine to call this after Dispose().
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.SearcherLifetimeManager.IPruner">
            <summary>
            See <see cref="M:Lucene.Net.Search.SearcherLifetimeManager.Prune(Lucene.Net.Search.SearcherLifetimeManager.IPruner)"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherLifetimeManager.IPruner.DoPrune(System.Double,Lucene.Net.Search.IndexSearcher)">
            <summary>
            Return <c>true</c> if this searcher should be removed. </summary>
             <param name="ageSec"> How much time has passed since this
                    searcher was the current (live) searcher </param>
             <param name="searcher"> Searcher </param>
        </member>
        <member name="T:Lucene.Net.Search.SearcherLifetimeManager.PruneByAge">
            <summary>
            Simple pruner that drops any searcher older by
            more than the specified seconds, than the newest
            searcher.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherLifetimeManager.Prune(Lucene.Net.Search.SearcherLifetimeManager.IPruner)">
             <summary>
             Calls provided <see cref="T:Lucene.Net.Search.SearcherLifetimeManager.IPruner"/> to prune entries.  The
             entries are passed to the <see cref="T:Lucene.Net.Search.SearcherLifetimeManager.IPruner"/> in sorted (newest to
             oldest <see cref="T:Lucene.Net.Search.IndexSearcher"/>) order.
            
             <para/><b>NOTE</b>: you must peridiocally call this, ideally
             from the same background thread that opens new
             searchers.
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherLifetimeManager.Dispose">
             <summary>
             Close this to future searching; any searches still in
             process in other threads won't be affected, and they
             should still call <see cref="M:Lucene.Net.Search.SearcherLifetimeManager.Release(Lucene.Net.Search.IndexSearcher)"/> after they are
             done.
            
             <para/><b>NOTE</b>: you must ensure no other threads are
             calling <see cref="M:Lucene.Net.Search.SearcherLifetimeManager.Record(Lucene.Net.Search.IndexSearcher)"/> while you call Dispose();
             otherwise it's possible not all searcher references
             will be freed.
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.SearcherManager">
             <summary>
             Utility class to safely share <see cref="T:Lucene.Net.Search.IndexSearcher"/> instances across multiple
             threads, while periodically reopening. This class ensures each searcher is
             disposed only once all threads have finished using it.
            
             <para/>
             Use <see cref="M:Lucene.Net.Search.ReferenceManager`1.Acquire"/> to obtain the current searcher, and <see cref="M:Lucene.Net.Search.ReferenceManager`1.Release(`0)"/> to
             release it, like this:
            
             <code>
             IndexSearcher s = manager.Acquire();
             try 
             {
                 // Do searching, doc retrieval, etc. with s
             } 
             finally 
             {
                 manager.Release(s);
                 // Do not use s after this!
                 s = null;
             }
             </code>
            
             <para/>
             In addition you should periodically call <see cref="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh"/>. While it's
             possible to call this just before running each query, this is discouraged
             since it penalizes the unlucky queries that do the reopen. It's better to use
             a separate background thread, that periodically calls <see cref="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh"/>. Finally,
             be sure to call <see cref="M:Lucene.Net.Search.ReferenceManager`1.Dispose"/> once you are done.
             <para/>
             @lucene.experimental
             </summary>
             <seealso cref="T:Lucene.Net.Search.SearcherFactory"/>
        </member>
        <member name="M:Lucene.Net.Search.SearcherManager.#ctor(Lucene.Net.Index.IndexWriter,System.Boolean,Lucene.Net.Search.SearcherFactory)">
            <summary>
            Creates and returns a new <see cref="T:Lucene.Net.Search.SearcherManager"/> from the given
            <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
            <param name="writer">
                     The <see cref="T:Lucene.Net.Index.IndexWriter"/> to open the <see cref="T:Lucene.Net.Index.IndexReader"/> from. </param>
            <param name="applyAllDeletes">
                     If <c>true</c>, all buffered deletes will be applied (made
                     visible) in the <see cref="T:Lucene.Net.Search.IndexSearcher"/> / <see cref="T:Lucene.Net.Index.DirectoryReader"/>.
                     If <c>false</c>, the deletes may or may not be applied, but
                     remain buffered (in <see cref="T:Lucene.Net.Index.IndexWriter"/>) so that they will be applied in
                     the future. Applying deletes can be costly, so if your app can
                     tolerate deleted documents being returned you might gain some
                     performance by passing <c>false</c>. See
                     <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexWriter,System.Boolean)"/>. </param>
            <param name="searcherFactory">
                     An optional <see cref="T:Lucene.Net.Search.SearcherFactory"/>. Pass <c>null</c> if you
                     don't require the searcher to be warmed before going live or other
                     custom behavior.
            </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Search.SearcherManager.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Search.SearcherFactory)">
            <summary>
            Creates and returns a new <see cref="T:Lucene.Net.Search.SearcherManager"/> from the given <see cref="T:Lucene.Net.Store.Directory"/>. </summary>
            <param name="dir"> The directory to open the <see cref="T:Lucene.Net.Index.DirectoryReader"/> on. </param>
            <param name="searcherFactory"> An optional <see cref="T:Lucene.Net.Search.SearcherFactory"/>. Pass
                   <c>null</c> if you don't require the searcher to be warmed
                   before going live or other custom behavior.
            </param>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Search.SearcherManager.IsSearcherCurrent">
            <summary>
            Returns <c>true</c> if no changes have occured since this searcher
            ie. reader was opened, otherwise <c>false</c>. </summary>
            <seealso cref="M:Lucene.Net.Index.DirectoryReader.IsCurrent"/>
        </member>
        <member name="M:Lucene.Net.Search.SearcherManager.GetSearcher(Lucene.Net.Search.SearcherFactory,Lucene.Net.Index.IndexReader)">
            <summary>
            Expert: creates a searcher from the provided 
            <see cref="T:Lucene.Net.Index.IndexReader"/> using the provided 
            <see cref="T:Lucene.Net.Search.SearcherFactory"/>.  NOTE: this decRefs incoming reader
            on throwing an exception.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.AfterEffect">
            <summary>
            This class acts as the base class for the implementations of the <em>first
            normalization of the informative content</em> in the DFR framework. This
            component is also called the <em>after effect</em> and is defined by the
            formula <em>Inf<sub>2</sub> = 1 - Prob<sub>2</sub></em>, where
            <em>Prob<sub>2</sub></em> measures the <em>information gain</em>.
            <para/>
            @lucene.experimental 
            </summary>
            <seealso cref="T:Lucene.Net.Search.Similarities.DFRSimilarity"/>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single)">
            <summary>
            Returns the aftereffect score. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Single)">
            <summary>
            Returns an explanation for the score. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.AfterEffect.NoAfterEffect">
            <summary>
            Implementation used when there is no aftereffect. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.NoAfterEffect.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.ToString">
            <summary>
            Subclasses must override this method to return the code of the
            after effect formula. Refer to the original paper for the list.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.AfterEffectB">
            <summary>
            Model of the information gain based on the ratio of two Bernoulli processes.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffectB.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.AfterEffectL">
            <summary>
            Model of the information gain based on Laplace's law of succession.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffectL.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModel">
            <summary>
            This class acts as the base class for the specific <em>basic model</em>
            implementations in the DFR framework. Basic models compute the
            <em>informative content Inf<sub>1</sub> = -log<sub>2</sub>Prob<sub>1</sub>
            </em>.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Search.Similarities.DFRSimilarity"/>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModel.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModel.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single)">
            <summary>
            Returns the informative content score. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModel.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Single)">
            <summary>
            Returns an explanation for the score.
            <para>Most basic models use the number of documents and the total term
            frequency to compute Inf<sub>1</sub>. this method provides a generic
            explanation for such models. Subclasses that use other statistics must
            override this method.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModel.ToString">
            <summary>
            Subclasses must override this method to return the code of the
            basic model formula. Refer to the original paper for the list.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelBE">
            <summary>
            Limiting form of the Bose-Einstein model. The formula used in Lucene differs
            slightly from the one in the original paper: <c>F</c> is increased by <c>tfn+1</c>
            and <c>N</c> is increased by <c>F</c>
            <para/>
            @lucene.experimental
            <para/>
            NOTE: in some corner cases this model may give poor performance with Normalizations that
            return large values for <c>tfn</c> such as <see cref="T:Lucene.Net.Search.Similarities.NormalizationH3"/>. Consider using the
            geometric approximation (<see cref="T:Lucene.Net.Search.Similarities.BasicModelG"/>) instead, which provides the same relevance
            but with less practical problems.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelBE.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelBE.F(System.Double,System.Double)">
            <summary>
            The <em>f</em> helper function defined for <em>B<sub>E</sub></em>. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelD">
            <summary>
            Implements the approximation of the binomial model with the divergence
            for DFR. The formula used in Lucene differs slightly from the one in the
            original paper: to avoid underflow for small values of <c>N</c> and
            <c>F</c>, <c>N</c> is increased by <c>1</c> and
            <c>F</c> is always increased by <c>tfn+1</c>.
            <para/>
            WARNING: for terms that do not meet the expected random distribution
            (e.g. stopwords), this model may give poor performance, such as
            abnormally high scores for low tf values.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelD.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelG">
            <summary>
            Geometric as limiting form of the Bose-Einstein model.  The formula used in Lucene differs
            slightly from the one in the original paper: <c>F</c> is increased by <c>1</c>
            and <c>N</c> is increased by <c>F</c>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelG.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelIF">
            <summary>
            An approximation of the <em>I(n<sub>e</sub>)</em> model.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelIF.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelIn">
            <summary>
            The basic tf-idf model of randomness.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelIn.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelIne">
            <summary>
            Tf-idf model of randomness, based on a mixture of Poisson and inverse
            document frequency.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelIne.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelP">
            <summary>
            Implements the Poisson approximation for the binomial model for DFR.
            <para/>
            @lucene.experimental
            <para/>
            WARNING: for terms that do not meet the expected random distribution
            (e.g. stopwords), this model may give poor performance, such as
            abnormally high scores for low tf values.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicModelP.LOG2_E">
            <summary>
            <c>log2(Math.E)</c>, precomputed. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelP.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicStats">
            <summary>
            Stores all statistics commonly used ranking methods.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_numberOfDocuments">
            <summary>
            The number of documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_numberOfFieldTokens">
            <summary>
            The total number of tokens in the field. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_avgFieldLength">
            <summary>
            The average field length. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_docFreq">
            <summary>
            The document frequency. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_totalTermFreq">
            <summary>
            The total number of occurrences of this term across all documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_queryBoost">
            <summary>
            Query's inner boost. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_topLevelBoost">
            <summary>
            Any outer query's boost. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_totalBoost">
            <summary>
            For most Similarities, the immediate and the top level query boosts are
            not handled differently. Hence, this field is just the product of the
            other two.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicStats.#ctor(System.String,System.Single)">
            <summary>
            Constructor. Sets the query boost. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.NumberOfDocuments">
            <summary>
            Gets or Sets the number of documents. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.NumberOfFieldTokens">
            <summary>
            Returns the total number of tokens in the field. </summary>
            <seealso cref="P:Lucene.Net.Index.Terms.SumTotalTermFreq"/>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.AvgFieldLength">
            <summary>
            Returns the average field length. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.DocFreq">
            <summary>
            Returns the document frequency. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.TotalTermFreq">
            <summary>
            Returns the total number of occurrences of this term across all documents. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.Field">
            <summary>
            The field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicStats.GetValueForNormalization">
            <summary>
            The square of the raw normalization value. </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.BasicStats.RawNormalizationValue"/>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicStats.RawNormalizationValue">
            <summary>
            Computes the raw normalization value. This basic implementation returns
            the query boost. Subclasses may override this method to include other
            factors (such as idf), or to save the value for inclusion in
            <seealso cref="M:Lucene.Net.Search.Similarities.BasicStats.Normalize(System.Single,System.Single)"/>, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicStats.Normalize(System.Single,System.Single)">
            <summary>
            No normalization is done. <paramref name="topLevelBoost"/> is saved in the object,
            however.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.TotalBoost">
            <summary>
            Returns the total boost. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BM25Similarity">
            <summary>
            BM25 Similarity. Introduced in Stephen E. Robertson, Steve Walker,
            Susan Jones, Micheline Hancock-Beaulieu, and Mike Gatford. Okapi at TREC-3.
            In Proceedings of the Third <b>T</b>ext <b>RE</b>trieval <b>C</b>onference (TREC 1994).
            Gaithersburg, USA, November 1994.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.#ctor(System.Single,System.Single)">
            <summary>
            BM25 with the supplied parameter values. </summary>
            <param name="k1"> Controls non-linear term frequency normalization (saturation). </param>
            <param name="b"> Controls to what degree document length normalizes tf values. </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.#ctor">
            <summary>
            BM25 with these default values:
            <list type="bullet">
              <item><description><c>k1 = 1.2</c>,</description></item>
              <item><description><c>b = 0.75</c>.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.Idf(System.Int64,System.Int64)">
            <summary>
            Implemented as <c>log(1 + (numDocs - docFreq + 0.5)/(docFreq + 0.5))</c>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.SloppyFreq(System.Int32)">
            <summary>
            Implemented as <c>1 / (distance + 1)</c>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.ScorePayload(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            The default implementation returns <c>1</c> </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.AvgFieldLength(Lucene.Net.Search.CollectionStatistics)">
            <summary>
            The default implementation computes the average as <c>sumTotalTermFreq / maxDoc</c>,
            or returns <c>1</c> if the index does not store sumTotalTermFreq (Lucene 3.x indexes
            or any field that omits frequency information).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.EncodeNormValue(System.Single,System.Int32)">
            <summary>
            The default implementation encodes <c>boost / sqrt(length)</c>
            with <see cref="M:Lucene.Net.Util.SmallSingle.SingleToByte315(System.Single)"/>.  This is compatible with
            Lucene's default implementation.  If you change this, then you should
            change <see cref="M:Lucene.Net.Search.Similarities.BM25Similarity.DecodeNormValue(System.Byte)"/> to match.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.DecodeNormValue(System.Byte)">
            <summary>
            The default implementation returns <c>1 / f<sup>2</sup></c>
            where <c>f</c> is <see cref="M:Lucene.Net.Util.SmallSingle.Byte315ToSingle(System.Byte)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.discountOverlaps">
            <summary>
            True if overlap tokens (tokens with a position of increment of zero) are
            discounted from the document's length.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.DiscountOverlaps">
            <summary>
            Gets or Sets whether overlap tokens (Tokens with 0 position increment) are
            ignored when computing norm.  By default this is true, meaning overlap
            tokens do not count when computing norms.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.NORM_TABLE">
            <summary>
            Cache of decoded bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.IdfExplain(Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics)">
             <summary>
             Computes a score factor for a simple term and returns an explanation
             for that score factor.
            
             <para/>
             The default implementation uses:
            
             <code>
                 Idf(docFreq, searcher.MaxDoc);
             </code>
            
             Note that <see cref="P:Lucene.Net.Search.CollectionStatistics.MaxDoc"/> is used instead of
             <see cref="P:Lucene.Net.Index.IndexReader.NumDocs"/> because also
             <see cref="P:Lucene.Net.Search.TermStatistics.DocFreq"/> is used, and when the latter
             is inaccurate, so is <see cref="P:Lucene.Net.Search.CollectionStatistics.MaxDoc"/>, and in the same direction.
             In addition, <see cref="P:Lucene.Net.Search.CollectionStatistics.MaxDoc"/> is more efficient to compute
             </summary>
             <param name="collectionStats"> collection-level statistics </param>
             <param name="termStats"> term-level statistics for the term </param>
             <returns> an <see cref="T:Lucene.Net.Search.Explanation"/> object that includes both an idf score factor
                       and an explanation for the term. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.IdfExplain(Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics[])">
             <summary>
             Computes a score factor for a phrase.
            
             <para/>
             The default implementation sums the idf factor for
             each term in the phrase.
             </summary>
             <param name="collectionStats"> collection-level statistics </param>
             <param name="termStats"> term-level statistics for the terms in the phrase </param>
             <returns> an <see cref="T:Lucene.Net.Search.Explanation"/> object that includes both an idf
                     score factor for the phrase and an explanation
                     for each term. </returns>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats">
            <summary>
            Collection statistics for the BM25 model. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Idf">
            <summary>
            BM25's idf </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Avgdl">
            <summary>
            The average document length. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.QueryBoost">
            <summary>
            query's inner boost </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.TopLevelBoost">
            <summary>
            query's outer boost (only for explain) </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Weight">
            <summary>
            weight (idf * boost) </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Field">
            <summary>
            field name, for pulling norms </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Cache">
            <summary>
            precomputed norm[256] with k1 * ((1 - b) + b * dl / avgdl) </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.K1">
            <summary>
            Returns the <c>k1</c> parameter </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.BM25Similarity.#ctor(System.Single,System.Single)"/>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.B">
            <summary>
            Returns the <c>b</c> parameter </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.BM25Similarity.#ctor(System.Single,System.Single)"/>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.DefaultSimilarity">
            <summary>
            Expert: Default scoring implementation which encodes (<see cref="M:Lucene.Net.Search.Similarities.DefaultSimilarity.EncodeNormValue(System.Single)"/>)
            norm values as a single byte before being stored. At search time,
            the norm byte value is read from the index
            <see cref="T:Lucene.Net.Store.Directory"/> and
            decoded (<see cref="M:Lucene.Net.Search.Similarities.DefaultSimilarity.DecodeNormValue(System.Int64)"/>) back to a float <i>norm</i> value.
            this encoding/decoding, while reducing index size, comes with the price of
            precision loss - it is not guaranteed that <i>Decode(Encode(x)) = x</i>. For
            instance, <i>Decode(Encode(0.89)) = 0.75</i>.
            <para/>
            Compression of norm values to a single byte saves memory at search time,
            because once a field is referenced at search time, its norms - for all
            documents - are maintained in memory.
            <para/>
            The rationale supporting such lossy compression of norm values is that given
            the difficulty (and inaccuracy) of users to express their true information
            need by a query, only big differences matter. 
            <para/>
            Last, note that search time is too late to modify this <i>norm</i> part of
            scoring, e.g. by using a different <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> for search.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DefaultSimilarity.NORM_TABLE">
            <summary>
            Cache of decoded bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.Coord(System.Int32,System.Int32)">
            <summary>
            Implemented as <c>overlap / maxOverlap</c>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.QueryNorm(System.Single)">
            <summary>
            Implemented as <c>1/sqrt(sumOfSquaredWeights)</c>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.EncodeNormValue(System.Single)">
            <summary>
            Encodes a normalization factor for storage in an index.
            <para/>
            The encoding uses a three-bit mantissa, a five-bit exponent, and the
            zero-exponent point at 15, thus representing values from around 7x10^9 to
            2x10^-9 with about one significant decimal digit of accuracy. Zero is also
            represented. Negative numbers are rounded up to zero. Values too large to
            represent are rounded down to the largest representable value. Positive
            values too small to represent are rounded up to the smallest positive
            representable value.
            </summary>
            <seealso cref="P:Lucene.Net.Documents.Field.Boost"/>
            <seealso cref="T:Lucene.Net.Util.SmallSingle"/>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.DecodeNormValue(System.Int64)">
            <summary>
            Decodes the norm value, assuming it is a single byte.
            </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.DefaultSimilarity.EncodeNormValue(System.Single)"/>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.LengthNorm(Lucene.Net.Index.FieldInvertState)">
             <summary>
             Implemented as
             <c>state.Boost * LengthNorm(numTerms)</c>, where
             <c>numTerms</c> is <see cref="P:Lucene.Net.Index.FieldInvertState.Length"/> if 
             <see cref="P:Lucene.Net.Search.Similarities.DefaultSimilarity.DiscountOverlaps"/> is <c>false</c>, else it's 
             <see cref="P:Lucene.Net.Index.FieldInvertState.Length"/> - 
             <see cref="P:Lucene.Net.Index.FieldInvertState.NumOverlap"/>.
            
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.Tf(System.Single)">
            <summary>
            Implemented as <c>Math.Sqrt(freq)</c>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.SloppyFreq(System.Int32)">
            <summary>
            Implemented as <c>1 / (distance + 1)</c>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.ScorePayload(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            The default implementation returns <c>1</c> </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.Idf(System.Int64,System.Int64)">
            <summary>
            Implemented as <c>log(numDocs/(docFreq+1)) + 1</c>. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DefaultSimilarity.m_discountOverlaps">
            <summary>
            <c>True</c> if overlap tokens (tokens with a position of increment of zero) are
            discounted from the document's length.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.DefaultSimilarity.DiscountOverlaps">
            <summary>
            Determines whether overlap tokens (Tokens with
            0 position increment) are ignored when computing
            norm.  By default this is true, meaning overlap
            tokens do not count when computing norms.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.ComputeNorm(Lucene.Net.Index.FieldInvertState)"/>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.DFRSimilarity">
            <summary>
            Implements the <em>divergence from randomness (DFR)</em> framework
            introduced in Gianni Amati and Cornelis Joost Van Rijsbergen. 2002.
            Probabilistic models of information retrieval based on measuring the
            divergence from randomness. ACM Trans. Inf. Syst. 20, 4 (October 2002),
            357-389.
            <para>The DFR scoring formula is composed of three separate components: the
            <em>basic model</em>, the <em>aftereffect</em> and an additional
            <em>normalization</em> component, represented by the classes
            <see cref="T:Lucene.Net.Search.Similarities.BasicModel"/>, <see cref="T:Lucene.Net.Search.Similarities.AfterEffect"/> and <see cref="T:Lucene.Net.Search.Similarities.Normalization"/>,
            respectively. The names of these classes were chosen to match the names of
            their counterparts in the Terrier IR engine.</para>
            <para>To construct a <see cref="T:Lucene.Net.Search.Similarities.DFRSimilarity"/>, you must specify the implementations for
            all three components of DFR:
            <list type="table">
                <listheader>
                    <term>Component</term>
                    <term>Implementations</term>
                </listheader>
                <item>
                    <term><see cref="T:Lucene.Net.Search.Similarities.BasicModel"/>: Basic model of information content:</term>
                    <term>
                        <list type="bullet">
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.BasicModelBE"/>: Limiting form of Bose-Einstein</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.BasicModelG"/>: Geometric approximation of Bose-Einstein</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.BasicModelP"/>: Poisson approximation of the Binomial</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.BasicModelD"/>: Divergence approximation of the Binomial</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.BasicModelIn"/>: Inverse document frequency</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.BasicModelIne"/>: Inverse expected document frequency [mixture of Poisson and IDF]</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.BasicModelIF"/>: Inverse term frequency [approximation of I(ne)]</description></item>
                        </list>
                    </term>
                </item>
                <item>
                    <term><see cref="T:Lucene.Net.Search.Similarities.AfterEffect"/>: First normalization of information gain:</term>
                    <term>
                        <list type="bullet">
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.AfterEffectL"/>: Laplace's law of succession</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.AfterEffectB"/>: Ratio of two Bernoulli processes</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.AfterEffect.NoAfterEffect"/>: no first normalization</description></item>
                        </list>
                    </term>
                </item>
                <item>
                    <term><see cref="T:Lucene.Net.Search.Similarities.Normalization"/>: Second (length) normalization:</term>
                    <term>
                        <list type="bullet">
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.NormalizationH1"/>: Uniform distribution of term frequency</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.NormalizationH2"/>: term frequency density inversely related to length</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.NormalizationH3"/>: term frequency normalization provided by Dirichlet prior</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.NormalizationZ"/>: term frequency normalization provided by a Zipfian relation</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.Normalization.NoNormalization"/>: no second normalization</description></item>
                        </list>
                    </term>
                </item>
            </list>
            
            </para>
            <para>Note that <em>qtf</em>, the multiplicity of term-occurrence in the query,
            is not handled by this implementation.
            </para> 
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Search.Similarities.BasicModel"/>
            <seealso cref="T:Lucene.Net.Search.Similarities.AfterEffect"/>
            <seealso cref="T:Lucene.Net.Search.Similarities.Normalization"/>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DFRSimilarity.m_basicModel">
            <summary>
            The basic model for information content. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DFRSimilarity.m_afterEffect">
            <summary>
            The first normalization of the information content. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DFRSimilarity.m_normalization">
            <summary>
            The term frequency normalization. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DFRSimilarity.#ctor(Lucene.Net.Search.Similarities.BasicModel,Lucene.Net.Search.Similarities.AfterEffect,Lucene.Net.Search.Similarities.Normalization)">
            <summary>
            Creates DFRSimilarity from the three components.
            <para/>
            Note that <c>null</c> values are not allowed:
            if you want no normalization or after-effect, instead pass
            <see cref="T:Lucene.Net.Search.Similarities.Normalization.NoNormalization"/> or <see cref="T:Lucene.Net.Search.Similarities.AfterEffect.NoAfterEffect"/> respectively. </summary>
            <param name="basicModel"> Basic model of information content </param>
            <param name="afterEffect"> First normalization of information gain </param>
            <param name="normalization"> Second (length) normalization </param>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.DFRSimilarity.BasicModel">
            <summary>
            Returns the basic model of information content
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.DFRSimilarity.AfterEffect">
            <summary>
            Returns the first normalization
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.DFRSimilarity.Normalization">
            <summary>
            Returns the second normalization
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.Distribution">
            <summary>
            The probabilistic distribution used to model term occurrence
            in information-based models. 
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Search.Similarities.IBSimilarity"/>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Distribution.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Distribution.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Computes the score. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Distribution.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Explains the score. Returns the name of the model only, since
            both <c>tfn</c> and <c>lambda</c> are explained elsewhere.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Distribution.ToString">
            <summary>
            Subclasses must override this method to return the name of the
            distribution.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.DistributionLL">
            <summary>
            Log-logistic distribution.
            <para>Unlike for DFR, the natural logarithm is used, as
            it is faster to compute and the original paper does not express any
            preference to a specific base.</para>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DistributionLL.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.DistributionSPL">
            <summary>
            The smoothed power-law (SPL) distribution for the information-based framework
            that is described in the original paper.
            <para>Unlike for DFR, the natural logarithm is used, as
            it is faster to compute and the original paper does not express any
            preference to a specific base.</para>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DistributionSPL.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.IBSimilarity">
            <summary>
            Provides a framework for the family of information-based models, as described
            in St&#201;phane Clinchant and Eric Gaussier. 2010. Information-based
            models for ad hoc IR. In Proceeding of the 33rd international ACM SIGIR
            conference on Research and development in information retrieval (SIGIR '10).
            ACM, New York, NY, USA, 234-241.
            <para>The retrieval function is of the form <em>RSV(q, d) = &#8721;
            -x<sup>q</sup><sub>w</sub> log Prob(X<sub>w</sub> &gt;=
            t<sup>d</sup><sub>w</sub> | &#955;<sub>w</sub>)</em>, where
            <list type="bullet">
                <item><description><em>x<sup>q</sup><sub>w</sub></em> is the query boost;</description></item>
                <item><description><em>X<sub>w</sub></em> is a random variable that counts the occurrences
                    of word <em>w</em>;</description></item>
                <item><description><em>t<sup>d</sup><sub>w</sub></em> is the normalized term frequency;</description></item>
                <item><description><em>&#955;<sub>w</sub></em> is a parameter.</description></item>
            </list>
            </para>
            <para>The framework described in the paper has many similarities to the DFR
            framework (see <see cref="T:Lucene.Net.Search.Similarities.DFRSimilarity"/>). It is possible that the two
            Similarities will be merged at one point.</para>
            <para>To construct an <see cref="T:Lucene.Net.Search.Similarities.IBSimilarity"/>, you must specify the implementations for
            all three components of the Information-Based model.
            <list type="table">
                <listheader>
                    <term>Component</term>
                    <term>Implementations</term>
                </listheader>
                <item>
                    <term><see cref="P:Lucene.Net.Search.Similarities.IBSimilarity.Distribution"/>: Probabilistic distribution used to
                        model term occurrence</term>
                    <term>
                        <list type="bullet">
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.DistributionLL"/>: Log-logistic</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.DistributionLL"/>: Smoothed power-law</description></item>
                        </list>
                    </term>
                </item>
                <item>
                    <term><see cref="P:Lucene.Net.Search.Similarities.IBSimilarity.Lambda"/>: &#955;<sub>w</sub> parameter of the
                        probability distribution</term>
                    <term>
                        <list type="bullet">
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.LambdaDF"/>: <c>N<sub>w</sub>/N</c> or average
                                number of documents where w occurs</description></item>
                            <item><description><see cref="T:Lucene.Net.Search.Similarities.LambdaTTF"/>: <c>F<sub>w</sub>/N</c> or
                                average number of occurrences of w in the collection</description></item>
                        </list>
                    </term>
                </item>
                <item>
                    <term><see cref="P:Lucene.Net.Search.Similarities.IBSimilarity.Normalization"/>: Term frequency normalization</term>
                    <term>Any supported DFR normalization (listed in
                                 <see cref="T:Lucene.Net.Search.Similarities.DFRSimilarity"/>)
                    </term>
                </item>
            </list>
            </para>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Search.Similarities.DFRSimilarity"/>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.IBSimilarity.m_distribution">
            <summary>
            The probabilistic distribution used to model term occurrence. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.IBSimilarity.m_lambda">
            <summary>
            The <em>lambda (&#955;<sub>w</sub>)</em> parameter. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.IBSimilarity.m_normalization">
            <summary>
            The term frequency normalization. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.IBSimilarity.#ctor(Lucene.Net.Search.Similarities.Distribution,Lucene.Net.Search.Similarities.Lambda,Lucene.Net.Search.Similarities.Normalization)">
            <summary>
            Creates IBSimilarity from the three components.
            <para/>
            Note that <c>null</c> values are not allowed:
            if you want no normalization, instead pass
            <see cref="T:Lucene.Net.Search.Similarities.Normalization.NoNormalization"/>. </summary>
            <param name="distribution"> probabilistic distribution modeling term occurrence </param>
            <param name="lambda"> distribution's &#955;<sub>w</sub> parameter </param>
            <param name="normalization"> term frequency normalization </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.IBSimilarity.ToString">
            <summary>
            The name of IB methods follow the pattern
            <c>IB &lt;distribution&gt; &lt;lambda&gt;&lt;normalization&gt;</c>. The name of the
            distribution is the same as in the original paper; for the names of lambda
            parameters, refer to the doc of the <see cref="T:Lucene.Net.Search.Similarities.Lambda"/> classes.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.IBSimilarity.Distribution">
            <summary>
            Returns the distribution
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.IBSimilarity.Lambda">
            <summary>
            Returns the distribution's lambda parameter
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.IBSimilarity.Normalization">
            <summary>
            Returns the term frequency normalization
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.Lambda">
            <summary>
            The <em>lambda (&#955;<sub>w</sub>)</em> parameter in information-based
            models. 
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Search.Similarities.IBSimilarity"/> 
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Lambda.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Lambda.CalculateLambda(Lucene.Net.Search.Similarities.BasicStats)">
            <summary>
            Computes the lambda parameter. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Lambda.Explain(Lucene.Net.Search.Similarities.BasicStats)">
            <summary>
            Explains the lambda parameter. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Lambda.ToString">
            <summary>
            Subclasses must override this method to return the code of the lambda
            formula. Since the original paper is not very clear on this matter, and
            also uses the DFR naming scheme incorrectly, the codes here were chosen
            arbitrarily.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LambdaDF">
            <summary>
            Computes lambda as <c>docFreq+1 / numberOfDocuments+1</c>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LambdaDF.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LambdaTTF">
            <summary>
            Computes lambda as <c>totalTermFreq+1 / numberOfDocuments+1</c>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LambdaTTF.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMDirichletSimilarity">
             <summary>
             Bayesian smoothing using Dirichlet priors. From Chengxiang Zhai and John
             Lafferty. 2001. A study of smoothing methods for language models applied to
             Ad Hoc information retrieval. In Proceedings of the 24th annual international
             ACM SIGIR conference on Research and development in information retrieval
             (SIGIR '01). ACM, New York, NY, USA, 334-342.
             <para>
             The formula as defined the paper assigns a negative score to documents that
             contain the term, but with fewer occurrences than predicted by the collection
             language model. The Lucene implementation returns <c>0</c> for such
             documents.
             </para>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.LMDirichletSimilarity.mu">
            <summary>
            The &#956; parameter. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMDirichletSimilarity.#ctor(Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel,System.Single)">
            <summary>
            Instantiates the similarity with the provided &#956; parameter. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMDirichletSimilarity.#ctor(System.Single)">
            <summary>
            Instantiates the similarity with the provided &#956; parameter. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMDirichletSimilarity.#ctor(Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel)">
            <summary>
            Instantiates the similarity with the default &#956; value of 2000. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMDirichletSimilarity.#ctor">
            <summary>
            Instantiates the similarity with the default &#956; value of 2000. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.LMDirichletSimilarity.Mu">
            <summary>
            Returns the &#956; parameter. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity">
             <summary>
             Language model based on the Jelinek-Mercer smoothing method. From Chengxiang
             Zhai and John Lafferty. 2001. A study of smoothing methods for language
             models applied to Ad Hoc information retrieval. In Proceedings of the 24th
             annual international ACM SIGIR conference on Research and development in
             information retrieval (SIGIR '01). ACM, New York, NY, USA, 334-342.
             <para>The model has a single parameter, &#955;. According to said paper, the
             optimal value depends on both the collection and the query. The optimal value
             is around <c>0.1</c> for title queries and <c>0.7</c> for long queries.</para>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity.lambda">
            <summary>
            The &#955; parameter. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity.#ctor(Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel,System.Single)">
            <summary>
            Instantiates with the specified <paramref name="collectionModel"/> and &#955; parameter. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity.#ctor(System.Single)">
            <summary>
            Instantiates with the specified &#955; parameter. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity.Lambda">
            <summary>
            Returns the &#955; parameter. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMSimilarity">
            <summary>
            Abstract superclass for language modeling Similarities. The following inner
            types are introduced:
            <list type="bullet">
                <item><description><see cref="T:Lucene.Net.Search.Similarities.LMSimilarity.LMStats"/>, which defines a new statistic, the probability that
                    the collection language model generates the current term;</description></item>
                <item><description><see cref="T:Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel"/>, which is a strategy interface for object that
                    compute the collection language model <c>p(w|C)</c>;</description></item>
                <item><description><see cref="T:Lucene.Net.Search.Similarities.LMSimilarity.DefaultCollectionModel"/>, an implementation of the former, that
                    computes the term probability as the number of occurrences of the term in the
                    collection, divided by the total number of tokens.</description></item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.LMSimilarity.m_collectionModel">
            <summary>
            The collection model. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.#ctor(Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel)">
            <summary>
            Creates a new instance with the specified collection language model. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.#ctor">
            <summary>
            Creates a new instance with the default collection language model. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.FillBasicStats(Lucene.Net.Search.Similarities.BasicStats,Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics)">
            <summary>
            Computes the collection probability of the current term in addition to the
            usual statistics.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.GetName">
            <summary>
            Returns the name of the LM method. The values of the parameters should be
            included as well.
            <para>Used in <see cref="M:Lucene.Net.Search.Similarities.LMSimilarity.ToString"/></para>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.ToString">
            <summary>
            Returns the name of the LM method. If a custom collection model strategy is
            used, its name is included as well. </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.LMSimilarity.GetName"/>
            <seealso cref="M:Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel.GetName"/>
            <seealso cref="T:Lucene.Net.Search.Similarities.LMSimilarity.DefaultCollectionModel"/>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMSimilarity.LMStats">
            <summary>
            Stores the collection distribution of the current term. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.LMSimilarity.LMStats.collectionProbability">
            <summary>
            The probability that the current term is generated by the collection. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.LMStats.#ctor(System.String,System.Single)">
            <summary>
            Creates <see cref="T:Lucene.Net.Search.Similarities.LMSimilarity.LMStats"/> for the provided field and query-time boost
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.LMSimilarity.LMStats.CollectionProbability">
            <summary>
            Returns the probability that the current term is generated by the
            collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel">
            <summary>
            A strategy for computing the collection language model. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel.ComputeProbability(Lucene.Net.Search.Similarities.BasicStats)">
            <summary>
            Computes the probability <c>p(w|C)</c> according to the language model
            strategy for the current term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel.GetName">
            <summary>
            The name of the collection model strategy. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMSimilarity.DefaultCollectionModel">
            <summary>
            Models <c>p(w|C)</c> as the number of occurrences of the term in the
            collection, divided by the total number of tokens <c>+ 1</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.DefaultCollectionModel.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.MultiSimilarity">
            <summary>
            Implements the CombSUM method for combining evidence from multiple
            similarity values described in: Joseph A. Shaw, Edward A. Fox.
            In Text REtrieval Conference (1993), pp. 243-252
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.MultiSimilarity.m_sims">
            <summary>
            the sub-similarities used to create the combined score </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.MultiSimilarity.#ctor(Lucene.Net.Search.Similarities.Similarity[])">
            <summary>
            Creates a <see cref="T:Lucene.Net.Search.Similarities.MultiSimilarity"/> which will sum the scores
            of the provided <paramref name="sims"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.Normalization">
            <summary>
            This class acts as the base class for the implementations of the term
            frequency normalization methods in the DFR framework.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Search.Similarities.DFRSimilarity"/>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.Tfn(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Returns the normalized term frequency. </summary>
            <param name="len"> the field length.  </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Returns an explanation for the normalized term frequency.
            <para>The default normalization methods use the field length of the document
            and the average field length to compute the normalized term frequency.
            This method provides a generic explanation for such methods.
            Subclasses that use other statistics must override this method.</para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.Normalization.NoNormalization">
            <summary>
            Implementation used when there is no normalization. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.NoNormalization.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.ToString">
            <summary>
            Subclasses must override this method to return the code of the
            normalization formula. Refer to the original paper for the list.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.NormalizationH1">
            <summary>
            Normalization model that assumes a uniform distribution of the term frequency.
            <para>While this model is parameterless in the
            <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.742">
            original article</a>, <a href="http://dl.acm.org/citation.cfm?id=1835490">
            information-based models</a> (see <see cref="T:Lucene.Net.Search.Similarities.IBSimilarity"/>) introduced a
            multiplying factor.
            The default value for the <c>c</c> parameter is <c>1</c>.</para>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH1.#ctor(System.Single)">
            <summary>
            Creates <see cref="T:Lucene.Net.Search.Similarities.NormalizationH1"/> with the supplied parameter <paramref name="c"/>. </summary>
            <param name="c"> Hyper-parameter that controls the term frequency
            normalization with respect to the document length. </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH1.#ctor">
            <summary>
            Calls <see cref="T:NormalizationH1(1)"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.NormalizationH1.C">
            <summary>
            Returns the <c>c</c> parameter. </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.NormalizationH1.#ctor(System.Single)"/>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.NormalizationH2">
            <summary>
            Normalization model in which the term frequency is inversely related to the
            length.
            <para>While this model is parameterless in the
            <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.742">
            original article</a>, the <a href="http://theses.gla.ac.uk/1570/">thesis</a>
            introduces the parameterized variant.
            The default value for the <c>c</c> parameter is <c>1</c>.</para>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH2.#ctor(System.Single)">
            <summary>
            Creates <see cref="T:Lucene.Net.Search.Similarities.NormalizationH2"/> with the supplied parameter <paramref name="c"/>. </summary>
            <param name="c"> Hyper-parameter that controls the term frequency
            normalization with respect to the document length. </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH2.#ctor">
            <summary>
            Calls <see cref="T:NormalizationH2(1)"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.NormalizationH2.C">
            <summary>
            Returns the <c>c</c> parameter. </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.NormalizationH2.#ctor(System.Single)"/>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.NormalizationH3">
            <summary>
            Dirichlet Priors normalization
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH3.#ctor">
            <summary>
            Calls <see cref="T:NormalizationH3(800)"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH3.#ctor(System.Single)">
            <summary>
            Creates <see cref="T:Lucene.Net.Search.Similarities.NormalizationH3"/> with the supplied parameter <c>&#956;</c>. </summary>
            <param name="mu"> smoothing parameter <c>&#956;</c> </param>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.NormalizationH3.Mu">
            <summary>
            Returns the parameter <c>&#956;</c> </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.NormalizationH3.#ctor(System.Single)"/>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.NormalizationZ">
            <summary>
            Pareto-Zipf Normalization
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationZ.#ctor">
            <summary>
            Calls <see cref="T:NormalizationZ(0.3)"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationZ.#ctor(System.Single)">
            <summary>
            Creates <see cref="T:Lucene.Net.Search.Similarities.NormalizationZ"/> with the supplied parameter <paramref name="z"/>. </summary>
            <param name="z"> represents <c>A/(A+1)</c> where <c>A</c>
                     measures the specificity of the language. </param>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.NormalizationZ.Z">
            <summary>
            Returns the parameter <c>z</c> </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.NormalizationZ.#ctor(System.Single)"/>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.PerFieldSimilarityWrapper">
            <summary>
            Provides the ability to use a different <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> for different fields.
            <para/>
            Subclasses should implement <see cref="M:Lucene.Net.Search.Similarities.PerFieldSimilarityWrapper.Get(System.String)"/> to return an appropriate
            <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> (for example, using field-specific parameter values) for the field.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.PerFieldSimilarityWrapper.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.PerFieldSimilarityWrapper.Get(System.String)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> for scoring a field.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.Similarity">
            <summary>
            Similarity defines the components of Lucene scoring.
            <para/>
            Expert: Scoring API.
            <para/>
            This is a low-level API, you should only extend this API if you want to implement
            an information retrieval <i>model</i>.  If you are instead looking for a convenient way
            to alter Lucene's scoring, consider extending a higher-level implementation
            such as <see cref="T:Lucene.Net.Search.Similarities.TFIDFSimilarity"/>, which implements the vector space model with this API, or
            just tweaking the default implementation: <see cref="T:Lucene.Net.Search.Similarities.DefaultSimilarity"/>.
            <para/>
            Similarity determines how Lucene weights terms, and Lucene interacts with
            this class at both <a href="#indextime">index-time</a> and
            <a href="#querytime">query-time</a>.
            <para/>
            <a name="indextime"/>
            At indexing time, the indexer calls <see cref="M:Lucene.Net.Search.Similarities.Similarity.ComputeNorm(Lucene.Net.Index.FieldInvertState)"/>, allowing
            the <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> implementation to set a per-document value for the field that will
            be later accessible via <see cref="M:Lucene.Net.Index.AtomicReader.GetNormValues(System.String)"/>.  Lucene makes no assumption
            about what is in this norm, but it is most useful for encoding length normalization
            information.
            <para/>
            Implementations should carefully consider how the normalization is encoded: while
            Lucene's classical <see cref="T:Lucene.Net.Search.Similarities.TFIDFSimilarity"/> encodes a combination of index-time boost
            and length normalization information with <see cref="T:Lucene.Net.Util.SmallSingle"/> into a single byte, this
            might not be suitable for all purposes.
            <para/>
            Many formulas require the use of average document length, which can be computed via a
            combination of <see cref="P:Lucene.Net.Search.CollectionStatistics.SumTotalTermFreq"/> and
            <see cref="P:Lucene.Net.Search.CollectionStatistics.MaxDoc"/> or <see cref="P:Lucene.Net.Search.CollectionStatistics.DocCount"/>,
            depending upon whether the average should reflect field sparsity.
            <para/>
            Additional scoring factors can be stored in named
            <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/>s and accessed
            at query-time with <see cref="M:Lucene.Net.Index.AtomicReader.GetNumericDocValues(System.String)"/>.
            <para/>
            Finally, using index-time boosts (either via folding into the normalization byte or
            via <see cref="T:Lucene.Net.Index.DocValues"/>), is an inefficient way to boost the scores of different fields if the
            boost will be the same for every document, instead the Similarity can simply take a constant
            boost parameter <i>C</i>, and <see cref="T:Lucene.Net.Search.Similarities.PerFieldSimilarityWrapper"/> can return different
            instances with different boosts depending upon field name.
            <para/>
            <a name="querytime"/>
            At query-time, Queries interact with the Similarity via these steps:
            <list type="number">
              <item><description>The <see cref="M:Lucene.Net.Search.Similarities.Similarity.ComputeWeight(System.Single,Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics[])"/> method is called a single time,
                  allowing the implementation to compute any statistics (such as IDF, average document length, etc)
                  across <i>the entire collection</i>. The <see cref="T:Lucene.Net.Search.TermStatistics"/> and <see cref="T:Lucene.Net.Search.CollectionStatistics"/> passed in
                  already contain all of the raw statistics involved, so a <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> can freely use any combination
                  of statistics without causing any additional I/O. Lucene makes no assumption about what is
                  stored in the returned <see cref="T:Lucene.Net.Search.Similarities.Similarity.SimWeight"/> object.</description></item>
              <item><description>The query normalization process occurs a single time: <see cref="M:Lucene.Net.Search.Similarities.Similarity.SimWeight.GetValueForNormalization"/>
                  is called for each query leaf node, <see cref="M:Lucene.Net.Search.Similarities.Similarity.QueryNorm(System.Single)"/> is called for the top-level
                  query, and finally <see cref="M:Lucene.Net.Search.Similarities.Similarity.SimWeight.Normalize(System.Single,System.Single)"/> passes down the normalization value
                  and any top-level boosts (e.g. from enclosing <see cref="T:Lucene.Net.Search.BooleanQuery"/>s).</description></item>
              <item><description>For each segment in the index, the <see cref="T:Lucene.Net.Search.Query"/> creates a <see cref="M:Lucene.Net.Search.Similarities.Similarity.GetSimScorer(Lucene.Net.Search.Similarities.Similarity.SimWeight,Lucene.Net.Index.AtomicReaderContext)"/>
                  The GetScore() method is called for each matching document.</description></item>
            </list>
            <para/>
            <a name="explaintime"/>
            When <see cref="M:Lucene.Net.Search.IndexSearcher.Explain(Lucene.Net.Search.Query,System.Int32)"/> is called, queries consult the Similarity's DocScorer for an
            explanation of how it computed its score. The query passes in a the document id and an explanation of how the frequency
            was computed.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.Similarity"/>
            <seealso cref="P:Lucene.Net.Search.IndexSearcher.Similarity"/>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.Coord(System.Int32,System.Int32)">
            <summary>
            Hook to integrate coordinate-level matching.
            <para/>
            By default this is disabled (returns <c>1</c>), as with
            most modern models this will only skew performance, but some
            implementations such as <see cref="T:Lucene.Net.Search.Similarities.TFIDFSimilarity"/> override this.
            </summary>
            <param name="overlap"> the number of query terms matched in the document </param>
            <param name="maxOverlap"> the total number of terms in the query </param>
            <returns> a score factor based on term overlap with the query </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.QueryNorm(System.Single)">
            <summary>
            Computes the normalization value for a query given the sum of the
            normalized weights <see cref="M:Lucene.Net.Search.Similarities.Similarity.SimWeight.GetValueForNormalization"/> of
            each of the query terms.  this value is passed back to the
            weight (<see cref="M:Lucene.Net.Search.Similarities.Similarity.SimWeight.Normalize(System.Single,System.Single)"/> of each query
            term, to provide a hook to attempt to make scores from different
            queries comparable.
            <para/>
            By default this is disabled (returns <c>1</c>), but some
            implementations such as <see cref="T:Lucene.Net.Search.Similarities.TFIDFSimilarity"/> override this.
            </summary>
            <param name="valueForNormalization"> the sum of the term normalization values </param>
            <returns> a normalization factor for query weights </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.ComputeNorm(Lucene.Net.Index.FieldInvertState)">
             <summary>
             Computes the normalization value for a field, given the accumulated
             state of term processing for this field (see <see cref="T:Lucene.Net.Index.FieldInvertState"/>).
            
             <para/>Matches in longer fields are less precise, so implementations of this
             method usually set smaller values when <c>state.Length</c> is large,
             and larger values when <code>state.Length</code> is small.
             <para/>
             @lucene.experimental
             </summary>
             <param name="state"> current processing state for this field </param>
             <returns> computed norm value </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.ComputeWeight(System.Single,Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics[])">
            <summary>
            Compute any collection-level weight (e.g. IDF, average document length, etc) needed for scoring a query.
            </summary>
            <param name="queryBoost"> the query-time boost. </param>
            <param name="collectionStats"> collection-level statistics, such as the number of tokens in the collection. </param>
            <param name="termStats"> term-level statistics, such as the document frequency of a term across the collection. </param>
            <returns> <see cref="T:Lucene.Net.Search.Similarities.Similarity.SimWeight"/> object with the information this <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> needs to score a query. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.GetSimScorer(Lucene.Net.Search.Similarities.Similarity.SimWeight,Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Search.Similarities.Similarity.SimScorer"/> to score matching documents from a segment of the inverted index. </summary>
            <param name="weight"> collection information from <see cref="M:Lucene.Net.Search.Similarities.Similarity.ComputeWeight(System.Single,Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics[])"/> </param>
            <param name="context"> segment of the inverted index to be scored. </param>
            <returns> Sloppy <see cref="T:Lucene.Net.Search.Similarities.Similarity.SimScorer"/> for scoring documents across <c>context</c> </returns>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.Similarity.SimScorer">
            <summary>
            API for scoring "sloppy" queries such as <see cref="T:Lucene.Net.Search.TermQuery"/>,
            <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/>, and <see cref="T:Lucene.Net.Search.PhraseQuery"/>.
            <para/>
            Frequencies are floating-point values: an approximate
            within-document frequency adjusted for "sloppiness" by
            <see cref="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.ComputeSlopFactor(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.Score(System.Int32,System.Single)">
            <summary>
            Score a single document </summary>
            <param name="doc"> document id within the inverted index segment </param>
            <param name="freq"> sloppy term frequency </param>
            <returns> document's score </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.ComputeSlopFactor(System.Int32)">
            <summary>
            Computes the amount of a sloppy phrase match, based on an edit distance. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.ComputePayloadFactor(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Calculate a scoring factor based on the data in the payload. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.Explain(System.Int32,Lucene.Net.Search.Explanation)">
            <summary>
            Explain the score for a single document </summary>
            <param name="doc"> document id within the inverted index segment </param>
            <param name="freq"> Explanation of how the sloppy term frequency was computed </param>
            <returns> document's score </returns>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.Similarity.SimWeight">
            <summary>
            Stores the weight for a query across the indexed collection. this abstract
            implementation is empty; descendants of <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> should
            subclass <see cref="T:Lucene.Net.Search.Similarities.Similarity.SimWeight"/> and define the statistics they require in the
            subclass. Examples include idf, average field length, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimWeight.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimWeight.GetValueForNormalization">
            <summary>
            The value for normalization of contained query clauses (e.g. sum of squared weights).
            <para/>
            NOTE: a <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> implementation might not use any query normalization at all,
            its not required. However, if it wants to participate in query normalization,
            it can return a value here.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimWeight.Normalize(System.Single,System.Single)">
            <summary>
            Assigns the query normalization factor and boost from parent queries to this.
            <para/>
            NOTE: a <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> implementation might not use this normalized value at all,
            its not required. However, its usually a good idea to at least incorporate
            the <paramref name="topLevelBoost"/> (e.g. from an outer <see cref="T:Lucene.Net.Search.BooleanQuery"/>) into its score.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.SimilarityBase">
            <summary>
            A subclass of <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> that provides a simplified API for its
            descendants. Subclasses are only required to implement the <see cref="M:Lucene.Net.Search.Similarities.SimilarityBase.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)"/>
            and <see cref="M:Lucene.Net.Search.Similarities.SimilarityBase.ToString"/> methods. Implementing
            <see cref="M:Lucene.Net.Search.Similarities.SimilarityBase.Explain(Lucene.Net.Search.Explanation,Lucene.Net.Search.Similarities.BasicStats,System.Int32,System.Single,System.Single)"/> is optional,
            inasmuch as <see cref="T:Lucene.Net.Search.Similarities.SimilarityBase"/> already provides a basic explanation of the score
            and the term frequency. However, implementers of a subclass are encouraged to
            include as much detail about the scoring method as possible.
            <para/>
            Note: multi-word queries such as phrase queries are scored in a different way
            than Lucene's default ranking algorithm: whereas it "fakes" an IDF value for
            the phrase as a whole (since it does not know it), this class instead scores
            phrases as a summation of the individual term scores.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.SimilarityBase.LOG_2">
            <summary>
            For <see cref="M:Lucene.Net.Search.Similarities.SimilarityBase.Log2(System.Double)"/>. Precomputed for efficiency reasons. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.SimilarityBase.discountOverlaps">
            <summary>
            True if overlap tokens (tokens with a position of increment of zero) are
            discounted from the document's length.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.SimilarityBase.DiscountOverlaps">
            <summary>
            Determines whether overlap tokens (Tokens with
            0 position increment) are ignored when computing
            norm.  By default this is <c>true</c>, meaning overlap
            tokens do not count when computing norms.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.SimilarityBase.ComputeNorm(Lucene.Net.Index.FieldInvertState)"/>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.NewStats(System.String,System.Single)">
            <summary>
            Factory method to return a custom stats object </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.FillBasicStats(Lucene.Net.Search.Similarities.BasicStats,Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics)">
            <summary>
            Fills all member fields defined in <see cref="T:Lucene.Net.Search.Similarities.BasicStats"/> in <paramref name="stats"/>.
            Subclasses can override this method to fill additional stats.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Scores the document <c>doc</c>.
            <para>Subclasses must apply their scoring formula in this class.</para> </summary>
            <param name="stats"> the corpus level statistics. </param>
            <param name="freq"> the term frequency. </param>
            <param name="docLen"> the document length. </param>
            <returns> the score. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.Explain(Lucene.Net.Search.Explanation,Lucene.Net.Search.Similarities.BasicStats,System.Int32,System.Single,System.Single)">
            <summary>
            Subclasses should implement this method to explain the score. <paramref name="expl"/>
            already contains the score, the name of the class and the doc id, as well
            as the term frequency and its explanation; subclasses can add additional
            clauses to explain details of their scoring formulae.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="expl"> the explanation to extend with details. </param>
            <param name="stats"> the corpus level statistics. </param>
            <param name="doc"> the document id. </param>
            <param name="freq"> the term frequency. </param>
            <param name="docLen"> the document length. </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Int32,Lucene.Net.Search.Explanation,System.Single)">
            <summary>
            Explains the score. The implementation here provides a basic explanation
            in the format <em>Score(name-of-similarity, doc=doc-id,
            freq=term-frequency), computed from:</em>, and
            attaches the score (computed via the <see cref="M:Lucene.Net.Search.Similarities.SimilarityBase.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)"/>
            method) and the explanation for the term frequency. Subclasses content with
            this format may add additional details in
            <see cref="M:Lucene.Net.Search.Similarities.SimilarityBase.Explain(Lucene.Net.Search.Explanation,Lucene.Net.Search.Similarities.BasicStats,System.Int32,System.Single,System.Single)"/>.
            </summary>
            <param name="stats"> the corpus level statistics. </param>
            <param name="doc"> the document id. </param>
            <param name="freq"> the term frequency and its explanation. </param>
            <param name="docLen"> the document length. </param>
            <returns> the explanation. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.ToString">
            <summary>
            Subclasses must override this method to return the name of the <see cref="T:Lucene.Net.Search.Similarities.Similarity"/>
            and preferably the values of parameters (if any) as well.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.SimilarityBase.NORM_TABLE">
            <summary>
            Norm -> document length map. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.ComputeNorm(Lucene.Net.Index.FieldInvertState)">
            <summary>
            Encodes the document length in the same way as <see cref="T:Lucene.Net.Search.Similarities.TFIDFSimilarity"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.DecodeNormValue(System.Byte)">
            <summary>
            Decodes a normalization factor (document length) stored in an index. </summary>
            <see cref="M:Lucene.Net.Search.Similarities.SimilarityBase.EncodeNormValue(System.Single,System.Single)"/>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.EncodeNormValue(System.Single,System.Single)">
            <summary>
            Encodes the length to a byte via <see cref="T:Lucene.Net.Util.SmallSingle"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.Log2(System.Double)">
            <summary>
            Returns the base two logarithm of <c>x</c>. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.SimilarityBase.BasicSimScorer">
            <summary>
            Delegates the <see cref="M:Lucene.Net.Search.Similarities.SimilarityBase.BasicSimScorer.Score(System.Int32,System.Single)"/> and
            <see cref="M:Lucene.Net.Search.Similarities.SimilarityBase.BasicSimScorer.Explain(System.Int32,Lucene.Net.Search.Explanation)"/> methods to
            <see cref="M:Lucene.Net.Search.Similarities.SimilarityBase.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)"/> and
            <see cref="M:Lucene.Net.Search.Similarities.SimilarityBase.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Int32,Lucene.Net.Search.Explanation,System.Single)"/>,
            respectively.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.TFIDFSimilarity">
             <summary>
             Implementation of <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> with the Vector Space Model.
             <para/>
             Expert: Scoring API.
             <para/>TFIDFSimilarity defines the components of Lucene scoring.
             Overriding computation of these components is a convenient
             way to alter Lucene scoring.
            
             <para/>Suggested reading:
             <a href="http://nlp.stanford.edu/IR-book/html/htmledition/queries-as-vectors-1.html">
             Introduction To Information Retrieval, Chapter 6</a>.
            
             <para/>The following describes how Lucene scoring evolves from
             underlying information retrieval models to (efficient) implementation.
             We first brief on <i>VSM Score</i>,
             then derive from it <i>Lucene's Conceptual Scoring Formula</i>,
             from which, finally, evolves <i>Lucene's Practical Scoring Function</i>
             (the latter is connected directly with Lucene classes and methods).
            
             <para/>Lucene combines
             <a href="http://en.wikipedia.org/wiki/Standard_Boolean_model">
             Boolean model (BM) of Information Retrieval</a>
             with
             <a href="http://en.wikipedia.org/wiki/Vector_Space_Model">
             Vector Space Model (VSM) of Information Retrieval</a> -
             documents "approved" by BM are scored by VSM.
            
             <para/>In VSM, documents and queries are represented as
             weighted vectors in a multi-dimensional space,
             where each distinct index term is a dimension,
             and weights are
             <a href="http://en.wikipedia.org/wiki/Tfidf">Tf-idf</a> values.
            
             <para/>VSM does not require weights to be <i>Tf-idf</i> values,
             but <i>Tf-idf</i> values are believed to produce search results of high quality,
             and so Lucene is using <i>Tf-idf</i>.
             <i>Tf</i> and <i>Idf</i> are described in more detail below,
             but for now, for completion, let's just say that
             for given term <i>t</i> and document (or query) <i>x</i>,
             <i>Tf(t,x)</i> varies with the number of occurrences of term <i>t</i> in <i>x</i>
             (when one increases so does the other) and
             <i>idf(t)</i> similarly varies with the inverse of the
             number of index documents containing term <i>t</i>.
            
             <para/><i>VSM score</i> of document <i>d</i> for query <i>q</i> is the
             <a href="http://en.wikipedia.org/wiki/Cosine_similarity">
             Cosine Similarity</a>
             of the weighted query vectors <i>V(q)</i> and <i>V(d)</i>:
             <para/>
             <list type="table">
                 <item>
                     <term>
                         <list type="table">
                             <item>
                                 <term>cosine-similarity(q,d) &#160; = &#160;</term>
                                 <term>
                                     <table>
                                         <item><term><small>V(q)&#160;&#183;&#160;V(d)</small></term></item>
                                         <item><term>&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;</term></item>
                                         <item><term><small>|V(q)|&#160;|V(d)|</small></term></item>
                                     </table>
                                 </term>
                             </item>
                         </list>
                     </term>
                 </item>
                 <item>
                     <term>VSM Score</term>
                 </item>
             </list>
             <para/>
             
            
             Where <i>V(q)</i> &#183; <i>V(d)</i> is the
             <a href="http://en.wikipedia.org/wiki/Dot_product">dot product</a>
             of the weighted vectors,
             and <i>|V(q)|</i> and <i>|V(d)|</i> are their
             <a href="http://en.wikipedia.org/wiki/Euclidean_norm#Euclidean_norm">Euclidean norms</a>.
            
             <para/>Note: the above equation can be viewed as the dot product of
             the normalized weighted vectors, in the sense that dividing
             <i>V(q)</i> by its euclidean norm is normalizing it to a unit vector.
            
             <para/>Lucene refines <i>VSM score</i> for both search quality and usability:
             <list type="bullet">
              <item><description>Normalizing <i>V(d)</i> to the unit vector is known to be problematic in that
              it removes all document length information.
              For some documents removing this info is probably ok,
              e.g. a document made by duplicating a certain paragraph <i>10</i> times,
              especially if that paragraph is made of distinct terms.
              But for a document which contains no duplicated paragraphs,
              this might be wrong.
              To avoid this problem, a different document length normalization
              factor is used, which normalizes to a vector equal to or larger
              than the unit vector: <i>doc-len-norm(d)</i>.
              </description></item>
            
              <item><description>At indexing, users can specify that certain documents are more
              important than others, by assigning a document boost.
              For this, the score of each document is also multiplied by its boost value
              <i>doc-boost(d)</i>.
              </description></item>
            
              <item><description>Lucene is field based, hence each query term applies to a single
              field, document length normalization is by the length of the certain field,
              and in addition to document boost there are also document fields boosts.
              </description></item>
            
              <item><description>The same field can be added to a document during indexing several times,
              and so the boost of that field is the multiplication of the boosts of
              the separate additions (or parts) of that field within the document.
              </description></item>
            
              <item><description>At search time users can specify boosts to each query, sub-query, and
              each query term, hence the contribution of a query term to the score of
              a document is multiplied by the boost of that query term <i>query-boost(q)</i>.
              </description></item>
            
              <item><description>A document may match a multi term query without containing all
              the terms of that query (this is correct for some of the queries),
              and users can further reward documents matching more query terms
              through a coordination factor, which is usually larger when
              more terms are matched: <i>coord-factor(q,d)</i>.
              </description></item>
             </list>
            
             <para/>Under the simplifying assumption of a single field in the index,
             we get <i>Lucene's Conceptual scoring formula</i>:
             
             <para/>
             <list type="table">
                 <item>
                     <term>
                         <list type="table">
                             <item>
                                 <term>
                                     score(q,d) &#160; = &#160;
                                     <font color="#FF9933">coord-factor(q,d)</font> &#183; &#160;
                                     <font color="#CCCC00">query-boost(q)</font> &#183; &#160;
                                 </term>
                                 <term>
                                     <list type="table">
                                         <item><term><small><font color="#993399">V(q)&#160;&#183;&#160;V(d)</font></small></term></item>
                                         <item><term>&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;</term></item>
                                         <item><term><small><font color="#FF33CC">|V(q)|</font></small></term></item>
                                     </list>
                                 </term>
                                 <term>
                                     &#160; &#183; &#160; <font color="#3399FF">doc-len-norm(d)</font>
                                     &#160; &#183; &#160; <font color="#3399FF">doc-boost(d)</font>
                                 </term>
                             </item>
                         </list>
                     </term>
                 </item>
                 <item>
                     <term>Lucene Conceptual Scoring Formula</term>
                 </item>
             </list>
             <para/>
            
            
             <para/>The conceptual formula is a simplification in the sense that (1) terms and documents
             are fielded and (2) boosts are usually per query term rather than per query.
            
             <para/>We now describe how Lucene implements this conceptual scoring formula, and
             derive from it <i>Lucene's Practical Scoring Function</i>.
            
             <para/>For efficient score computation some scoring components
             are computed and aggregated in advance:
            
             <list type="bullet">
              <item><description><i>Query-boost</i> for the query (actually for each query term)
              is known when search starts.
              </description></item>
            
              <item><description>Query Euclidean norm <i>|V(q)|</i> can be computed when search starts,
              as it is independent of the document being scored.
              From search optimization perspective, it is a valid question
              why bother to normalize the query at all, because all
              scored documents will be multiplied by the same <i>|V(q)|</i>,
              and hence documents ranks (their order by score) will not
              be affected by this normalization.
              There are two good reasons to keep this normalization:
              <list type="bullet">
               <item><description>Recall that
               <a href="http://en.wikipedia.org/wiki/Cosine_similarity">
               Cosine Similarity</a> can be used find how similar
               two documents are. One can use Lucene for e.g.
               clustering, and use a document as a query to compute
               its similarity to other documents.
               In this use case it is important that the score of document <i>d3</i>
               for query <i>d1</i> is comparable to the score of document <i>d3</i>
               for query <i>d2</i>. In other words, scores of a document for two
               distinct queries should be comparable.
               There are other applications that may require this.
               And this is exactly what normalizing the query vector <i>V(q)</i>
               provides: comparability (to a certain extent) of two or more queries.
               </description></item>
            
               <item><description>Applying query normalization on the scores helps to keep the
               scores around the unit vector, hence preventing loss of score data
               because of floating point precision limitations.
               </description></item>
              </list>
              </description></item>
            
              <item><description>Document length norm <i>doc-len-norm(d)</i> and document
              boost <i>doc-boost(d)</i> are known at indexing time.
              They are computed in advance and their multiplication
              is saved as a single value in the index: <i>norm(d)</i>.
              (In the equations below, <i>norm(t in d)</i> means <i>norm(field(t) in doc d)</i>
              where <i>field(t)</i> is the field associated with term <i>t</i>.)
              </description></item>
             </list>
            
             <para/><i>Lucene's Practical Scoring Function</i> is derived from the above.
             The color codes demonstrate how it relates
             to those of the <i>conceptual</i> formula:
            
             <para/>
             <list type="table">
                 <item>
                     <term>
                         <list type="table">
                             <item>
                                 <term>
                                     score(q,d) &#160; = &#160;
                                     <a href="#formula_coord"><font color="#FF9933">coord(q,d)</font></a> &#160; &#183; &#160;
                                     <a href="#formula_queryNorm"><font color="#FF33CC">queryNorm(q)</font></a> &#160; &#183; &#160;
                                 </term>
                                 <term><big><big><big>&#8721;</big></big></big></term>
                                 <term>
                                     <big><big>(</big></big>
                                     <a href="#formula_tf"><font color="#993399">tf(t in d)</font></a> &#160; &#183; &#160;
                                     <a href="#formula_idf"><font color="#993399">idf(t)</font></a><sup>2</sup> &#160; &#183; &#160;
                                     <a href="#formula_termBoost"><font color="#CCCC00">t.Boost</font></a> &#160; &#183; &#160;
                                     <a href="#formula_norm"><font color="#3399FF">norm(t,d)</font></a>
                                     <big><big>)</big></big>
                                 </term>
                             </item>
                             <item>
                                 <term></term>
                                 <term><small>t in q</small></term>
                                 <term></term>
                             </item>
                         </list>
                     </term>
                 </item>
                 <item>
                     <term>Lucene Practical Scoring Function</term>
                 </item>
             </list>
            
             <para/> where
             <list type="number">
                <item><description>
                  <a name="formula_tf"></a>
                  <b><i>tf(t in d)</i></b>
                  correlates to the term's <i>frequency</i>,
                  defined as the number of times term <i>t</i> appears in the currently scored document <i>d</i>.
                  Documents that have more occurrences of a given term receive a higher score.
                  Note that <i>tf(t in q)</i> is assumed to be <i>1</i> and therefore it does not appear in this equation,
                  However if a query contains twice the same term, there will be
                  two term-queries with that same term and hence the computation would still be correct (although
                  not very efficient).
                  The default computation for <i>tf(t in d)</i> in
                  DefaultSimilarity (<see cref="M:Lucene.Net.Search.Similarities.DefaultSimilarity.Tf(System.Single)"/>) is:
            
                     <para/>
                     <list type="table">
                         <item>
                             <term>
                                 tf(t in d) &#160; = &#160;
                             </term>
                             <term>
                                 frequency<sup><big>&#189;</big></sup>
                             </term>
                         </item>
                     </list>
                     <para/>
                     
                </description></item>
            
                <item><description>
                  <a name="formula_idf"></a>
                  <b><i>idf(t)</i></b> stands for Inverse Document Frequency. this value
                  correlates to the inverse of <i>DocFreq</i>
                  (the number of documents in which the term <i>t</i> appears).
                  this means rarer terms give higher contribution to the total score.
                  <i>idf(t)</i> appears for <i>t</i> in both the query and the document,
                  hence it is squared in the equation.
                  The default computation for <i>idf(t)</i> in
                  DefaultSimilarity (<see cref="M:Lucene.Net.Search.Similarities.DefaultSimilarity.Idf(System.Int64,System.Int64)"/>) is:
            
                     <para/>
                     <list type="table">
                         <item>
                             <term>idf(t) &#160; = &#160;</term>
                             <term>1 + log <big>(</big></term>
                             <term>
                                 <list type="table">
                                     <item><term><small>NumDocs</small></term></item>
                                     <item><term>&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;</term></item>
                                     <item><term><small>DocFreq+1</small></term></item>
                                 </list>
                             </term>
                             <term><big>)</big></term>
                         </item>
                     </list>
                     <para/>
             
                </description></item>
            
                <item><description>
                  <a name="formula_coord"></a>
                  <b><i>coord(q,d)</i></b>
                  is a score factor based on how many of the query terms are found in the specified document.
                  Typically, a document that contains more of the query's terms will receive a higher score
                  than another document with fewer query terms.
                  this is a search time factor computed in
                  coord(q,d) (<see cref="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.Coord(System.Int32,System.Int32)"/>)
                  by the Similarity in effect at search time.
                  <para/>
                </description></item>
            
                <item><description><b>
                  <a name="formula_queryNorm"></a>
                  <i>queryNorm(q)</i>
                  </b>
                  is a normalizing factor used to make scores between queries comparable.
                  this factor does not affect document ranking (since all ranked documents are multiplied by the same factor),
                  but rather just attempts to make scores from different queries (or even different indexes) comparable.
                  this is a search time factor computed by the Similarity in effect at search time.
            
                  The default computation in
                  DefaultSimilarity (<see cref="M:Lucene.Net.Search.Similarities.DefaultSimilarity.QueryNorm(System.Single)"/>)
                  produces a <a href="http://en.wikipedia.org/wiki/Euclidean_norm#Euclidean_norm">Euclidean norm</a>:
                  
                  <para/>
                  <list type="table">
                     <item>
                         <term>
                             queryNorm(q)  &#160; = &#160;
                             queryNorm(sumOfSquaredWeights)
                             &#160; = &#160;
                         </term>
                         <term>
                             <list type="table">
                                 <item><term><big>1</big></term></item>
                                 <item><term><big>&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;</big></term></item>
                                 <item><term>sumOfSquaredWeights<sup><big>&#189;</big></sup></term></item>
                             </list>
                         </term>
                     </item>
                  </list>
                  <para/>
            
                  The sum of squared weights (of the query terms) is
                  computed by the query <see cref="T:Lucene.Net.Search.Weight"/> object.
                  For example, a <see cref="T:Lucene.Net.Search.BooleanQuery"/>
                  computes this value as:
                  
                  <para/>
                  <list type="table">
                     <item>
                         <term>
                             sumOfSquaredWeights &#160; = &#160;
                             q.Boost <sup><big>2</big></sup>
                             &#160;&#183;&#160;
                         </term> 
                         <term><big><big><big>&#8721;</big></big></big></term>
                         <term>
                             <big><big>(</big></big>
                             <a href="#formula_idf">idf(t)</a> &#160;&#183;&#160;
                             <a href="#formula_termBoost">t.Boost</a>
                             <big><big>) <sup>2</sup> </big></big>
                         </term>
                     </item>
                     <item>
                         <term></term>
                         <term><small>t in q</small></term>
                         <term></term>
                     </item>
                  </list>
                  where sumOfSquaredWeights is <see cref="M:Lucene.Net.Search.Weight.GetValueForNormalization"/> and
                  q.Boost is <see cref="P:Lucene.Net.Search.Query.Boost"/>
                  <para/>
                </description></item>
            
                <item><description>
                  <a name="formula_termBoost"></a>
                  <b><i>t.Boost</i></b>
                  is a search time boost of term <i>t</i> in the query <i>q</i> as
                  specified in the query text
                  (see <a href="{@docRoot}/../queryparser/org/apache/lucene/queryparser/classic/package-summary.html#Boosting_a_Term">query syntax</a>),
                  or as set by application calls to
                  <see cref="P:Lucene.Net.Search.Query.Boost"/>.
                  Notice that there is really no direct API for accessing a boost of one term in a multi term query,
                  but rather multi terms are represented in a query as multi
                  <see cref="T:Lucene.Net.Search.TermQuery"/> objects,
                  and so the boost of a term in the query is accessible by calling the sub-query
                  <see cref="P:Lucene.Net.Search.Query.Boost"/>.
                  <para/>
                </description></item>
            
                <item><description>
                  <a name="formula_norm"></a>
                  <b><i>norm(t,d)</i></b> encapsulates a few (indexing time) boost and length factors:
            
                  <list type="bullet">
                    <item><description><b>Field boost</b> - set
                    <see cref="P:Lucene.Net.Documents.Field.Boost"/>
                    before adding the field to a document.
                    </description></item>
                    <item><description><b>lengthNorm</b> - computed
                    when the document is added to the index in accordance with the number of tokens
                    of this field in the document, so that shorter fields contribute more to the score.
                    LengthNorm is computed by the <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> class in effect at indexing.
                    </description></item>
                  </list>
                  The <see cref="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.ComputeNorm(Lucene.Net.Index.FieldInvertState)"/> method is responsible for
                  combining all of these factors into a single <see cref="T:System.Single"/>.
            
                  <para/>
                  When a document is added to the index, all the above factors are multiplied.
                  If the document has multiple fields with the same name, all their boosts are multiplied together:
                  
                  <para/>
                  <list type="table">
                     <item>
                         <term>
                             norm(t,d) &#160; = &#160;
                             lengthNorm
                             &#160;&#183;&#160;
                         </term>
                         <term><big><big><big>&#8719;</big></big></big></term>
                         <term><see cref="P:Lucene.Net.Index.IIndexableField.Boost"/></term>
                     </item>
                     <item>
                         <term></term>
                         <term><small>field <i><b>f</b></i> in <i>d</i> named as <i><b>t</b></i></small></term>
                         <term></term>
                     </item>
                  </list>
                  Note that search time is too late to modify this <i>norm</i> part of scoring,
                  e.g. by using a different <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> for search.
                </description></item>
             </list>
             </summary>
             <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.Similarity"/>
             <seealso cref="P:Lucene.Net.Search.IndexSearcher.Similarity"/>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.Coord(System.Int32,System.Int32)">
             <summary>
             Computes a score factor based on the fraction of all query terms that a
             document contains.  this value is multiplied into scores.
            
             <para/>The presence of a large portion of the query terms indicates a better
             match with the query, so implementations of this method usually return
             larger values when the ratio between these parameters is large and smaller
             values when the ratio between them is small.
             </summary>
             <param name="overlap"> The number of query terms matched in the document </param>
             <param name="maxOverlap"> The total number of terms in the query </param>
             <returns> A score factor based on term overlap with the query </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.QueryNorm(System.Single)">
             <summary>
             Computes the normalization value for a query given the sum of the squared
             weights of each of the query terms.  this value is multiplied into the
             weight of each query term. While the classic query normalization factor is
             computed as 1/sqrt(sumOfSquaredWeights), other implementations might
             completely ignore sumOfSquaredWeights (ie return 1).
            
             <para/>This does not affect ranking, but the default implementation does make scores
             from different queries more comparable than they would be by eliminating the
             magnitude of the <see cref="T:Lucene.Net.Search.Query"/> vector as a factor in the score.
             </summary>
             <param name="sumOfSquaredWeights"> The sum of the squares of query term weights </param>
             <returns> A normalization factor for query weights </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.Tf(System.Single)">
             <summary>
             Computes a score factor based on a term or phrase's frequency in a
             document.  This value is multiplied by the <see cref="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.Idf(System.Int64,System.Int64)"/>
             factor for each term in the query and these products are then summed to
             form the initial score for a document.
            
             <para/>Terms and phrases repeated in a document indicate the topic of the
             document, so implementations of this method usually return larger values
             when <paramref name="freq"/> is large, and smaller values when <paramref name="freq"/>
             is small.
             </summary>
             <param name="freq"> The frequency of a term within a document </param>
             <returns> A score factor based on a term's within-document frequency </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.IdfExplain(Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics)">
             <summary>
             Computes a score factor for a simple term and returns an explanation
             for that score factor.
            
             <para/>
             The default implementation uses:
            
             <code>
             Idf(docFreq, searcher.MaxDoc);
             </code>
            
             Note that <see cref="P:Lucene.Net.Search.CollectionStatistics.MaxDoc"/> is used instead of
             <see cref="P:Lucene.Net.Index.IndexReader.NumDocs"/> because also
             <see cref="P:Lucene.Net.Search.TermStatistics.DocFreq"/> is used, and when the latter
             is inaccurate, so is <see cref="P:Lucene.Net.Search.CollectionStatistics.MaxDoc"/>, and in the same direction.
             In addition, <see cref="P:Lucene.Net.Search.CollectionStatistics.MaxDoc"/> is more efficient to compute
             </summary>
             <param name="collectionStats"> Collection-level statistics </param>
             <param name="termStats"> Term-level statistics for the term </param>
             <returns> An Explain object that includes both an idf score factor
                       and an explanation for the term. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.IdfExplain(Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics[])">
             <summary>
             Computes a score factor for a phrase.
            
             <para/>
             The default implementation sums the idf factor for
             each term in the phrase.
             </summary>
             <param name="collectionStats"> Collection-level statistics </param>
             <param name="termStats"> Term-level statistics for the terms in the phrase </param>
             <returns> An Explain object that includes both an idf
                     score factor for the phrase and an explanation
                     for each term. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.Idf(System.Int64,System.Int64)">
             <summary>
             Computes a score factor based on a term's document frequency (the number
             of documents which contain the term).  This value is multiplied by the
             <see cref="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.Tf(System.Single)"/> factor for each term in the query and these products are
             then summed to form the initial score for a document.
            
             <para/>Terms that occur in fewer documents are better indicators of topic, so
             implementations of this method usually return larger values for rare terms,
             and smaller values for common terms.
             </summary>
             <param name="docFreq"> The number of documents which contain the term </param>
             <param name="numDocs"> The total number of documents in the collection </param>
             <returns> A score factor based on the term's document frequency </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.LengthNorm(Lucene.Net.Index.FieldInvertState)">
            <summary>
            Compute an index-time normalization value for this field instance.
            <para/>
            This value will be stored in a single byte lossy representation by
            <see cref="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.EncodeNormValue(System.Single)"/>.
            </summary>
            <param name="state"> Statistics of the current field (such as length, boost, etc) </param>
            <returns> An index-time normalization value </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.DecodeNormValue(System.Int64)">
            <summary>
            Decodes a normalization factor stored in an index.
            </summary>
            <see cref="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.EncodeNormValue(System.Single)"/>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.EncodeNormValue(System.Single)">
            <summary>
            Encodes a normalization factor for storage in an index. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.SloppyFreq(System.Int32)">
             <summary>
             Computes the amount of a sloppy phrase match, based on an edit distance.
             this value is summed for each sloppy phrase match in a document to form
             the frequency to be used in scoring instead of the exact term count.
            
             <para/>A phrase match with a small edit distance to a document passage more
             closely matches the document, so implementations of this method usually
             return larger values when the edit distance is small and smaller values
             when it is large.
             </summary>
             <seealso cref="P:Lucene.Net.Search.PhraseQuery.Slop"/>
             <param name="distance"> The edit distance of this sloppy phrase match </param>
             <returns> The frequency increment for this match </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.ScorePayload(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Calculate a scoring factor based on the data in the payload.  Implementations
            are responsible for interpreting what is in the payload.  Lucene makes no assumptions about
            what is in the byte array.
            </summary>
            <param name="doc"> The docId currently being scored. </param>
            <param name="start"> The start position of the payload </param>
            <param name="end"> The end position of the payload </param>
            <param name="payload"> The payload byte array to be scored </param>
            <returns> An implementation dependent float to be used as a scoring factor </returns>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.TFIDFSimilarity.IDFStats">
            <summary>
            Collection statistics for the TF-IDF model. The only statistic of interest
            to this model is idf.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.TFIDFSimilarity.IDFStats.Idf">
            <summary>
            The idf and its explanation </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.PhraseFreq">
            <summary>
            Score a candidate doc for all slop-valid position-combinations (matches)
            encountered while traversing/hopping the PhrasePositions.
            <para/> The score contribution of a match depends on the distance:
            <para/> - highest score for distance=0 (exact match).
            <para/> - score gets lower as distance gets higher.
            <para/>Example: for query "a b"~2, a document "x a b a y" can be scored twice:
            once for "a b" (distance=0), and once for "b a" (distance=2).
            <para/>Possibly not all valid combinations are encountered, because for efficiency
            we always propagate the least PhrasePosition. This allows to base on
            <see cref="T:Lucene.Net.Util.PriorityQueue`1"/> and move forward faster.
            As result, for example, document "a b c b a"
            would score differently for queries "a b c"~4 and "c b a"~4, although
            they really are equivalent.
            Similarly, for doc "a b c b a f g", query "c b"~2
            would get same score as "g f"~2, although "c b"~2 could be matched twice.
            We may want to fix this in the future (currently not, for performance reasons).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.AdvancePP(Lucene.Net.Search.PhrasePositions)">
            <summary>
            Advance a PhrasePosition and update 'end', return false if exhausted </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.AdvanceRpts(Lucene.Net.Search.PhrasePositions)">
            <summary>
            pp was just advanced. If that caused a repeater collision, resolve by advancing the lesser
            of the two colliding pps. Note that there can only be one collision, as by the initialization
            there were no collisions before pp was advanced.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.Lesser(Lucene.Net.Search.PhrasePositions,Lucene.Net.Search.PhrasePositions)">
            <summary>
            Compare two pps, but only by position and offset </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.Collide(Lucene.Net.Search.PhrasePositions)">
            <summary>
            Index of a pp2 colliding with pp, or -1 if none </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.InitPhrasePositions">
            <summary>
            Initialize <see cref="T:Lucene.Net.Search.PhrasePositions"/> in place.
            A one time initialization for this scorer (on first doc matching all terms):
            <list type="bullet">
                <item><description>Check if there are repetitions</description></item>
                <item><description>If there are, find groups of repetitions.</description></item>
            </list>
            Examples:
            <list type="number">
                <item><description>no repetitions: <b>"ho my"~2</b></description></item>
                <item><description>>repetitions: <b>"ho my my"~2</b></description></item>
                <item><description>repetitions: <b>"my ho my"~2</b></description></item>
            </list> 
            </summary>
            <returns> <c>false</c> if PPs are exhausted (and so current doc will not be a match)  </returns>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.InitSimple">
            <summary>
            No repeats: simplest case, and most common. It is important to keep this piece of the code simple and efficient </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.InitComplex">
            <summary>
            With repeats: not so simple. </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.PlaceFirstPositions">
            <summary>
            Move all PPs to their first position </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.FillQueue">
            <summary>
            Fill the queue (all pps are already placed) </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.AdvanceRepeatGroups">
            <summary>
            At initialization (each doc), each repetition group is sorted by (query) offset.
            this provides the start condition: no collisions.
            <para/>Case 1: no multi-term repeats
            <para/>
            It is sufficient to advance each pp in the group by one less than its group index.
            So lesser pp is not advanced, 2nd one advance once, 3rd one advanced twice, etc.
            <para/>Case 2: multi-term repeats
            </summary>
            <returns> <c>false</c> if PPs are exhausted.  </returns>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.InitFirstTime">
            <summary>
            Initialize with checking for repeats. Heavy work, but done only for the first candidate doc.
            <para/>
            If there are repetitions, check if multi-term postings (MTP) are involved.
            <para/>
            Without MTP, once PPs are placed in the first candidate doc, repeats (and groups) are visible.
            <para/>
            With MTP, a more complex check is needed, up-front, as there may be "hidden collisions".
            <para/>
            For example P1 has {A,B}, P1 has {B,C}, and the first doc is: "A C B". At start, P1 would point
            to "A", p2 to "C", and it will not be identified that P1 and P2 are repetitions of each other.
            <para/>
            The more complex initialization has two parts:
            <para/>
            (1) identification of repetition groups.
            <para/>
            (2) advancing repeat groups at the start of the doc.
            <para/>
            For (1), a possible solution is to just create a single repetition group,
            made of all repeating pps. But this would slow down the check for collisions,
            as all pps would need to be checked. Instead, we compute "connected regions"
            on the bipartite graph of postings and terms.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.SortRptGroups(System.Collections.Generic.IList{System.Collections.Generic.IList{Lucene.Net.Search.PhrasePositions}})">
            <summary>
            Sort each repetition group by (query) offset.
            Done only once (at first doc) and allows to initialize faster for each doc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.GatherRptGroups(J2N.Collections.Generic.LinkedDictionary{Lucene.Net.Index.Term,System.Nullable{System.Int32}})">
            <summary>
            Detect repetition groups. Done once - for first doc. </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.TpPos(Lucene.Net.Search.PhrasePositions)">
            <summary>
            Actual position in doc of a PhrasePosition, relies on that position = tpPos - offset) </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.RepeatingTerms">
            <summary>
            Find repeating terms and assign them ordinal values </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.RepeatingPPs(System.Collections.Generic.IDictionary{Lucene.Net.Index.Term,System.Nullable{System.Int32}})">
            <summary>
            Find repeating pps, and for each, if has multi-terms, update this.hasMultiTermRpts </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.PpTermsBitSets(Lucene.Net.Search.PhrasePositions[],System.Collections.Generic.IDictionary{Lucene.Net.Index.Term,System.Nullable{System.Int32}})">
            <summary>
            bit-sets - for each repeating pp, for each of its repeating terms, the term ordinal values is set </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.UnionTermGroups(System.Collections.Generic.IList{Lucene.Net.Util.FixedBitSet})">
            <summary>
            Union (term group) bit-sets until they are disjoint (O(n^^2)), and each group have different terms </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.TermGroups(J2N.Collections.Generic.LinkedDictionary{Lucene.Net.Index.Term,System.Nullable{System.Int32}},System.Collections.Generic.IList{Lucene.Net.Util.FixedBitSet})">
            <summary>
            Map each term to the single group that contains it </summary>
        </member>
        <member name="T:Lucene.Net.Search.Sort">
             <summary>
             Encapsulates sort criteria for returned hits.
            
             <para/>The fields used to determine sort order must be carefully chosen.
             <see cref="T:Lucene.Net.Documents.Document"/>s must contain a single term in such a field,
             and the value of the term should indicate the document's relative position in
             a given sort order.  The field must be indexed, but should not be tokenized,
             and does not need to be stored (unless you happen to want it back with the
             rest of your document data).  In other words:
            
             <para/><code>document.Add(new Field("byNumber", x.ToString(CultureInfo.InvariantCulture), Field.Store.NO, Field.Index.NOT_ANALYZED));</code>
            
            
             <para/><h3>Valid Types of Values</h3>
            
             <para/>There are four possible kinds of term values which may be put into
             sorting fields: <see cref="T:System.Int32"/>s, <see cref="T:System.Int64"/>s, <see cref="T:System.Single"/>s, or <see cref="T:System.String"/>s.  Unless
             <see cref="T:Lucene.Net.Search.SortField"/> objects are specified, the type of value
             in the field is determined by parsing the first term in the field.
            
             <para/><see cref="T:System.Int32"/> term values should contain only digits and an optional
             preceding negative sign.  Values must be base 10 and in the range
             <see cref="F:System.Int32.MinValue"/> and <see cref="F:System.Int32.MaxValue"/> inclusive.
             Documents which should appear first in the sort
             should have low value integers, later documents high values
             (i.e. the documents should be numbered <c>1..n</c> where
             <c>1</c> is the first and <c>n</c> the last).
            
             <para/><see cref="T:System.Int64"/> term values should contain only digits and an optional
             preceding negative sign.  Values must be base 10 and in the range
             <see cref="F:System.Int64.MinValue"/> and <see cref="F:System.Int64.MaxValue"/> inclusive.
             Documents which should appear first in the sort
             should have low value integers, later documents high values.
            
             <para/><see cref="T:System.Single"/> term values should conform to values accepted by
             <see cref="T:System.Single"/> (except that <c>NaN</c>
             and <c>Infinity</c> are not supported).
             <see cref="T:Lucene.Net.Documents.Document"/>s which should appear first in the sort
             should have low values, later documents high values.
            
             <para/><see cref="T:System.String"/> term values can contain any valid <see cref="T:System.String"/>, but should
             not be tokenized.  The values are sorted according to their
             comparable natural order (<see cref="P:System.StringComparer.Ordinal"/>).  Note that using this type
             of term value has higher memory requirements than the other
             two types.
            
             <para/><h3>Object Reuse</h3>
            
             <para/>One of these objects can be
             used multiple times and the sort order changed between usages.
            
             <para/>This class is thread safe.
            
             <para/><h3>Memory Usage</h3>
            
             <para/>Sorting uses of caches of term values maintained by the
             internal HitQueue(s).  The cache is static and contains an <see cref="T:System.Int32"/>
             or <see cref="T:System.Single"/> array of length <c>IndexReader.MaxDoc</c> for each field
             name for which a sort is performed.  In other words, the size of the
             cache in bytes is:
            
             <para/><code>4 * IndexReader.MaxDoc * (# of different fields actually used to sort)</code>
            
             <para/>For <see cref="T:System.String"/> fields, the cache is larger: in addition to the
             above array, the value of every term in the field is kept in memory.
             If there are many unique terms in the field, this could
             be quite large.
            
             <para/>Note that the size of the cache is not affected by how many
             fields are in the index and <i>might</i> be used to sort - only by
             the ones actually used to sort a result set.
            
             <para/>Created: Feb 12, 2004 10:53:57 AM
             <para/>
             @since   lucene 1.4
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.Sort.RELEVANCE">
            <summary>
            Represents sorting by computed relevance. Using this sort criteria returns
            the same results as calling
            <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32)"/>without a sort criteria,
            only with slightly more overhead.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Sort.INDEXORDER">
            <summary>
            Represents sorting by index order. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor">
            <summary>
            Sorts by computed relevance. This is the same sort criteria as calling
            <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32)"/> without a sort criteria,
            only with slightly more overhead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField)">
            <summary>
            Sorts by the criteria in the given <see cref="T:Lucene.Net.Search.SortField"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField[])">
            <summary>
            Sorts in succession by the criteria in each <see cref="T:Lucene.Net.Search.SortField"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField)">
            <summary>Sets the sort to the given criteria. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField[])">
            <summary>Sets the sort to the given criteria in succession. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.GetSort">
            <summary> Representation of the sort criteria.</summary>
            <returns> Array of <see cref="T:Lucene.Net.Search.SortField"/> objects used in this sort criteria
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Sort.Rewrite(Lucene.Net.Search.IndexSearcher)">
            <summary>
            Rewrites the <see cref="T:Lucene.Net.Search.SortField"/>s in this <see cref="T:Lucene.Net.Search.Sort"/>, returning a new <see cref="T:Lucene.Net.Search.Sort"/> if any of the fields
            changes during their rewriting.
            <para/>
            @lucene.experimental
            </summary>
            <param name="searcher"> <see cref="T:Lucene.Net.Search.IndexSearcher"/> to use in the rewriting </param>
            <returns> <c>this</c> if the Sort/Fields have not changed, or a new <see cref="T:Lucene.Net.Search.Sort"/> if there
                   is a change </returns>
            <exception cref="T:System.IO.IOException"> Can be thrown by the rewriting</exception>
        </member>
        <member name="M:Lucene.Net.Search.Sort.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <paramref name="o"/> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Sort.NeedsScores">
            <summary>
            Returns <c>true</c> if the relevance score is needed to sort documents. </summary>
        </member>
        <member name="T:Lucene.Net.Search.SortField">
             <summary>
             Stores information about how to sort documents by terms in an individual
             field.  Fields must be indexed in order to sort by them.
            
             <para/>Created: Feb 11, 2004 1:25:29 PM
             <para/>
             @since   lucene 1.4 </summary>
             <seealso cref="T:Lucene.Net.Search.Sort"/>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FIELD_SCORE">
            <summary>
            Represents sorting by document score (relevance). </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FIELD_DOC">
            <summary>
            Represents sorting by document number (index order). </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortFieldType)">
            <summary>
            Creates a sort by terms in the given field with the type of term
            values explicitly given. </summary>
            <param name="field"> Name of field to sort by. Can be <c>null</c> if
                          <paramref name="type"/> is <see cref="F:Lucene.Net.Search.SortFieldType.SCORE"/> or <see cref="F:Lucene.Net.Search.SortFieldType.DOC"/>. </param>
            <param name="type"> Type of values in the terms. </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortFieldType,System.Boolean)">
            <summary>
            Creates a sort, possibly in reverse, by terms in the given field with the
            type of term values explicitly given. </summary>
            <param name="field">  Name of field to sort by.  Can be <c>null</c> if
                          <paramref name="type"/> is <see cref="F:Lucene.Net.Search.SortFieldType.SCORE"/> or <see cref="F:Lucene.Net.Search.SortFieldType.DOC"/>. </param>
            <param name="type">   Type of values in the terms. </param>
            <param name="reverse"> <c>True</c> if natural order should be reversed. </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldCache.IParser)">
            <summary>
            Creates a sort by terms in the given field, parsed
            to numeric values using a custom <see cref="T:Lucene.Net.Search.FieldCache.IParser"/>. </summary>
            <param name="field">  Name of field to sort by.  Must not be <c>null</c>. </param>
            <param name="parser"> Instance of a <see cref="T:Lucene.Net.Search.FieldCache.IParser"/>,
             which must subclass one of the existing numeric
             parsers from <see cref="T:Lucene.Net.Search.IFieldCache"/>. Sort type is inferred
             by testing which numeric parser the parser subclasses. </param>
            <exception cref="T:System.ArgumentException"> if the parser fails to
             subclass an existing numeric parser, or field is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldCache.IParser,System.Boolean)">
            <summary>
            Creates a sort, possibly in reverse, by terms in the given field, parsed
            to numeric values using a custom <see cref="T:Lucene.Net.Search.FieldCache.IParser"/>. </summary>
            <param name="field">  Name of field to sort by.  Must not be <c>null</c>. </param>
            <param name="parser"> Instance of a <see cref="T:Lucene.Net.Search.FieldCache.IParser"/>,
             which must subclass one of the existing numeric
             parsers from <see cref="T:Lucene.Net.Search.IFieldCache"/>. Sort type is inferred
             by testing which numeric parser the parser subclasses. </param>
            <param name="reverse"> <c>True</c> if natural order should be reversed. </param>
            <exception cref="T:System.ArgumentException"> if the parser fails to
             subclass an existing numeric parser, or field is <c>null</c> </exception>
        </member>
        <member name="F:Lucene.Net.Search.SortField.STRING_FIRST">
            <summary>
            Pass this to <see cref="P:Lucene.Net.Search.SortField.MissingValue"/> to have missing
            string values sort first.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.STRING_LAST">
            <summary>
            Pass this to <see cref="P:Lucene.Net.Search.SortField.MissingValue"/> to have missing
            string values sort last.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldComparerSource)">
            <summary>
            Creates a sort with a custom comparison function. </summary>
            <param name="field"> Name of field to sort by; cannot be <c>null</c>. </param>
            <param name="comparer"> Returns a comparer for sorting hits. </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldComparerSource,System.Boolean)">
            <summary>
            Creates a sort, possibly in reverse, with a custom comparison function. </summary>
            <param name="field"> Name of field to sort by; cannot be <c>null</c>. </param>
            <param name="comparer"> Returns a comparer for sorting hits. </param>
            <param name="reverse"> <c>True</c> if natural order should be reversed. </param>
        </member>
        <member name="P:Lucene.Net.Search.SortField.Field">
            <summary>
            Returns the name of the field.  Could return <c>null</c>
            if the sort is by <see cref="F:Lucene.Net.Search.SortFieldType.SCORE"/> or <see cref="F:Lucene.Net.Search.SortFieldType.DOC"/>. </summary>
            <returns> Name of field, possibly <c>null</c>. </returns>
        </member>
        <member name="P:Lucene.Net.Search.SortField.Type">
            <summary>
            Returns the type of contents in the field. </summary>
            <returns> One of <see cref="F:Lucene.Net.Search.SortFieldType.SCORE"/>, <see cref="F:Lucene.Net.Search.SortFieldType.DOC"/>, 
            <see cref="F:Lucene.Net.Search.SortFieldType.STRING"/>, <see cref="F:Lucene.Net.Search.SortFieldType.INT32"/> or <see cref="F:Lucene.Net.Search.SortFieldType.SINGLE"/>. </returns>
        </member>
        <member name="P:Lucene.Net.Search.SortField.Parser">
            <summary>
            Returns the instance of a <see cref="T:Lucene.Net.Search.IFieldCache"/> parser that fits to the given sort type.
            May return <c>null</c> if no parser was specified. Sorting is using the default parser then. </summary>
            <returns> An instance of a <see cref="T:Lucene.Net.Search.IFieldCache"/> parser, or <c>null</c>. </returns>
        </member>
        <member name="P:Lucene.Net.Search.SortField.IsReverse">
            <summary>
            Returns whether the sort should be reversed. </summary>
            <returns> <c>True</c> if natural order should be reversed. </returns>
        </member>
        <member name="P:Lucene.Net.Search.SortField.ComparerSource">
            <summary>
            Returns the <see cref="T:Lucene.Net.Search.FieldComparerSource"/> used for
            custom sorting.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <paramref name="o"/> is equal to this.  If a
            <see cref="T:Lucene.Net.Search.FieldComparerSource"/> or 
            <see cref="T:Lucene.Net.Search.FieldCache.IParser"/> was provided, it must properly
            implement equals (unless a singleton is always used).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetHashCode">
            <summary>
            Returns a hash code value for this object.  If a
            <see cref="T:Lucene.Net.Search.FieldComparerSource"/> or
            <see cref="T:Lucene.Net.Search.FieldCache.IParser"/> was provided, it must properly
            implement GetHashCode() (unless a singleton is always
            used).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetComparer(System.Int32,System.Int32)">
            <summary>
            Returns the <see cref="T:Lucene.Net.Search.FieldComparer"/> to use for
            sorting.
            <para/>
            @lucene.experimental
            </summary>
            <param name="numHits"> Number of top hits the queue will store </param>
            <param name="sortPos"> Position of this <see cref="T:Lucene.Net.Search.SortField"/> within 
              <see cref="T:Lucene.Net.Search.Sort"/>.  The comparer is primary if sortPos==0,
              secondary if sortPos==1, etc.  Some comparers can
              optimize themselves when they are the primary sort. </param>
            <returns> <see cref="T:Lucene.Net.Search.FieldComparer"/> to use when sorting </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.Rewrite(Lucene.Net.Search.IndexSearcher)">
            <summary>
            Rewrites this <see cref="T:Lucene.Net.Search.SortField"/>, returning a new <see cref="T:Lucene.Net.Search.SortField"/> if a change is made.
            Subclasses should override this define their rewriting behavior when this
            SortField is of type <see cref="F:Lucene.Net.Search.SortFieldType.REWRITEABLE"/>.
            <para/>
            @lucene.experimental
            </summary>
            <param name="searcher"> <see cref="T:Lucene.Net.Search.IndexSearcher"/> to use during rewriting </param>
            <returns> New rewritten <see cref="T:Lucene.Net.Search.SortField"/>, or <c>this</c> if nothing has changed. </returns>
            <exception cref="T:System.IO.IOException"> Can be thrown by the rewriting </exception>
        </member>
        <member name="P:Lucene.Net.Search.SortField.NeedsScores">
            <summary>
            Whether the relevance score is needed to sort documents. </summary>
        </member>
        <member name="T:Lucene.Net.Search.SortFieldType">
            <summary>
            Specifies the type of the terms to be sorted, or special types such as CUSTOM
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.SCORE">
            <summary>
            Sort by document score (relevance).  Sort values are <see cref="T:System.Single"/> and higher
            values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.DOC">
            <summary>
            Sort by document number (index order).  Sort values are <see cref="T:System.Int32"/> and lower
            values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.STRING">
            <summary>
            Sort using term values as <see cref="T:System.String"/>s.  Sort values are <see cref="T:System.String"/>s and lower
            values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.INT32">
            <summary>
            Sort using term values as encoded <see cref="T:System.Int32"/>s.  Sort values are <see cref="T:System.Int32"/> and
            lower values are at the front.
            <para/>
            NOTE: This was INT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.SINGLE">
            <summary>
            Sort using term values as encoded <see cref="T:System.Single"/>s.  Sort values are <see cref="T:System.Single"/> and
            lower values are at the front.
            <para/>
            NOTE: This was FLOAT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.INT64">
            <summary>
            Sort using term values as encoded <see cref="T:System.Int64"/>s.  Sort values are <see cref="T:System.Int64"/> and
            lower values are at the front.
            <para/>
            NOTE: This was LONG in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.DOUBLE">
            <summary>
            Sort using term values as encoded <see cref="T:System.Double"/>s.  Sort values are <see cref="T:System.Double"/> and
            lower values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.INT16">
            <summary>
            Sort using term values as encoded <see cref="T:System.Int16"/>s.  Sort values are <see cref="T:System.Int16"/> and
            lower values are at the front.
            <para/>
            NOTE: This was SHORT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.CUSTOM">
            <summary>
            Sort using a custom <see cref="T:System.Collections.Generic.IComparer`1"/>.  Sort values are any <see cref="T:System.IComparable`1"/> and
            sorting is done according to natural order.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.BYTE">
            <summary>
            Sort using term values as encoded <see cref="T:System.Byte"/>s.  Sort values are <see cref="T:System.Byte"/> and
            lower values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.STRING_VAL">
            <summary>
            Sort using term values as <see cref="T:System.String"/>s, but comparing by
            value (using <see cref="M:Lucene.Net.Util.BytesRef.CompareTo(Lucene.Net.Util.BytesRef)"/>) for all comparisons.
            this is typically slower than <see cref="F:Lucene.Net.Search.SortFieldType.STRING"/>, which
            uses ordinals to do the sorting.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.BYTES">
            <summary>
            Sort use <see cref="T:byte[]"/> index values. </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.REWRITEABLE">
            <summary>
            Force rewriting of <see cref="T:Lucene.Net.Search.SortField"/> using <see cref="M:Lucene.Net.Search.SortField.Rewrite(Lucene.Net.Search.IndexSearcher)"/>
            before it can be used for sorting
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.SortRescorer">
            <summary>
            A <see cref="T:Lucene.Net.Search.Rescorer"/> that re-sorts according to a provided
            Sort.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortRescorer.#ctor(Lucene.Net.Search.Sort)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.FieldMaskingSpanQuery">
             <summary>
             <para>Wrapper to allow <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> objects participate in composite
             single-field SpanQueries by 'lying' about their search field. That is,
             the masked <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> will function as normal,
             but <see cref="P:Lucene.Net.Search.Spans.SpanQuery.Field"/> simply hands back the value supplied
             in this class's constructor.</para>
            
             <para>This can be used to support Queries like <see cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/> or
             <see cref="T:Lucene.Net.Search.Spans.SpanOrQuery"/> across different fields, which is not ordinarily
             permitted.</para>
            
             <para>This can be useful for denormalized relational data: for example, when
             indexing a document with conceptually many 'children': </para>
            
             <code>
              teacherid: 1
              studentfirstname: james
              studentsurname: jones
            
              teacherid: 2
              studenfirstname: james
              studentsurname: smith
              studentfirstname: sally
              studentsurname: jones
             </code>
            
             <para>A <see cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/> with a slop of 0 can be applied across two
             <see cref="T:Lucene.Net.Search.Spans.SpanTermQuery"/> objects as follows:
             <code>
                 SpanQuery q1  = new SpanTermQuery(new Term("studentfirstname", "james"));
                 SpanQuery q2  = new SpanTermQuery(new Term("studentsurname", "jones"));
                 SpanQuery q2m = new FieldMaskingSpanQuery(q2, "studentfirstname");
                 Query q = new SpanNearQuery(new SpanQuery[] { q1, q2m }, -1, false);
             </code>
             to search for 'studentfirstname:james studentsurname:jones' and find
             teacherid 1 without matching teacherid 2 (which has a 'james' in position 0
             and 'jones' in position 1). </para>
            
             <para>Note: as <see cref="P:Lucene.Net.Search.Spans.FieldMaskingSpanQuery.Field"/> returns the masked field, scoring will be
             done using the <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> and collection statistics of the field name supplied,
             but with the term statistics of the real field. This may lead to exceptions,
             poor performance, and unexpected scoring behavior.</para>
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.NearSpansOrdered">
             <summary>
             A <see cref="T:Lucene.Net.Search.Spans.Spans"/> that is formed from the ordered subspans of a <see cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/>
             where the subspans do not overlap and have a maximum slop between them.
             <para/>
             The formed spans only contains minimum slop matches.
             <para/>
             The matching slop is computed from the distance(s) between
             the non overlapping matching <see cref="T:Lucene.Net.Search.Spans.Spans"/>.
             <para/>
             Successive matches are always formed from the successive <see cref="T:Lucene.Net.Search.Spans.Spans"/>
             of the <see cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/>.
             <para/>
             The formed spans may contain overlaps when the slop is at least 1.
             For example, when querying using
             <c>t1 t2 t3</c>
             with slop at least 1, the fragment:
             <c>t1 t2 t1 t3 t2 t3</c>
             matches twice:
             <c>t1 t2 .. t3      </c>
             <c>      t1 .. t2 t3</c>
            
             <para/>
             Expert:
             Only public for subclassing.  Most implementations should not need this class
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.NearSpansOrdered.subSpans">
            <summary>
            The spans in the same order as the <see cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/> </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.NearSpansOrdered.inSameDoc">
            <summary>
            Indicates that all subSpans have same <see cref="P:Lucene.Net.Search.Spans.NearSpansOrdered.Doc"/> </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.NearSpansOrdered.Doc">
            <summary>
            Returns the document number of the current match.  Initially invalid. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.NearSpansOrdered.Start">
            <summary>
            Returns the start position of the current match.  Initially invalid. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.NearSpansOrdered.End">
            <summary>
            Returns the end position of the current match.  Initially invalid. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.Next">
            <summary>
            Move to the next match, returning true iff any such exists. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.SkipTo(System.Int32)">
            <summary>
            Skips to the first match beyond the current, whose document number is
            greater than or equal to <i>target</i>.
            <para/>The behavior of this method is <b>undefined</b> when called with
            <c> target &lt;= current</c>, or after the iterator has exhausted.
            Both cases may result in unpredicted behavior.
            <para/>Returns <c>true</c> if there is such
            a match.  
            <para/>Behaves as if written: 
            <code>
                bool SkipTo(int target) 
                {
                    do 
                    {
                        if (!Next())
                            return false;
                    } while (target > Doc);
                    return true;
                }
            </code>
            Most implementations are considerably more efficient than that.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.AdvanceAfterOrdered">
            <summary>
            Advances the <see cref="P:Lucene.Net.Search.Spans.NearSpansOrdered.SubSpans"/> to just after an ordered match with a minimum slop
            that is smaller than the slop allowed by the <see cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/>. </summary>
            <returns> <c>true</c> if there is such a match. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.ToSameDoc">
            <summary>
            Advance the <see cref="P:Lucene.Net.Search.Spans.NearSpansOrdered.SubSpans"/> to the same document </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.DocSpansOrdered(Lucene.Net.Search.Spans.Spans,Lucene.Net.Search.Spans.Spans)">
            <summary>
            Check whether two <see cref="T:Lucene.Net.Search.Spans.Spans"/> in the same document are ordered. </summary>
            <returns> <c>true</c> if <paramref name="spans1"/> starts before <paramref name="spans2"/>
                         or the spans start at the same position,
                         and <paramref name="spans1"/> ends before <paramref name="spans2"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.DocSpansOrdered(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like <see cref="M:Lucene.Net.Search.Spans.NearSpansOrdered.DocSpansOrdered(Lucene.Net.Search.Spans.Spans,Lucene.Net.Search.Spans.Spans)"/>, but use the spans
            starts and ends as parameters.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.StretchToOrder">
            <summary>
            Order the <see cref="P:Lucene.Net.Search.Spans.NearSpansOrdered.SubSpans"/> within the same document by advancing all later spans
            after the previous one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.ShrinkToAfterShortestMatch">
            <summary>
            The <see cref="P:Lucene.Net.Search.Spans.NearSpansOrdered.SubSpans"/> are ordered in the same doc, so there is a possible match.
            Compute the slop while making the match as short as possible by advancing
            all <see cref="P:Lucene.Net.Search.Spans.NearSpansOrdered.SubSpans"/> except the last one in reverse order.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.NearSpansUnordered">
            <summary>
            Similar to <see cref="T:Lucene.Net.Search.Spans.NearSpansOrdered"/>, but for the unordered case.
            <para/>
            Expert:
            Only public for subclassing.  Most implementations should not need this class
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.NearSpansUnordered.SpansCell">
            <summary>
            Wraps a <see cref="T:Lucene.Net.Search.Spans.Spans"/>, and can be used to form a linked list. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansUnordered.GetPayload">
            <summary>
            WARNING: The List is not necessarily in order of the the positions </summary>
            <returns> Collection of <see cref="T:byte[]"/> payloads </returns>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanFirstQuery">
            <summary>
            Matches spans near the beginning of a field.
            <para/>
            This class is a simple extension of <see cref="T:Lucene.Net.Search.Spans.SpanPositionRangeQuery"/> in that it assumes the
            start to be zero and only checks the end boundary.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,System.Int32)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.Spans.SpanFirstQuery"/> matching spans in <paramref name="match"/> whose end
            position is less than or equal to <paramref name="end"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1">
            <summary>
            Wraps any <see cref="T:Lucene.Net.Search.MultiTermQuery"/> as a <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/>,
            so it can be nested within other <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> classes.
            <para/>
            The query is rewritten by default to a <see cref="T:Lucene.Net.Search.Spans.SpanOrQuery"/> containing
            the expanded terms, but this can be customized.
            <para/>
            Example:
            <code>
            WildcardQuery wildcard = new WildcardQuery(new Term("field", "bro?n"));
            SpanQuery spanWildcard = new SpanMultiTermQueryWrapper&lt;WildcardQuery&gt;(wildcard);
            // do something with spanWildcard, such as use it in a SpanFirstQuery
            </code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.#ctor(`0)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1"/>.
            </summary>
            <param name="query"> Query to wrap.
            <para/>
            NOTE: This will set <see cref="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod"/>
            on the wrapped <paramref name="query"/>, changing its rewrite method to a suitable one for spans.
            Be sure to not change the rewrite method on the wrapped query afterwards! Doing so will
            throw <see cref="T:System.NotSupportedException"/> on rewriting this query! </param>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.MultiTermRewriteMethod">
            <summary>
            Expert: Gets or Sets the rewrite method. This only makes sense
            to be a span rewrite method.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.WrappedQuery">
            <summary>
            Returns the wrapped query </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.SCORING_SPAN_QUERY_REWRITE">
            <summary>
            A rewrite method that first translates each term into a <see cref="T:Lucene.Net.Search.Spans.SpanTermQuery"/> in a
            <see cref="F:Lucene.Net.Search.Occur.SHOULD"/> clause in a <see cref="T:Lucene.Net.Search.BooleanQuery"/>, and keeps the
            scores as computed by the query.
            </summary>
            <seealso cref="P:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.MultiTermRewriteMethod"/>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.TopTermsSpanBooleanQueryRewrite">
             <summary>
             A rewrite method that first translates each term into a <see cref="T:Lucene.Net.Search.Spans.SpanTermQuery"/> in a
             <see cref="F:Lucene.Net.Search.Occur.SHOULD"/> clause in a <see cref="T:Lucene.Net.Search.BooleanQuery"/>, and keeps the
             scores as computed by the query.
            
             <para/>
             This rewrite method only uses the top scoring terms so it will not overflow
             the boolean max clause count.
             </summary>
             <seealso cref="P:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.MultiTermRewriteMethod"/>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.TopTermsSpanBooleanQueryRewrite.#ctor(System.Int32)">
            <summary>
            Create a <see cref="T:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.TopTermsSpanBooleanQueryRewrite"/> for
            at most <paramref name="size"/> terms.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.TopTermsSpanBooleanQueryRewrite.Count">
            <summary>
            return the maximum priority queue size.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanRewriteMethod">
            <summary>
            Abstract class that defines how the query is rewritten. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.ISpanMultiTermQueryWrapper">
            <summary>
            LUCENENET specific interface for referring to/identifying a <see cref="T:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1"/> without
            referring to its generic closing type.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.ISpanMultiTermQueryWrapper.MultiTermRewriteMethod">
            <summary>
            Expert: Gets or Sets the rewrite method. This only makes sense
            to be a span rewrite method.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.ISpanMultiTermQueryWrapper.WrappedQuery">
            <summary>
            Returns the wrapped query </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNearPayloadCheckQuery">
            <summary>
            Only return those matches that have a specific payload at
            the given position.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearPayloadCheckQuery.#ctor(Lucene.Net.Search.Spans.SpanNearQuery,System.Collections.Generic.ICollection{System.Byte[]})">
            <param name="match">          The underlying <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> to check.</param>
            <param name="payloadToMatch"> The <see cref="T:ICollection{byte[]}"/> of payloads to match.
            IMPORTANT: If the type provided does not implement <see cref="T:System.Collections.Generic.IList`1"/> (including arrays) or
            <see cref="T:System.Collections.Generic.ISet`1"/>, it should either implement <see cref="T:System.Collections.IStructuralEquatable"/> or override
            <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/> with implementations
            that compare the values of the byte arrays to ensure they are the same.</param>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNearQuery">
            <summary>
            Matches spans which are near one another.  One can specify <i>slop</i>, the
            maximum number of intervening unmatched positions, as well as whether
            matches are required to be in-order.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[],System.Int32,System.Boolean)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/>.  Matches spans matching a span from each
            clause, with up to <paramref name="slop"/> total unmatched positions between
            them.  * When <paramref name="inOrder"/> is <c>true</c>, the spans from each clause
            must be * ordered as in <paramref name="clauses"/>. </summary>
            <param name="clauses"> The clauses to find near each other </param>
            <param name="slop"> The slop value </param>
            <param name="inOrder"> <c>true</c> if order is important</param>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.GetClauses">
            <summary>
            Return the clauses whose spans are matched. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNearQuery.Slop">
            <summary>
            Return the maximum number of intervening unmatched positions permitted. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNearQuery.IsInOrder">
            <summary>
            Return <c>true</c> if matches are required to be in-order. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNotQuery">
            <summary>
            Removes matches which overlap with another <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> or
            within a x tokens before or y tokens after another <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.Spans.SpanNotQuery"/> matching spans from <paramref name="include"/> which
            have no overlap with spans from <paramref name="exclude"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery,System.Int32)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.Spans.SpanNotQuery"/> matching spans from <paramref name="include"/> which
            have no overlap with spans from <paramref name="exclude"/> within
            <paramref name="dist"/> tokens of <paramref name="include"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery,System.Int32,System.Int32)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.Spans.SpanNotQuery"/> matching spans from <paramref name="include"/> which
            have no overlap with spans from <paramref name="exclude"/> within
            <paramref name="pre"/> tokens before or <paramref name="post"/> tokens of <paramref name="include"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNotQuery.Include">
            <summary>
            Return the <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> whose matches are filtered. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNotQuery.Exclude">
            <summary>
            Return the <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> whose matches must not overlap those returned. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <paramref name="o"/> is equal to this. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanOrQuery">
            <summary>
            Matches the union of its clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[])">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.Spans.SpanOrQuery"/> merging the provided <paramref name="clauses"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.AddClause(Lucene.Net.Search.Spans.SpanQuery)">
            <summary>
            Adds a <paramref name="clause"/> to this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.GetClauses">
            <summary>
            Return the clauses whose spans are matched. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanPayloadCheckQuery">
            <summary>
            Only return those matches that have a specific payload at
            the given position.
            <para/>
            Do not use this with a <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> that contains a <see cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/>.  Instead, use
            <see cref="T:Lucene.Net.Search.Spans.SpanNearPayloadCheckQuery"/> since it properly handles the fact that payloads
            aren't ordered by <see cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanPayloadCheckQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,System.Collections.Generic.ICollection{System.Byte[]})">
            
             <param name="match"> The underlying <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> to check </param>
             <param name="payloadToMatch"> The <see cref="T:ICollection{byte[]}"/> of payloads to match.
             IMPORTANT: If the type provided does not implement <see cref="T:System.Collections.Generic.IList`1"/> (including arrays) or
             <see cref="T:System.Collections.Generic.ISet`1"/>, it should either implement <see cref="T:System.Collections.IStructuralEquatable"/> or override
             <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/> with implementations
             that compare the values of the byte arrays to ensure they are the same.</param>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanPositionCheckQuery">
            <summary>
            Base class for filtering a <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> based on the position of a match.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanPositionCheckQuery.Match">
            <returns> 
            The <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> whose matches are filtered.
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptStatus">
            <summary>
            Return value for <see cref="M:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptPosition(Lucene.Net.Search.Spans.Spans)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptStatus.YES">
            <summary>
            Indicates the match should be accepted </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptStatus.NO">
            <summary>
            Indicates the match should be rejected </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptStatus.NO_AND_ADVANCE">
            <summary>
            Indicates the match should be rejected, and the enumeration should advance
            to the next document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptPosition(Lucene.Net.Search.Spans.Spans)">
            <summary>
            Implementing classes are required to return whether the current position is a match for the passed in
            "match" <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/>.
            <para/>
            This is only called if the underlying <see cref="M:Lucene.Net.Search.Spans.Spans.Next"/> for the
            match is successful
            </summary>
            <param name="spans"> The <see cref="T:Lucene.Net.Search.Spans.Spans"/> instance, positioned at the spot to check </param>
            <returns> Whether the match is accepted, rejected, or rejected and should move to the next doc.
            </returns>
            <seealso cref="M:Lucene.Net.Search.Spans.Spans.Next"/>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanPositionRangeQuery">
            <summary>
            Checks to see if the <see cref="P:Lucene.Net.Search.Spans.SpanPositionCheckQuery.Match"/> lies between a start and end position
            </summary>
            <seealso cref="T:Lucene.Net.Search.Spans.SpanFirstQuery">for a derivation that is optimized for the case where start position is 0</seealso>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanPositionRangeQuery.Start">
            <returns> The minimum position permitted in a match </returns>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanPositionRangeQuery.End">
            <returns> The maximum end position permitted in a match. </returns>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanQuery">
            <summary>
            Base class for span-based queries. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetSpans(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits,System.Collections.Generic.IDictionary{Lucene.Net.Index.Term,Lucene.Net.Index.TermContext})">
            <summary>
            Expert: Returns the matches for this query in an index.  Used internally
            to search for spans.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanQuery.Field">
            <summary>
            Returns the name of the field matched by this query.
            <para/>
            Note that this may return <c>null</c> if the query matches no terms.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.Spans">
            <summary>
            Expert: an enumeration of span matches.  Used to implement span searching.
            Each span represents a range of term positions within a document.  Matches
            are enumerated in order, by increasing document number, within that by
            increasing start position and finally by increasing end position.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.Next">
            <summary>
            Move to the next match, returning true if any such exists. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.SkipTo(System.Int32)">
            <summary>
            Skips to the first match beyond the current, whose document number is
            greater than or equal to <i>target</i>.
            <para/>The behavior of this method is <b>undefined</b> when called with
            <c> target &lt;= current</c>, or after the iterator has exhausted.
            Both cases may result in unpredicted behavior.
            <para/>Returns <c>true</c> if there is such
            a match.  
            <para/>Behaves as if written: 
            <code>
                bool SkipTo(int target) 
                {
                    do 
                    {
                        if (!Next())
                            return false;
                    } while (target > Doc);
                    return true;
                }
            </code>
            Most implementations are considerably more efficient than that.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.Spans.Doc">
            <summary>
            Returns the document number of the current match.  Initially invalid. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.Spans.Start">
            <summary>
            Returns the start position of the current match.  Initially invalid. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.Spans.End">
            <summary>
            Returns the end position of the current match.  Initially invalid. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.GetPayload">
            <summary>
            Returns the payload data for the current span.
            this is invalid until <see cref="M:Lucene.Net.Search.Spans.Spans.Next"/> is called for
            the first time.
            This method must not be called more than once after each call
            of <see cref="M:Lucene.Net.Search.Spans.Spans.Next"/>. However, most payloads are loaded lazily,
            so if the payload data for the current position is not needed,
            this method may not be called at all for performance reasons. An ordered
            SpanQuery does not lazy load, so if you have payloads in your index and
            you do not want ordered SpanNearQuerys to collect payloads, you can
            disable collection with a constructor option.
            <para/>
            Note that the return type is a collection, thus the ordering should not be relied upon.
            <para/>
            @lucene.experimental
            </summary>
            <returns> A <see cref="T:ICollection{byte[]}"/> of byte arrays containing the data of this payload, 
            otherwise <c>null</c> if <see cref="P:Lucene.Net.Search.Spans.Spans.IsPayloadAvailable"/> is <c>false</c> </returns>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="P:Lucene.Net.Search.Spans.Spans.IsPayloadAvailable">
            <summary>
            Checks if a payload can be loaded at this position.
            <para/>
            Payloads can only be loaded once per call to
            <see cref="M:Lucene.Net.Search.Spans.Spans.Next"/>.
            </summary>
            <returns> <c>true</c> if there is a payload available at this position that can be loaded </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.GetCost">
            <summary>
            Returns the estimated cost of this spans.
            <para/>
            This is generally an upper bound of the number of documents this iterator
            might match, but may be a rough heuristic, hardcoded value, or otherwise
            completely inaccurate.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanScorer">
            <summary>
            Public for extension only.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanScorer.SloppyFreq">
            <summary>
            Returns the intermediate "sloppy freq" adjusted for edit distance
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanTermQuery">
            <summary>
            Matches spans containing a term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.Spans.SpanTermQuery"/> matching the named term's spans. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanTermQuery.Term">
            <summary>
            Return the term whose spans are matched. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanWeight">
            <summary>
            Expert-only.  Public for use by other weight implementations
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.TermSpans">
            <summary>
            Expert:
            Public for extension only
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermCollectingRewrite`1.GetTopLevelQuery">
            <summary>
            Return a suitable top-level <see cref="T:Lucene.Net.Search.Query"/> for holding all expanded terms. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermCollectingRewrite`1.AddClause(`0,Lucene.Net.Index.Term,System.Int32,System.Single)">
            <summary>
            Add a <see cref="T:Lucene.Net.Search.MultiTermQuery"/> term to the top-level query </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermCollectingRewrite`1.TermCollector.Attributes">
            <summary>
            attributes used for communication with the enum </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermCollectingRewrite`1.TermCollector.Collect(Lucene.Net.Util.BytesRef)">
            <summary>
            return false to stop collecting </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermCollectingRewrite`1.TermCollector.SetNextEnum(Lucene.Net.Index.TermsEnum)">
            <summary>
            the next segment's <seealso cref="T:Lucene.Net.Index.TermsEnum"/> that is used to collect terms </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermQuery">
            <summary>
            A <see cref="T:Lucene.Net.Search.Query"/> that matches documents containing a term.
            this may be combined with other terms with a <see cref="T:Lucene.Net.Search.BooleanQuery"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.TermWeight.GetTermsEnum(Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.TermsEnum"/> positioned at this weights <see cref="T:Lucene.Net.Index.Term"/> or <c>null</c> if
            the term does not exist in the given context.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Constructs a query for the term <paramref name="t"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term,System.Int32)">
            <summary>
            Expert: constructs a <see cref="T:Lucene.Net.Search.TermQuery"/> that will use the
            provided <paramref name="docFreq"/> instead of looking up the docFreq
            against the searcher.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Index.TermContext)">
            <summary>
            Expert: constructs a <see cref="T:Lucene.Net.Search.TermQuery"/> that will use the
            provided docFreq instead of looking up the docFreq
            against the searcher.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermQuery.Term">
            <summary>
            Returns the term of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <paramref name="o"/> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermRangeFilter">
             <summary>
             A <see cref="T:Lucene.Net.Search.Filter"/> that restricts search results to a range of term
             values in a given field.
            
             <para/>This filter matches the documents looking for terms that fall into the
             supplied range according to 
             <see cref="M:System.Byte.CompareTo(System.Byte)"/>,  It is not intended
             for numerical ranges; use <see cref="T:Lucene.Net.Search.NumericRangeFilter"/> instead.
            
             <para/>If you construct a large number of range filters with different ranges but on the
             same field, <see cref="T:Lucene.Net.Search.FieldCacheRangeFilter"/> may have significantly better performance.
             <para/>
             @since 2.9
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeFilter.#ctor(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
            <param name="fieldName"> The field this range applies to </param>
            <param name="lowerTerm"> The lower bound on this range </param>
            <param name="upperTerm"> The upper bound on this range </param>
            <param name="includeLower"> Does this range include the lower bound? </param>
            <param name="includeUpper"> Does this range include the upper bound? </param>
            <exception cref="T:System.ArgumentException"> if both terms are <c>null</c> or if
             lowerTerm is <c>null</c> and includeLower is <c>true</c> (similar for upperTerm
             and includeUpper) </exception>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeFilter.NewStringRange(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a new <see cref="T:Lucene.Net.Search.TermRangeFilter"/> using <see cref="T:System.String"/>s for term text.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeFilter.Less(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Constructs a filter for field <paramref name="fieldName"/> matching
            less than or equal to <paramref name="upperTerm"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeFilter.More(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Constructs a filter for field <paramref name="fieldName"/> matching
            greater than or equal to <paramref name="lowerTerm"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeFilter.LowerTerm">
            <summary>
            Returns the lower value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeFilter.UpperTerm">
            <summary>
            Returns the upper value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeFilter.IncludesLower">
            <summary>
            Returns <c>true</c> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeFilter.IncludesUpper">
            <summary>
            Returns <c>true</c> if the upper endpoint is inclusive </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermRangeQuery">
             <summary>
             A <see cref="T:Lucene.Net.Search.Query"/> that matches documents within an range of terms.
            
             <para/>This query matches the documents looking for terms that fall into the
             supplied range according to 
             <see cref="M:System.Byte.CompareTo(System.Byte)"/>. It is not intended
             for numerical ranges; use <see cref="T:Lucene.Net.Search.NumericRangeQuery"/> instead.
            
             <para/>This query uses the
             <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT"/>
             rewrite method.
             <para/>
             @since 2.9
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeQuery.#ctor(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
             <summary>
             Constructs a query selecting all terms greater/equal than <paramref name="lowerTerm"/>
             but less/equal than <paramref name="upperTerm"/>.
            
             <para/>
             If an endpoint is <c>null</c>, it is said
             to be "open". Either or both endpoints may be open.  Open endpoints may not
             be exclusive (you can't select all but the first or last term without
             explicitly specifying the term to exclude.)
             </summary>
             <param name="field"> The field that holds both lower and upper terms. </param>
             <param name="lowerTerm">
                      The term text at the lower end of the range. </param>
             <param name="upperTerm">
                      The term text at the upper end of the range. </param>
             <param name="includeLower">
                      If true, the <paramref name="lowerTerm"/> is
                      included in the range. </param>
             <param name="includeUpper">
                      If true, the <paramref name="upperTerm"/> is
                      included in the range. </param>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeQuery.NewStringRange(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a new <see cref="T:Lucene.Net.Search.TermRangeQuery"/> using <see cref="T:System.String"/>s for term text.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeQuery.LowerTerm">
            <summary>
            Returns the lower value of this range query </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeQuery.UpperTerm">
            <summary>
            Returns the upper value of this range query </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeQuery.IncludesLower">
            <summary>
            Returns <c>true</c> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeQuery.IncludesUpper">
            <summary>
            Returns <c>true</c> if the upper endpoint is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermRangeTermsEnum">
            <summary>
            Subclass of <see cref="T:Lucene.Net.Index.FilteredTermsEnum"/> for enumerating all terms that match the
            specified range parameters.
            <para>Term enumerations are always ordered by
            <see cref="P:Lucene.Net.Index.FilteredTermsEnum.Comparer"/>.  Each term in the enumeration is
            greater than all that precede it.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeTermsEnum.#ctor(Lucene.Net.Index.TermsEnum,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
             <summary>
             Enumerates all terms greater/equal than <paramref name="lowerTerm"/>
             but less/equal than <paramref name="upperTerm"/>.
            
             If an endpoint is <c>null</c>, it is said to be "open". Either or both
             endpoints may be open.  Open endpoints may not be exclusive
             (you can't select all but the first or last term without
             explicitly specifying the term to exclude.)
             </summary>
             <param name="tenum">
                      TermsEnum to filter </param>
             <param name="lowerTerm">
                      The term text at the lower end of the range </param>
             <param name="upperTerm">
                      The term text at the upper end of the range </param>
             <param name="includeLower">
                      If true, the <paramref name="lowerTerm"/> is included in the range. </param>
             <param name="includeUpper">
                      If true, the <paramref name="upperTerm"/> is included in the range. </param>
        </member>
        <member name="T:Lucene.Net.Search.TermScorer">
            <summary>
            Expert: A <see cref="T:Lucene.Net.Search.Scorer"/> for documents matching a <see cref="T:Lucene.Net.Index.Term"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermScorer.#ctor(Lucene.Net.Search.Weight,Lucene.Net.Index.DocsEnum,Lucene.Net.Search.Similarities.Similarity.SimScorer)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Search.TermScorer"/>.
            </summary>
            <param name="weight">
                     The weight of the <see cref="T:Lucene.Net.Index.Term"/> in the query. </param>
            <param name="td">
                     An iterator over the documents matching the <see cref="T:Lucene.Net.Index.Term"/>. </param>
            <param name="docScorer">
                     The <see cref="T:Lucene.Net.Search.Similarities.Similarity.SimScorer"/> implementation
                     to be used for score computations. </param>
        </member>
        <member name="M:Lucene.Net.Search.TermScorer.NextDoc">
            <summary>
            Advances to the next document matching the query.
            </summary>
            <returns> The document matching the query or <see cref="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS"/> if there are no more documents. </returns>
        </member>
        <member name="M:Lucene.Net.Search.TermScorer.Advance(System.Int32)">
            <summary>
            Advances to the first match beyond the current whose document number is
            greater than or equal to a given target.
            <para/>
            The implementation uses <see cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/>.
            </summary>
            <param name="target">
                     The target document number. </param>
            <returns> The matching document or <see cref="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS"/> if none exist. </returns>
        </member>
        <member name="M:Lucene.Net.Search.TermScorer.ToString">
            <summary>
            Returns a string representation of this <see cref="T:Lucene.Net.Search.TermScorer"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermStatistics">
            <summary>
            Contains statistics for a specific term
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermStatistics.#ctor(Lucene.Net.Util.BytesRef,System.Int64,System.Int64)">
            <summary>
            Sole constructor.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermStatistics.Term">
            <summary>
            Returns the term text </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermStatistics.DocFreq">
            <summary>
            Returns the number of documents this term occurs in </summary>
            <seealso cref="P:Lucene.Net.Index.TermsEnum.DocFreq"/>
        </member>
        <member name="P:Lucene.Net.Search.TermStatistics.TotalTermFreq">
            <summary>
            Returns the total number of occurrences of this term </summary>
            <seealso cref="P:Lucene.Net.Index.TermsEnum.TotalTermFreq"/>
        </member>
        <member name="T:Lucene.Net.Search.TimeLimitingCollector">
            <summary>
            The <see cref="T:Lucene.Net.Search.TimeLimitingCollector"/> is used to timeout search requests that
            take longer than the maximum allowed search time limit. After this time is
            exceeded, the search thread is stopped by throwing a
            <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException">
            <summary>
            Thrown when elapsed search time exceeds allowed search time. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.TimeAllowed">
            <summary>
            Returns allowed time (milliseconds). </summary>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.TimeElapsed">
            <summary>
            Returns elapsed time (milliseconds). </summary>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.LastDocCollected">
            <summary>
            Returns last doc (absolute doc id) that was collected when the search time exceeded. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.#ctor(Lucene.Net.Search.ICollector,Lucene.Net.Util.Counter,System.Int64)">
            <summary>
            Create a <see cref="T:Lucene.Net.Search.TimeLimitingCollector"/> wrapper over another <see cref="T:Lucene.Net.Search.ICollector"/> with a specified timeout. </summary>
            <param name="collector"> The wrapped <see cref="T:Lucene.Net.Search.ICollector"/> </param>
            <param name="clock"> The timer clock </param>
            <param name="ticksAllowed"> Max time allowed for collecting
            hits after which <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException"/> is thrown </param>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.SetBaseline(System.Int64)">
            <summary>
            Sets the baseline for this collector. By default the collectors baseline is
            initialized once the first reader is passed to the collector.
            To include operations executed in prior to the actual document collection
            set the baseline through this method in your prelude.
            <para>
            Example usage:
            <code>
                // Counter is in the Lucene.Net.Util namespace
                Counter clock = Counter.NewCounter(true);
                long baseline = clock.Get();
                // ... prepare search
                TimeLimitingCollector collector = new TimeLimitingCollector(c, clock, numTicks);
                collector.SetBaseline(baseline);
                indexSearcher.Search(query, collector);
            </code>
            </para> 
            </summary>
            <seealso cref="M:Lucene.Net.Search.TimeLimitingCollector.SetBaseline"/>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.SetBaseline">
            <summary>
            Syntactic sugar for <see cref="M:Lucene.Net.Search.TimeLimitingCollector.SetBaseline(System.Int64)"/> using <see cref="M:Lucene.Net.Util.Counter.Get"/>
            on the clock passed to the constructor.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.IsGreedy">
            <summary>
            Checks if this time limited collector is greedy in collecting the last hit.
            A non greedy collector, upon a timeout, would throw a <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException"/>
            without allowing the wrapped collector to collect current doc. A greedy one would
            first allow the wrapped hit collector to collect current doc and only then
            throw a <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException"/>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.Collect(System.Int32)">
            <summary>
            Calls <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/> on the decorated <see cref="T:Lucene.Net.Search.ICollector"/>
            unless the allowed time has passed, in which case it throws an exception.
            </summary>
            <exception cref="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException">
                      If the time allowed has exceeded. </exception>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.SetCollector(Lucene.Net.Search.ICollector)">
            <summary>
            This is so the same timer can be used with a multi-phase search process such as grouping.
            We don't want to create a new <see cref="T:Lucene.Net.Search.TimeLimitingCollector"/> for each phase because that would
            reset the timer for each phase.  Once time is up subsequent phases need to timeout quickly.
            </summary>
            <param name="collector"> The actual collector performing search functionality. </param>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.GlobalCounter">
            <summary>
            Returns the global <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/>'s <see cref="T:Lucene.Net.Util.Counter"/>
            <para>
            Invoking this creates may create a new instance of <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> iff
            the global <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> has never been accessed before. The thread
            returned from this method is started on creation and will be alive unless
            you stop the <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> via <see cref="M:Lucene.Net.Search.TimeLimitingCollector.TimerThread.StopTimer"/>.
            </para> 
            @lucene.experimental
            </summary>
            <returns> the global TimerThreads <seealso cref="T:Lucene.Net.Util.Counter"/> </returns>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.GlobalTimerThread">
            <summary>
            Returns the global <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/>.
            <para>
            Invoking this creates may create a new instance of <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> iff
            the global <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> has never been accessed before. The thread
            returned from this method is started on creation and will be alive unless
            you stop the <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> via <see cref="M:Lucene.Net.Search.TimeLimitingCollector.TimerThread.StopTimer"/>.
            </para>
            @lucene.experimental
            </summary>
            <returns> the global <see cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> </returns>
        </member>
        <member name="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread">
            <summary>
            Thread used to timeout search requests.
            Can be stopped completely with <see cref="M:Lucene.Net.Search.TimeLimitingCollector.TimerThread.StopTimer"/>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimerThread.Milliseconds">
            <summary>
            Get the timer value in milliseconds.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.TimerThread.StopTimer">
            <summary>
            Stops the timer thread
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimerThread.Resolution">
            <summary>
            Return the timer resolution. </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopDocs">
            <summary>
            Represents hits returned by 
            <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)"/> and 
            <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopDocs.TotalHits">
            <summary>
            The total number of hits for the query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopDocs.ScoreDocs">
            <summary>
            The top hits for the query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.maxScore">
            <summary>
            Stores the maximum score value encountered, needed for normalizing. </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopDocs.MaxScore">
            <summary>
            Returns the maximum score value encountered. Note that in case
            scores are not tracked, this returns <see cref="F:System.Single.NaN"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[])">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Search.TopDocs"/> with a default <c>maxScore=System.Single.NaN</c>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.Merge(Lucene.Net.Search.Sort,System.Int32,Lucene.Net.Search.TopDocs[])">
             <summary>
             Returns a new <see cref="T:Lucene.Net.Search.TopDocs"/>, containing <paramref name="topN"/> results across
             the provided <see cref="T:Lucene.Net.Search.TopDocs"/>, sorting by the specified 
             <see cref="T:Lucene.Net.Search.Sort"/>.  Each of the <see cref="T:Lucene.Net.Search.TopDocs"/> must have been sorted by
             the same <see cref="T:Lucene.Net.Search.Sort"/>, and sort field values must have been
             filled (ie, <c>fillFields=true</c> must be
             passed to
             <see cref="M:Lucene.Net.Search.TopFieldCollector.Create(Lucene.Net.Search.Sort,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/>.
            
             <para/>Pass <paramref name="sort"/>=null to merge sort by score descending.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.Merge(Lucene.Net.Search.Sort,System.Int32,System.Int32,Lucene.Net.Search.TopDocs[])">
            <summary>
            Same as <see cref="M:Lucene.Net.Search.TopDocs.Merge(Lucene.Net.Search.Sort,System.Int32,Lucene.Net.Search.TopDocs[])"/> but also slices the result at the same time based
            on the provided start and size. The return <c>TopDocs</c> will always have a scoreDocs with length of 
            at most <see cref="P:Lucene.Net.Util.PriorityQueue`1.Count"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopDocsCollector`1">
            <summary>
            A base class for all collectors that return a <see cref="T:Lucene.Net.Search.TopDocs"/> output. This
            collector allows easy extension by providing a single constructor which
            accepts a <see cref="T:Lucene.Net.Util.PriorityQueue`1"/> as well as protected members for that
            priority queue and a counter of the number of total hits.
            <para/>
            Extending classes can override any of the methods to provide their own
            implementation, as well as avoid the use of the priority queue entirely by
            passing null to <see cref="M:Lucene.Net.Search.TopDocsCollector`1.#ctor(Lucene.Net.Util.PriorityQueue{`0})"/>. In that case
            however, you might want to consider overriding all methods, in order to avoid
            a <see cref="T:System.NullReferenceException"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocsCollector`1.EMPTY_TOPDOCS">
            <summary>
            This is used in case <see cref="M:Lucene.Net.Search.TopDocsCollector`1.GetTopDocs"/> is called with illegal parameters, or there
            simply aren't (enough) results.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocsCollector`1.m_pq">
            <summary>
            The priority queue which holds the top documents. Note that different
            implementations of <see cref="T:Lucene.Net.Util.PriorityQueue`1"/> give different meaning to 'top documents'.
            <see cref="T:Lucene.Net.Search.HitQueue"/> for example aggregates the top scoring documents, while other priority queue
            implementations may hold documents sorted by other criteria.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocsCollector`1.m_totalHits">
            <summary>
            The total number of documents that the collector encountered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.#ctor(Lucene.Net.Util.PriorityQueue{`0})">
            <summary>
            Sole constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.PopulateResults(Lucene.Net.Search.ScoreDoc[],System.Int32)">
            <summary>
            Populates the results array with the <see cref="T:Lucene.Net.Search.ScoreDoc"/> instances. This can be
            overridden in case a different <see cref="T:Lucene.Net.Search.ScoreDoc"/> type should be returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.NewTopDocs(Lucene.Net.Search.ScoreDoc[],System.Int32)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Search.TopDocs"/> instance containing the given results. If
            <paramref name="results"/> is <c>null</c> it means there are no results to return,
            either because there were 0 calls to <see cref="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)"/> or because the arguments to
            <see cref="T:Lucene.Net.Search.TopDocs"/> were invalid.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopDocsCollector`1.TotalHits">
            <summary>
            The total number of documents that matched this query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopDocsCollector`1.TopDocsCount">
            <summary>
            The number of valid priority queue entries 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.GetTopDocs">
            <summary>
            Returns the top docs that were collected by this collector. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.GetTopDocs(System.Int32)">
            <summary>
            Returns the documents in the rage [<paramref name="start"/> .. pq.Count) that were collected
            by this collector. Note that if <paramref name="start"/> &gt;= pq.Count, an empty <see cref="T:Lucene.Net.Search.TopDocs"/> is
            returned.
            <para/>
            This method is convenient to call if the application always asks for the
            last results, starting from the last 'page'.
            <para/>
            <b>NOTE:</b> you cannot call this method more than once for each search
            execution. If you need to call it more than once, passing each time a
            different <paramref name="start"/>, you should call <see cref="M:Lucene.Net.Search.TopDocsCollector`1.GetTopDocs"/> and work
            with the returned <see cref="T:Lucene.Net.Search.TopDocs"/> object, which will contain all the
            results this search execution collected.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.GetTopDocs(System.Int32,System.Int32)">
            <summary>
            Returns the documents in the rage [<paramref name="start"/> .. <paramref name="start"/>+<paramref name="howMany"/>) that were
            collected by this collector. Note that if <paramref name="start"/> >= pq.Count, an empty
            <see cref="T:Lucene.Net.Search.TopDocs"/> is returned, and if pq.Count - <paramref name="start"/> &lt; <paramref name="howMany"/>, then only the
            available documents in [<paramref name="start"/> .. pq.Count) are returned.
            <para/>
            This method is useful to call in case pagination of search results is
            allowed by the search application, as well as it attempts to optimize the
            memory used by allocating only as much as requested by <paramref name="howMany"/>.
            <para/>
            <b>NOTE:</b> you cannot call this method more than once for each search
            execution. If you need to call it more than once, passing each time a
            different range, you should call <see cref="M:Lucene.Net.Search.TopDocsCollector`1.GetTopDocs"/> and work with the
            returned <see cref="T:Lucene.Net.Search.TopDocs"/> object, which will contain all the results this
            search execution collected.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.SetScorer(Lucene.Net.Search.Scorer)">
            <summary>
            Called before successive calls to <see cref="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)"/>. Implementations
            that need the score of the current document (passed-in to
            <see cref="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)"/>), should save the passed-in <see cref="T:Lucene.Net.Search.Scorer"/> and call
            <see cref="M:Lucene.Net.Search.Scorer.GetScore"/> when needed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)">
            <summary>
            Called once for every document matching a query, with the unbased document
            number.
            <para/>Note: The collection of the current segment can be terminated by throwing
            a <see cref="T:Lucene.Net.Search.CollectionTerminatedException"/>. In this case, the last docs of the
            current <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> will be skipped and <see cref="T:Lucene.Net.Search.IndexSearcher"/>
            will swallow the exception and continue collection with the next leaf.
            <para/>
            Note: this is called in an inner search loop. For good search performance,
            implementations of this method should not call <see cref="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)"/> or
            <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/> on every hit.
            Doing so can slow searches by an order of magnitude or more.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.SetNextReader(Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Called before collecting from each <see cref="T:Lucene.Net.Index.AtomicReaderContext"/>. All doc ids in
            <see cref="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)"/> will correspond to <see cref="P:Lucene.Net.Index.IndexReaderContext.Reader"/>.
            <para/>
            Add <see cref="P:Lucene.Net.Index.AtomicReaderContext.DocBase"/> to the current <see cref="P:Lucene.Net.Index.IndexReaderContext.Reader"/>'s
            internal document id to re-base ids in <see cref="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)"/>.
            </summary>
            <param name="context">Next atomic reader context </param>
        </member>
        <member name="P:Lucene.Net.Search.TopDocsCollector`1.AcceptsDocsOutOfOrder">
             <summary>
             Return <c>true</c> if this collector does not
             require the matching docIDs to be delivered in int sort
             order (smallest to largest) to <see cref="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)"/>.
            
             <para> Most Lucene Query implementations will visit
             matching docIDs in order.  However, some queries
             (currently limited to certain cases of <see cref="T:Lucene.Net.Search.BooleanQuery"/>) 
             can achieve faster searching if the
             <see cref="T:Lucene.Net.Search.ICollector"/> allows them to deliver the
             docIDs out of order.</para>
            
             <para> Many collectors don't mind getting docIDs out of
             order, so it's important to return <c>true</c>
             here.</para>
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.ITopDocsCollector">
            <summary>
            LUCENENET specific interface used to reference <see cref="T:Lucene.Net.Search.TopDocsCollector`1"/>
            without referencing its generic type.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.ITopDocsCollector.TotalHits">
            <summary>
            The total number of documents that matched this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ITopDocsCollector.GetTopDocs">
            <summary>
            Returns the top docs that were collected by this collector. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ITopDocsCollector.GetTopDocs(System.Int32)">
            <summary>
            Returns the documents in the rage [<paramref name="start"/> .. pq.Count) that were collected
            by this collector. Note that if <paramref name="start"/> &gt;= pq.Count, an empty <see cref="T:Lucene.Net.Search.TopDocs"/> is
            returned.
            <para/>
            This method is convenient to call if the application always asks for the
            last results, starting from the last 'page'.
            <para/>
            <b>NOTE:</b> you cannot call this method more than once for each search
            execution. If you need to call it more than once, passing each time a
            different <paramref name="start"/>, you should call <see cref="M:Lucene.Net.Search.ITopDocsCollector.GetTopDocs"/> and work
            with the returned <see cref="T:Lucene.Net.Search.TopDocs"/> object, which will contain all the
            results this search execution collected.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ITopDocsCollector.GetTopDocs(System.Int32,System.Int32)">
            <summary>
            Returns the documents in the rage [<paramref name="start"/> .. <paramref name="start"/>+<paramref name="howMany"/>) that were
            collected by this collector. Note that if <paramref name="start"/> >= pq.Count, an empty
            <see cref="T:Lucene.Net.Search.TopDocs"/> is returned, and if pq.Count - <paramref name="start"/> &lt; <paramref name="howMany"/>, then only the
            available documents in [<paramref name="start"/> .. pq.Count) are returned.
            <para/>
            This method is useful to call in case pagination of search results is
            allowed by the search application, as well as it attempts to optimize the
            memory used by allocating only as much as requested by <paramref name="howMany"/>.
            <para/>
            <b>NOTE:</b> you cannot call this method more than once for each search
            execution. If you need to call it more than once, passing each time a
            different range, you should call <see cref="M:Lucene.Net.Search.ITopDocsCollector.GetTopDocs"/> and work with the
            returned <see cref="T:Lucene.Net.Search.TopDocs"/> object, which will contain all the results this
            search execution collected.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector">
            <summary>
            A <see cref="T:Lucene.Net.Search.ICollector"/> that sorts by <see cref="T:Lucene.Net.Search.SortField"/> using
            <see cref="T:Lucene.Net.Search.FieldComparer"/>s.
            <para/>
            See the <see cref="M:Lucene.Net.Search.TopFieldCollector.Create(Lucene.Net.Search.Sort,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/> method
            for instantiating a <see cref="T:Lucene.Net.Search.TopFieldCollector"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.OneComparerNonScoringCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> over one <see cref="T:Lucene.Net.Search.SortField"/> criteria, without
            tracking document scores and maxScore.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.OutOfOrderOneComparerNonScoringCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> over one <see cref="T:Lucene.Net.Search.SortField"/> criteria, without
            tracking document scores and maxScore, and assumes out of orderness in doc
            Ids collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.OneComparerScoringNoMaxScoreCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> over one <see cref="T:Lucene.Net.Search.SortField"/> criteria, while tracking
            document scores but no maxScore.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.OutOfOrderOneComparerScoringNoMaxScoreCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> over one <see cref="T:Lucene.Net.Search.SortField"/> criteria, while tracking
            document scores but no maxScore, and assumes out of orderness in doc Ids
            collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.OneComparerScoringMaxScoreCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> over one <see cref="T:Lucene.Net.Search.SortField"/> criteria, with tracking
            document scores and maxScore.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.OutOfOrderOneComparerScoringMaxScoreCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> over one <see cref="T:Lucene.Net.Search.SortField"/> criteria, with tracking
            document scores and maxScore, and assumes out of orderness in doc Ids
            collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.MultiComparerNonScoringCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> over multiple <see cref="T:Lucene.Net.Search.SortField"/> criteria, without
            tracking document scores and maxScore.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.OutOfOrderMultiComparerNonScoringCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> over multiple <see cref="T:Lucene.Net.Search.SortField"/> criteria, without
            tracking document scores and maxScore, and assumes out of orderness in doc
            Ids collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.MultiComparerScoringMaxScoreCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> over multiple <see cref="T:Lucene.Net.Search.SortField"/> criteria, with
            tracking document scores and maxScore.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.OutOfOrderMultiComparerScoringMaxScoreCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> over multiple <see cref="T:Lucene.Net.Search.SortField"/> criteria, with
            tracking document scores and maxScore, and assumes out of orderness in doc
            Ids collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.MultiComparerScoringNoMaxScoreCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> over multiple <see cref="T:Lucene.Net.Search.SortField"/> criteria, with
            tracking document scores and maxScore.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.OutOfOrderMultiComparerScoringNoMaxScoreCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> over multiple <see cref="T:Lucene.Net.Search.SortField"/> criteria, with
            tracking document scores and maxScore, and assumes out of orderness in doc
            Ids collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector.PagingFieldCollector">
            <summary>
            Implements a <see cref="T:Lucene.Net.Search.TopFieldCollector"/> when after != null.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopFieldCollector.maxScore">
            <summary>
            Stores the maximum score value encountered, needed for normalizing. If
            document scores are not tracked, this value is initialized to NaN.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopFieldCollector.Create(Lucene.Net.Search.Sort,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
             <summary>
             Creates a new <see cref="T:Lucene.Net.Search.TopFieldCollector"/> from the given
             arguments.
            
             <para/><b>NOTE</b>: The instances returned by this method
             pre-allocate a full array of length
             <paramref name="numHits"/>.
             </summary>
             <param name="sort">
                      The sort criteria (<see cref="T:Lucene.Net.Search.SortField"/>s). </param>
             <param name="numHits">
                      The number of results to collect. </param>
             <param name="fillFields">
                      Specifies whether the actual field values should be returned on
                      the results (<see cref="T:Lucene.Net.Search.FieldDoc"/>). </param>
             <param name="trackDocScores">
                      Specifies whether document scores should be tracked and set on the
                      results. Note that if set to <c>false</c>, then the results' scores will
                      be set to <see cref="F:System.Single.NaN"/>. Setting this to <c>true</c> affects performance, as
                      it incurs the score computation on each competitive result.
                      Therefore if document scores are not required by the application,
                      it is recommended to set it to <c>false</c>. </param>
             <param name="trackMaxScore">
                      Specifies whether the query's <see cref="F:Lucene.Net.Search.TopFieldCollector.maxScore"/> should be tracked and set
                      on the resulting <see cref="T:Lucene.Net.Search.TopDocs"/>. Note that if set to <c>false</c>,
                      <see cref="P:Lucene.Net.Search.TopDocs.MaxScore"/> returns <see cref="F:System.Single.NaN"/>. Setting this to
                      <c>true</c> affects performance as it incurs the score computation on
                      each result. Also, setting this <c>true</c> automatically sets
                      <paramref name="trackDocScores"/> to <c>true</c> as well. </param>
             <param name="docsScoredInOrder">
                      Specifies whether documents are scored in doc Id order or not by
                      the given <see cref="T:Lucene.Net.Search.Scorer"/> in <see cref="M:Lucene.Net.Search.ICollector.SetScorer(Lucene.Net.Search.Scorer)"/>. </param>
             <returns> A <see cref="T:Lucene.Net.Search.TopFieldCollector"/> instance which will sort the results by
                     the sort criteria. </returns>
             <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Search.TopFieldCollector.Create(Lucene.Net.Search.Sort,System.Int32,Lucene.Net.Search.FieldDoc,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
             <summary>
             Creates a new <see cref="T:Lucene.Net.Search.TopFieldCollector"/> from the given
             arguments.
            
             <para/><b>NOTE</b>: The instances returned by this method
             pre-allocate a full array of length
             <paramref name="numHits"/>.
             </summary>
             <param name="sort">
                      The sort criteria (<see cref="T:Lucene.Net.Search.SortField"/>s). </param>
             <param name="numHits">
                      The number of results to collect. </param>
             <param name="after">
                      Only hits after this <see cref="T:Lucene.Net.Search.FieldDoc"/> will be collected </param>
             <param name="fillFields">
                      Specifies whether the actual field values should be returned on
                      the results (<see cref="T:Lucene.Net.Search.FieldDoc"/>). </param>
             <param name="trackDocScores">
                      Specifies whether document scores should be tracked and set on the
                      results. Note that if set to <c>false</c>, then the results' scores will
                      be set to <see cref="F:System.Single.NaN"/>. Setting this to <c>true</c> affects performance, as
                      it incurs the score computation on each competitive result.
                      Therefore if document scores are not required by the application,
                      it is recommended to set it to <c>false</c>. </param>
             <param name="trackMaxScore">
                      Specifies whether the query's maxScore should be tracked and set
                      on the resulting <see cref="T:Lucene.Net.Search.TopDocs"/>. Note that if set to <c>false</c>,
                      <see cref="P:Lucene.Net.Search.TopDocs.MaxScore"/> returns <see cref="F:System.Single.NaN"/>. Setting this to
                      <c>true</c> affects performance as it incurs the score computation on
                      each result. Also, setting this <c>true</c> automatically sets
                      <paramref name="trackDocScores"/> to <c>true</c> as well. </param>
             <param name="docsScoredInOrder">
                      Specifies whether documents are scored in doc Id order or not by
                      the given <see cref="T:Lucene.Net.Search.Scorer"/> in <see cref="M:Lucene.Net.Search.ICollector.SetScorer(Lucene.Net.Search.Scorer)"/>. </param>
             <returns> A <see cref="T:Lucene.Net.Search.TopFieldCollector"/> instance which will sort the results by
                     the sort criteria. </returns>
             <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldDocs">
            <summary>
            Represents hits returned by 
            <see cref="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopFieldDocs.Fields">
            <summary>
            The fields which were used to sort results by. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopFieldDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[],Lucene.Net.Search.SortField[],System.Single)">
            <summary>
            Creates one of these objects. </summary>
            <param name="totalHits">  Total number of hits for the query. </param>
            <param name="scoreDocs">  The top hits for the query. </param>
            <param name="fields">     The sort criteria used to find the top hits. </param>
            <param name="maxScore">   The maximum score encountered. </param>
        </member>
        <member name="T:Lucene.Net.Search.TopScoreDocCollector">
             <summary>
             A <see cref="T:Lucene.Net.Search.ICollector"/> implementation that collects the top-scoring hits,
             returning them as a <see cref="T:Lucene.Net.Search.TopDocs"/>. this is used by <see cref="T:Lucene.Net.Search.IndexSearcher"/> to
             implement <see cref="T:Lucene.Net.Search.TopDocs"/>-based search. Hits are sorted by score descending
             and then (when the scores are tied) docID ascending. When you create an
             instance of this collector you should know in advance whether documents are
             going to be collected in doc Id order or not.
            
             <para/><b>NOTE</b>: The values <see cref="F:System.Single.NaN"/> and
             <see cref="F:System.Single.NegativeInfinity"/> are not valid scores.  This
             collector will not properly collect hits with such
             scores.
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopScoreDocCollector.Create(System.Int32,System.Boolean)">
             <summary>
             Creates a new <see cref="T:Lucene.Net.Search.TopScoreDocCollector"/> given the number of hits to
             collect and whether documents are scored in order by the input
             <see cref="T:Lucene.Net.Search.Scorer"/> to <see cref="M:Lucene.Net.Search.TopScoreDocCollector.SetScorer(Lucene.Net.Search.Scorer)"/>.
            
             <para/><b>NOTE</b>: The instances returned by this method
             pre-allocate a full array of length
             <paramref name="numHits"/>, and fill the array with sentinel
             objects.
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopScoreDocCollector.Create(System.Int32,Lucene.Net.Search.ScoreDoc,System.Boolean)">
             <summary>
             Creates a new <see cref="T:Lucene.Net.Search.TopScoreDocCollector"/> given the number of hits to
             collect, the bottom of the previous page, and whether documents are scored in order by the input
             <see cref="T:Lucene.Net.Search.Scorer"/> to <see cref="M:Lucene.Net.Search.TopScoreDocCollector.SetScorer(Lucene.Net.Search.Scorer)"/>.
            
             <para/><b>NOTE</b>: The instances returned by this method
             pre-allocate a full array of length
             <paramref name="numHits"/>, and fill the array with sentinel
             objects.
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopTermsRewrite`1">
            <summary>
            Base rewrite method for collecting only the top terms
            via a priority queue.
            <para/>
            @lucene.internal - Only public to be accessible by spans package.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopTermsRewrite`1.#ctor(System.Int32)">
            <summary>
            Create a <see cref="T:Lucene.Net.Search.TopTermsRewrite`1"/> for
            at most <paramref name="count"/> terms.
            <para/>
            NOTE: if <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/> is smaller than
            <paramref name="count"/>, then it will be used instead.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopTermsRewrite`1.Count">
            <summary>
            Return the maximum priority queue size.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopTermsRewrite`1.MaxSize">
            <summary>
            Return the maximum size of the priority queue (for boolean rewrites this is <see cref="P:Lucene.Net.Search.BooleanQuery.MaxClauseCount"/>). </summary>
        </member>
        <member name="T:Lucene.Net.Search.TotalHitCountCollector">
            <summary>
            Just counts the total number of hits.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TotalHitCountCollector.TotalHits">
            <summary>
            Returns how many hits matched the search. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Weight">
            <summary>
            Expert: Calculate query weights and build query scorers.
            <para/>
            The purpose of <see cref="T:Lucene.Net.Search.Weight"/> is to ensure searching does not modify a
            <see cref="T:Lucene.Net.Search.Query"/>, so that a <see cref="T:Lucene.Net.Search.Query"/> instance can be reused.
            <para/>
            <see cref="T:Lucene.Net.Search.IndexSearcher"/> dependent state of the query should reside in the
            <see cref="T:Lucene.Net.Search.Weight"/>.
            <para/>
            <see cref="T:Lucene.Net.Index.AtomicReader"/> dependent state should reside in the <see cref="T:Lucene.Net.Search.Scorer"/>.
            <para/>
            Since <see cref="T:Lucene.Net.Search.Weight"/> creates <see cref="T:Lucene.Net.Search.Scorer"/> instances for a given
            <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> (<see cref="M:Lucene.Net.Search.Weight.GetScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)"/>)
            callers must maintain the relationship between the searcher's top-level
            <see cref="T:Lucene.Net.Index.IndexReaderContext"/> and the context used to create a <see cref="T:Lucene.Net.Search.Scorer"/>.
            <para/>
            A <see cref="T:Lucene.Net.Search.Weight"/> is used in the following way:
            <list type="number">
                <item><description>A <see cref="T:Lucene.Net.Search.Weight"/> is constructed by a top-level query, given a
                    <see cref="T:Lucene.Net.Search.IndexSearcher"/> (<see cref="M:Lucene.Net.Search.Query.CreateWeight(Lucene.Net.Search.IndexSearcher)"/>).</description></item>
                <item><description>The <see cref="M:Lucene.Net.Search.Weight.GetValueForNormalization"/> method is called on the
                    <see cref="T:Lucene.Net.Search.Weight"/> to compute the query normalization factor
                    <see cref="M:Lucene.Net.Search.Similarities.Similarity.QueryNorm(System.Single)"/> of the query clauses contained in the
                    query.</description></item>
                <item><description>The query normalization factor is passed to <see cref="M:Lucene.Net.Search.Weight.Normalize(System.Single,System.Single)"/>. At
                    this point the weighting is complete.</description></item>
                <item><description>A <see cref="T:Lucene.Net.Search.Scorer"/> is constructed by
                    <see cref="M:Lucene.Net.Search.Weight.GetScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)"/>.</description></item>
            </list>
            <para/>
            @since 2.9
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Explain(Lucene.Net.Index.AtomicReaderContext,System.Int32)">
            <summary>
            An explanation of the score computation for the named document.
            </summary>
            <param name="context"> The readers context to create the <see cref="T:Lucene.Net.Search.Explanation"/> for. </param>
            <param name="doc"> The document's id relative to the given context's reader </param>
            <returns> An <see cref="T:Lucene.Net.Search.Explanation"/> for the score </returns>
            <exception cref="T:System.IO.IOException"> if an <see cref="T:System.IO.IOException"/> occurs </exception>
        </member>
        <member name="P:Lucene.Net.Search.Weight.Query">
            <summary>
            The query that this concerns. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.GetValueForNormalization">
            <summary>
            The value for normalization of contained query clauses (e.g. sum of squared weights). </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Normalize(System.Single,System.Single)">
            <summary>
            Assigns the query normalization factor and boost from parent queries to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.GetScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Search.Scorer"/> which scores documents in/out-of order according
            to <c>scoreDocsInOrder</c>.
            <para/>
            <b>NOTE:</b> even if <c>scoreDocsInOrder</c> is <c>false</c>, it is
            recommended to check whether the returned <see cref="T:Lucene.Net.Search.Scorer"/> indeed scores
            documents out of order (i.e., call <see cref="P:Lucene.Net.Search.Weight.ScoresDocsOutOfOrder"/>), as
            some <see cref="T:Lucene.Net.Search.Scorer"/> implementations will always return documents
            in-order.
            <para/>
            <b>NOTE:</b> <c>null</c> can be returned if no documents will be scored by this
            query.
            </summary>
            <param name="context">
                     The <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> for which to return the <see cref="T:Lucene.Net.Search.Scorer"/>. </param>
            <param name="acceptDocs">
                     <see cref="T:Lucene.Net.Util.IBits"/> that represent the allowable docs to match (typically deleted docs
                     but possibly filtering other documents)
            </param>
            <returns> A <see cref="T:Lucene.Net.Search.Scorer"/> which scores documents in/out-of order. </returns>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Search.Weight.GetBulkScorer(Lucene.Net.Index.AtomicReaderContext,System.Boolean,Lucene.Net.Util.IBits)">
            <summary>
            Optional method, to return a <see cref="T:Lucene.Net.Search.BulkScorer"/> to
            score the query and send hits to a <see cref="T:Lucene.Net.Search.ICollector"/>.
            Only queries that have a different top-level approach
            need to override this; the default implementation
            pulls a normal <see cref="T:Lucene.Net.Search.Scorer"/> and iterates and
            collects the resulting hits.
            </summary>
            <param name="context">
                     The <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> for which to return the <see cref="T:Lucene.Net.Search.Scorer"/>. </param>
            <param name="scoreDocsInOrder">
                     Specifies whether in-order scoring of documents is required. Note
                     that if set to <c>false</c> (i.e., out-of-order scoring is required),
                     this method can return whatever scoring mode it supports, as every
                     in-order scorer is also an out-of-order one. However, an
                     out-of-order scorer may not support <see cref="M:Lucene.Net.Search.DocIdSetIterator.NextDoc"/>
                     and/or <see cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/>, therefore it is recommended to
                     request an in-order scorer if use of these
                     methods is required. </param>
            <param name="acceptDocs">
                     <see cref="T:Lucene.Net.Util.IBits"/> that represent the allowable docs to match (typically deleted docs
                     but possibly filtering other documents)
            </param>
            <returns> A <see cref="T:Lucene.Net.Search.BulkScorer"/> which scores documents and
            passes them to a collector. </returns>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="T:Lucene.Net.Search.Weight.DefaultBulkScorer">
            <summary>
            Just wraps a <see cref="T:Lucene.Net.Search.Scorer"/> and performs top scoring using it. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Weight.ScoresDocsOutOfOrder">
            <summary>
            Returns true if this implementation scores docs only out of order. This
            method is used in conjunction with <see cref="T:Lucene.Net.Search.ICollector"/>'s
            <see cref="P:Lucene.Net.Search.ICollector.AcceptsDocsOutOfOrder"/> and
            <see cref="M:Lucene.Net.Search.Weight.GetBulkScorer(Lucene.Net.Index.AtomicReaderContext,System.Boolean,Lucene.Net.Util.IBits)"/> to
            create a matching <see cref="T:Lucene.Net.Search.Scorer"/> instance for a given <see cref="T:Lucene.Net.Search.ICollector"/>, or
            vice versa.
            <para/>
            <b>NOTE:</b> the default implementation returns <c>false</c>, i.e.
            the <see cref="T:Lucene.Net.Search.Scorer"/> scores documents in-order.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.WildcardQuery">
             <summary>
             Implements the wildcard search query. Supported wildcards are <c>*</c>, which
             matches any character sequence (including the empty one), and <c>?</c>,
             which matches any single character. '\' is the escape character.
             <para/>
             Note this query can be slow, as it
             needs to iterate over many terms. In order to prevent extremely slow WildcardQueries,
             a Wildcard term should not start with the wildcard <c>*</c>
            
             <para/>This query uses the 
             <see cref="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT"/>
             rewrite method.
             </summary>
             <seealso cref="T:Lucene.Net.Search.AutomatonQuery"/>
        </member>
        <member name="F:Lucene.Net.Search.WildcardQuery.WILDCARD_STRING">
            <summary>
            String equality with support for wildcards </summary>
        </member>
        <member name="F:Lucene.Net.Search.WildcardQuery.WILDCARD_CHAR">
            <summary>
            Char equality with support for wildcards </summary>
        </member>
        <member name="F:Lucene.Net.Search.WildcardQuery.WILDCARD_ESCAPE">
            <summary>
            Escape character </summary>
        </member>
        <member name="M:Lucene.Net.Search.WildcardQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Constructs a query for terms matching <paramref name="term"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.WildcardQuery.ToAutomaton(Lucene.Net.Index.Term)">
            <summary>
            Convert Lucene wildcard syntax into an automaton.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.WildcardQuery.Term">
            <summary>
            Returns the pattern term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.WildcardQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ReferenceContext`1">
            <summary>
            <see cref="T:Lucene.Net.Search.ReferenceContext`1"/> holds a reference instance and
            ensures it is properly de-referenced from its corresponding <see cref="T:Lucene.Net.Search.ReferenceManager`1"/>
            when <see cref="M:Lucene.Net.Search.ReferenceContext`1.Dispose"/> is called. This class is primarily intended
            to be used with a using block.
            <para/>
            LUCENENET specific
            </summary>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="P:Lucene.Net.Search.ReferenceContext`1.Reference">
            <summary>
            The reference acquired from the <see cref="T:Lucene.Net.Search.ReferenceManager`1"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceContext`1.Dispose">
            <summary>
            Ensures the reference is properly de-referenced from its <see cref="T:Lucene.Net.Search.ReferenceManager`1"/>.
            After this call, <see cref="P:Lucene.Net.Search.ReferenceContext`1.Reference"/> will be <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManagerExtensions.GetContext``1(Lucene.Net.Search.ReferenceManager{``0})">
            <summary>
            Obtain the current reference.
            <para/>
            Like <see cref="M:Lucene.Net.Search.ReferenceManager`1.Acquire"/>, but intended for use in a using
            block so calling <see cref="M:Lucene.Net.Search.ReferenceManager`1.Release(`0)"/> happens implicitly.
            For example:
            <para/>
            <code>
            var searcherManager = new SearcherManager(indexWriter, true, null);
            using (var context = searcherManager.GetContext())
            {
                IndexSearcher searcher = context.Reference;
                
                // use searcher...
            }
            </code>
            </summary>
            <typeparam name="T">The reference type</typeparam>
            <param name="referenceManager">this <see cref="T:Lucene.Net.Search.ReferenceManager`1"/></param>
            <returns>A <see cref="T:Lucene.Net.Search.ReferenceContext`1"/> instance that holds the 
            <see cref="P:Lucene.Net.Search.ReferenceContext`1.Reference"/> and ensures it is released properly 
            when <see cref="M:Lucene.Net.Search.ReferenceContext`1.Dispose"/> is called.</returns>
        </member>
        <member name="T:Lucene.Net.Store.BaseDirectory">
            <summary>
            Base implementation for a concrete <see cref="T:Lucene.Net.Store.Directory"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.BaseDirectory.m_lockFactory">
            <summary>
            Holds the LockFactory instance (implements locking for
            this <see cref="T:Lucene.Net.Store.Directory"/> instance).
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BaseDirectory.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedChecksum">
            <summary>
            Wraps another <see cref="T:Lucene.Net.Support.IChecksum"/> with an internal buffer
            to speed up checksum calculations.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedChecksum.DEFAULT_BUFFERSIZE">
            <summary>
            Default buffer size: 256 </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedChecksum.#ctor(Lucene.Net.Support.IChecksum)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.BufferedChecksum"/> with <see cref="F:Lucene.Net.Store.BufferedChecksum.DEFAULT_BUFFERSIZE"/> </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedChecksum.#ctor(Lucene.Net.Support.IChecksum,System.Int32)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.BufferedChecksum"/> with the specified <paramref name="bufferSize"/> </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedChecksumIndexInput">
            <summary>
            Simple implementation of <see cref="T:Lucene.Net.Store.ChecksumIndexInput"/> that wraps
            another input and delegates calls.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedChecksumIndexInput.#ctor(Lucene.Net.Store.IndexInput)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Store.BufferedChecksumIndexInput"/> </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedIndexInput">
            <summary>
            Base implementation class for buffered <see cref="T:Lucene.Net.Store.IndexInput"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedIndexInput.BUFFER_SIZE">
            <summary>
            Default buffer size set to <see cref="F:Lucene.Net.Store.BufferedIndexInput.BUFFER_SIZE"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedIndexInput.MERGE_BUFFER_SIZE">
            <summary>
            A buffer size for merges set to <see cref="F:Lucene.Net.Store.BufferedIndexInput.MERGE_BUFFER_SIZE"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.#ctor(System.String,System.Int32)">
            <summary>
            Inits <see cref="T:Lucene.Net.Store.BufferedIndexInput"/> with a specific <paramref name="bufferSize"/> </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.SetBufferSize(System.Int32)">
            <summary>
            Change the buffer size used by this <see cref="T:Lucene.Net.Store.IndexInput"/> </summary>
        </member>
        <member name="P:Lucene.Net.Store.BufferedIndexInput.BufferSize">
            <summary>
            Returns buffer size.
            </summary>
            <seealso cref="M:Lucene.Net.Store.BufferedIndexInput.SetBufferSize(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadInt16">
            <summary>
            NOTE: this was readShort() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadInt32">
            <summary>
            NOTE: this was readInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadInt64">
            <summary>
            NOTE: this was readLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadVInt32">
            <summary>
            NOTE: this was readVInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadVInt64">
            <summary>
            NOTE: this was readVLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Expert: implements buffer refill.  Reads bytes from the current position
            in the input. </summary>
            <param name="b"> the array to read bytes into </param>
            <param name="offset"> the offset in the array to start storing bytes </param>
            <param name="length"> the number of bytes to read </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.SeekInternal(System.Int64)">
            <summary>
            Expert: implements seek.  Sets current position in this file, where the
            next <see cref="M:Lucene.Net.Store.BufferedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)"/> will occur. </summary>
            <seealso cref="M:Lucene.Net.Store.BufferedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.FlushBuffer(Lucene.Net.Store.IndexOutput,System.Int64)">
            <summary>
            Flushes the in-memory buffer to the given output, copying at most
            <paramref name="numBytes"/>.
            <para/>
            <b>NOTE:</b> this method does not refill the buffer, however it does
            advance the buffer position.
            </summary>
            <returns> the number of bytes actually flushed from the in-memory buffer. </returns>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.GetBufferSize(Lucene.Net.Store.IOContext)">
            <summary>
            Returns default buffer sizes for the given <see cref="T:Lucene.Net.Store.IOContext"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedIndexOutput">
            <summary>
            Base implementation class for buffered <see cref="T:Lucene.Net.Store.IndexOutput"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedIndexOutput.DEFAULT_BUFFER_SIZE">
            <summary>
            The default buffer size in bytes (<see cref="F:Lucene.Net.Store.BufferedIndexOutput.DEFAULT_BUFFER_SIZE"/>). </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.#ctor">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Store.BufferedIndexOutput"/> with the default buffer size
            (<see cref="F:Lucene.Net.Store.BufferedIndexOutput.DEFAULT_BUFFER_SIZE"/> bytes see <see cref="F:Lucene.Net.Store.BufferedIndexOutput.DEFAULT_BUFFER_SIZE"/>)
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Store.BufferedIndexOutput"/> with the given buffer size. </summary>
            <param name="bufferSize"> the buffer size in bytes used to buffer writes internally. </param>
            <exception cref="T:System.ArgumentException"> if the given buffer size is less or equal to <c>0</c> </exception>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.FlushBuffer(System.Byte[],System.Int32)">
            <summary>
            Expert: implements buffer write.  Writes bytes at the current position in
            the output. </summary>
            <param name="b"> the bytes to write </param>
            <param name="len"> the number of bytes to write </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.FlushBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Expert: implements buffer write.  Writes bytes at the current position in
            the output. </summary>
            <param name="b"> the bytes to write </param>
            <param name="offset"> the offset in the byte array </param>
            <param name="len"> the number of bytes to write </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="P:Lucene.Net.Store.BufferedIndexOutput.BufferSize">
            <summary>
            Returns size of the used output buffer in bytes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.ByteArrayDataInput">
            <summary>
            DataInput backed by a byte array.
            <b>WARNING:</b> this class omits all low-level checks.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteArrayDataInput.Rewind">
            <summary>
            NOTE: sets pos to 0, which is not right if you had
            called reset w/ non-zero offset!!
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteArrayDataInput.ReadInt16">
            <summary>
            LUCENENET NOTE: Important - always cast to ushort (System.UInt16) before using to ensure
            the value is positive!
            <para/>
            NOTE: this was readShort() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteArrayDataInput.ReadInt32">
            <summary>
            NOTE: this was readInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteArrayDataInput.ReadInt64">
            <summary>
            NOTE: this was readLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteArrayDataInput.ReadVInt32">
            <summary>
            NOTE: this was readVInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteArrayDataInput.ReadVInt64">
            <summary>
            NOTE: this was readVLong() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.ByteArrayDataOutput">
            <summary>
            DataOutput backed by a byte array.
            <b>WARNING:</b> this class omits most low-level checks,
            so be sure to test heavily with assertions enabled.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.ByteBufferIndexInput">
            <summary>
            Base <see cref="T:Lucene.Net.Store.IndexInput"/> implementation that uses an array
            of <see cref="T:J2N.IO.ByteBuffer"/>s to represent a file.
            <para/>
            Because Java's <see cref="T:J2N.IO.ByteBuffer"/> uses an <see cref="T:System.Int32"/> to address the
            values, it's necessary to access a file greater
            <see cref="F:System.Int32.MaxValue"/> in size using multiple byte buffers.
            <para/>
            For efficiency, this class requires that the buffers
            are a power-of-two (<c>chunkSizePower</c>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.ReadInt16">
            <summary>
            NOTE: this was readShort() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.ReadInt32">
            <summary>
            NOTE: this was readInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.ReadInt64">
            <summary>
            NOTE: this was readLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.Slice(System.String,System.Int64,System.Int64)">
            <summary>
            Creates a slice of this index input, with the given description, offset, and length. The slice is seeked to the beginning.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.BuildSlice(J2N.IO.ByteBuffer[],System.Int64,System.Int64)">
            <summary>
            Returns a sliced view from a set of already-existing buffers:
            the last buffer's <see cref="P:J2N.IO.Buffer.Limit"/> will be correct, but
            you must deal with <paramref name="offset"/> separately (the first buffer will not be adjusted)
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.FreeBuffer(J2N.IO.ByteBuffer)">
            <summary>
            Called when the contents of a buffer will be no longer needed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.ChecksumIndexInput">
            <summary>
            Extension of <see cref="T:Lucene.Net.Store.IndexInput"/>, computing checksum as it goes.
            Callers can retrieve the checksum via <see cref="P:Lucene.Net.Store.ChecksumIndexInput.Checksum"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ChecksumIndexInput.#ctor(System.String)">
            <summary>
            <paramref name="resourceDescription"/> should be a non-null, opaque string
            describing this resource; it's returned from
            <see cref="M:System.Object.ToString"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.ChecksumIndexInput.Checksum">
            <summary>
            Returns the current checksum value </summary>
        </member>
        <member name="M:Lucene.Net.Store.ChecksumIndexInput.Seek(System.Int64)">
            <summary>
            Sets current position in this file, where the next read will occur. 
            <para/>
            <see cref="T:Lucene.Net.Store.ChecksumIndexInput"/> can only seek forward and seeks are expensive
            since they imply to read bytes in-between the current position and the
            target position in order to update the checksum.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.CompoundFileDirectory">
            <summary>
            Class for accessing a compound stream.
            This class implements a directory, but is limited to only read operations.
            Directory methods that would normally modify data throw an exception.
            <para/>
            All files belonging to a segment have the same name with varying extensions.
            The extensions correspond to the different file formats used by the <see cref="T:Lucene.Net.Codecs.Codec"/>.
            When using the Compound File format these files are collapsed into a
            single <c>.cfs</c> file (except for the <see cref="T:Lucene.Net.Codecs.LiveDocsFormat"/>, with a
            corresponding <c>.cfe</c> file indexing its sub-files.
            <para/>
            Files:
            <list type="bullet">
                <item><description><c>.cfs</c>: An optional "virtual" file consisting of all the other
                    index files for systems that frequently run out of file handles.</description></item>
                <item><description><c>.cfe</c>: The "virtual" compound file's entry table holding all
                    entries in the corresponding .cfs file.</description></item>
            </list>
            <para>Description:</para>
            <list type="bullet">
                <item><description>Compound (.cfs) --&gt; Header, FileData <sup>FileCount</sup></description></item>
                <item><description>Compound Entry Table (.cfe) --&gt; Header, FileCount, &lt;FileName,
                    DataOffset, DataLength&gt; <sup>FileCount</sup>, Footer</description></item>
                <item><description>Header --&gt; <see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/></description></item>
                <item><description>FileCount --&gt; <see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/></description></item>
                <item><description>DataOffset,DataLength --&gt; <see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/></description></item>
                <item><description>FileName --&gt; <see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/></description></item>
                <item><description>FileData --&gt; raw file data</description></item>
                <item><description>Footer --&gt; <see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/></description></item>
            </list>
            <para>Notes:</para>
            <list type="bullet">
              <item><description>FileCount indicates how many files are contained in this compound file.
                    The entry table that follows has that many entries.</description></item>
              <item><description>Each directory entry contains a long pointer to the start of this file's data
                    section, the files length, and a <see cref="T:System.String"/> with that file's name.</description></item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.CompoundFileDirectory.FileEntry">
            <summary>
            Offset/Length for a slice inside of a compound file </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext,System.Boolean)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.CompoundFileDirectory"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.ReadEntries(Lucene.Net.Store.Directory.IndexInputSlicer,Lucene.Net.Store.Directory,System.String)">
            <summary>
            Helper method that reads CFS entries from an input stream </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.ListAll">
            <summary>
            Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.FileExists(System.String)">
            <summary>
            Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.DeleteFile(System.String)">
            <summary>
            Not implemented </summary>
            <exception cref="T:System.NotSupportedException"> always: not supported by CFS  </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.RenameFile(System.String,System.String)">
            <summary>
            Not implemented </summary>
            <exception cref="T:System.NotSupportedException"> always: not supported by CFS  </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.FileLength(System.String)">
            <summary>
            Returns the length of a file in the directory. </summary>
            <exception cref="T:System.IO.IOException"> if the file does not exist  </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.MakeLock(System.String)">
            <summary>
            Not implemented </summary>
            <exception cref="T:System.NotSupportedException"> always: not supported by CFS  </exception>
        </member>
        <member name="T:Lucene.Net.Store.CompoundFileWriter">
            <summary>
            Combines multiple files into a single compound file.
            <para/>
            @lucene.internal 
            </summary>
            <seealso cref="T:Lucene.Net.Store.CompoundFileDirectory"/>
        </member>
        <member name="P:Lucene.Net.Store.CompoundFileWriter.FileEntry.File">
            <summary>
            source file </summary>
        </member>
        <member name="P:Lucene.Net.Store.CompoundFileWriter.FileEntry.Offset">
            <summary>
            temporary holder for the start of this file's data section </summary>
        </member>
        <member name="P:Lucene.Net.Store.CompoundFileWriter.FileEntry.Dir">
            <summary>
            the directory which contains the file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileWriter.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>
            Create the compound stream in the specified file. The file name is the
            entire name (no extensions are added).
            </summary>
            <exception cref="T:System.ArgumentNullException">
                      if <paramref name="dir"/> or <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="P:Lucene.Net.Store.CompoundFileWriter.Directory">
            <summary>
            Returns the directory of the compound file. </summary>
        </member>
        <member name="P:Lucene.Net.Store.CompoundFileWriter.Name">
            <summary>
            Returns the name of the compound file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileWriter.Dispose">
            <summary>
            Disposes all resources and writes the entry table
            </summary>
            <exception cref="T:System.InvalidOperationException">
                      if <see cref="M:Lucene.Net.Store.CompoundFileWriter.Dispose"/> had been called before or if no file has been added to
                      this object </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileWriter.CopyFileEntry(Lucene.Net.Store.IndexOutput,Lucene.Net.Store.CompoundFileWriter.FileEntry)">
            <summary>
            Copy the contents of the file with specified extension into the provided
            output stream.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.DataInput">
             <summary>
             Abstract base class for performing read operations of Lucene's low-level
             data types.
            
             <para/><see cref="T:Lucene.Net.Store.DataInput"/> may only be used from one thread, because it is not
             thread safe (it keeps internal state like file position). To allow
             multithreaded use, every <see cref="T:Lucene.Net.Store.DataInput"/> instance must be cloned before
             used in another thread. Subclasses must therefore implement <see cref="M:Lucene.Net.Store.DataInput.Clone"/>,
             returning a new <see cref="T:Lucene.Net.Store.DataInput"/> which operates on the same underlying
             resource, but positioned independently.
             </summary>
        </member>
        <member name="F:Lucene.Net.Store.DataInput.skipBuffer">
            <summary>
            This buffer is used to skip over bytes with the default implementation of
            skipBytes. The reason why we need to use an instance member instead of
            sharing a single instance across threads is that some delegating
            implementations of DataInput might want to reuse the provided buffer in
            order to eg.update the checksum. If we shared the same buffer across
            threads, then another thread might update the buffer while the checksum is
            being computed, making it invalid. See LUCENE-5583 for more information.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadByte">
            <summary>
            Reads and returns a single byte. </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a specified number of bytes into an array at the specified offset. </summary>
            <param name="b"> the array to read bytes into </param>
            <param name="offset"> the offset in the array to start storing bytes </param>
            <param name="len"> the number of bytes to read </param>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteBytes(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadBytes(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Reads a specified number of bytes into an array at the
            specified offset with control over whether the read
            should be buffered (callers who have their own buffer
            should pass in "false" for <paramref name="useBuffer"/>).  Currently only
            <see cref="T:Lucene.Net.Store.BufferedIndexInput"/> respects this parameter. </summary>
            <param name="b"> the array to read bytes into </param>
            <param name="offset"> the offset in the array to start storing bytes </param>
            <param name="len"> the number of bytes to read </param>
            <param name="useBuffer"> set to false if the caller will handle
            buffering. </param>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteBytes(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadInt16">
            <summary>
            Reads two bytes and returns a <see cref="T:System.Int16"/>. 
            <para/>
            LUCENENET NOTE: Important - always cast to ushort (System.UInt16) before using to ensure
            the value is positive!
            <para/>
            NOTE: this was readShort() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteInt16(System.Int16)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadInt32">
            <summary>
            Reads four bytes and returns an <see cref="T:System.Int32"/>. 
            <para/>
            NOTE: this was readInt() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadVInt32">
            <summary>
            Reads an <see cref="T:System.Int32"/> stored in variable-length format.  Reads between one and
            five bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            <para/>
            The format is described further in <see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>.
            <para/>
            NOTE: this was readVInt() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadInt64">
            <summary>
            Reads eight bytes and returns a <see cref="T:System.Int64"/>. 
            <para/>
            NOTE: this was readLong() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadVInt64">
            <summary>
            Reads a <see cref="T:System.Int64"/> stored in variable-length format.  Reads between one and
            nine bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            <para/>
            The format is described further in <seealso cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>.
            <para/>
            NOTE: this was readVLong() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadString">
            <summary>
            Reads a <see cref="T:System.String"/>. </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.Clone">
             <summary>
             Returns a clone of this stream.
            
             <para/>Clones of a stream access the same data, and are positioned at the same
             point as the stream they were cloned from.
            
             <para/>Expert: Subclasses must ensure that clones may be positioned at
             different points in the input from each other and from the stream they
             were cloned from.
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadStringStringMap">
            <summary>
            Reads a IDictionary&lt;string,string&gt; previously written
             with <see cref="M:Lucene.Net.Store.DataOutput.WriteStringStringMap(System.Collections.Generic.IDictionary{System.String,System.String})"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadStringSet">
            <summary>
            Reads a ISet&lt;string&gt; previously written
            with <see cref="M:Lucene.Net.Store.DataOutput.WriteStringSet(System.Collections.Generic.ISet{System.String})"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.SkipBytes(System.Int64)">
            <summary>
            Skip over <paramref name="numBytes"/> bytes. The contract on this method is that it
            should have the same behavior as reading the same number of bytes into a
            buffer and discarding its content. Negative values of <paramref name="numBytes"/>
            are not supported.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.DataOutput">
             <summary>
             Abstract base class for performing write operations of Lucene's low-level
             data types.
            
             <para/><see cref="T:Lucene.Net.Store.DataOutput"/> may only be used from one thread, because it is not
             thread safe (it keeps internal state like file position).
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)">
            <summary>
            Writes a single byte.
            <para/>
            The most primitive data type is an eight-bit byte. Files are
            accessed as sequences of bytes. All other data types are defined
            as sequences of bytes, so file formats are byte-order independent.
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadByte"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteBytes(System.Byte[],System.Int32)">
            <summary>
            Writes an array of bytes.
            </summary>
            <param name="b">the bytes to write</param>
            <param name="length">the number of bytes to write</param>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadBytes(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes an array of bytes. </summary>
            <param name="b"> the bytes to write </param>
            <param name="offset"> the offset in the byte array </param>
            <param name="length"> the number of bytes to write </param>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadBytes(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> as four bytes.
            <para/>
            32-bit unsigned integer written as four bytes, high-order bytes first.
            <para/>
            NOTE: this was writeInt() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadInt32"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteInt16(System.Int16)">
            <summary>
            Writes a short as two bytes. 
            <para/>
            NOTE: this was writeShort() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadInt16"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> in a variable-length format.  Writes between one and
            five bytes.  Smaller values take fewer bytes.  Negative numbers are
            supported, but should be avoided.
            <para>VByte is a variable-length format for positive integers is defined where the
            high-order bit of each byte indicates whether more bytes remain to be read. The
            low-order seven bits are appended as increasingly more significant bits in the
            resulting integer value. Thus values from zero to 127 may be stored in a single
            byte, values from 128 to 16,383 may be stored in two bytes, and so on.</para>
            <para>VByte Encoding Example</para>
            <list type="table">
                <listheader>
                    <term>Value</term>
                    <term>Byte 1</term>
                    <term>Byte 2</term>
                    <term>Byte 3</term>
                </listheader>
                <item>
                    <term>0</term>
                    <term>00000000</term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term>1</term>
                    <term>00000001</term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term>2</term>
                    <term>00000010</term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term>...</term>
                    <term></term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term>127</term>
                    <term>01111111</term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term>128</term>
                    <term>10000000</term>
                    <term>00000001</term>
                    <term></term>
                </item>
                <item>
                    <term>129</term>
                    <term>10000001</term>
                    <term>00000001</term>
                    <term></term>
                </item>
                <item>
                    <term>130</term>
                    <term>10000010</term>
                    <term>00000001</term>
                    <term></term>
                </item>
                <item>
                    <term>...</term>
                    <term></term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term>16,383</term>
                    <term>11111111</term>
                    <term>01111111</term>
                    <term></term>
                </item>
                <item>
                    <term>16,384</term>
                    <term>10000000</term>
                    <term>10000000</term>
                    <term>00000001</term>
                </item>
                <item>
                    <term>16,385</term>
                    <term>10000001</term>
                    <term>10000000</term>
                    <term>00000001</term>
                </item>
                <item>
                    <term>...</term>
                    <term></term>
                    <term></term>
                    <term></term>
                </item>
            </list>
            
            <para>this provides compression while still being efficient to decode.</para>
            <para/>
            NOTE: this was writeVInt() in Lucene
            </summary>
            <param name="i"> Smaller values take fewer bytes.  Negative numbers are
            supported, but should be avoided. </param>
            <exception cref="T:System.IO.IOException"> If there is an I/O error writing to the underlying medium. </exception>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadVInt32"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> as eight bytes.
            <para/>
            64-bit unsigned integer written as eight bytes, high-order bytes first.
            <para/>
            NOTE: this was writeLong() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadInt64"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)">
            <summary>
            Writes an <see cref="T:System.Int64"/> in a variable-length format.  Writes between one and nine
            bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            <para/>
            The format is described further in <see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>. 
            <para/>
            NOTE: this was writeVLong() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadVInt64"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteString(System.String)">
            <summary>
            Writes a string.
            <para/>
            Writes strings as UTF-8 encoded bytes. First the length, in bytes, is
            written as a <see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>, followed by the bytes.
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadString"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.CopyBytes(Lucene.Net.Store.DataInput,System.Int64)">
            <summary>
            Copy numBytes bytes from input to ourself. </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteStringStringMap(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Writes a <see cref="T:IDictionary{string, string}"/>.
            <para/>
            First the size is written as an <see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>,
            followed by each key-value pair written as two consecutive
            <see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>s.
            </summary>
            <param name="map"> Input <see cref="T:IDictionary{string, string}"/>. May be <c>null</c> (equivalent to an empty dictionary) </param>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteStringSet(System.Collections.Generic.ISet{System.String})">
            <summary>
            Writes a <see cref="T:System.String"/> set.
            <para/>
            First the size is written as an <see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>,
            followed by each value written as a
            <see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>.
            </summary>
            <param name="set"> Input <see cref="T:ISet{string}"/>. May be <c>null</c> (equivalent to an empty set) </param>
        </member>
        <member name="T:Lucene.Net.Store.Directory">
            <summary>
            A <see cref="T:Lucene.Net.Store.Directory"/> is a flat list of files.  Files may be written once, when they
            are created.  Once a file is created it may only be opened for read, or
            deleted.  Random access is permitted both when reading and writing.
            <para/>
            .NET's i/o APIs not used directly, but rather all i/o is
            through this API.  This permits things such as: 
            <list type="bullet">
                <item><description> implementation of RAM-based indices;</description></item>
                <item><description> implementation indices stored in a database;</description></item>
                <item><description> implementation of an index as a single file;</description></item>
            </list>
            <para/>
            Directory locking is implemented by an instance of
            <see cref="T:Lucene.Net.Store.LockFactory"/>, and can be changed for each <see cref="T:Lucene.Net.Store.Directory"/>
            instance using <see cref="M:Lucene.Net.Store.Directory.SetLockFactory(Lucene.Net.Store.LockFactory)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.ListAll">
            <summary>
            Returns an array of strings, one for each file in the directory.
            </summary>
            <exception cref="T:System.IO.DirectoryNotFoundException"> if the directory is not prepared for any
                    write operations (such as <see cref="M:Lucene.Net.Store.Directory.CreateOutput(System.String,Lucene.Net.Store.IOContext)"/>). </exception>
            <exception cref="T:System.IO.IOException"> in case of other IO errors </exception>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileExists(System.String)">
            <summary>
            Returns <c>true</c> iff a file with the given name exists.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.DeleteFile(System.String)">
            <summary>
            Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileLength(System.String)">
            <summary>
            Returns the length of a file in the directory. this method follows the
            following contract:
            <list>
                <item><description>Throws <see cref="T:System.IO.FileNotFoundException"/>
                    if the file does not exist.</description></item>
                <item><description>Returns a value &gt;=0 if the file exists, which specifies its length.</description></item>
            </list>
            </summary>
            <param name="name"> the name of the file for which to return the length. </param>
            <exception cref="T:System.IO.IOException"> if there was an IO error while retrieving the file's
                    length. </exception>
        </member>
        <member name="M:Lucene.Net.Store.Directory.CreateOutput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Sync(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Ensure that any writes to these files are moved to
            stable storage.  Lucene uses this to properly commit
            changes to the index, to prevent a machine/OS crash
            from corrupting the index.<br/>
            <br/>
            NOTE: Clients may call this method for same files over
            and over again, so some impls might optimize for that.
            For other impls the operation can be a noop, for various
            reasons.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a stream reading an existing file, with the
            specified read buffer size.  The particular <see cref="T:Lucene.Net.Store.Directory"/>
            implementation may ignore the buffer size.  Currently
            the only <see cref="T:Lucene.Net.Store.Directory"/> implementations that respect this
            parameter are <see cref="T:Lucene.Net.Store.FSDirectory"/> and 
            <see cref="T:Lucene.Net.Store.CompoundFileDirectory"/>.
            <para/>Throws <see cref="T:System.IO.FileNotFoundException"/>
            if the file does not exist.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.OpenChecksumInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a stream reading an existing file, computing checksum as it reads </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.MakeLock(System.String)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Store.Lock"/>. </summary>
            <param name="name"> the name of the lock file </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.ClearLock(System.String)">
            <summary>
            Attempt to clear (forcefully unlock and remove) the
            specified lock.  Only call this at a time when you are
            certain this lock is no longer in use. </summary>
            <param name="name"> name of the lock to be cleared. </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Dispose">
            <summary>
            Disposes the store. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Dispose(System.Boolean)">
            <summary>
            Disposes the store. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.SetLockFactory(Lucene.Net.Store.LockFactory)">
            <summary>
            Set the <see cref="T:Lucene.Net.Store.LockFactory"/> that this <see cref="T:Lucene.Net.Store.Directory"/> instance should
            use for its locking implementation.  Each * instance of
            <see cref="T:Lucene.Net.Store.LockFactory"/> should only be used for one directory (ie,
            do not share a single instance across multiple
            Directories).
            </summary>
            <param name="lockFactory"> instance of <see cref="T:Lucene.Net.Store.LockFactory"/>. </param>
        </member>
        <member name="P:Lucene.Net.Store.Directory.LockFactory">
            <summary>
            Get the <see cref="T:Lucene.Net.Store.LockFactory"/> that this <see cref="T:Lucene.Net.Store.Directory"/> instance is
            using for its locking implementation.  Note that this
            may be null for <see cref="T:Lucene.Net.Store.Directory"/> implementations that provide
            their own locking implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.GetLockID">
            <summary>
            Return a string identifier that uniquely differentiates
            this <see cref="T:Lucene.Net.Store.Directory"/> instance from other <see cref="T:Lucene.Net.Store.Directory"/> instances.
            This ID should be the same if two <see cref="T:Lucene.Net.Store.Directory"/> instances
            (even in different AppDomains and/or on different machines)
            are considered "the same index".  This is how locking
            "scopes" to the right index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Copy(Lucene.Net.Store.Directory,System.String,System.String,Lucene.Net.Store.IOContext)">
             <summary>
             Copies the file <paramref name="src"/> to <seealso cref="T:Lucene.Net.Store.Directory"/> <paramref name="to"/> under the new
             file name <paramref name="dest"/>.
             <para/>
             If you want to copy the entire source directory to the destination one, you
             can do so like this:
            
             <code>
             Directory to; // the directory to copy to
             foreach (string file in dir.ListAll()) {
                 dir.Copy(to, file, newFile, IOContext.DEFAULT); // newFile can be either file, or a new name
             }
             </code>
             <para/>
             <b>NOTE:</b> this method does not check whether <paramref name="dest"/> exist and will
             overwrite it if it does.
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.CreateSlicer(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Store.Directory.IndexInputSlicer"/> for the given file name.
            <see cref="T:Lucene.Net.Store.Directory.IndexInputSlicer"/> allows other <see cref="T:Lucene.Net.Store.Directory"/> implementations to
            efficiently open one or more sliced <see cref="T:Lucene.Net.Store.IndexInput"/> instances from a
            single file handle. The underlying file handle is kept open until the
            <see cref="T:Lucene.Net.Store.Directory.IndexInputSlicer"/> is closed.
            <para/>Throws <see cref="T:System.IO.FileNotFoundException"/>
            if the file does not exist.
            <para/>
            @lucene.internal
            @lucene.experimental
            </summary>
            <exception cref="T:System.IO.IOException">
                      if an <seealso cref="T:System.IO.IOException"/> occurs</exception>
        </member>
        <member name="M:Lucene.Net.Store.Directory.EnsureOpen">
            <exception cref="T:System.ObjectDisposedException"> if this Directory is closed </exception>
        </member>
        <member name="T:Lucene.Net.Store.Directory.IndexInputSlicer">
            <summary>
            Allows to create one or more sliced <see cref="T:Lucene.Net.Store.IndexInput"/> instances from a single
            file handle. Some <see cref="T:Lucene.Net.Store.Directory"/> implementations may be able to efficiently map slices of a file
            into memory when only certain parts of a file are required.
            <para/>
            @lucene.internal
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.IndexInputSlicer.OpenSlice(System.String,System.Int64,System.Int64)">
            <summary>
            Returns an <see cref="T:Lucene.Net.Store.IndexInput"/> slice starting at the given offset with the given length.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.IndexInputSlicer.OpenFullSlice">
            <summary>
            Returns an <see cref="T:Lucene.Net.Store.IndexInput"/> slice starting at offset <c>0</c> with a
            length equal to the length of the underlying file </summary>
        </member>
        <member name="T:Lucene.Net.Store.Directory.SlicedIndexInput">
            <summary>
            Implementation of an <see cref="T:Lucene.Net.Store.IndexInput"/> that reads from a portion of
            a file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.SlicedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Expert: implements buffer refill.  Reads bytes from the current
            position in the input. </summary>
            <param name="b"> the array to read bytes into </param>
            <param name="offset"> the offset in the array to start storing bytes </param>
            <param name="len"> the number of bytes to read </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.SlicedIndexInput.SeekInternal(System.Int64)">
            <summary>
            Expert: implements seek.  Sets current position in this file, where
            the next <see cref="M:Lucene.Net.Store.Directory.SlicedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)"/> will occur. 
            </summary>
            <seealso cref="M:Lucene.Net.Store.Directory.SlicedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.Directory.SlicedIndexInput.Dispose(System.Boolean)">
            <summary>
            Closes the stream to further operations.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.FileSwitchDirectory">
             <summary>
             Expert: A <see cref="T:Lucene.Net.Store.Directory"/> instance that switches files between
             two other <see cref="T:Lucene.Net.Store.Directory"/> instances.
            
             <para/>Files with the specified extensions are placed in the
             primary directory; others are placed in the secondary
             directory.  The provided <see cref="T:ISet{string}"/> must not change once passed
             to this class, and must allow multiple threads to call
             contains at once.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="P:Lucene.Net.Store.FileSwitchDirectory.PrimaryDir">
            <summary>
            Return the primary directory </summary>
        </member>
        <member name="P:Lucene.Net.Store.FileSwitchDirectory.SecondaryDir">
            <summary>
            Return the secondary directory </summary>
        </member>
        <member name="M:Lucene.Net.Store.FileSwitchDirectory.GetExtension(System.String)">
            <summary>
            Utility method to return a file's extension. </summary>
        </member>
        <member name="T:Lucene.Net.Store.FilterDirectory">
            <summary>
            Directory implementation that delegates calls to another directory.
            This class can be used to add limitations on top of an existing
            <see cref="T:Lucene.Net.Store.Directory"/> implementation such as
            rate limiting (<see cref="T:Lucene.Net.Store.RateLimitedDirectoryWrapper"/>) or to add additional
            sanity checks for tests. However, if you plan to write your own
            <see cref="T:Lucene.Net.Store.Directory"/> implementation, you should consider extending directly
            <see cref="T:Lucene.Net.Store.Directory"/> or <see cref="T:Lucene.Net.Store.BaseDirectory"/> rather than try to reuse
            functionality of existing <see cref="T:Lucene.Net.Store.Directory"/>s by extending this class.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FilterDirectory.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Sole constructor, typically called from sub-classes. </summary>
        </member>
        <member name="P:Lucene.Net.Store.FilterDirectory.Delegate">
            <summary>
            Return the wrapped <see cref="T:Lucene.Net.Store.Directory"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Store.FlushInfo">
            <summary>
            <para>A FlushInfo provides information required for a FLUSH context.
            It is used as part of an <see cref="T:Lucene.Net.Store.IOContext"/> in case of FLUSH context.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FlushInfo.#ctor(System.Int32,System.Int64)">
            <summary>
            <para/>Creates a new <see cref="T:Lucene.Net.Store.FlushInfo"/> instance from
            the values required for a FLUSH <see cref="T:Lucene.Net.Store.IOContext"/> context.
            <para/>
            These values are only estimates and are not the actual values.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.FSDirectory">
             <summary>
             Base class for <see cref="P:Lucene.Net.Store.FSDirectory.Directory"/> implementations that store index
             files in the file system.
             <para/>
             There are currently three core
             subclasses:
            
             <list type="bullet">
            
                 <item><description> <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> is a straightforward
                     implementation using <see cref="T:System.IO.FileStream"/>.
                     However, it has poor concurrent performance
                     (multiple threads will bottleneck) as it
                     synchronizes when multiple threads read from the
                     same file.</description></item>
            
                 <item><description> <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> uses java.nio's
                     FileChannel's positional io when reading to avoid
                     synchronization when reading from the same file.
                     Unfortunately, due to a Windows-only <a
                     href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265734">Sun
                     JRE bug</a> this is a poor choice for Windows, but
                     on all other platforms this is the preferred
                     choice. Applications using <see cref="M:System.Threading.Thread.Interrupt"/> or
                     <see cref="T:System.Threading.Tasks.Task`1"/> should use
                     <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> instead. See <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> java doc
                     for details.</description></item>
            
                 <item><description> <see cref="T:Lucene.Net.Store.MMapDirectory"/> uses memory-mapped IO when
                     reading. This is a good choice if you have plenty
                     of virtual memory relative to your index size, eg
                     if you are running on a 64 bit runtime, or you are
                     running on a 32 bit runtime but your index sizes are
                     small enough to fit into the virtual memory space.
                     <para/>
                     Applications using <see cref="M:System.Threading.Thread.Interrupt"/> or
                     <see cref="T:System.Threading.Tasks.Task"/> should use
                     <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> instead. See <see cref="T:Lucene.Net.Store.MMapDirectory"/>
                     doc for details.</description></item>
             </list>
            
             Unfortunately, because of system peculiarities, there is
             no single overall best implementation.  Therefore, we've
             added the <see cref="M:Lucene.Net.Store.FSDirectory.Open(System.String)"/> method  (or one of its overloads), to allow Lucene to choose
             the best <see cref="T:Lucene.Net.Store.FSDirectory"/> implementation given your
             environment, and the known limitations of each
             implementation.  For users who have no reason to prefer a
             specific implementation, it's best to simply use 
             <see cref="M:Lucene.Net.Store.FSDirectory.Open(System.String)"/>  (or one of its overloads).  For all others, you should instantiate the
             desired implementation directly.
            
             <para/>The locking implementation is by default 
             <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>, but can be changed by
             passing in a custom <see cref="T:Lucene.Net.Store.LockFactory"/> instance.
             </summary>
             <seealso cref="P:Lucene.Net.Store.FSDirectory.Directory"/>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.DEFAULT_READ_CHUNK_SIZE">
            <summary>
            Default read chunk size: 8192 bytes (this is the size up to which the runtime
            does not allocate additional arrays while reading/writing) </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.FSDirectory"/> for the named location (ctor for subclasses). </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<seealso cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Open(System.IO.DirectoryInfo)">
             <summary>
             Creates an <see cref="T:Lucene.Net.Store.FSDirectory"/> instance, trying to pick the
             best implementation given the current environment.
             The directory returned uses the <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            
             <para/>Currently this returns <see cref="T:Lucene.Net.Store.MMapDirectory"/> for most Solaris
             and Windows 64-bit runtimes, <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> for other
             non-Windows runtimes, and <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> for other
             runtimes on Windows. It is highly recommended that you consult the
             implementation's documentation for your platform before
             using this method.
            
             <para/><b>NOTE</b>: this method may suddenly change which
             implementation is returned from release to release, in
             the event that higher performance defaults become
             possible; if the precise implementation is important to
             your application, please instantiate it directly,
             instead. For optimal performance you should consider using
             <see cref="T:Lucene.Net.Store.MMapDirectory"/> on 64 bit runtimes.
            
             <para/>See <see cref="T:Lucene.Net.Store.FSDirectory"/>.
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Open(System.String)">
            <summary>
            Just like <see cref="M:Lucene.Net.Store.FSDirectory.Open(System.IO.DirectoryInfo)"/>, but
            allows you to specify the directory as a <see cref="T:System.String"/>.
            </summary>
            <param name="path">The path (to a directory) to open</param>
            <returns>An open <see cref="T:Lucene.Net.Store.FSDirectory"/></returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Open(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Just like <see cref="M:Lucene.Net.Store.FSDirectory.Open(System.IO.DirectoryInfo)"/>, but allows you to
            also specify a custom <see cref="T:Lucene.Net.Store.LockFactory"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Open(System.String,Lucene.Net.Store.LockFactory)">
            <summary>
            Just like <see cref="M:Lucene.Net.Store.FSDirectory.Open(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)"/>, but
            allows you to specify the directory as a <see cref="T:System.String"/>.
            </summary>
            <param name="path">The path (to a directory) to open</param>
            <param name="lockFactory"></param>
            <returns>An open <see cref="T:Lucene.Net.Store.FSDirectory"/></returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.ListAll(System.IO.DirectoryInfo)">
            <summary>
            Lists all files (not subdirectories) in the
            directory.  This method never returns <c>null</c> (throws
            <seealso cref="T:System.IO.IOException"/> instead).
            </summary>
            <exception cref="T:System.IO.DirectoryNotFoundException"> if the directory
            does not exist, or does exist but is not a
            directory or is invalid (for example, it is on an unmapped drive). </exception>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.ListAll">
            <summary>
            Lists all files (not subdirectories) in the
            directory. </summary>
            <seealso cref="M:Lucene.Net.Store.FSDirectory.ListAll(System.IO.DirectoryInfo)"/>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileExists(System.String)">
            <summary>
            Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileLength(System.String)">
            <summary>
            Returns the length in bytes of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.DeleteFile(System.String)">
            <summary>
            Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.CreateOutput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Store.IndexOutput"/> for the file with the given name. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Dispose(System.Boolean)">
            <summary>
            Closes the store to future operations. </summary>
        </member>
        <member name="P:Lucene.Net.Store.FSDirectory.Directory">
            <summary> the underlying filesystem directory </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.ToString">
            <summary>
            For debug output. </summary>
        </member>
        <member name="P:Lucene.Net.Store.FSDirectory.ReadChunkSize">
            <summary>
            this setting has no effect anymore. </summary>
        </member>
        <member name="T:Lucene.Net.Store.FSDirectory.FSIndexOutput">
            <summary>
            Writes output with <see cref="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.WriteByte(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.FlushBuffer(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.Seek(System.Int64)">
            <summary>
            Random-access methods </summary>
        </member>
        <member name="P:Lucene.Net.Store.FSDirectory.FSIndexOutput.Length">
            <inheritdoc/>
        </member>
        <member name="P:Lucene.Net.Store.FSDirectory.FSIndexOutput.Checksum">
            <inheritdoc/>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.GetFilePointer">
            <inheritdoc/>
        </member>
        <member name="T:Lucene.Net.Store.FSLockFactory">
            <summary>
            Base class for file system based locking implementation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSLockFactory.m_lockDir">
            <summary>
            Directory for the lock files.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSLockFactory.SetLockDir(System.IO.DirectoryInfo)">
            <summary>
            Set the lock directory. This property can be only called
            once to initialize the lock directory. It is used by <see cref="T:Lucene.Net.Store.FSDirectory"/>
            to set the lock directory to itself.
            Subclasses can also use this property to set the directory
            in the constructor.
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.FSLockFactory.LockDir">
            <summary>
            Gets the lock directory.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.IndexInput">
             <summary>
             Abstract base class for input from a file in a <see cref="T:Lucene.Net.Store.Directory"/>.  A
             random-access input stream.  Used for all Lucene index input operations.
            
             <para/><see cref="T:Lucene.Net.Store.IndexInput"/> may only be used from one thread, because it is not
             thread safe (it keeps internal state like file position). To allow
             multithreaded use, every <see cref="T:Lucene.Net.Store.IndexInput"/> instance must be cloned before
             used in another thread. Subclasses must therefore implement <see cref="M:Lucene.Net.Store.IndexInput.Clone"/>,
             returning a new <see cref="T:Lucene.Net.Store.IndexInput"/> which operates on the same underlying
             resource, but positioned independently. Lucene never closes cloned
             <see cref="T:Lucene.Net.Store.IndexInput"/>s, it will only do this on the original one.
             The original instance must take care that cloned instances throw
             <see cref="T:System.ObjectDisposedException"/> when the original one is closed.
             </summary>
             <seealso cref="T:Lucene.Net.Store.Directory"/>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.#ctor(System.String)">
            <summary>
            <paramref name="resourceDescription"/> should be a non-null, opaque string
            describing this resource; it's returned from
            <see cref="M:Lucene.Net.Store.IndexInput.ToString"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Dispose">
            <summary>
            Closes the stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Dispose(System.Boolean)">
            <summary>
            Closes the stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.GetFilePointer">
            <summary>
            Returns the current position in this file, where the next read will
            occur. </summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.Seek(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Seek(System.Int64)">
            <summary>
            Sets current position in this file, where the next read will occur.
            </summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.GetFilePointer"/>
        </member>
        <member name="P:Lucene.Net.Store.IndexInput.Length">
            <summary>
            The number of bytes in the file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ToString">
            <summary>
            Returns the resourceDescription that was passed into the constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Clone">
             <summary>
             Returns a clone of this stream.
            
             <para/>Clones of a stream access the same data, and are positioned at the same
             point as the stream they were cloned from.
            
             <para/>Expert: Subclasses must ensure that clones may be positioned at
             different points in the input from each other and from the stream they
             were cloned from.
             
             <para/><b>Warning:</b> Lucene never closes cloned
             <see cref="T:Lucene.Net.Store.IndexInput"/>s, it will only do this on the original one.
             The original instance must take care that cloned instances throw
             <see cref="T:System.ObjectDisposedException"/> when the original one is closed.
             </summary>
        </member>
        <member name="T:Lucene.Net.Store.IndexOutput">
             <summary>
             Abstract base class for output to a file in a <see cref="T:Lucene.Net.Store.Directory"/>.  A random-access
             output stream.  Used for all Lucene index output operations.
            
             <para/><see cref="T:Lucene.Net.Store.IndexOutput"/> may only be used from one thread, because it is not
             thread safe (it keeps internal state like file position).
             </summary>
             <seealso cref="T:Lucene.Net.Store.Directory"/>
             <seealso cref="T:Lucene.Net.Store.IndexInput"/>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Flush">
            <summary>
            Forces any buffered output to be written. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Dispose">
            <summary>
            Closes this stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Dispose(System.Boolean)">
            <summary>
            Closes this stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.GetFilePointer">
            <summary>
            Returns the current position in this file, where the next write will
            occur. </summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.Seek(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Seek(System.Int64)">
            <summary>
            Sets current position in this file, where the next write will occur. </summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.GetFilePointer"/>
        </member>
        <member name="P:Lucene.Net.Store.IndexOutput.Checksum">
            <summary>
            Returns the current checksum of bytes written so far </summary>
        </member>
        <member name="P:Lucene.Net.Store.IndexOutput.Length">
            <summary>
            Gets or Sets the file length. By default, this property's setter does
            nothing (it's optional for a <see cref="T:Lucene.Net.Store.Directory"/> to implement
            it).  But, certain <see cref="T:Lucene.Net.Store.Directory"/> implementations (for 
            example <see cref="T:Lucene.Net.Store.FSDirectory"/>) can use this to inform the
            underlying IO system to pre-allocate the file to the
            specified size.  If the length is longer than the
            current file length, the bytes added to the file are
            undefined.  Otherwise the file is truncated.</summary>
        </member>
        <member name="T:Lucene.Net.Store.InputStreamDataInput">
            <summary>
            A <see cref="T:Lucene.Net.Store.DataInput"/> wrapping a plain <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.IOContext">
            <summary>
            <see cref="T:Lucene.Net.Store.IOContext"/> holds additional details on the merge/search context. A <see cref="T:Lucene.Net.Store.IOContext"/>
            object can never be initialized as null as passed as a parameter to either
            <see cref="M:Lucene.Net.Store.Directory.OpenInput(System.String,Lucene.Net.Store.IOContext)"/> or
            <see cref="M:Lucene.Net.Store.Directory.CreateOutput(System.String,Lucene.Net.Store.IOContext)"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.IOContext.UsageContext">
            <summary>
            <see cref="T:Lucene.Net.Store.IOContext.UsageContext"/> is a enumeration which specifies the context in which the <see cref="T:Lucene.Net.Store.Directory"/>
            is being used for.
            <para/>
            NOTE: This was Context in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.IOContext.Context">
            <summary>
            A <see cref="T:Lucene.Net.Store.IOContext.UsageContext"/> setting
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.IOContext.#ctor(Lucene.Net.Store.IOContext,System.Boolean)">
            <summary>
            This constructor is used to initialize a <see cref="T:Lucene.Net.Store.IOContext"/> instance with a new value for the <see cref="P:Lucene.Net.Store.IOContext.ReadOnce"/> property. </summary>
            <param name="ctxt"> <see cref="T:Lucene.Net.Store.IOContext"/> object whose information is used to create the new instance except the <see cref="P:Lucene.Net.Store.IOContext.ReadOnce"/> property. </param>
            <param name="readOnce"> The new <see cref="T:Lucene.Net.Store.IOContext"/> object will use this value for <see cref="P:Lucene.Net.Store.IOContext.ReadOnce"/>.  </param>
        </member>
        <member name="T:Lucene.Net.Store.Lock">
            <summary>
            An interprocess mutex lock.
            <para/>Typical use might look like:
            
            <code>
                var result = Lock.With.NewAnonymous&lt;string&gt;(
                    @lock: directory.MakeLock("my.lock"), 
                    lockWaitTimeout: Lock.LOCK_OBTAIN_WAIT_FOREVER, 
                    doBody: () =>
                {
                    //... code to execute while locked ...
                    return "the result";
                }).Run();
            </code>
            </summary>
            <seealso cref="M:Lucene.Net.Store.Directory.MakeLock(System.String)"/>
        </member>
        <member name="F:Lucene.Net.Store.Lock.LOCK_POLL_INTERVAL">
            <summary>
            How long <see cref="M:Lucene.Net.Store.Lock.Obtain(System.Int64)"/> waits, in milliseconds,
            in between attempts to acquire the lock.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.Lock.LOCK_OBTAIN_WAIT_FOREVER">
            <summary>
            Pass this value to <see cref="M:Lucene.Net.Store.Lock.Obtain(System.Int64)"/> to try
            forever to obtain the lock.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.NewAnonymous``1(Lucene.Net.Store.Lock,System.Int32,System.Func{``0})">
            <summary>
            Creates a new instance with the ability to specify the <see cref="M:Lucene.Net.Store.Lock.With`1.DoBody"/> method
            through the <paramref name="doBody"/> argument
            <para/>
            Simple example:
            <code>
                var result = Lock.With.NewAnonymous&lt;string&gt;(
                    @lock: directory.MakeLock("my.lock"), 
                    lockWaitTimeout: Lock.LOCK_OBTAIN_WAIT_FOREVER, 
                    doBody: () =>
                {
                    //... code to execute while locked ...
                    return "the result";
                }).Run();
            </code>
            <para/>
            The result of the operation is the value that is returned from <paramref name="doBody"/>
            (i.e. () => { return "the result"; }). The type of <typeparam name="T"/> determines the
            return type of the operation.
            </summary>
            <param name="lock"> the <see cref="T:Lucene.Net.Store.Lock"/> instance to use </param>
            <param name="lockWaitTimeout"> length of time to wait in
                   milliseconds or 
                   <see cref="F:Lucene.Net.Store.Lock.LOCK_OBTAIN_WAIT_FOREVER"/> to retry forever </param>
            <param name="doBody"> a delegate method that </param>
            <returns>The value that is returned from the <paramref name="doBody"/> delegate method (i.e. () => { return theObject; })</returns>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Obtain">
            <summary>
            Attempts to obtain exclusive access and immediately return
            upon success or failure.  Use <see cref="M:Lucene.Net.Store.Lock.Dispose"/> to
            release the lock. </summary>
            <returns> true iff exclusive access is obtained </returns>
        </member>
        <member name="P:Lucene.Net.Store.Lock.FailureReason">
            <summary>
            If a lock obtain called, this failureReason may be set
            with the "root cause" <see cref="T:System.Exception"/> as to why the lock was
            not obtained.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Obtain(System.Int64)">
            <summary>
            Attempts to obtain an exclusive lock within amount of
            time given. Polls once per <see cref="F:Lucene.Net.Store.Lock.LOCK_POLL_INTERVAL"/>
            (currently 1000) milliseconds until <paramref name="lockWaitTimeout"/> is
            passed.
            </summary>
            <param name="lockWaitTimeout"> length of time to wait in
                   milliseconds or 
                   <see cref="F:Lucene.Net.Store.Lock.LOCK_OBTAIN_WAIT_FOREVER"/> to retry forever </param>
            <returns> <c>true</c> if lock was obtained </returns>
            <exception cref="T:Lucene.Net.Store.LockObtainFailedException"> if lock wait times out </exception>
            <exception cref="T:System.ArgumentException"> if <paramref name="lockWaitTimeout"/> is
                    out of bounds </exception>
            <exception cref="T:System.IO.IOException"> if <see cref="M:Lucene.Net.Store.Lock.Obtain"/> throws <see cref="T:System.IO.IOException"/> </exception>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Dispose">
            <summary>
            Releases exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Dispose(System.Boolean)">
            <summary>
            Releases exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.IsLocked">
            <summary>
            Returns <c>true</c> if the resource is currently locked.  Note that one must
            still call <see cref="M:Lucene.Net.Store.Lock.Obtain"/> before using the resource.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.Lock.With`1">
            <summary>
            Utility class for executing code with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With`1.#ctor(Lucene.Net.Store.Lock,System.Int64)">
            <summary>
            Constructs an executor that will grab the named <paramref name="lock"/>. </summary>
            <param name="lock"> the <see cref="T:Lucene.Net.Store.Lock"/> instance to use </param>
            <param name="lockWaitTimeout"> length of time to wait in
                   milliseconds or 
                   <see cref="F:Lucene.Net.Store.Lock.LOCK_OBTAIN_WAIT_FOREVER"/> to retry forever </param>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With`1.DoBody">
            <summary>
            Code to execute with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With`1.Run">
            <summary>
            Calls <see cref="M:Lucene.Net.Store.Lock.With`1.DoBody"/> while <i>lock</i> is obtained.  Blocks if lock
            cannot be obtained immediately.  Retries to obtain lock once per second
            until it is obtained, or until it has tried ten times. Lock is released when
            <see cref="M:Lucene.Net.Store.Lock.With`1.DoBody"/> exits. </summary>
            <exception cref="T:Lucene.Net.Store.LockObtainFailedException"> if lock could not
            be obtained </exception>
            <exception cref="T:System.IO.IOException"> if <see cref="M:Lucene.Net.Store.Lock.Obtain"/> throws <see cref="T:System.IO.IOException"/> </exception>
        </member>
        <member name="T:Lucene.Net.Store.Lock.AnonymousWith`1">
            <summary>
            LUCENENET specific class to simulate the anonymous creation of a With class in Java
            by using deletate methods.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.LockFactory">
             <summary>
             <para>Base class for Locking implementation.  <see cref="T:Lucene.Net.Store.Directory"/> uses
             instances of this class to implement locking.</para>
            
             <para>Lucene uses <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/> by default for
             <see cref="T:Lucene.Net.Store.FSDirectory"/>-based index directories.</para>
            
             <para>Special care needs to be taken if you change the locking
             implementation: First be certain that no writer is in fact
             writing to the index otherwise you can easily corrupt
             your index. Be sure to do the <see cref="T:Lucene.Net.Store.LockFactory"/> change on all Lucene
             instances and clean up all leftover lock files before starting
             the new configuration for the first time. Different implementations
             can not work together!</para>
            
             <para>If you suspect that some <see cref="T:Lucene.Net.Store.LockFactory"/> implementation is
             not working properly in your environment, you can easily
             test it by using <see cref="T:Lucene.Net.Store.VerifyingLockFactory"/>, 
             <see cref="T:Lucene.Net.Store.LockVerifyServer"/> and <see cref="T:Lucene.Net.Store.LockStressTest"/>.</para>
             </summary>
             <seealso cref="T:Lucene.Net.Store.LockVerifyServer"/>
             <seealso cref="T:Lucene.Net.Store.LockStressTest"/>
             <seealso cref="T:Lucene.Net.Store.VerifyingLockFactory"/>
        </member>
        <member name="P:Lucene.Net.Store.LockFactory.LockPrefix">
            <summary>
            Gets or Sets the prefix in use for all locks created in this
            <see cref="T:Lucene.Net.Store.LockFactory"/>.  This is normally called once, when a
            <see cref="T:Lucene.Net.Store.Directory"/> gets this <see cref="T:Lucene.Net.Store.LockFactory"/> instance.  However, you
            can also call this (after this instance is assigned to
            a <see cref="T:Lucene.Net.Store.Directory"/>) to override the prefix in use.  This
            is helpful if you're running Lucene on machines that
            have different mount points for the same shared
            directory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.MakeLock(System.String)">
            <summary>
            Return a new <see cref="T:Lucene.Net.Store.Lock"/> instance identified by <paramref name="lockName"/>. </summary>
            <param name="lockName"> name of the lock to be created. </param>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.ClearLock(System.String)">
            <summary>
            Attempt to clear (forcefully unlock and remove) the
            specified lock.  Only call this at a time when you are
            certain this lock is no longer in use. </summary>
            <param name="lockName"> name of the lock to be cleared. </param>
        </member>
        <member name="T:Lucene.Net.Store.LockObtainFailedException">
            <summary>
            This exception is thrown when the <c>write.lock</c>
            could not be acquired.  This
            happens when a writer tries to open an index
            that another writer already has open. </summary>
            <seealso cref="M:Lucene.Net.Store.Lock.Obtain(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Store.LockObtainFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Store.LockReleaseFailedException">
            <summary>
            This exception is thrown when the <c>write.lock</c>
            could not be released. </summary>
            <seealso cref="M:Lucene.Net.Store.Lock.Dispose"/>
        </member>
        <member name="M:Lucene.Net.Store.LockReleaseFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Store.LockStressTest">
            <summary>
            Simple standalone tool that forever acquires &amp; releases a
            lock using a specific <see cref="T:Lucene.Net.Store.LockFactory"/>.  Run without any args
            to see usage.
            </summary>
            <seealso cref="T:Lucene.Net.Store.VerifyingLockFactory"/>
            <seealso cref="T:Lucene.Net.Store.LockVerifyServer"/>
        </member>
        <member name="T:Lucene.Net.Store.LockVerifyServer">
            <summary>
            Simple standalone server that must be running when you
            use <see cref="T:Lucene.Net.Store.VerifyingLockFactory"/>.  This server simply
            verifies at most one process holds the lock at a time.
            Run without any args to see usage.
            </summary>
            <seealso cref="T:Lucene.Net.Store.VerifyingLockFactory"/>
            <seealso cref="T:Lucene.Net.Store.LockStressTest"/>
        </member>
        <member name="T:Lucene.Net.Store.MergeInfo">
            <summary>
            <para>A MergeInfo provides information required for a MERGE context.
            It is used as part of an <see cref="T:Lucene.Net.Store.IOContext"/> in case of MERGE context.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.MergeInfo.#ctor(System.Int32,System.Int64,System.Boolean,System.Int32)">
            <summary>
            <para/>Creates a new <see cref="T:Lucene.Net.Store.MergeInfo"/> instance from
            the values required for a MERGE <see cref="T:Lucene.Net.Store.IOContext"/> context.
            <para/>
            These values are only estimates and are not the actual values.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.MMapDirectory">
             <summary>
             File-based <see cref="T:Lucene.Net.Store.Directory"/> implementation that uses
             <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile"/> for reading, and
             <see cref="T:Lucene.Net.Store.FSDirectory.FSIndexOutput"/> for writing.
            
             <para/><b>NOTE</b>: memory mapping uses up a portion of the
             virtual memory address space in your process equal to the
             size of the file being mapped.  Before using this class,
             be sure your have plenty of virtual address space, e.g. by
             using a 64 bit runtime, or a 32 bit runtime with indexes that are
             guaranteed to fit within the address space.
             On 32 bit platforms also consult <see cref="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory,System.Int32)"/>
             if you have problems with mmap failing because of fragmented
             address space. If you get an <see cref="T:System.OutOfMemoryException"/>, it is recommended
             to reduce the chunk size, until it works.
             <para>
             <b>NOTE:</b> Accessing this class either directly or
             indirectly from a thread while it's interrupted can close the
             underlying channel immediately if at the same time the thread is
             blocked on IO. The channel will remain closed and subsequent access
             to <see cref="T:Lucene.Net.Store.MMapDirectory"/> will throw a <see cref="T:System.ObjectDisposedException"/>.
             </para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Store.MMapDirectory.DEFAULT_MAX_BUFF">
            <summary>
            Default max chunk size. </summary>
            <seealso cref="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.MMapDirectory"/> for the named location.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.MMapDirectory"/> for the named location and <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory,System.Int32)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.MMapDirectory"/> for the named location, specifying the
            maximum chunk size used for memory mapping.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or <c>null</c> for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <param name="maxChunkSize"> maximum chunk size (default is 1 GiBytes for
            64 bit runtimes and 256 MiBytes for 32 bit runtimes) used for memory mapping.
            <para/>
            Especially on 32 bit platform, the address space can be very fragmented,
            so large index files cannot be mapped. Using a lower chunk size makes
            the directory implementation a little bit slower (as the correct chunk
            may be resolved on lots of seeks) but the chance is higher that mmap
            does not fail. On 64 bit platforms, this parameter should always
            be <c>1 &lt;&lt; 30</c>, as the address space is big enough.
            <para/>
            <b>Please note:</b> The chunk size is always rounded down to a power of 2.
            </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.String,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.MMapDirectory"/> for the named location.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.String)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.MMapDirectory"/> for the named location and <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.String,Lucene.Net.Store.LockFactory,System.Int32)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.MMapDirectory"/> for the named location, specifying the
            maximum chunk size used for memory mapping.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or <c>null</c> for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <param name="maxChunkSize"> maximum chunk size (default is 1 GiBytes for
            64 bit runtimes and 256 MiBytes for 32 bit runtimes) used for memory mapping.
            <para/>
            Especially on 32 bit platform, the address space can be very fragmented,
            so large index files cannot be mapped. Using a lower chunk size makes
            the directory implementation a little bit slower (as the correct chunk
            may be resolved on lots of seeks) but the chance is higher that mmap
            does not fail. On 64 bit platforms, this parameter should always
            be <c>1 &lt;&lt; 30</c>, as the address space is big enough.
            <para/>
            <b>Please note:</b> The chunk size is always rounded down to a power of 2.
            </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="P:Lucene.Net.Store.MMapDirectory.MaxChunkSize">
            <summary>
            Returns the current mmap chunk size. </summary>
            <seealso cref="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Store.IndexInput"/> for the file with the given name. </summary>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.MMapIndexInput.FreeBuffer(J2N.IO.ByteBuffer)">
            <summary>
            Try to unmap the buffer, this method silently fails if no support
            for that in the runtime. On Windows, this leads to the fact,
            that mmapped files cannot be modified or deleted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.Map(Lucene.Net.Store.MMapDirectory.MMapIndexInput,System.IO.FileStream,System.Int64,System.Int64)">
            <summary>
            Maps a file into a set of buffers </summary>
        </member>
        <member name="T:Lucene.Net.Store.NativeFSLockFactory">
             <summary>
             <para>Implements <see cref="T:Lucene.Net.Store.LockFactory"/> using native OS file
             locks.  For NFS based access to an index, it's
             recommended that you try <see cref="T:Lucene.Net.Store.SimpleFSLockFactory"/>
             first and work around the one limitation that a lock file
             could be left when the runtime exits abnormally.</para>
            
             <para>The primary benefit of <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/> is
             that locks (not the lock file itsself) will be properly
             removed (by the OS) if the runtime has an abnormal exit.</para>
            
             <para>Note that, unlike <see cref="T:Lucene.Net.Store.SimpleFSLockFactory"/>, the existence of
             leftover lock files in the filesystem is fine because the OS
             will free the locks held against these files even though the
             files still remain. Lucene will never actively remove the lock
             files, so although you see them, the index may not be locked.</para>
            
             <para>Special care needs to be taken if you change the locking
             implementation: First be certain that no writer is in fact
             writing to the index otherwise you can easily corrupt
             your index. Be sure to do the <see cref="T:Lucene.Net.Store.LockFactory"/> change on all Lucene
             instances and clean up all leftover lock files before starting
             the new configuration for the first time. Different implementations
             can not work together!</para>
            
             <para>If you suspect that this or any other <see cref="T:Lucene.Net.Store.LockFactory"/> is
             not working properly in your environment, you can easily
             test it by using <see cref="T:Lucene.Net.Store.VerifyingLockFactory"/>,
             <see cref="T:Lucene.Net.Store.LockVerifyServer"/> and <see cref="T:Lucene.Net.Store.LockStressTest"/>.</para>
             </summary>
             <seealso cref="T:Lucene.Net.Store.LockFactory"/>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor">
            <summary>
            Create a <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/> instance, with <c>null</c> (unset)
            lock directory. When you pass this factory to a <see cref="T:Lucene.Net.Store.FSDirectory"/>
            subclass, the lock directory is automatically set to the
            directory itself. Be sure to create one instance for each directory
            your create!
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor(System.String)">
            <summary>
            Create a <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/> instance, storing lock
            files into the specified <paramref name="lockDirName"/>
            </summary>
            <param name="lockDirName"> where lock files are created. </param>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/> instance, storing lock
            files into the specified <paramref name="lockDir"/>
            </summary>
            <param name="lockDir"> where lock files are created. </param>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.GetCanonicalPathOfLockFile(System.String)">
            <summary>
            Given a lock name, return the full prefixed path of the actual lock file.
            </summary>
            <param name="lockName"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Store.SharingNativeFSLock.IsShareViolation(System.IO.IOException)">
            <summary>
            Return true if the <see cref="T:System.IO.IOException"/> is the result of a share violation
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLock.IsLockViolation(System.IO.IOException)">
            <summary>
            Return true if the <see cref="T:System.IO.IOException"/> is the result of a lock violation
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.NIOFSDirectory">
            <summary>
            An <see cref="T:Lucene.Net.Store.FSDirectory"/> implementation that uses <see cref="T:System.IO.FileStream"/>'s
            positional read, which allows multiple threads to read from the same file
            without synchronizing.
            <para/>
            This class only uses <see cref="T:System.IO.FileStream"/> when reading; writing is achieved with
            <see cref="T:Lucene.Net.Store.FSDirectory.FSIndexOutput"/>.
            <para>
            <b>NOTE</b>: <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> is not recommended on Windows because of a bug in
            how FileChannel.read is implemented in Sun's JRE. Inside of the
            implementation the position is apparently synchronized. See <a
            href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265734">here</a>
            for details.
            </para>
            <para>
            <font color="red"><b>NOTE:</b> Accessing this class either directly or
            indirectly from a thread while it's interrupted can close the
            underlying file descriptor immediately if at the same time the thread is
            blocked on IO. The file descriptor will remain closed and subsequent access
            to <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> will throw a <see cref="T:System.ObjectDisposedException"/>. If
            your application uses either <see cref="M:System.Threading.Thread.Interrupt"/> or
            <see cref="T:System.Threading.Tasks.Task"/> you should use <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> in
            favor of <see cref="T:Lucene.Net.Store.NIOFSDirectory"/>.</font>
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NIOFSDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> for the named location.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.NIOFSDirectory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> for the named location and <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.NIOFSDirectory.#ctor(System.String,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> for the named location.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.NIOFSDirectory.#ctor(System.String)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> for the named location and <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.NIOFSDirectory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Store.IndexInput"/> for the file with the given name. </summary>
        </member>
        <member name="T:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput">
            <summary>
            Reads bytes with the <see cref="M:Lucene.Net.Support.IO.StreamExtensions.Read(System.IO.Stream,J2N.IO.ByteBuffer,System.Int64)"/>
            extension method for <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.CHUNK_SIZE">
            <summary>
            The maximum chunk size for reads of 16384 bytes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.m_channel">
            <summary>
            the file channel we will read from </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.isClone">
            <summary>
            is this instance a clone and hence does not own the file to close it </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.m_off">
            <summary>
            start offset: non-zero in the slice case </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.m_end">
            <summary>
            end offset (start+length) </summary>
        </member>
        <member name="T:Lucene.Net.Store.NoLockFactory">
            <summary>
            Use this <see cref="T:Lucene.Net.Store.LockFactory"/> to disable locking entirely.
            Only one instance of this lock is created.  You should call 
            <see cref="M:Lucene.Net.Store.NoLockFactory.GetNoLockFactory"/> to get the instance.
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockFactory"/>
        </member>
        <member name="T:Lucene.Net.Store.NRTCachingDirectory">
             <summary>
             Wraps a <see cref="T:Lucene.Net.Store.RAMDirectory"/>
             around any provided delegate directory, to
             be used during NRT search.
            
             <para>This class is likely only useful in a near-real-time
             context, where indexing rate is lowish but reopen
             rate is highish, resulting in many tiny files being
             written.  This directory keeps such segments (as well as
             the segments produced by merging them, as long as they
             are small enough), in RAM.</para>
            
             <para>This is safe to use: when your app calls <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>,
             all cached files will be flushed from the cached and sync'd.</para>
            
             <para/>Here's a simple example usage:
            
             <code>
                 Directory fsDir = FSDirectory.Open(new DirectoryInfo("/path/to/index"));
                 NRTCachingDirectory cachedFSDir = new NRTCachingDirectory(fsDir, 5.0, 60.0);
                 IndexWriterConfig conf = new IndexWriterConfig(Version.LUCENE_48, analyzer);
                 IndexWriter writer = new IndexWriter(cachedFSDir, conf);
             </code>
            
             <para>This will cache all newly flushed segments, all merges
             whose expected segment size is &lt;= 5 MB, unless the net
             cached bytes exceeds 60 MB at which point all writes will
             not be cached (until the net bytes falls below 60 MB).</para>
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.NRTCachingDirectory.#ctor(Lucene.Net.Store.Directory,System.Double,System.Double)">
            <summary>
            We will cache a newly created output if 1) it's a
            flush or a merge and the estimated size of the merged segment is &lt;=
            maxMergeSizeMB, and 2) the total cached bytes is &lt;=
            maxCachedMB
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NRTCachingDirectory.GetSizeInBytes">
            <summary>
            Returns how many bytes are being used by the
            <see cref="T:Lucene.Net.Store.RAMDirectory"/> cache
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NRTCachingDirectory.Dispose(System.Boolean)">
            <summary>
            Dispose this directory, which flushes any cached files
            to the delegate and then disposes the delegate.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NRTCachingDirectory.DoCacheWrite(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Subclass can override this to customize logic; return
            <c>true</c> if this file should be written to the <see cref="T:Lucene.Net.Store.RAMDirectory"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.OutputStreamDataOutput">
            <summary>
            A <see cref="T:Lucene.Net.Store.DataOutput"/> wrapping a plain <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMDirectory">
             <summary>
             A memory-resident <see cref="T:Lucene.Net.Store.Directory"/> implementation.  Locking
             implementation is by default the <see cref="T:Lucene.Net.Store.SingleInstanceLockFactory"/>
             but can be changed with <see cref="M:Lucene.Net.Store.Directory.SetLockFactory(Lucene.Net.Store.LockFactory)"/>.
            
             <para/><b>Warning:</b> This class is not intended to work with huge
             indexes. Everything beyond several hundred megabytes will waste
             resources (GC cycles), because it uses an internal buffer size
             of 1024 bytes, producing millions of <see cref="T:byte[1024]"/> arrays.
             This class is optimized for small memory-resident indexes.
             It also has bad concurrency on multithreaded environments.
            
             <para/>It is recommended to materialize large indexes on disk and use
             <see cref="T:Lucene.Net.Store.MMapDirectory"/>, which is a high-performance directory
             implementation working directly on the file system cache of the
             operating system, so copying data to heap space is not useful.
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor">
            <summary>
            Constructs an empty <see cref="T:Lucene.Net.Store.Directory"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Store.IOContext)">
             <summary>
             Creates a new <see cref="T:Lucene.Net.Store.RAMDirectory"/> instance from a different
             <see cref="T:Lucene.Net.Store.Directory"/> implementation.  This can be used to load
             a disk-based index into memory.
            
             <para/><b>Warning:</b> this class is not intended to work with huge
             indexes. Everything beyond several hundred megabytes will waste
             resources (GC cycles), because it uses an internal buffer size
             of 1024 bytes, producing millions of <see cref="T:byte[1024]"/> arrays.
             this class is optimized for small memory-resident indexes.
             It also has bad concurrency on multithreaded environments.
            
             <para/>For disk-based indexes it is recommended to use
             <see cref="T:Lucene.Net.Store.MMapDirectory"/>, which is a high-performance directory
             implementation working directly on the file system cache of the
             operating system, so copying data to heap space is not useful.
            
             <para/>Note that the resulting <see cref="T:Lucene.Net.Store.RAMDirectory"/> instance is fully
             independent from the original <see cref="T:Lucene.Net.Store.Directory"/> (it is a
             complete copy).  Any subsequent changes to the
             original <see cref="T:Lucene.Net.Store.Directory"/> will not be visible in the
             <see cref="T:Lucene.Net.Store.RAMDirectory"/> instance.
             </summary>
             <param name="dir"> a <see cref="T:Lucene.Net.Store.Directory"/> value </param>
             <param name="context">io context</param>
             <exception cref="T:System.IO.IOException"> if an error occurs </exception>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileExists(System.String)">
            <summary>
            Returns true iff the named file exists in this directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileLength(System.String)">
            <summary>
            Returns the length in bytes of a file in the directory. </summary>
            <exception cref="T:System.IO.IOException"> if the file does not exist </exception>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.GetSizeInBytes">
            <summary>
            Return total size in bytes of all files in this directory. This is
            currently quantized to <see cref="F:Lucene.Net.Store.RAMOutputStream.BUFFER_SIZE"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.DeleteFile(System.String)">
            <summary>
            Removes an existing file in the directory. </summary>
            <exception cref="T:System.IO.IOException"> if the file does not exist </exception>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.CreateOutput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates a new, empty file in the directory with the given name. Returns a stream writing this file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.NewRAMFile">
            <summary>
            Returns a new <see cref="T:Lucene.Net.Store.RAMFile"/> for storing data. this method can be
            overridden to return different <see cref="T:Lucene.Net.Store.RAMFile"/> impls, that e.g. override
            <see cref="M:Lucene.Net.Store.RAMFile.NewBuffer(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a stream reading an existing file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.Dispose(System.Boolean)">
            <summary>
            Closes the store to future operations, releasing associated memory. </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMFile">
            <summary>
            Represents a file in RAM as a list of <see cref="T:byte[]"/> buffers.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMFile.#ctor">
            <summary>
            File used as buffer, in no <see cref="T:Lucene.Net.Store.RAMDirectory"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.RAMFile.Length">
            <summary>
            For non-stream access from thread that might be concurrent with writing
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMFile.NewBuffer(System.Int32)">
            <summary>
            Expert: allocate a new buffer.
            Subclasses can allocate differently. </summary>
            <param name="size"> size of allocated buffer. </param>
            <returns> allocated buffer. </returns>
        </member>
        <member name="T:Lucene.Net.Store.RAMInputStream">
            <summary>
            A memory-resident <see cref="T:Lucene.Net.Store.IndexInput"/> implementation.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMOutputStream">
            <summary>
            A memory-resident <see cref="T:Lucene.Net.Store.IndexOutput"/> implementation.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.#ctor">
            <summary>
            Construct an empty output buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.WriteTo(Lucene.Net.Store.DataOutput)">
            <summary>
            Copy the current contents of this buffer to the named output. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Copy the current contents of this buffer to output
            byte array
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.Reset">
            <summary>
            Resets this to an empty file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.GetSizeInBytes">
            <summary>
            Returns byte usage of all buffers. </summary>
        </member>
        <member name="T:Lucene.Net.Store.RateLimitedDirectoryWrapper">
            
             <summary>
             A <see cref="T:Lucene.Net.Store.Directory"/> wrapper that allows <see cref="T:Lucene.Net.Store.IndexOutput"/> rate limiting using
             IO context (<see cref="T:Lucene.Net.Store.IOContext.UsageContext"/>) specific rate limiters (<see cref="T:Lucene.Net.Store.RateLimiter"/>).
             <para/>
             @lucene.experimental
             </summary>
             <seealso cref="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.SetRateLimiter(Lucene.Net.Store.RateLimiter,Lucene.Net.Store.IOContext.UsageContext)"/>
        </member>
        <member name="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.SetMaxWriteMBPerSec(System.Nullable{System.Double},Lucene.Net.Store.IOContext.UsageContext)">
             <summary>
             Sets the maximum (approx) MB/sec allowed by all write IO performed by
             <see cref="T:Lucene.Net.Store.IndexOutput"/> created with the given <see cref="T:Lucene.Net.Store.IOContext.UsageContext"/>. Pass 
             <c>null</c> for <paramref name="mbPerSec"/> to have no limit.
            
             <para/>
             <b>NOTE</b>: For already created <see cref="T:Lucene.Net.Store.IndexOutput"/> instances there is no
             guarantee this new rate will apply to them; it will only be guaranteed to
             apply for new created <see cref="T:Lucene.Net.Store.IndexOutput"/> instances.
             <para/>
             <b>NOTE</b>: this is an optional operation and might not be respected by
             all <see cref="T:Lucene.Net.Store.Directory"/> implementations. Currently only buffered (<see cref="T:Lucene.Net.Store.FSDirectory"/>)
             <see cref="T:Lucene.Net.Store.Directory"/> implementations use rate-limiting.
             <para/>
             @lucene.experimental
             </summary>
             <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Store.Directory"/> is already disposed
             </exception>
        </member>
        <member name="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.SetRateLimiter(Lucene.Net.Store.RateLimiter,Lucene.Net.Store.IOContext.UsageContext)">
             <summary>
             Sets the rate limiter to be used to limit (approx) MB/sec allowed by all IO
             performed with the given context (<see cref="T:Lucene.Net.Store.IOContext.UsageContext"/>). Pass <c>null</c> to
             have no limit.
            
             <para/>
             Passing an instance of rate limiter compared to setting it using
             <see cref="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.SetMaxWriteMBPerSec(System.Nullable{System.Double},Lucene.Net.Store.IOContext.UsageContext)"/>
             allows to use the same limiter instance across several directories globally
             limiting IO across them.
             <para/>
             @lucene.experimental
             </summary>
             <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Store.Directory"/> is already disposed
             </exception>
        </member>
        <member name="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.GetMaxWriteMBPerSec(Lucene.Net.Store.IOContext.UsageContext)">
            <summary>
            See <see cref="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.SetMaxWriteMBPerSec(System.Nullable{System.Double},Lucene.Net.Store.IOContext.UsageContext)"/>.
            <para/>
            @lucene.experimental
            </summary>
            <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Store.Directory"/> is already disposed
            </exception>
        </member>
        <member name="T:Lucene.Net.Store.RateLimitedIndexOutput">
            <summary>
            A rate limiting (<see cref="T:Lucene.Net.Store.RateLimiter"/>) <see cref="T:Lucene.Net.Store.IndexOutput"/>
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.RateLimiter">
            <summary>
            Abstract base class to rate limit IO.  Typically implementations are
            shared across multiple <see cref="T:Lucene.Net.Store.IndexInput"/>s or <see cref="T:Lucene.Net.Store.IndexOutput"/>s (for example
            those involved all merging).  Those <see cref="T:Lucene.Net.Store.IndexInput"/>s and
            <see cref="T:Lucene.Net.Store.IndexOutput"/>s would call <see cref="M:Lucene.Net.Store.RateLimiter.Pause(System.Int64)"/> whenever they
            want to read bytes or write bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.SetMbPerSec(System.Double)">
            <summary>
            Sets an updated mb per second rate limit.
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.RateLimiter.MbPerSec">
            <summary>
            The current mb per second rate limit.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.Pause(System.Int64)">
            <summary>
            Pauses, if necessary, to keep the instantaneous IO
            rate at or below the target.
            <para>
            Note: the implementation is thread-safe
            </para> 
            </summary>
            <returns> the pause time in nano seconds </returns>
        </member>
        <member name="T:Lucene.Net.Store.RateLimiter.SimpleRateLimiter">
            <summary>
            Simple class to rate limit IO.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.SimpleRateLimiter.#ctor(System.Double)">
            <summary>
            <paramref name="mbPerSec"/> is the MB/sec max IO rate </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.SimpleRateLimiter.SetMbPerSec(System.Double)">
            <summary>
            Sets an updated mb per second rate limit.
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.RateLimiter.SimpleRateLimiter.MbPerSec">
            <summary>
            The current mb per second rate limit.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.SimpleRateLimiter.Pause(System.Int64)">
            <summary>
            Pauses, if necessary, to keep the instantaneous IO
            rate at or below the target. NOTE: multiple threads
            may safely use this, however the implementation is
            not perfectly thread safe but likely in practice this
            is harmless (just means in some rare cases the rate
            might exceed the target).  It's best to call this
            with a biggish count, not one byte at a time. </summary>
            <returns> the pause time in nano seconds </returns>
        </member>
        <member name="T:Lucene.Net.Store.SimpleFSDirectory">
            <summary>
            A straightforward implementation of <see cref="T:Lucene.Net.Store.FSDirectory"/>
            using <see cref="T:System.IO.FileStream"/>.  However, this class has
            poor concurrent performance (multiple threads will
            bottleneck) as it synchronizes when multiple threads
            read from the same file.  It's usually better to use
            <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> or <see cref="T:Lucene.Net.Store.MMapDirectory"/> instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> for the named location.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> for the named location and <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.#ctor(System.String,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> for the named location.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.#ctor(System.String)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> for the named location and <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Store.IndexInput"/> for the file with the given name. </summary>
        </member>
        <member name="T:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput">
            <summary>
            Reads bytes with <see cref="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)"/> followed by
            <see cref="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.m_file">
            <summary>
            the file channel we will read from </summary>
        </member>
        <member name="P:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.IsClone">
            <summary>
            is this instance a clone and hence does not own the file to close it </summary>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.m_off">
            <summary>
            start offset: non-zero in the slice case </summary>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.m_end">
            <summary>
            end offset (start+length) </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <see cref="T:Lucene.Net.Store.IndexInput"/> methods </summary>
        </member>
        <member name="T:Lucene.Net.Store.SimpleFSLockFactory">
             <summary>
             <para>Implements <see cref="T:Lucene.Net.Store.LockFactory"/> using 
             <see cref="M:System.IO.File.WriteAllText(System.String,System.String,System.Text.Encoding)"/> 
             (writes the file with UTF8 encoding and no byte order mark).</para>
            
             <para>Special care needs to be taken if you change the locking
             implementation: First be certain that no writer is in fact
             writing to the index otherwise you can easily corrupt
             your index. Be sure to do the <see cref="T:Lucene.Net.Store.LockFactory"/> change to all Lucene
             instances and clean up all leftover lock files before starting
             the new configuration for the first time. Different implementations
             can not work together!</para>
            
             <para>If you suspect that this or any other <see cref="T:Lucene.Net.Store.LockFactory"/> is
             not working properly in your environment, you can easily
             test it by using <see cref="T:Lucene.Net.Store.VerifyingLockFactory"/>, 
             <see cref="T:Lucene.Net.Store.LockVerifyServer"/> and <see cref="T:Lucene.Net.Store.LockStressTest"/>.</para>
             </summary>
             <seealso cref="T:Lucene.Net.Store.LockFactory"/>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor">
            <summary>
            Create a <see cref="T:Lucene.Net.Store.SimpleFSLockFactory"/> instance, with <c>null</c> (unset)
            lock directory. When you pass this factory to a <see cref="T:Lucene.Net.Store.FSDirectory"/>
            subclass, the lock directory is automatically set to the
            directory itself. Be sure to create one instance for each directory
            your create!
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Instantiate using the provided directory (as a <see cref="T:System.IO.DirectoryInfo"/> instance). </summary>
            <param name="lockDir"> where lock files should be created. </param>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor(System.String)">
            <summary>
            Instantiate using the provided directory name (<see cref="T:System.String"/>). </summary>
            <param name="lockDirName"> where lock files should be created. </param>
        </member>
        <member name="T:Lucene.Net.Store.SingleInstanceLockFactory">
            <summary>
            Implements <see cref="T:Lucene.Net.Store.LockFactory"/> for a single in-process instance,
            meaning all locking will take place through this one instance.
            Only use this <see cref="T:Lucene.Net.Store.LockFactory"/> when you are certain all
            <see cref="T:Lucene.Net.Index.IndexReader"/>s and <see cref="T:Lucene.Net.Index.IndexWriter"/>s for a given index are running
            against a single shared in-process <see cref="T:Lucene.Net.Store.Directory"/> instance.  This is
            currently the default locking for <see cref="T:Lucene.Net.Store.RAMDirectory"/>.
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockFactory"/>
        </member>
        <member name="T:Lucene.Net.Store.TrackingDirectoryWrapper">
            <summary>
            A delegating <see cref="T:Lucene.Net.Store.Directory"/> that records which files were
            written to and deleted.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.VerifyingLockFactory">
            <summary>
            A <see cref="T:Lucene.Net.Store.LockFactory"/> that wraps another 
            <see cref="T:Lucene.Net.Store.LockFactory"/> and verifies that each lock obtain/release
            is "correct" (never results in two processes holding the
            lock at the same time).  It does this by contacting an
            external server (<see cref="T:Lucene.Net.Store.LockVerifyServer"/>) to assert that
            at most one process holds the lock at a time.  To use
            this, you should also run <see cref="T:Lucene.Net.Store.LockVerifyServer"/> on the
            host &amp; port matching what you pass to the constructor.
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockVerifyServer"/>
            <seealso cref="T:Lucene.Net.Store.LockStressTest"/>
        </member>
        <member name="M:Lucene.Net.Store.VerifyingLockFactory.#ctor(Lucene.Net.Store.LockFactory,System.IO.Stream)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Store.VerifyingLockFactory"/> instance.
            </summary>
            <param name="lf"> the <see cref="T:Lucene.Net.Store.LockFactory"/> that we are testing </param>
            <param name="stream"> the socket's stream input/output to <see cref="T:Lucene.Net.Store.LockVerifyServer"/> </param>
        </member>
        <member name="M:Lucene.Net.Support.Arrays.Equals``1(``0[],``0[])">
            <summary>
            Compares the entire members of one array whith the other one.
            </summary>
            <param name="a">The array to be compared.</param>
            <param name="b">The array to be compared with.</param>
            <returns>Returns true if the two specified arrays of Objects are equal
            to one another. The two arrays are considered equal if both arrays
            contain the same number of elements, and all corresponding pairs of
            elements in the two arrays are equal. Two objects e1 and e2 are
            considered equal if (e1==null ? e2==null : e1.Equals(e2)). In other
            words, the two arrays are equal if they contain the same elements in
            the same order. Also, two array references are considered equal if
            both are null.
            <para/>
            Note that if the type of <typeparam name="T"/> is a <see cref="T:System.Collections.Generic.IDictionary`2"/>,
            <see cref="T:System.Collections.Generic.IList`1"/>, or <see cref="T:System.Collections.Generic.ISet`1"/>, its values and any nested collection values
            will be compared for equality as well.
            </returns>
        </member>
        <member name="M:Lucene.Net.Support.Arrays.GetHashCode``1(``0[])">
            <summary>
            Returns a hash code based on the contents of the given array. For any two
            <typeparamref name="T"/> arrays <c>a</c> and <c>b</c>, if
            <c>Arrays.Equals(b)</c> returns <c>true</c>, it means
            that the return value of <c>Arrays.GetHashCode(a)</c> equals <c>Arrays.GetHashCode(b)</c>.
            </summary>
            <typeparam name="T">The array element type.</typeparam>
            <param name="array">The array whose hash code to compute.</param>
            <returns>The hash code for <paramref name="array"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.Arrays.Fill``1(``0[],``0)">
            <summary>
            Assigns the specified value to each element of the specified array.
            </summary>
            <typeparam name="T">the type of the array</typeparam>
            <param name="a">the array to be filled</param>
            <param name="val">the value to be stored in all elements of the array</param>
        </member>
        <member name="M:Lucene.Net.Support.Arrays.Fill``1(``0[],System.Int32,System.Int32,``0)">
            <summary>
            Assigns the specified long value to each element of the specified
            range of the specified array of longs.  The range to be filled
            extends from index <paramref name="fromIndex"/>, inclusive, to index
            <paramref name="toIndex"/>, exclusive.  (If <c>fromIndex==toIndex</c>, the
            range to be filled is empty.)
            </summary>
            <typeparam name="T">the type of the array</typeparam>
            <param name="a">the array to be filled</param>
            <param name="fromIndex">
            the index of the first element (inclusive) to be
            filled with the specified value
            </param>
            <param name="toIndex">
            the index of the last element (exclusive) to be
            filled with the specified value
            </param>
            <param name="val">the value to be stored in all elements of the array</param>
            <exception cref="T:System.ArgumentException">if <c>fromIndex &gt; toIndex</c></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">if <c>fromIndex &lt; 0</c> or <c>toIndex &gt; a.Length</c></exception>
        </member>
        <member name="M:Lucene.Net.Support.Arrays.ToString``1(``0[])">
            <summary>
            Creates a <see cref="T:System.String"/> representation of the array passed.
            The result is surrounded by brackets <c>"[]"</c>, each
            element is converted to a <see cref="T:System.String"/> via the
            <see cref="P:J2N.Text.StringFormatter.InvariantCulture"/> and separated by <c>", "</c>. If
            the array is <c>null</c>, then <c>"null"</c> is returned.
            </summary>
            <typeparam name="T">The type of array element.</typeparam>
            <param name="array"></param>
        </member>
        <member name="T:Lucene.Net.Support.AssemblyUtils">
            <summary>
            Methods for working with Assemblies.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.AssemblyUtils.GetReferencedAssemblies">
            <summary>
            Gets a list of the host assembly's referenced assemblies excluding 
            any Microsoft, System, or Mono prefixed assemblies or assemblies with
            official Microsoft key hashes. Essentially, we get a list of all non
            Microsoft assemblies here.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.AssemblyUtils.DotNetFrameworkFilter">
            <summary>
            Assembly filter logic from:
            https://raw.githubusercontent.com/Microsoft/dotnet-apiport/master/src/Microsoft.Fx.Portability/Analyzer/DotNetFrameworkFilter.cs
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.AssemblyUtils.DotNetFrameworkFilter.s_microsoftKeys">
            <summary>
            These keys are a collection of public key tokens derived from all the reference assemblies in
            "%ProgramFiles%\Reference Assemblies\Microsoft" on a Windows 10 machine with VS 2015 installed
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.AssemblyUtils.DotNetFrameworkFilter.IsFrameworkAssembly(System.Reflection.Assembly)">
            <summary>
            Gets a best guess as to whether this assembly is a .NET Framework assembly or not.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.AssemblyUtils.DotNetFrameworkFilter.IsFrameworkAssembly(System.Reflection.AssemblyName)">
            <summary>
            Gets a best guess as to whether this assembly is a .NET Framework assembly or not.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.BitArrayExtensions">
            <summary>
            This class provides supporting methods of java.util.BitSet
            that are not present in System.Collections.BitArray.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.NextSetBit(System.Collections.BitArray,System.Int32)">
            <summary>
            Returns the next set bit at or after index, or -1 if no such bit exists.
            </summary>
            <param name="bitArray"></param>
            <param name="index">the index of bit array at which to start checking</param>
            <returns>the next set bit or -1</returns>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.NextClearBit(System.Collections.BitArray,System.Int32)">
            <summary>
            Returns the next un-set bit at or after index, or -1 if no such bit exists.
            </summary>
            <param name="bitArray"></param>
            <param name="index">the index of bit array at which to start checking</param>
            <returns>the next set bit or -1</returns>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.Cardinality(System.Collections.BitArray)">
            <summary>
            Returns the number of bits set to <c>true</c> in this <see cref="T:System.Collections.BitArray"/>.
            </summary>
            <param name="bits">This <see cref="T:System.Collections.BitArray"/>.</param>
            <returns>The number of bits set to true in this <see cref="T:System.Collections.BitArray"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.Set(System.Collections.BitArray,System.Int32)">
            <summary>
            Sets the bit at the given <paramref name="index"/> to true.
            </summary>
            <param name="bits">The BitArray object.</param>
            <param name="index">The position to set to true.</param>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.Set(System.Collections.BitArray,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets the bit at the given index range to true.
            </summary>
            <param name="bits">The BitArray object.</param>
            <param name="fromIndex">The start of the range to set(inclusive)</param>
            <param name="toIndex">The end of the range to set(exclusive)</param>
            <param name="value">the value to set to the range</param>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.Clear(System.Collections.BitArray,System.Int32)">
            <summary>
            Sets the bit at the given <paramref name="index"/> to false.
            </summary>
            <param name="bits">The BitArray object.</param>
            <param name="index">The position to set to false.</param>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.Clear(System.Collections.BitArray)">
            <summary>
            Sets all bits to false
            </summary>
            <param name="bits">The BitArray object.</param>
        </member>
        <member name="M:Lucene.Net.Support.Collections.ToString``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            This is the same implementation of ToString from Java's AbstractCollection
            (the default implementation for all sets and lists)
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Collections.ToString``1(System.Collections.Generic.ICollection{``0},System.Globalization.CultureInfo)">
            <summary>
            This is the same implementation of ToString from Java's AbstractCollection
            (the default implementation for all sets and lists), plus the ability
            to specify culture for formatting of nested numbers and dates. Note that
            this overload will change the culture of the current thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Collections.ToString``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            This is the same implementation of ToString from Java's AbstractMap
            (the default implementation for all dictionaries)
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Collections.ToString``2(System.Collections.Generic.IDictionary{``0,``1},System.Globalization.CultureInfo)">
            <summary>
            This is the same implementation of ToString from Java's AbstractMap
            (the default implementation for all dictionaries), plus the ability
            to specify culture for formatting of nested numbers and dates. Note that
            this overload will change the culture of the current thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Collections.ToString(System.Object)">
            <summary>
            This is a helper method that assists with recursively building
            a string of the current collection and all nested collections.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Collections.ToString(System.Object,System.Globalization.CultureInfo)">
            <summary>
            This is a helper method that assists with recursively building
            a string of the current collection and all nested collections, plus the ability
            to specify culture for formatting of nested numbers and dates. Note that
            this overload will change the culture of the current thread.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.Collections.ReverseComparer2`1.cmp">
             The comparer specified in the static factory.  This will never
             be null, as the static factory returns a ReverseComparer
             instance if its argument is null.
            
             @serial
        </member>
        <member name="T:Lucene.Net.Support.ConcurrentHashSet`1">
            <summary>
            Represents a thread-safe hash-based unique collection.
            </summary>
            <typeparam name="T">The type of the items in the collection.</typeparam>
            <remarks>
            All public members of <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
        </member>
        <member name="P:Lucene.Net.Support.ConcurrentHashSet`1.Count">
            <summary>
            Gets the number of items contained in the <see
            cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>.
            </summary>
            <value>The number of items contained in the <see
            cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>.</value>
            <remarks>Count has snapshot semantics and represents the number of items in the <see
            cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>
            at the moment when Count was accessed.</remarks>
        </member>
        <member name="P:Lucene.Net.Support.ConcurrentHashSet`1.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/> is empty.
            </summary>
            <value>true if the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/> is empty; otherwise,
            false.</value>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentHashSet`1.#ctor">
            <summary>
            Initializes a new instance of the <see
            cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>
            class that is empty, has the default concurrency level, has the default initial capacity, and
            uses the default comparer for the item type.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentHashSet`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see
            cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>
            class that is empty, has the specified concurrency level and capacity, and uses the default
            comparer for the item type.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the
            <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/> concurrently.</param>
            <param name="capacity">The initial number of elements that the <see
            cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>
            can contain.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="concurrencyLevel"/> is
            less than 1.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> <paramref name="capacity"/> is less than
            0.</exception>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>
            class that contains elements copied from the specified <see
            cref="T:System.Collections.IEnumerable{T}"/>, has the default concurrency
            level, has the default initial capacity, and uses the default comparer for the item type.
            </summary>
            <param name="collection">The <see
            cref="T:System.Collections.IEnumerable{T}"/> whose elements are copied to
            the new
            <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is a null reference.</exception>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentHashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>
            class that is empty, has the specified concurrency level and capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer{T}"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{T}"/>
            implementation to use when comparing items.</param>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>
            class that contains elements copied from the specified <see
            cref="T:System.Collections.IEnumerable"/>, has the default concurrency level, has the default
            initial capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer{T}"/>.
            </summary>
            <param name="collection">The <see
            cref="T:System.Collections.IEnumerable{T}"/> whose elements are copied to
            the new
            <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{T}"/>
            implementation to use when comparing items.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is a null reference
            (Nothing in Visual Basic).
            </exception>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentHashSet`1.#ctor(System.Int32,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/> 
            class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable"/>, 
            has the specified concurrency level, has the specified initial capacity, and uses the specified 
            <see cref="T:System.Collections.Generic.IEqualityComparer{T}"/>.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the 
            <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/> concurrently.</param>
            <param name="collection">The <see cref="T:System.Collections.IEnumerable{T}"/> whose elements are copied to the new 
            <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{T}"/> implementation to use 
            when comparing items.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="collection"/> is a null reference.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="concurrencyLevel"/> is less than 1.
            </exception>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentHashSet`1.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>
            class that is empty, has the specified concurrency level, has the specified initial capacity, and
            uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer{T}"/>.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the
            <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/> concurrently.</param>
            <param name="capacity">The initial number of elements that the <see
            cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>
            can contain.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{T}"/>
            implementation to use when comparing items.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="concurrencyLevel"/> is less than 1. -or-
            <paramref name="capacity"/> is less than 0.
            </exception>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentHashSet`1.Add(`0)">
            <summary>
            Adds the specified item to the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>.
            </summary>
            <param name="item">The item to add.</param>
            <returns>true if the items was added to the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>
            successfully; false if it already exists.</returns>
            <exception cref="T:System.OverflowException">The <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>
            contains too many items.</exception>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentHashSet`1.Clear">
            <summary>
            Removes all items from the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentHashSet`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/> contains the specified
            item.
            </summary>
            <param name="item">The item to locate in the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>.</param>
            <returns>true if the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/> contains the item; otherwise, false.</returns>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentHashSet`1.TryRemove(`0)">
            <summary>
            Attempts to remove the item from the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>true if an item was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentHashSet`1.GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see
            cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>.</summary>
            <returns>An enumerator for the <see cref="T:Lucene.Net.Support.ConcurrentHashSet`1"/>.</returns>
            <remarks>
            The enumerator returned from the collection is safe to use concurrently with
            reads and writes to the collection, however it does not represent a moment-in-time snapshot
            of the collection.  The contents exposed through the enumerator may contain modifications
            made to the collection after <see cref="M:Lucene.Net.Support.ConcurrentHashSet`1.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentSet`1.Equals(System.Object,System.Collections.IEqualityComparer)">
            <summary>
            Determines whether the specified object is structurally equal to the current set
            using rules provided by the specified <paramref name="comparer"/>.
            </summary>
            <param name="other">The object to compare with the current object.</param>
            <param name="comparer">The <see cref="T:System.Collections.IEqualityComparer"/> implementation to use to determine
            whether the current object and <paramref name="other"/> are structurally equal.</param>
            <returns><c>true</c> if <paramref name="other"/> is structurally equal to the current set;
            otherwise, <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="comparer"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentSet`1.GetHashCode(System.Collections.IEqualityComparer)">
            <summary>
            Gets the hash code representing the current set using rules specified by the
            provided <paramref name="comparer"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.IEqualityComparer"/> implementation to use to generate
            the hash code.</param>
            <returns>A hash code representing the current set.</returns>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentSet`1.Equals(System.Object)">
            <summary>
            Determines whether the specified object is structurally equal to the current set
            using rules similar to those in the JDK's AbstactSet class. Two sets are considered
            equal when they both contain the same objects (in any order).
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns><c>true</c> if the specified object implements <see cref="T:System.Collections.Generic.ISet`1"/>
            and it contains the same elements; otherwise, <c>false</c>.</returns>
            <seealso cref="M:Lucene.Net.Support.ConcurrentSet`1.Equals(System.Object,System.Collections.IEqualityComparer)"/>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentSet`1.GetHashCode">
            <summary>
            Gets the hash code for the current list. The hash code is calculated 
            by taking each nested element's hash code into account.
            </summary>
            <returns>A hash code for the current object.</returns>
            <seealso cref="M:Lucene.Net.Support.ConcurrentSet`1.GetHashCode(System.Collections.IEqualityComparer)"/>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentSet`1.ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns a string that represents the current set using the specified
            <paramref name="format"/> and <paramref name="formatProvider"/>.
            </summary>
            <returns>A string that represents the current set.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="format"/> is <c>null</c>.</exception>
            <exception cref="T:System.FormatException">
            <paramref name="format"/> is invalid.
            <para/>
            -or-
            <para/>
            The index of a format item is not zero.
            </exception>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentSet`1.ToString">
            <summary>
            Returns a string that represents the current set using
            <see cref="P:J2N.Text.StringFormatter.CurrentCulture"/>.
            <para/>
            The presentation has a specific format. It is enclosed by square
            brackets ("[]"). Elements are separated by ', ' (comma and space).
            </summary>
            <returns>A string that represents the current set.</returns>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentSet`1.ToString(System.IFormatProvider)">
            <summary>
            Returns a string that represents the current set using the specified
            <paramref name="formatProvider"/>.
            </summary>
            <returns>A string that represents the current set.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="formatProvider"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.ConcurrentSet`1.ToString(System.String)">
            <summary>
            Returns a string that represents the current set using the specified
            <paramref name="format"/> and <see cref="P:J2N.Text.StringFormatter.CurrentCulture"/>.
            <para/>
            The presentation has a specific format. It is enclosed by square
            brackets ("[]"). Elements are separated by ', ' (comma and space).
            </summary>
            <returns>A string that represents the current set.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="format"/> is <c>null</c>.</exception>
            <exception cref="T:System.FormatException">
            <paramref name="format"/> is invalid.
            <para/>
            -or-
            <para/>
            The index of a format item is not zero.
            </exception>
        </member>
        <member name="M:Lucene.Net.Support.DictionaryExtensions.AsConcurrent``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns a concurrent wrapper for the current <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the dictionary.</typeparam>
            <param name="dictionary">The collection to make concurrent (thread-safe).</param>
            <returns>An object that acts as a read-only wrapper around the current <see cref="T:System.Collections.Generic.ISet`1"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> is <c>null</c>.</exception>
            <remarks>
            To synchronize any modifications to the <see cref="T:System.Collections.Generic.ISet`1"/> object, expose it only through this wrapper.
            <para/>
            The set returned uses simple locking and may not be the most performant solution, but it provides a quick
            way to make any set thread-safe.
            <para/>
            This method is an O(1) operation.
            </remarks>
        </member>
        <member name="T:Lucene.Net.Support.EnumerableExtensions">
            <summary>
            .NET Specific Helper Extensions for IEnumerable
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.EnumerableExtensions.InPairs``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``1})">
            <summary>
            Enumerates a sequence in pairs  
            </summary>
            <remarks>
            In the case of an uneven amount of elements, the list call to <paramref name="join" /> pases <code>default(T)</code> as the second parameter.
            </remarks>
            <typeparam name="T">The type of the elements of <paramref name="source" />.</typeparam>
            <typeparam name="TOut">The type of the elements returned from <paramref name="join" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to enumerate in pairs.</param>
            <param name="join">A function that is invoked for each pair of elements.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> or <paramref name="join" /> is <see langword="null" />.</exception>
            <returns>A new <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing the results from each pair.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EnumerableExtensions.TakeAllButLast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Take all but the last element of the sequence.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">This <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</param>
            <returns>The resulting <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EnumerableExtensions.TakeAllButLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Take all but the last <paramref name="n"/> elements of the sequence.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">This <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</param>
            <param name="n">The number of elements at the end of the sequence to exclude.</param>
            <returns>The resulting <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="T:Lucene.Net.Support.ExceptionToClassNameConventionAttribute">
            <summary>
            Use this attribute to make an exception to the class naming rules (which should not be named like Interfaces).
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.ExceptionToNetNumericConventionAttribute">
            <summary>
            Properties, methods, or events marked with this attribute can ignore
            the numeric naming conventions of "Int16", "Int32", "Int64", and "Single"
            that are commonly used in .NET method and property names.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.ExceptionToNullableEnumConventionAttribute">
            <summary>
            Use this attribute to make an exception to the nullable enum rule.
            Some of these cannot be avoided.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IChecksum">
            <summary>
            Contains conversion support elements such as classes, interfaces and static methods.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.FileSupport">
            <summary>
            Represents the methods to support some operations over files.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.FileSupport.CreateTempFile(System.String,System.String)">
            <summary>
            Creates a new empty file in a random subdirectory of <see cref="M:System.IO.Path.GetTempPath"/>, using the given prefix and 
            suffix strings to generate its name.
            </summary>
            <remarks>
            If this method returns successfully then it is guaranteed that:
            <list type="number">
            <item><description>The file denoted by the returned abstract pathname did not exist before this method was invoked, and</description></item>
            <item><description>Neither this method nor any of its variants will return the same abstract pathname again in the current invocation of the virtual machine.</description></item>
            </list>
            This method provides only part of a temporary-file facility. However, the file will not be deleted automatically, 
            it must be deleted by the caller.
            <para/>
            The prefix argument must be at least three characters long. It is recommended that the prefix be a short, meaningful 
            string such as "hjb" or "mail". 
            <para/>
            The suffix argument may be null, in which case a random suffix will be used.
            <para/>
            Both prefix and suffix must be provided with valid characters for the underlying system, as specified by 
            <see cref="M:System.IO.Path.GetInvalidFileNameChars"/>.
            <para/>
            If the directory argument is null then the system-dependent default temporary-file directory will be used, 
            with a random subdirectory name. The default temporary-file directory is specified by the 
            <see cref="M:System.IO.Path.GetTempPath"/> method. On UNIX systems the default value of this property is typically 
            "/tmp" or "/var/tmp"; on Microsoft Windows systems it is typically "C:\\Users\\[UserName]\\AppData\Local\Temp".
            </remarks>
            <param name="prefix">The prefix string to be used in generating the file's name; must be at least three characters long</param>
            <param name="suffix">The suffix string to be used in generating the file's name; may be null, in which case a random suffix will be generated</param>
            <returns>A <see cref="T:System.IO.FileInfo"/> instance representing the temp file that was created.</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.FileSupport.CreateTempFile(System.String,System.String,System.IO.DirectoryInfo)">
            <summary>
            Creates a new empty file in the specified directory, using the given prefix and suffix strings to generate its name.
            </summary>
            <remarks>
            If this method returns successfully then it is guaranteed that:
            <list type="number">
            <item><description>The file denoted by the returned abstract pathname did not exist before this method was invoked, and</description></item>
            <item><description>Neither this method nor any of its variants will return the same abstract pathname again in the current invocation of the virtual machine.</description></item>
            </list>
            This method provides only part of a temporary-file facility. However, the file will not be deleted automatically, 
            it must be deleted by the caller.
            <para/>
            The prefix argument must be at least three characters long. It is recommended that the prefix be a short, meaningful 
            string such as "hjb" or "mail". 
            <para/>
            The suffix argument may be null, in which case a random suffix will be used.
            <para/>
            Both prefix and suffix must be provided with valid characters for the underlying system, as specified by 
            <see cref="M:System.IO.Path.GetInvalidFileNameChars"/>.
            <para/>
            If the directory argument is null then the system-dependent default temporary-file directory will be used, 
            with a random subdirectory name. The default temporary-file directory is specified by the 
            <see cref="M:System.IO.Path.GetTempPath"/> method. On UNIX systems the default value of this property is typically 
            "/tmp" or "/var/tmp"; on Microsoft Windows systems it is typically "C:\\Users\\[UserName]\\AppData\Local\Temp".
            </remarks>
            <param name="prefix">The prefix string to be used in generating the file's name; must be at least three characters long</param>
            <param name="suffix">The suffix string to be used in generating the file's name; may be null, in which case a random suffix will be generated</param>
            <param name="directory">The directory in which the file is to be created, or null if the default temporary-file directory is to be used</param>
            <returns>A <see cref="T:System.IO.FileInfo"/> instance representing the temp file that was created.</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.FileSupport.IsFileAlreadyExistsException(System.Exception,System.String)">
            <summary>
            Tests whether the passed in <see cref="T:System.Exception"/> is an <see cref="T:System.IO.IOException"/>
            corresponding to the underlying operating system's "File Already Exists" violation.
            This works by forcing the exception to occur during initialization and caching the
            <see cref="P:System.Exception.HResult"/> value for the current OS.
            </summary>
            <param name="ex">An exception, for comparison.</param>
            <param name="filePath">The path of the file to check. This is used as a fallback in case the
            current OS doesn't have an HResult (an edge case).</param>
            <returns><c>true</c> if the exception passed is an <see cref="T:System.IO.IOException"/> with an 
            <see cref="P:System.Exception.HResult"/> corresponding to the operating system's "File Already Exists" violation, which
            occurs when an attempt is made to create a file that already exists.</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.FileSupport.NewTempFileName(System.String,System.String,System.IO.DirectoryInfo)">
            <summary>
            Generates a new random file name with the provided <paramref name="directory"/>, 
            <paramref name="prefix"/> and optional <paramref name="suffix"/>.
            </summary>
            <param name="prefix">The prefix string to be used in generating the file's name</param>
            <param name="suffix">The suffix string to be used in generating the file's name; may be null, in which case a random suffix will be generated</param>
            <param name="directory">A <see cref="T:System.IO.DirectoryInfo"/> object containing the temp directory path. Must not be null.</param>
            <returns>A random file name</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.FileSupport.GetCanonicalPath(System.IO.FileSystemInfo)">
            <summary>
            Returns the absolute path of this <see cref="T:System.IO.FileSystemInfo"/> with all references resolved and
            any drive letters normalized to upper case on Windows. An
            <em>absolute</em> path is one that begins at the root of the file
            system. The canonical path is one in which all references have been
            resolved. For the cases of '..' and '.', where the file system supports
            parent and working directory respectively, these are removed and replaced
            with a direct directory reference. 
            </summary>
            <param name="path">This <see cref="T:System.IO.FileSystemInfo"/> instance.</param>
            <returns>The canonical path of this file.</returns>
        </member>
        <member name="T:Lucene.Net.Support.IO.SafeTextWriterWrapper">
            <summary>
            Decorates a <see cref="T:System.IO.TextWriter"/> instance and
            makes no assumptions about whether <see cref="M:System.IDisposable.Dispose"/>
            has been called on the inner instance or not. Acts like a circuit breaker -
            the first <see cref="T:System.ObjectDisposedException"/> caught turns it off and
            the rest of the calls are ignored after that point until <see cref="M:Lucene.Net.Support.IO.SafeTextWriterWrapper.Reset"/>
            is called.
            <para/>
            The primary purpose is for using a <see cref="T:System.IO.TextWriter"/> instance within a non-disposable
            parent object. Since the creator of the <see cref="T:System.IO.TextWriter"/> ultimately is responsible for
            disposing it, our non-disposable object has no way of knowing whether it is safe to use the <see cref="T:System.IO.TextWriter"/>.
            Wraping the <see cref="T:System.IO.TextWriter"/> within a <see cref="T:Lucene.Net.Support.IO.SafeTextWriterWrapper"/> ensures the
            non-disposable object can continue to make calls to the <see cref="T:System.IO.TextWriter"/> without raising
            exceptions (it is presumed that the <see cref="T:System.IO.TextWriter"/> functionality is optional).
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.StreamExtensions">
            <summary>
            Extension methods that make a <see cref="T:System.IO.Stream"/> effectively into a
            binary serializer with no encoding. We simply convert types into bytes
            and write them without any concern whether surrogate pairs are respected,
            similar to what BinaryFormatter does.
            This makes it possible to serialize/deserialize raw character arrays
            and get the data back in the same order without any exceptions warning
            that the order is not valid and without the need for BinaryFormatter.
            <para/>
            Byte order is little-endian (same as <see cref="T:System.IO.BinaryReader"/> and <see cref="T:System.IO.BinaryWriter"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.StreamExtensions.Read(System.IO.Stream,J2N.IO.ByteBuffer,System.Int64)">
            <summary>
            Reads a sequence of bytes from a <see cref="T:System.IO.Stream"/> to the given <see cref="T:J2N.IO.ByteBuffer"/>, starting at the given position.
            The <paramref name="stream"/> must be both seekable and readable.
            </summary>
            <param name="stream">The stream to read.</param>
            <param name="destination">The <see cref="T:J2N.IO.ByteBuffer"/> to write to.</param>
            <param name="position">The file position at which the transfer is to begin; must be non-negative.</param>
            <returns>The number of bytes read, possibly zero.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> or <paramref name="destination"/> is <c>null</c></exception>
            <exception cref="T:System.NotSupportedException">
            <paramref name="stream"/> is not readable.
            <para/>
            -or-
            <para/>
            <paramref name="stream"/> is not seekable.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="position"/> is less than 0.
            <para/>
            -or-
            <para/>
            <paramref name="position"/> is greater than the <see cref="P:System.IO.Stream.Length"/> of the stream.
            </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <exception cref="T:System.ObjectDisposedException"><paramref name="stream"/> has already been disposed.</exception>
            <remarks>
            This method is atomic when used by itself, but does not synchronize with the rest of the stream methods.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Support.ListExtensions.BinarySearch``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Performs a binary search for the specified element in the specified
            sorted list. The list needs to be already sorted in natural sorting
            order. Searching in an unsorted array has an undefined result. It's also
            undefined which element is found if there are multiple occurrences of the
            same element.
            </summary>
            <typeparam name="T">The element type. Must implement <see cref="T:System.IComparable`1"/>"/>.</typeparam>
            <param name="list">The sorted list to search.</param>
            <param name="item">The element to find.</param>
            <returns>The non-negative index of the element, or a negative index which
            is the <c>-index - 1</c> where the element would be inserted.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.ListExtensions.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IComparer{``0})">
            <summary>
            Performs a binary search for the specified element in the specified
            sorted list using the specified comparator. The list needs to be already
            sorted according to the <paramref name="comparer"/> passed. Searching in an unsorted array
            has an undefined result. It's also undefined which element is found if
            there are multiple occurrences of the same element.
            </summary>
            <typeparam name="T">The element type. Must implement <see cref="T:System.IComparable`1"/>"/>.</typeparam>
            <param name="list">The sorted <see cref="T:System.Collections.Generic.IList`1"/> to search.</param>
            <param name="item">The element to find.</param>
            <param name="comparer">The comparer. If the comparer is <c>null</c> then the
            search uses the objects' natural ordering.</param>
            <returns>the non-negative index of the element, or a negative index which
            is the <c>-index - 1</c> where the element would be inserted.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.SubList`1.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>
            Creates a ranged view of the given <paramref name="list"/>.
            </summary>
            <param name="list">The original list to view.</param>
            <param name="fromIndex">The inclusive starting index.</param>
            <param name="toIndex">The exclusive ending index.</param>
        </member>
        <member name="T:Lucene.Net.Support.Number">
            <summary>
            A simple class for number conversions.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.Number.MIN_RADIX">
            <summary>
            Min radix value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.Number.MAX_RADIX">
            <summary>
            Max radix value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Number.ToString(System.Single)">
            <summary>
            Converts a number to System.String.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.Parse(System.String,System.Int32)">
            <summary>
            Parses a number in the specified radix.
            </summary>
            <param name="s">An input System.String.</param>
            <param name="radix">A radix.</param>
            <returns>The parsed number in the specified radix.</returns>
        </member>
        <member name="M:Lucene.Net.Support.SetExtensions.AsConcurrent``1(System.Collections.Generic.ISet{``0})">
            <summary>
            Returns a concurrent wrapper for the current <see cref="T:System.Collections.Generic.ISet`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
            <param name="set">The collection to make concurrent (thread-safe).</param>
            <returns>An object that acts as a read-only wrapper around the current <see cref="T:System.Collections.Generic.ISet`1"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="set"/> is <c>null</c>.</exception>
            <remarks>
            To synchronize any modifications to the <see cref="T:System.Collections.Generic.ISet`1"/> object, expose it only through this wrapper.
            <para/>
            The set returned uses simple locking and may not be the most performant solution, but it provides a quick
            way to make any set thread-safe. A synchronization object is exposed through the <see cref="P:System.Collections.ICollection.SyncRoot"/>
            property that can be used for external synchronization.
            <para/>
            This method is an O(1) operation.
            </remarks>
        </member>
        <member name="T:Lucene.Net.Support.Threading.LimitedConcurrencyLevelTaskScheduler">
            <summary>
            Provides a task scheduler that ensures a maximum concurrency level while 
            running on top of the thread pool.
            
            Source: https://msdn.microsoft.com/en-us/library/system.threading.tasks.taskscheduler(v=vs.110).aspx
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.Threading.ReaderWriterLockSlimExtensions">
            <summary>
            Extensions to help obtain/release from a ReaderWriterSlimLock.
            Taken from:
            http://stackoverflow.com/questions/170028/how-would-you-simplify-entering-and-exiting-a-readerwriterlock
            
            LUCENENET specific
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.WeakDictionary`2.WeakKey`1">
            <summary>
            A weak reference wrapper for the hashtable keys. Whenever a key\value pair
            is added to the hashtable, the key is wrapped using a WeakKey. WeakKey saves the
            value of the original object hashcode for fast comparison.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.WritableArrayAttribute">
            <summary>
            Attribute to define a property or method as a writable array.
            Per MSDN, members should never return arrays because the array contents
            can be updated, which makes the behavior confusing. However,
            Lucene's design sometimes relies on other classes to update arrays -
            both as array fields and as methods that return arrays. So, in these
            cases we are making an exception to this rule and marking them with
            <see cref="T:Lucene.Net.Support.WritableArrayAttribute"/> to signify that this is intentional.
            <para/>
            For properties that violate this rule, you should also use
            the <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute"/>:
            <code>
            [WritableArray, SuppressMessage("Microsoft.Performance", "CA1819", Justification = "Lucene's design requires some writable array properties")]
            </code>
            </summary>
        </member>
        <member name="T:Lucene.Net.Configuration.ConfigurationBuilder">
            <summary>
            Used to build key/value based configuration settings for use in an application.
            </summary>
        </member>
        <member name="P:Lucene.Net.Configuration.ConfigurationBuilder.Sources">
            <summary>
            Returns the sources used to obtain configuration values.
            </summary>
        </member>
        <member name="P:Lucene.Net.Configuration.ConfigurationBuilder.Properties">
            <summary>
            Gets a key/value collection that can be used to share data between the <see cref="T:Microsoft.Extensions.Configuration.IConfigurationBuilder"/>
            and the registered <see cref="T:Microsoft.Extensions.Configuration.IConfigurationProvider"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationBuilder.Add(Microsoft.Extensions.Configuration.IConfigurationSource)">
            <summary>
            Adds a new configuration source.
            </summary>
            <param name="source">The configuration source to add.</param>
            <returns>The same <see cref="T:Microsoft.Extensions.Configuration.IConfigurationBuilder"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationBuilder.Build">
            <summary>
            Builds an <see cref="T:Microsoft.Extensions.Configuration.IConfiguration"/> with keys and values from the set of providers registered in
            <see cref="P:Lucene.Net.Configuration.ConfigurationBuilder.Sources"/>.
            </summary>
            <returns>An <see cref="T:Microsoft.Extensions.Configuration.IConfigurationRoot"/> with keys and values from the registered providers.</returns>
        </member>
        <member name="T:Lucene.Net.Configuration.ConfigurationProvider">
            <summary>
            Base helper class for implementing an <see cref="T:Microsoft.Extensions.Configuration.IConfigurationProvider"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationProvider.#ctor">
            <summary>
            Initializes a new <see cref="T:Microsoft.Extensions.Configuration.IConfigurationProvider"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Configuration.ConfigurationProvider.Data">
            <summary>
            The configuration key value pairs for this provider.
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationProvider.TryGet(System.String,System.String@)">
            <summary>
            Attempts to find a value with the given key, returns true if one is found, false otherwise.
            </summary>
            <param name="key">The key to lookup.</param>
            <param name="value">The value found at key if one is found.</param>
            <returns>True if key has a value, false otherwise.</returns>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationProvider.Set(System.String,System.String)">
            <summary>
            Sets a value for a given key.
            </summary>
            <param name="key">The configuration key to set.</param>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationProvider.Load">
            <summary>
            Loads (or reloads) the data for this provider.
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationProvider.GetChildKeys(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Returns the list of keys that this provider has.
            </summary>
            <param name="earlierKeys">The earlier keys that other providers contain.</param>
            <param name="parentPath">The path for the parent IConfiguration.</param>
            <returns>The list of keys for this provider.</returns>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationProvider.GetReloadToken">
            <summary>
            Returns a <see cref="T:Microsoft.Extensions.Primitives.IChangeToken"/> that can be used to listen when this provider is reloaded.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationProvider.OnReload">
            <summary>
            Triggers the reload change token and creates a new one.
            </summary>
        </member>
        <member name="T:Lucene.Net.Configuration.ConfigurationReloadToken">
            <summary>
            Implements <see cref="T:Microsoft.Extensions.Primitives.IChangeToken"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Configuration.ConfigurationReloadToken.ActiveChangeCallbacks">
            <summary>
            Indicates if this token will proactively raise callbacks. Callbacks are still guaranteed to be invoked, eventually.
            </summary>
        </member>
        <member name="P:Lucene.Net.Configuration.ConfigurationReloadToken.HasChanged">
            <summary>
            Gets a value that indicates if a change has occurred.
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationReloadToken.RegisterChangeCallback(System.Action{System.Object},System.Object)">
            <summary>
            Registers for a callback that will be invoked when the entry has changed. <see cref="P:Microsoft.Extensions.Primitives.IChangeToken.HasChanged"/>
            MUST be set before the callback is invoked.
            </summary>
            <param name="callback">The callback to invoke.</param>
            <param name="state">State to be passed into the callback.</param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationReloadToken.OnReload">
            <summary>
            Used to trigger the change token when a reload occurs.
            </summary>
        </member>
        <member name="T:Lucene.Net.Configuration.ConfigurationRoot">
            <summary>
            The root node for a configuration.
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationRoot.#ctor(System.Collections.Generic.IList{Microsoft.Extensions.Configuration.IConfigurationProvider})">
            <summary>
            Initializes a Configuration root with a list of providers.
            </summary>
            <param name="providers">The <see cref="T:Microsoft.Extensions.Configuration.IConfigurationProvider"/>s for this configuration.</param>
        </member>
        <member name="P:Lucene.Net.Configuration.ConfigurationRoot.Providers">
            <summary>
            The <see cref="T:Microsoft.Extensions.Configuration.IConfigurationProvider"/>s for this configuration.
            </summary>
        </member>
        <member name="P:Lucene.Net.Configuration.ConfigurationRoot.Item(System.String)">
            <summary>
            Gets or sets the value corresponding to a configuration key.
            </summary>
            <param name="key">The configuration key.</param>
            <returns>The configuration value.</returns>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationRoot.GetChildren">
            <summary>
            Gets the immediate children sub-sections.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationRoot.GetReloadToken">
            <summary>
            Returns a <see cref="T:Microsoft.Extensions.Primitives.IChangeToken"/> that can be used to observe when this configuration is reloaded.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationRoot.GetSection(System.String)">
            <summary>
            Gets a configuration sub-section with the specified key.
            </summary>
            <param name="key">The key of the configuration section.</param>
            <returns>The <see cref="T:Microsoft.Extensions.Configuration.IConfigurationSection"/>.</returns>
            <remarks>
                This method will never return <c>null</c>. If no matching sub-section is found with the specified key,
                an empty <see cref="T:Microsoft.Extensions.Configuration.IConfigurationSection"/> will be returned.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationRoot.Reload">
            <summary>
            Force the configuration values to be reloaded from the underlying sources.
            </summary>
        </member>
        <member name="T:Lucene.Net.Configuration.ConfigurationSection">
            <summary>
            Represents a section of application configuration values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationSection.#ctor(Lucene.Net.Configuration.ConfigurationRoot,System.String)">
            <summary>
            Initializes a new instance.
            </summary>
            <param name="root">The configuration root.</param>
            <param name="path">The path to this section.</param>
        </member>
        <member name="P:Lucene.Net.Configuration.ConfigurationSection.Path">
            <summary>
            Gets the full path to this section from the <see cref="T:Microsoft.Extensions.Configuration.IConfigurationRoot"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Configuration.ConfigurationSection.Key">
            <summary>
            Gets the key this section occupies in its parent.
            </summary>
        </member>
        <member name="P:Lucene.Net.Configuration.ConfigurationSection.Value">
            <summary>
            Gets or sets the section value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Configuration.ConfigurationSection.Item(System.String)">
            <summary>
            Gets or sets the value corresponding to a configuration key.
            </summary>
            <param name="key">The configuration key.</param>
            <returns>The configuration value.</returns>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationSection.GetSection(System.String)">
            <summary>
            Gets a configuration sub-section with the specified key.
            </summary>
            <param name="key">The key of the configuration section.</param>
            <returns>The <see cref="T:Microsoft.Extensions.Configuration.IConfigurationSection"/>.</returns>
            <remarks>
                This method will never return <c>null</c>. If no matching sub-section is found with the specified key,
                an empty <see cref="T:Microsoft.Extensions.Configuration.IConfigurationSection"/> will be returned.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationSection.GetChildren">
            <summary>
            Gets the immediate descendant configuration sub-sections.
            </summary>
            <returns>The configuration sub-sections.</returns>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationSection.GetReloadToken">
            <summary>
            Returns a <see cref="T:Microsoft.Extensions.Primitives.IChangeToken"/> that can be used to observe when this configuration is reloaded.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Configuration.ConfigurationSettings">
            <summary>
            Provides access to the application's configuration settings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationSettings.SetConfigurationFactory(Lucene.Net.Configuration.IConfigurationFactory)">
            <summary>
            Sets the <see cref="T:Lucene.Net.Configuration.IConfigurationFactory"/> instance used to instantiate
            <see cref="T:Lucene.Net.Configuration.ConfigurationSettings"/> subclasses.
            </summary>
            <param name="configurationFactory">The new <see cref="T:Lucene.Net.Configuration.IConfigurationFactory"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="configurationFactory"/> parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Configuration.ConfigurationSettings.GetConfigurationFactory">
            <summary>
            Gets the associated <see cref="T:Lucene.Net.Configuration.IConfigurationFactory"/> factory.
            </summary>
            <returns>The <see cref="T:Lucene.Net.Configuration.IConfigurationFactory"/> factory.</returns>
        </member>
        <member name="P:Lucene.Net.Configuration.ConfigurationSettings.CurrentConfiguration">
            <summary>
            Returns the current configuration
            </summary>
        </member>
        <member name="T:Lucene.Net.Configuration.DefaultConfigurationFactory">
            <summary>
            The default implementation of <see cref="T:Lucene.Net.Configuration.IConfigurationFactory"/> that is used when
            the end user doesn't supply one. This implementation simply reads settings from
            environment variables.
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.DefaultConfigurationFactory.GetConfiguration">
            <summary>
            Returns the default configuration instance, creating it first if necessary.
            </summary>
            <returns>The default <see cref="T:Microsoft.Extensions.Configuration.IConfiguration"/> instance.</returns>
        </member>
        <member name="T:Lucene.Net.Configuration.IConfigurationFactory">
            <summary>
            Contract for extending the functionality of system properties by providing an application-defined
            <see cref="T:Microsoft.Extensions.Configuration.IConfiguration"/> instance.
            <para/>
            Usage: Implement this interface and set the implementation at application startup using 
            <see cref="M:Lucene.Net.Configuration.ConfigurationSettings.SetConfigurationFactory(Lucene.Net.Configuration.IConfigurationFactory)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.IConfigurationFactory.GetConfiguration">
            <summary>
            Gets or creates an instance of <see cref="T:Microsoft.Extensions.Configuration.IConfiguration"/> that Lucene.NET can use
            to read application-defined settings.
            <para/>
            The implementation is responsible for the lifetime of the <see cref="T:Microsoft.Extensions.Configuration.IConfiguration"/> instance.
            A typical implementation will either get the instance from a dependency injection container or
            provide its own caching mechanism to ensure the settings are not reloaded each time the method
            is called.
            </summary>
            <returns>The current <see cref="T:Microsoft.Extensions.Configuration.IConfiguration"/> instance.</returns>
        </member>
        <member name="T:Lucene.Net.Configuration.LuceneDefaultConfigurationProvider">
            <summary>
            An environment variable based <see cref="T:Lucene.Net.Configuration.ConfigurationProvider"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.LuceneDefaultConfigurationProvider.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.LuceneDefaultConfigurationProvider.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance with the specified prefix.
            </summary>
            <param name="prefix">A prefix used to filter the environment variables.</param>
        </member>
        <member name="M:Lucene.Net.Configuration.LuceneDefaultConfigurationProvider.Load">
            <summary>
            Loads the environment variables.
            </summary>
        </member>
        <member name="P:Lucene.Net.Configuration.LuceneDefaultConfigurationProvider.Data">
            <summary>
            The configuration key value pairs for this provider.
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.LuceneDefaultConfigurationProvider.Set(System.String,System.String)">
            <summary>
            Sets a value for a given key.
            </summary>
            <param name="key">The configuration key to set.</param>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:Lucene.Net.Configuration.LuceneDefaultConfigurationProvider.GetChildKeys(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Returns the list of keys that this provider has.
            </summary>
            <param name="earlierKeys">The earlier keys that other providers contain.</param>
            <param name="parentPath">The path for the parent IConfiguration.</param>
            <returns>The list of keys for this provider.</returns>
        </member>
        <member name="M:Lucene.Net.Configuration.LuceneDefaultConfigurationProvider.GetReloadToken">
            <summary>
            Returns a <see cref="T:Microsoft.Extensions.Primitives.IChangeToken"/> that can be used to listen when this provider is reloaded.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Configuration.LuceneDefaultConfigurationSource">
            <summary>
            Represents environment variables as an <see cref="T:Microsoft.Extensions.Configuration.IConfigurationSource"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Configuration.LuceneDefaultConfigurationSource.Prefix">
            <summary>
            A prefix used to filter environment variables.
            </summary>
        </member>
        <member name="P:Lucene.Net.Configuration.LuceneDefaultConfigurationSource.IgnoreSecurityExceptionsOnRead">
            <summary>
            Set to true by default - used to prevent any security exceptions thrown when reading environment variables
            </summary>
        </member>
        <member name="M:Lucene.Net.Configuration.LuceneDefaultConfigurationSource.Build(Microsoft.Extensions.Configuration.IConfigurationBuilder)">
            <summary>
            Builds the <see cref="T:Lucene.Net.Configuration.LuceneDefaultConfigurationProvider"/> for this source.
            </summary>
            <param name="builder">The <see cref="T:Microsoft.Extensions.Configuration.IConfigurationBuilder"/>.</param>
            <returns>A <see cref="T:Lucene.Net.Configuration.LuceneDefaultConfigurationProvider"/></returns>
        </member>
        <member name="T:Lucene.Net.Util.BundleResourceManagerFactory">
            <summary>
            This implementation of <see cref="T:Lucene.Net.Util.IResourceManagerFactory"/> uses a convention
            to retrieve resources. In Java NLS, the convention is to use the same name for the
            resource key propeties and for the resource file names. This presents a problem
            for .NET because the resource generator already creates an internal class with the
            same name as the <c>.resx</c> file.
            <para/>
            To work around this, we use the convention of appending the suffix "Bundle" to 
            the end of the type the resource key propeties are stored in. For example,
            if our constants are stored in a class named ErrorMessages, the type
            that will be looked up by this factory will be ErrorMessagesBundle (which is the
            name of the <c>.resx</c> file that should be added to your project).
            <para/>
            This implementation can be inherited to use a different convention or can be replaced
            to get the resources from an external source.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BundleResourceManagerFactory.Create(System.Type)">
            <summary>
            Creates a <see cref="T:System.Resources.ResourceManager"/> instance using the specified <paramref name="resourceSource"/>.
            </summary>
            <param name="resourceSource">The type representing the resource to retrieve.</param>
            <returns>A new <see cref="T:System.Resources.ResourceManager"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Util.BundleResourceManagerFactory.Release(System.Resources.ResourceManager)">
            <summary>
            Releases the <see cref="T:System.Resources.ResourceManager"/> instance including any disposable dependencies.
            </summary>
            <param name="manager">The <see cref="T:System.Resources.ResourceManager"/> to release.</param>
        </member>
        <member name="M:Lucene.Net.Util.BundleResourceManagerFactory.GetResourceName(System.Type)">
            <summary>
            Gets the fully-qualified name of the bundle as it would appear
            using <see cref="M:System.Reflection.Assembly.GetManifestResourceNames"/>, without the
            <c>.resources</c> extension. This is the name that is passed to the
            <c>baseName</c> parameter of
            <see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)"/>.
            </summary>
            <param name="clazz">The type of the NLS-derived class where the field strings are located that identify resources.</param>
            <returns>The resource name.</returns>
        </member>
        <member name="P:Lucene.Net.Util.BundleResourceManagerFactory.ResourceSuffix">
            <summary>
            The suffix to append to the resource key class name to locate the embedded resource.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ExceptionExtensions">
            <summary>
            Extensions to the <see cref="T:System.Exception"/> class to allow for
            adding and retrieving suppressed exceptions, like you can do in Java.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ExcludeServiceAttribute">
            <summary>
            Base class for <see cref="T:Lucene.Net.Util.Attribute"/> types that exclude services from Reflection scanning.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IProperties">
            <summary>
            Contract for Java-style properties.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IProperties.GetProperty(System.String)">
            <summary>
            Retrieves the value of a property from the current process.
            </summary>
            <param name="key">The name of the property.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.IProperties.GetProperty(System.String,System.String)">
            <summary>
            Retrieves the value of a property from the current process, 
            with a default value if it doens't exist or the caller doesn't have 
            permission to read the value.
            </summary>
            <param name="key">The name of the property.</param>
            <param name="defaultValue">The value to use if the property does not exist 
            or the caller doesn't have permission to read the value.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.IProperties.GetPropertyAsBoolean(System.String)">
            <summary>
            Retrieves the value of a property from the current process
            as <see cref="T:System.Boolean"/>. If the value cannot be cast to <see cref="T:System.Boolean"/>, returns <c>false</c>.
            </summary>
            <param name="key">The name of the property.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.IProperties.GetPropertyAsBoolean(System.String,System.Boolean)">
            <summary>
            Retrieves the value of a property from the current process as <see cref="T:System.Boolean"/>, 
            with a default value if it doens't exist, the caller doesn't have permission to read the value, 
            or the value cannot be cast to a <see cref="T:System.Boolean"/>.
            </summary>
            <param name="key">The name of the property.</param>
            <param name="defaultValue">The value to use if the property does not exist,
            the caller doesn't have permission to read the value, or the value cannot be cast to <see cref="T:System.Boolean"/>.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.IProperties.GetPropertyAsInt32(System.String)">
            <summary>
            Retrieves the value of a property from the current process
            as <see cref="T:System.Int32"/>. If the value cannot be cast to <see cref="T:System.Int32"/>, returns <c>0</c>.
            </summary>
            <param name="key">The name of the property.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.IProperties.GetPropertyAsInt32(System.String,System.Int32)">
            <summary>
            Retrieves the value of a property from the current process as <see cref="T:System.Int32"/>, 
            with a default value if it doens't exist, the caller doesn't have permission to read the value, 
            or the value cannot be cast to a <see cref="T:System.Int32"/>.
            </summary>
            <param name="key">The name of the property.</param>
            <param name="defaultValue">The value to use if the property does not exist,
            the caller doesn't have permission to read the value, or the value cannot be cast to <see cref="T:System.Int32"/>.</param>
            <returns>The property value.</returns>
        </member>
        <member name="T:Lucene.Net.Util.IResourceManagerFactory">
            <summary>
            LUCENENET specific interface used to inject instances of
            <see cref="T:System.Resources.ResourceManager"/>. This
            extension point can be used to override the default behavior
            to, for example, retrieve resources from a persistent data store,
            rather than getting them from resource files.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IServiceListable">
            <summary>
            LUCENENET specific contract that provides support for <see cref="P:Lucene.Net.Codecs.Codec.AvailableCodecs"/>, 
            <see cref="P:Lucene.Net.Codecs.DocValuesFormat.AvailableDocValuesFormats"/>, 
            and <see cref="P:Lucene.Net.Codecs.PostingsFormat.AvailablePostingsFormats"/>. Implement this
            interface in addition to <see cref="T:Lucene.Net.Codecs.ICodecFactory"/>, <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>,
            or <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/> to provide optional support for the above
            methods when providing a custom implementation. If this interface is not supported by
            the corresponding factory, a <see cref="T:System.NotSupportedException"/> will be thrown from the above methods.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.IServiceListable.AvailableServices">
            <summary>
            Lists the available services for the current service type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Util.ListExtensions">
            <summary>
            Extensions to <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ListExtensions.AddRange``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds the elements of the specified collection to the end of the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="list">The list to add to.</param>
            <param name="collection">The collection whose elements should be added to the end of the <see cref="T:System.Collections.Generic.IList`1"/>.
            The collection itself cannot be <c>null</c>, but it can contain elements that are <c>null</c>, if type
            <typeparamref name="T"/> is a reference type.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="collection"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Util.ListExtensions.Sort``1(System.Collections.Generic.IList{``0})">
            <summary>
            If the underlying type is <see cref="T:System.Collections.Generic.List`1"/>,
            calls <see cref="M:System.Collections.Generic.List`1.Sort"/>. If not, 
            uses <see cref="M:Lucene.Net.Util.CollectionUtil.TimSort``1(System.Collections.Generic.IList{``0})"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
        </member>
        <member name="M:Lucene.Net.Util.ListExtensions.Sort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            If the underlying type is <see cref="T:System.Collections.Generic.List`1"/>,
            calls <see cref="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})"/>. If not, 
            uses <see cref="M:Lucene.Net.Util.CollectionUtil.TimSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="comparer">the comparer to use for the sort</param>
        </member>
        <member name="M:Lucene.Net.Util.ListExtensions.Sort``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>
            If the underlying type is <see cref="T:System.Collections.Generic.List`1"/>,
            calls <see cref="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})"/>. If not, 
            uses <see cref="M:Lucene.Net.Util.CollectionUtil.TimSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="comparison">the comparison function to use for the sort</param>
        </member>
        <member name="M:Lucene.Net.Util.ListExtensions.TimSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> using the <see cref="T:System.Collections.Generic.IComparer`1"/>.
            This method uses the Tim sort
            algorithm, but falls back to binary sort for small lists.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
        </member>
        <member name="M:Lucene.Net.Util.ListExtensions.TimSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> using the <see cref="T:System.Collections.Generic.IComparer`1"/>.
            This method uses the Tim sort
            algorithm, but falls back to binary sort for small lists.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> to use for the sort.</param>
        </member>
        <member name="M:Lucene.Net.Util.ListExtensions.IntroSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> using the <see cref="T:System.Collections.Generic.IComparer`1"/>.
            This method uses the intro sort
            algorithm, but falls back to insertion sort for small lists. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
        </member>
        <member name="M:Lucene.Net.Util.ListExtensions.IntroSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> using the <see cref="T:System.Collections.Generic.IComparer`1"/>.
            This method uses the intro sort
            algorithm, but falls back to insertion sort for small lists. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> to use for the sort.</param>
        </member>
        <member name="T:Lucene.Net.Util.NamedServiceFactory`1">
            <summary>
            LUCENENET specific abstract class containing common fuctionality for named service factories.
            </summary>
            <typeparam name="TService">The type of service this factory applies to.</typeparam>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.EnsureInitialized">
            <summary>
            Ensures the <see cref="M:Lucene.Net.Util.NamedServiceFactory`1.Initialize"/> method has been called since the
            last application start. This method is thread-safe.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.Initialize">
            <summary>
            Initializes the dependencies of this factory (such as using Reflection to populate the type cache).
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.NamedServiceFactory`1.CodecsAssembly">
            <summary>
            The Lucene.Net.Codecs assembly or <c>null</c> if the assembly is not referenced
            in the host project.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.IsServiceType(System.Type)">
            <summary>
            Determines whether the given type is corresponding service for this class,
            based on its generic closing type <typeparamref name="TService"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of service to analyze.</param>
            <returns><c>true</c> if the service subclasses <typeparamref name="TService"/>, is public, and is not abstract; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.GetServiceName(System.Type)">
            <summary>
            Get the service name for the class (either by convention or by attribute).
            </summary>
            <param name="type">A service to get the name for.</param>
            <returns>The canonical name of the service or the name provided in the corresponding name attribute, if supplied.</returns>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.GetCanonicalName(System.Type)">
            <summary>
            Gets the type name without the suffix of the abstract base class it implements.
            If the class is generic, it will add the word "Generic" to the suffix in place of "`"
            to ensure the name is ASCII-only.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to get the name for.</param>
            <returns>The canonical name of the service.</returns>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.CheckServiceName(System.String)">
            <summary>
            Validates that a service name meets the requirements of Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.IsLetterOrDigit(System.Char)">
            <summary>
            Checks whether a character is a letter or digit (ascii) which are defined in the spec.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.NamedServiceFactory`1.IsFullyTrusted">
            <summary>
            Gets a value that indicates whether the current application domain executes with full trust.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.NumberFormat">
            <summary>
            A LUCENENET specific class that represents a numeric format. This class
            mimicks the design of Java's NumberFormat class, which unlike the
            <see cref="T:System.Globalization.NumberFormatInfo"/> class in .NET, can be subclassed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumberFormat.GetNumberFormat">
            <summary>
            When overridden in a subclass, provides the numeric format as a <see cref="T:System.String"/>.
            Generally, this is the same format that is passed into the <see cref="M:string.Format(IFormatProvider, string, object)"/>
            method.
            </summary>
            <returns>A numeric format string.</returns>
        </member>
        <member name="T:Lucene.Net.Util.Properties">
            <summary>
            Implementation of <see cref="T:Lucene.Net.Util.IProperties"/> that handles type conversion and default values 
            for Java-style properties.
            <para/>
            Reads properties from a <see cref="T:System.Func`1"/> that is supplied to the constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Properties.#ctor(System.Func{Microsoft.Extensions.Configuration.IConfiguration})">
            <summary>
            Initializes a new instance of <see cref="T:Lucene.Net.Util.Properties"/> with the specified <see cref="T:System.Func`1"/>.
            The delegate method ensures the current instance of <see cref="T:Microsoft.Extensions.Configuration.IConfiguration"/> is used.
            </summary>
            <param name="getConfiguration">The <see cref="T:System.Func`1"/>.</param>
        </member>
        <member name="M:Lucene.Net.Util.Properties.GetProperty(System.String)">
            <summary>
            Retrieves the value of an property from the current process.
            </summary>
            <param name="key">The name of the property.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.Properties.GetProperty(System.String,System.String)">
            <summary>
            Retrieves the value of an property from the current process, 
            with a default value if it doens't exist or the caller doesn't have 
            permission to read the value.
            </summary>
            <param name="key">The name of the property.</param>
            <param name="defaultValue">The value to use if the property does not exist 
            or the caller doesn't have permission to read the value.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.Properties.GetPropertyAsBoolean(System.String)">
            <summary>
            Retrieves the value of an property from the current process
            as <see cref="T:System.Boolean"/>. If the value cannot be cast to <see cref="T:System.Boolean"/>, returns <c>false</c>.
            </summary>
            <param name="key">The name of the property.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.Properties.GetPropertyAsBoolean(System.String,System.Boolean)">
            <summary>
            Retrieves the value of an property from the current process as <see cref="T:System.Boolean"/>, 
            with a default value if it doens't exist, the caller doesn't have permission to read the value, 
            or the value cannot be cast to a <see cref="T:System.Boolean"/>.
            </summary>
            <param name="key">The name of the property.</param>
            <param name="defaultValue">The value to use if the property does not exist,
            the caller doesn't have permission to read the value, or the value cannot be cast to <see cref="T:System.Boolean"/>.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.Properties.GetPropertyAsInt32(System.String)">
            <summary>
            Retrieves the value of an property from the current process
            as <see cref="T:System.Int32"/>. If the value cannot be cast to <see cref="T:System.Int32"/>, returns <c>0</c>.
            </summary>
            <param name="key">The name of the property.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.Properties.GetPropertyAsInt32(System.String,System.Int32)">
            <summary>
            Retrieves the value of an property from the current process as <see cref="T:System.Int32"/>, 
            with a default value if it doens't exist, the caller doesn't have permission to read the value, 
            or the value cannot be cast to a <see cref="T:System.Int32"/>.
            </summary>
            <param name="key">The name of the property.</param>
            <param name="defaultValue">The value to use if the property does not exist,
            the caller doesn't have permission to read the value, or the value cannot be cast to <see cref="T:System.Int32"/>.</param>
            <returns>The property value.</returns>
        </member>
        <member name="T:Lucene.Net.Util.ServiceNameAttribute">
            <summary>
            LUCENENET specific abstract class for <see cref="T:System.Attribute"/>s that can
            be used to override the default convention-based names of services. For example,
            "Lucene40Codec" will by convention be named "Lucene40". Using the <see cref="T:Lucene.Net.Codecs.CodecNameAttribute"/>,
            the name can be overridden with a custom value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ServiceNameAttribute.#ctor(System.String)">
            <summary>
            Sole constructor. Initializes the service name.
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:Lucene.Net.Util.ServiceNameAttribute.Name">
            <summary>
            Gets the service name.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.SystemConsole">
            <summary>
            Mimics <see cref="T:System.Console"/>, but allows for swapping
            the <see cref="T:System.IO.TextWriter"/> of 
            <see cref="P:Lucene.Net.Util.SystemConsole.Out"/> and <see cref="P:Lucene.Net.Util.SystemConsole.Error"/>, or the <see cref="T:System.IO.TextReader"/> of <see cref="P:Lucene.Net.Util.SystemConsole.In"/>
            with user-defined implementations.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.SystemProperties">
            <summary>
            Reads properties from an <see cref="T:Lucene.Net.Util.IProperties"/> instance. The default configuration reads
            the property valies from an <see cref="T:Microsoft.Extensions.Configuration.IConfiguration"/> instance returned by a
            <see cref="T:Lucene.Net.Configuration.IConfigurationFactory"/> implementation.
            The <see cref="T:Lucene.Net.Configuration.IConfigurationFactory"/> is set using
            <see cref="M:Lucene.Net.Configuration.ConfigurationSettings.SetConfigurationFactory(Lucene.Net.Configuration.IConfigurationFactory)"/>.
            This can be supplied a user implemented <see cref="T:Lucene.Net.Configuration.IConfigurationFactory"/> to customize
            the property sources.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SystemProperties.GetProperty(System.String)">
            <summary>
            Retrieves the value of a property from the current process.
            </summary>
            <param name="key">The name of the property.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.SystemProperties.GetProperty(System.String,System.String)">
            <summary>
            Retrieves the value of a property from the current process, 
            with a default value if it doens't exist or the caller doesn't have 
            permission to read the value.
            </summary>
            <param name="key">The name of the property.</param>
            <param name="defaultValue">The value to use if the property does not exist 
            or the caller doesn't have permission to read the value.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.SystemProperties.GetPropertyAsBoolean(System.String)">
            <summary>
            Retrieves the value of a property from the current process
            as <see cref="T:System.Boolean"/>. If the value cannot be cast to <see cref="T:System.Boolean"/>, returns <c>false</c>.
            </summary>
            <param name="key">The name of the property.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.SystemProperties.GetPropertyAsBoolean(System.String,System.Boolean)">
            <summary>
            Retrieves the value of a property from the current process as <see cref="T:System.Boolean"/>, 
            with a default value if it doens't exist, the caller doesn't have permission to read the value, 
            or the value cannot be cast to a <see cref="T:System.Boolean"/>.
            </summary>
            <param name="key">The name of the property.</param>
            <param name="defaultValue">The value to use if the property does not exist,
            the caller doesn't have permission to read the value, or the value cannot be cast to <see cref="T:System.Boolean"/>.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.SystemProperties.GetPropertyAsInt32(System.String)">
            <summary>
            Retrieves the value of a property from the current process
            as <see cref="T:System.Int32"/>. If the value cannot be cast to <see cref="T:System.Int32"/>, returns <c>0</c>.
            </summary>
            <param name="key">The name of the property.</param>
            <returns>The property value.</returns>
        </member>
        <member name="M:Lucene.Net.Util.SystemProperties.GetPropertyAsInt32(System.String,System.Int32)">
            <summary>
            Retrieves the value of a property from the current process as <see cref="T:System.Int32"/>, 
            with a default value if it doens't exist, the caller doesn't have permission to read the value, 
            or the value cannot be cast to a <see cref="T:System.Int32"/>.
            </summary>
            <param name="key">The name of the property.</param>
            <param name="defaultValue">The value to use if the property does not exist,
            the caller doesn't have permission to read the value, or the value cannot be cast to <see cref="T:System.Int32"/>.</param>
            <returns>The property value.</returns>
        </member>
        <member name="T:Lucene.Net.Util.IAccountable">
            <summary>
            An object whose RAM usage can be computed.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IAccountable.RamBytesUsed">
            <summary>
            Return the memory usage of this object in bytes. Negative values are illegal.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ArrayInPlaceMergeSorter`1">
            <summary>
            An <see cref="T:Lucene.Net.Util.InPlaceMergeSorter"/> for object arrays.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayInPlaceMergeSorter`1.#ctor(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new <see cref="T:Lucene.Net.Util.ArrayInPlaceMergeSorter`1"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.ArrayIntroSorter`1">
            <summary>
            An <see cref="T:Lucene.Net.Util.IntroSorter"/> for object arrays.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayIntroSorter`1.#ctor(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new <see cref="T:Lucene.Net.Util.ArrayIntroSorter`1"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.ArrayTimSorter`1">
            <summary>
            A <see cref="T:Lucene.Net.Util.TimSorter"/> for object arrays.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayTimSorter`1.#ctor(`0[],System.Collections.Generic.IComparer{`0},System.Int32)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Util.ArrayTimSorter`1"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.ArrayUtil">
            <summary>
            Methods for manipulating arrays.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.ArrayUtil.MAX_ARRAY_LENGTH">
            <summary>
            Maximum length for an array; we set this to "a
            bit" below <see cref="F:System.Int32.MaxValue"/> because the exact max
            allowed byte[] is JVM dependent, so we want to avoid
            a case where a large value worked during indexing on
            one JVM but failed later at search time with a
            different JVM.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.ParseInt32(System.Char[])">
            <summary>
            Parses the string argument as if it was an <see cref="T:System.Int32"/> value and returns the
            result. Throws <see cref="T:System.FormatException"/> if the string does not represent an
            int quantity.
            <para/>
            NOTE: This was parseInt() in Lucene
            </summary>
            <param name="chars"> A string representation of an int quantity. </param>
            <returns> The value represented by the argument </returns>
            <exception cref="T:System.FormatException"> If the argument could not be parsed as an int quantity. </exception>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.ParseInt32(System.Char[],System.Int32,System.Int32)">
            <summary>
            Parses a char array into an <see cref="T:System.Int32"/>. 
            <para/>
            NOTE: This was parseInt() in Lucene
            </summary>
            <param name="chars"> The character array </param>
            <param name="offset"> The offset into the array </param>
            <param name="len"> The length </param>
            <returns> the <see cref="T:System.Int32"/> </returns>
            <exception cref="T:System.FormatException"> If it can't parse </exception>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.ParseInt32(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Parses the string argument as if it was an <see cref="T:System.Int32"/> value and returns the
            result. Throws <see cref="T:System.FormatException"/> if the string does not represent an
            <see cref="T:System.Int32"/> quantity. The second argument specifies the radix to use when parsing
            the value.
            <para/>
            NOTE: This was parseInt() in Lucene
            </summary>
            <param name="chars"> A string representation of an int quantity. </param>
            <param name="radix"> The base to use for conversion. </param>
            <returns> The value represented by the argument </returns>
            <exception cref="T:System.FormatException"> If the argument could not be parsed as an int quantity. </exception>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.Oversize(System.Int32,System.Int32)">
            <summary>
            Returns an array size &gt;= <paramref name="minTargetSize"/>, generally
            over-allocating exponentially to achieve amortized
            linear-time cost as the array grows.
            <para/>
            NOTE: this was originally borrowed from Python 2.4.2
            listobject.c sources (attribution in LICENSE.txt), but
            has now been substantially changed based on
            discussions from java-dev thread with subject "Dynamic
            array reallocation algorithms", started on Jan 12
            2010.
            <para/>
            @lucene.internal
            </summary>
            <param name="minTargetSize"> Minimum required value to be returned. </param>
            <param name="bytesPerElement"> Bytes used by each element of
            the array.  See constants in <see cref="T:Lucene.Net.Util.RamUsageEstimator"/>. </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.GetHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns hash of chars in range start (inclusive) to
            end (inclusive)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.GetHashCode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns hash of bytes in range start (inclusive) to
            end (inclusive)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.Equals(System.Char[],System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            See if two array slices are the same.
            </summary>
            <param name="left">        The left array to compare </param>
            <param name="offsetLeft">  The offset into the array.  Must be positive </param>
            <param name="right">       The right array to compare </param>
            <param name="offsetRight"> the offset into the right array.  Must be positive </param>
            <param name="length">      The length of the section of the array to compare </param>
            <returns> <c>true</c> if the two arrays, starting at their respective offsets, are equal
            </returns>
            <seealso cref="M:Lucene.Net.Support.Arrays.Equals``1(``0[],``0[])"/>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.Equals(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            See if two array slices are the same.
            </summary>
            <param name="left">        The left array to compare </param>
            <param name="offsetLeft">  The offset into the array.  Must be positive </param>
            <param name="right">       The right array to compare </param>
            <param name="offsetRight"> the offset into the right array.  Must be positive </param>
            <param name="length">      The length of the section of the array to compare </param>
            <returns> <c>true</c> if the two arrays, starting at their respective offsets, are equal
            </returns>
            <seealso cref="M:Lucene.Net.Support.Arrays.Equals``1(``0[],``0[])"/>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.Equals(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            See if two array slices are the same.
            </summary>
            <param name="left">        The left array to compare </param>
            <param name="offsetLeft">  The offset into the array.  Must be positive </param>
            <param name="right">       The right array to compare </param>
            <param name="offsetRight"> the offset into the right array.  Must be positive </param>
            <param name="length">      The length of the section of the array to compare </param>
            <returns> <c>true</c> if the two arrays, starting at their respective offsets, are equal
            </returns>
            <seealso cref="M:Lucene.Net.Support.Arrays.Equals``1(``0[],``0[])"/>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.ToInt32Array(System.Collections.Generic.ICollection{System.Nullable{System.Int32}})">
            <summary>
            NOTE: This was toIntArray() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.GetNaturalComparer``1">
            <summary>
            Get the natural <see cref="T:System.Collections.Generic.IComparer`1"/> for the provided object class.
            <para/>
            The comparer returned depends on the <typeparam name="T"/> argument:
            <list type="number">
                <item><description>If the type is <see cref="T:System.String"/>, the comparer returned uses
                    the <see cref="M:System.String.CompareOrdinal(System.String,System.String)"/> to make the comparison
                    to ensure that the current culture doesn't affect the results. This is the
                    default string comparison used in Java, and what Lucene's design depends on.</description></item>
                <item><description>If the type implements <see cref="T:System.IComparable`1"/>, the comparer uses
                    <see cref="M:System.IComparable`1.CompareTo(`0)"/> for the comparison. This allows
                    the use of types with custom comparison schemes.</description></item>
                <item><description>If neither of the above conditions are true, will default to <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.</description></item>
            </list>
            <para/>
            NOTE: This was naturalComparer() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.Swap``1(``0[],System.Int32,System.Int32)">
            <summary>
            Swap values stored in slots <paramref name="i"/> and <paramref name="j"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.IntroSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given array slice using the <see cref="T:System.Collections.Generic.IComparer`1"/>. This method uses the intro sort
            algorithm, but falls back to insertion sort for small arrays. </summary>
            <param name="fromIndex"> Start index (inclusive) </param>
            <param name="toIndex"> End index (exclusive) </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.IntroSort``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given array using the <see cref="T:System.Collections.Generic.IComparer`1"/>. This method uses the intro sort
            algorithm, but falls back to insertion sort for small arrays.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.IntroSort``1(``0[],System.Int32,System.Int32)">
            <summary>
            Sorts the given array slice in natural order. This method uses the intro sort
            algorithm, but falls back to insertion sort for small arrays. </summary>
            <param name="fromIndex"> Start index (inclusive) </param>
            <param name="toIndex"> End index (exclusive) </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.IntroSort``1(``0[])">
            <summary>
            Sorts the given array in natural order. This method uses the intro sort
            algorithm, but falls back to insertion sort for small arrays.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.TimSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given array slice using the <see cref="T:System.Collections.Generic.IComparer`1"/>. This method uses the Tim sort
            algorithm, but falls back to binary sort for small arrays. </summary>
            <param name="fromIndex"> Start index (inclusive) </param>
            <param name="toIndex"> End index (exclusive) </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.TimSort``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given array using the <see cref="T:System.Collections.Generic.IComparer`1"/>. this method uses the Tim sort
            algorithm, but falls back to binary sort for small arrays.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.TimSort``1(``0[],System.Int32,System.Int32)">
            <summary>
            Sorts the given array slice in natural order. this method uses the Tim sort
            algorithm, but falls back to binary sort for small arrays. </summary>
            <param name="fromIndex"> Start index (inclusive) </param>
            <param name="toIndex"> End index (exclusive) </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.TimSort``1(``0[])">
            <summary>
            Sorts the given array in natural order. this method uses the Tim sort
            algorithm, but falls back to binary sort for small arrays.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IAttribute">
            <summary> Base interface for attributes.</summary>
        </member>
        <member name="T:Lucene.Net.Util.Attribute">
            <summary> Base class for Attributes that can be added to a
            <see cref="T:Lucene.Net.Util.AttributeSource" />.
            <para/>
            Attributes are used to add data in a dynamic, yet type-safe way to a source
            of usually streamed objects, e. g. a <see cref="T:Lucene.Net.Analysis.TokenStream" />.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.Clear">
            <summary> Clears the values in this <see cref="T:Lucene.Net.Util.Attribute"/> and resets it to its
            default value. If this implementation implements more than one <see cref="T:Lucene.Net.Util.Attribute"/> interface
            it clears all.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Attribute.StringBuilderAttributeReflector">
            <summary>
            This is equivalent to the anonymous class in the Java version of ReflectAsString
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.ReflectAsString(System.Boolean)">
            <summary>
            This method returns the current attribute values as a string in the following format
            by calling the <see cref="M:Lucene.Net.Util.Attribute.ReflectWith(Lucene.Net.Util.IAttributeReflector)"/> method:
            <list type="bullet">
                <item><term>if <paramref name="prependAttClass"/>=true:</term> <description> <c>"AttributeClass.Key=value,AttributeClass.Key=value"</c> </description></item>
                <item><term>if <paramref name="prependAttClass"/>=false:</term> <description> <c>"key=value,key=value"</c> </description></item>
            </list>
            </summary>
            <seealso cref="M:Lucene.Net.Util.Attribute.ReflectWith(Lucene.Net.Util.IAttributeReflector)"/>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.ReflectWith(Lucene.Net.Util.IAttributeReflector)">
            <summary>
            This method is for introspection of attributes, it should simply
            add the key/values this attribute holds to the given <see cref="T:Lucene.Net.Util.IAttributeReflector"/>.
            
            <para/>The default implementation calls <see cref="M:Lucene.Net.Util.IAttributeReflector.Reflect(System.Type,System.String,System.Object)"/> for all
            non-static fields from the implementing class, using the field name as key
            and the field value as value. The <see cref="T:Lucene.Net.Util.IAttribute"/> class is also determined by Reflection.
            Please note that the default implementation can only handle single-Attribute
            implementations.
            
            <para/>Custom implementations look like this (e.g. for a combined attribute implementation):
            <code>
                public void ReflectWith(IAttributeReflector reflector) 
                {
                    reflector.Reflect(typeof(ICharTermAttribute), "term", GetTerm());
                    reflector.Reflect(typeof(IPositionIncrementAttribute), "positionIncrement", GetPositionIncrement());
                }
            </code>
            
            <para/>If you implement this method, make sure that for each invocation, the same set of <see cref="T:Lucene.Net.Util.IAttribute"/>
            interfaces and keys are passed to <see cref="M:Lucene.Net.Util.IAttributeReflector.Reflect(System.Type,System.String,System.Object)"/> in the same order, but possibly
            different values. So don't automatically exclude e.g. <c>null</c> properties!
            </summary>
            <seealso cref="M:Lucene.Net.Util.Attribute.ReflectAsString(System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.ToString">
             <summary> The default implementation of this method accesses all declared
             fields of this object and prints the values in the following syntax:
            
             <code>
             public String ToString() 
             {
                 return "start=" + startOffset + ",end=" + endOffset;
             }
             </code>
            
             This method may be overridden by subclasses.
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.CopyTo(Lucene.Net.Util.IAttribute)">
            <summary> Copies the values from this <see cref="T:Lucene.Net.Util.Attribute"/> into the passed-in
            <paramref name="target"/> attribute. The <paramref name="target"/> implementation must support all the
            <see cref="T:Lucene.Net.Util.IAttribute"/>s this implementation supports.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.Clone">
            <summary> Shallow clone. Subclasses must override this if they
            need to clone any members deeply,
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IAttributeReflector">
            <summary>
            This interface is used to reflect contents of <see cref="T:Lucene.Net.Util.AttributeSource"/> or <see cref="T:Lucene.Net.Util.Attribute"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IAttributeReflector.Reflect``1(System.String,System.Object)">
            <summary>
            LUCENENET specific overload to support generics.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IAttributeReflector.Reflect(System.Type,System.String,System.Object)">
            <summary>
            This method gets called for every property in an <see cref="T:Lucene.Net.Util.Attribute"/>/<see cref="T:Lucene.Net.Util.AttributeSource"/>
            passing the <see cref="T:System.Type"/> of the <see cref="T:Lucene.Net.Util.IAttribute"/>, a <paramref name="key"/> and the actual <paramref name="value"/>.
            E.g., an invocation of <see cref="M:Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.ReflectWith(Lucene.Net.Util.IAttributeReflector)"/>
            would call this method once using <see cref="T:typeof(Analysis.TokenAttributes.ICharTermAttribute)"/>
            as attribute type, <c>"term"</c> as <paramref name="key"/> and the actual <paramref name="value"/> as a <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.AttributeSource">
            <summary>
            An <see cref="T:Lucene.Net.Util.AttributeSource"/> contains a list of different <see cref="T:Lucene.Net.Util.Attribute"/>s,
            and methods to add and get them. There can only be a single instance
            of an attribute in the same <see cref="T:Lucene.Net.Util.AttributeSource"/> instance. This is ensured
            by passing in the actual type of the <see cref="T:Lucene.Net.Util.IAttribute"/> to
            the <see cref="M:Lucene.Net.Util.AttributeSource.AddAttribute``1"/>, which then checks if an instance of
            that type is already present. If yes, it returns the instance, otherwise
            it creates a new instance and returns it.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.AttributeSource.AttributeFactory">
            <summary>
            An <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/> creates instances of <see cref="T:Lucene.Net.Util.Attribute"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.AttributeFactory.CreateAttributeInstance``1">
            <summary>
            returns an <see cref="T:Lucene.Net.Util.Attribute"/> for the supplied <see cref="T:Lucene.Net.Util.IAttribute"/> interface.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.AttributeSource.AttributeFactory.DEFAULT_ATTRIBUTE_FACTORY">
            <summary>
            This is the default factory that creates <see cref="T:Lucene.Net.Util.Attribute"/>s using the
            <see cref="T:System.Type"/> of the supplied <see cref="T:Lucene.Net.Util.IAttribute"/> interface by removing the <code>I</code> from the prefix.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.AttributeSource.State">
            <summary>
            This class holds the state of an <see cref="T:Lucene.Net.Util.AttributeSource"/>. </summary>
            <seealso cref="M:Lucene.Net.Util.AttributeSource.CaptureState"/>
            <seealso cref="M:Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State)"/>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.#ctor">
            <summary>
            An <see cref="T:Lucene.Net.Util.AttributeSource"/> using the default attribute factory <see cref="F:Lucene.Net.Util.AttributeSource.AttributeFactory.DEFAULT_ATTRIBUTE_FACTORY"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.#ctor(Lucene.Net.Util.AttributeSource)">
            <summary>
            An <see cref="T:Lucene.Net.Util.AttributeSource"/> that uses the same attributes as the supplied one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory)">
            <summary>
            An <see cref="T:Lucene.Net.Util.AttributeSource"/> using the supplied <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/> for creating new <see cref="T:Lucene.Net.Util.IAttribute"/> instances.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.GetAttributeFactory">
            <summary>
            Returns the used <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.GetAttributeClassesEnumerator">
            <summary>
            Returns a new iterator that iterates the attribute classes
            in the same order they were added in.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.GetAttributeImplsEnumerator">
            <summary>
            Returns a new iterator that iterates all unique <see cref="T:Lucene.Net.Util.IAttribute"/> implementations.
            This iterator may contain less entries than <see cref="M:Lucene.Net.Util.AttributeSource.GetAttributeClassesEnumerator"/>,
            if one instance implements more than one <see cref="T:Lucene.Net.Util.IAttribute"/> interface.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.AttributeSource.knownImplClasses">
            <summary>
            A cache that stores all interfaces for known implementation classes for performance (slow reflection) </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.AddAttributeImpl(Lucene.Net.Util.Attribute)">
            <summary>
            <b>Expert:</b> Adds a custom <see cref="T:Lucene.Net.Util.Attribute"/> instance with one or more <see cref="T:Lucene.Net.Util.IAttribute"/> interfaces.
            <para><font color="red"><b>Please note:</b> It is not guaranteed, that <paramref name="att"/> is added to
            the <see cref="T:Lucene.Net.Util.AttributeSource"/>, because the provided attributes may already exist.
            You should always retrieve the wanted attributes using <see cref="M:Lucene.Net.Util.AttributeSource.GetAttribute``1"/> after adding
            with this method and cast to your <see cref="T:System.Type"/>.
            The recommended way to use custom implementations is using an <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/>.
            </font></para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.AddAttribute``1">
            <summary>
            The caller must pass in an interface type that extends <see cref="T:Lucene.Net.Util.IAttribute"/>.
            This method first checks if an instance of the corresponding class is 
            already in this <see cref="T:Lucene.Net.Util.AttributeSource"/> and returns it. Otherwise a
            new instance is created, added to this <see cref="T:Lucene.Net.Util.AttributeSource"/> and returned. 
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.AttributeSource.HasAttributes">
            <summary>
            Returns <c>true</c>, if this <see cref="T:Lucene.Net.Util.AttributeSource"/> has any attributes </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.HasAttribute``1">
            <summary>
            The caller must pass in an interface type that extends <see cref="T:Lucene.Net.Util.IAttribute"/>.
            Returns <c>true</c>, if this <see cref="T:Lucene.Net.Util.AttributeSource"/> contains the corrsponding <see cref="T:Lucene.Net.Util.Attribute"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.GetAttribute``1">
            <summary>
            The caller must pass in an interface type that extends <see cref="T:Lucene.Net.Util.IAttribute"/>.
            Returns the instance of the corresponding <see cref="T:Lucene.Net.Util.Attribute"/> contained in this <see cref="T:Lucene.Net.Util.AttributeSource"/>
            </summary>
            <exception cref="T:System.ArgumentException"> if this <see cref="T:Lucene.Net.Util.AttributeSource"/> does not contain the
                    <see cref="T:Lucene.Net.Util.Attribute"/>. It is recommended to always use <see cref="M:Lucene.Net.Util.AttributeSource.AddAttribute``1"/> even in consumers
                    of <see cref="T:Lucene.Net.Analysis.TokenStream"/>s, because you cannot know if a specific <see cref="T:Lucene.Net.Analysis.TokenStream"/> really uses
                    a specific <see cref="T:Lucene.Net.Util.Attribute"/>. <see cref="M:Lucene.Net.Util.AttributeSource.AddAttribute``1"/> will automatically make the attribute
                    available. If you want to only use the attribute, if it is available (to optimize
                    consuming), use <see cref="M:Lucene.Net.Util.AttributeSource.HasAttribute``1"/>. </exception>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.ClearAttributes">
            <summary>
            Resets all <see cref="T:Lucene.Net.Util.Attribute"/>s in this <see cref="T:Lucene.Net.Util.AttributeSource"/> by calling
            <see cref="M:Lucene.Net.Util.Attribute.Clear"/> on each <see cref="T:Lucene.Net.Util.IAttribute"/> implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.CaptureState">
            <summary>
            Captures the state of all <see cref="T:Lucene.Net.Util.Attribute"/>s. The return value can be passed to
            <see cref="M:Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State)"/> to restore the state of this or another <see cref="T:Lucene.Net.Util.AttributeSource"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State)">
            <summary>
            Restores this state by copying the values of all attribute implementations
            that this state contains into the attributes implementations of the targetStream.
            The targetStream must contain a corresponding instance for each argument
            contained in this state (e.g. it is not possible to restore the state of
            an <see cref="T:Lucene.Net.Util.AttributeSource"/> containing a <see cref="T:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute"/> into a <see cref="T:Lucene.Net.Util.AttributeSource"/> using
            a <see cref="T:Lucene.Net.Analysis.Token"/> instance as implementation).
            <para/>
            Note that this method does not affect attributes of the targetStream
            that are not contained in this state. In other words, if for example
            the targetStream contains an <see cref="T:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute"/>, but this state doesn't, then
            the value of the <see cref="T:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute"/> remains unchanged. It might be desirable to
            reset its value to the default, in which case the caller should first
            call <see cref="M:Lucene.Net.Util.AttributeSource.ClearAttributes"/> (<c>TokenStream.ClearAttributes()</c> on the targetStream.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.ReflectAsString(System.Boolean)">
             <summary>
             This method returns the current attribute values as a string in the following format
             by calling the <see cref="M:Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector)"/> method:
            
             <list type="bullet">
                 <item><term>if <paramref name="prependAttClass"/>=true:</term> <description> <c>"AttributeClass.Key=value,AttributeClass.Key=value"</c> </description></item>
                 <item><term>if <paramref name="prependAttClass"/>=false:</term> <description> <c>"key=value,key=value"</c> </description></item>
             </list>
             </summary>
             <seealso cref="M:Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector)"/>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector)">
             <summary>
             This method is for introspection of attributes, it should simply
             add the key/values this <see cref="T:Lucene.Net.Util.AttributeSource"/> holds to the given <see cref="T:Lucene.Net.Util.IAttributeReflector"/>.
            
             <para>This method iterates over all <see cref="T:Lucene.Net.Util.IAttribute"/> implementations and calls the
             corresponding <see cref="M:Lucene.Net.Util.Attribute.ReflectWith(Lucene.Net.Util.IAttributeReflector)"/> method.</para>
             </summary>
             <seealso cref="M:Lucene.Net.Util.Attribute.ReflectWith(Lucene.Net.Util.IAttributeReflector)"/>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.CloneAttributes">
            <summary>
            Performs a clone of all <see cref="T:Lucene.Net.Util.Attribute"/> instances returned in a new
            <see cref="T:Lucene.Net.Util.AttributeSource"/> instance. This method can be used to e.g. create another <see cref="T:Lucene.Net.Analysis.TokenStream"/>
            with exactly the same attributes (using <see cref="M:Lucene.Net.Util.AttributeSource.#ctor(Lucene.Net.Util.AttributeSource)"/>).
            You can also use it as a (non-performant) replacement for <see cref="M:Lucene.Net.Util.AttributeSource.CaptureState"/>, if you need to look
            into / modify the captured state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.CopyTo(Lucene.Net.Util.AttributeSource)">
            <summary>
            Copies the contents of this <see cref="T:Lucene.Net.Util.AttributeSource"/> to the given target <see cref="T:Lucene.Net.Util.AttributeSource"/>.
            The given instance has to provide all <see cref="T:Lucene.Net.Util.IAttribute"/>s this instance contains.
            The actual attribute implementations must be identical in both <see cref="T:Lucene.Net.Util.AttributeSource"/> instances;
            ideally both <see cref="T:Lucene.Net.Util.AttributeSource"/> instances should use the same <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/>.
            You can use this method as a replacement for <see cref="M:Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State)"/>, if you use
            <see cref="M:Lucene.Net.Util.AttributeSource.CloneAttributes"/> instead of <see cref="M:Lucene.Net.Util.AttributeSource.CaptureState"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.ToString">
            <summary>
            Returns a string consisting of the class's simple name, the hex representation of the identity hash code,
            and the current reflection of all attributes. </summary>
            <seealso cref="M:Lucene.Net.Util.AttributeSource.ReflectAsString(System.Boolean)"/>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Automaton">
             <summary>
             Finite-state automaton with regular expression operations.
             <para/>
             Class invariants:
             <list type="bullet">
                 <item><description>An automaton is either represented explicitly (with <see cref="T:Lucene.Net.Util.Automaton.State"/> and
                     <see cref="T:Lucene.Net.Util.Automaton.Transition"/> objects) or with a singleton string (see
                     <see cref="P:Lucene.Net.Util.Automaton.Automaton.Singleton"/> and <see cref="M:Lucene.Net.Util.Automaton.Automaton.ExpandSingleton"/>) in case the automaton
                     is known to accept exactly one string. (Implicitly, all states and
                     transitions of an automaton are reachable from its initial state.)</description></item>
                 <item><description>Automata are always reduced (see <see cref="M:Lucene.Net.Util.Automaton.Automaton.Reduce"/>) and have no
                     transitions to dead states (see <see cref="M:Lucene.Net.Util.Automaton.Automaton.RemoveDeadTransitions"/>).</description></item>
                 <item><description>If an automaton is nondeterministic, then <see cref="P:Lucene.Net.Util.Automaton.Automaton.IsDeterministic"/>
                     returns <c>false</c> (but the converse is not required).</description></item>
                 <item><description>Automata provided as input to operations are generally assumed to be
                     disjoint.</description></item>
             </list>
             <para/>
             If the states or transitions are manipulated manually, the
             <see cref="M:Lucene.Net.Util.Automaton.Automaton.RestoreInvariant"/> method and <see cref="P:Lucene.Net.Util.Automaton.Automaton.IsDeterministic"/> setter
             should be used afterwards to restore representation invariants that are
             assumed by the built-in automata operations.
            
             <para/>
             <para>
             Note: this class has internal mutable state and is not thread safe. It is
             the caller's responsibility to ensure any necessary synchronization if you
             wish to use the same Automaton from multiple threads. In general it is instead
             recommended to use a <see cref="T:Lucene.Net.Util.Automaton.RunAutomaton"/> for multithreaded matching: it is immutable,
             thread safe, and much faster.
             </para>
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.MINIMIZE_HOPCROFT">
            <summary>
            Minimize using Hopcroft's O(n log n) algorithm. this is regarded as one of
            the most generally efficient algorithms that exist.
            </summary>
            <seealso cref="M:Lucene.Net.Util.Automaton.Automaton.SetMinimization(System.Int32)"/>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.minimization">
            <summary>
            Selects minimization algorithm (default: <c>MINIMIZE_HOPCROFT</c>). </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.initial">
            <summary>
            Initial state of this automaton. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.deterministic">
            <summary>
            If <c>true</c>, then this automaton is definitely deterministic (i.e., there are
            no choices for any run, but a run may crash).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.info">
            <summary>
            Extra data associated with this automaton. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.singleton">
            <summary>
            Singleton string. Null if not applicable. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.minimize_always">
            <summary>
            Minimize always flag. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.allow_mutation">
            <summary>
            Selects whether operations may modify the input automata (default:
            <c>false</c>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.#ctor(Lucene.Net.Util.Automaton.State)">
            <summary>
            Constructs a new automaton that accepts the empty language. Using this
            constructor, automata can be constructed manually from <see cref="T:Lucene.Net.Util.Automaton.State"/> and
            <see cref="T:Lucene.Net.Util.Automaton.Transition"/> objects.
            </summary>
            <seealso cref="T:Lucene.Net.Util.Automaton.State"/>
            <seealso cref="T:Lucene.Net.Util.Automaton.Transition"/>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.SetMinimization(System.Int32)">
            <summary>
            Selects minimization algorithm (default: <c>MINIMIZE_HOPCROFT</c>).
            </summary>
            <param name="algorithm"> minimization algorithm </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.SetMinimizeAlways(System.Boolean)">
            <summary>
            Sets or resets minimize always flag. If this flag is set, then
            <see cref="M:Lucene.Net.Util.Automaton.MinimizationOperations.Minimize(Lucene.Net.Util.Automaton.Automaton)"/> will automatically be
            invoked after all operations that otherwise may produce non-minimal
            automata. By default, the flag is not set.
            </summary>
            <param name="flag"> if <c>true</c>, the flag is set </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.SetAllowMutate(System.Boolean)">
            <summary>
            Sets or resets allow mutate flag. If this flag is set, then all automata
            operations may modify automata given as input; otherwise, operations will
            always leave input automata languages unmodified. By default, the flag is
            not set.
            </summary>
            <param name="flag"> if <c>true</c>, the flag is set </param>
            <returns> previous value of the flag </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.AllowMutate">
            <summary>
            Returns the state of the allow mutate flag. If this flag is set, then all
            automata operations may modify automata given as input; otherwise,
            operations will always leave input automata languages unmodified. By
            default, the flag is not set.
            </summary>
            <returns> current value of the flag </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.Singleton">
            <summary>
            Returns the singleton string for this automaton. An automaton that accepts
            exactly one string <i>may</i> be represented in singleton mode. In that
            case, this method may be used to obtain the string.
            </summary>
            <returns> String, <c>null</c> if this automaton is not in singleton mode. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetInitialState">
            <summary>
            Gets initial state.
            </summary>
            <returns> state </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.IsDeterministic">
            <summary>
            Returns deterministic flag for this automaton.
            </summary>
            <returns> <c>true</c> if the automaton is definitely deterministic, <c>false</c> if the
                    automaton may be nondeterministic </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.Info">
            <summary>
            Associates extra information with this automaton.
            </summary>
            <param name="value"> extra information </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetAcceptStates">
            <summary>
            Returns the set of reachable accept states.
            </summary>
            <returns> Set of <see cref="T:Lucene.Net.Util.Automaton.State"/> objects. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Totalize">
            <summary>
            Adds transitions to explicit crash state to ensure that transition function
            is total.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.RestoreInvariant">
            <summary>
            Restores representation invariant. This method must be invoked before any
            built-in automata operation is performed if automaton states or transitions
            are manipulated manually.
            </summary>
            <seealso cref="P:Lucene.Net.Util.Automaton.Automaton.IsDeterministic"/>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Reduce">
            <summary>
            Reduces this automaton. An automaton is "reduced" by combining overlapping
            and adjacent edge intervals with same destination.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetStartPoints">
            <summary>
            Returns sorted array of all interval start points.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetLiveStates">
            <summary>
            Returns the set of live states. A state is "live" if an accept state is
            reachable from it.
            </summary>
            <returns> Set of <see cref="T:Lucene.Net.Util.Automaton.State"/> objects. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.RemoveDeadTransitions">
            <summary>
            Removes transitions to dead states and calls <see cref="M:Lucene.Net.Util.Automaton.Automaton.Reduce"/>.
            (A state is "dead" if no accept state is
            reachable from it.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetSortedTransitions">
            <summary>
            Returns a sorted array of transitions for each state (and sets state
            numbers).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.ExpandSingleton">
            <summary>
            Expands singleton representation to normal representation. Does nothing if
            not in singleton representation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetNumberOfStates">
            <summary>
            Returns the number of states in this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetNumberOfTransitions">
            <summary>
            Returns the number of transitions in this automaton. This number is counted
            as the total number of edges, where one edge may be a character interval.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.ToString">
            <summary>
            Returns a string representation of this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.ToDot">
            <summary>
            Returns <a href="http://www.research.att.com/sw/tools/graphviz/"
            target="_top">Graphviz Dot</a> representation of this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.CloneExpanded">
            <summary>
            Returns a clone of this automaton, expands if singleton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.CloneExpandedIfRequired">
            <summary>
            Returns a clone of this automaton unless <see cref="F:Lucene.Net.Util.Automaton.Automaton.allow_mutation"/> is
            set, expands if singleton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Clone">
            <summary>
            Returns a clone of this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.CloneIfRequired">
            <summary>
            Returns a clone of this automaton, or this automaton itself if
            <see cref="F:Lucene.Net.Util.Automaton.Automaton.allow_mutation"/> flag is set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Concatenate(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Concatenate(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Concatenate(System.Collections.Generic.IList{Lucene.Net.Util.Automaton.Automaton})">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Concatenate(System.Collections.Generic.IList{Lucene.Net.Util.Automaton.Automaton})"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Optional">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Optional(Lucene.Net.Util.Automaton.Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Repeat">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Repeat(Lucene.Net.Util.Automaton.Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Repeat(System.Int32)">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Repeat(Lucene.Net.Util.Automaton.Automaton,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Repeat(System.Int32,System.Int32)">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Repeat(Lucene.Net.Util.Automaton.Automaton,System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Complement">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Complement(Lucene.Net.Util.Automaton.Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Minus(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Minus(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Intersection(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Intersection(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.SubsetOf(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.SubsetOf(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Union(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Union(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.Automaton})">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.Automaton})"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Determinize">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Determinize(Lucene.Net.Util.Automaton.Automaton)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.IsEmptyString">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.IsEmptyString(Lucene.Net.Util.Automaton.Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Minimize(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <see cref="M:Lucene.Net.Util.Automaton.MinimizationOperations.Minimize(Lucene.Net.Util.Automaton.Automaton)"/>. Returns the
            automaton being given as argument.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.IAutomatonProvider">
            <summary>
            Automaton provider for <see cref="T:Lucene.Net.Util.Automaton.RegExp"/>.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="M:Lucene.Net.Util.Automaton.RegExp.ToAutomaton(Lucene.Net.Util.Automaton.IAutomatonProvider)"/>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.IAutomatonProvider.GetAutomaton(System.String)">
            <summary>
            Returns automaton of the given name.
            </summary>
            <param name="name"> Automaton name. </param>
            <returns> Automaton. </returns>
            <exception cref="T:System.IO.IOException"> If errors occur. </exception>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.BasicAutomata">
            <summary>
            Construction of basic automata.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeEmpty">
            <summary>
            Returns a new (deterministic) automaton with the empty language.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeEmptyString">
            <summary>
            Returns a new (deterministic) automaton that accepts only the empty string.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeAnyString">
            <summary>
            Returns a new (deterministic) automaton that accepts all strings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeAnyChar">
            <summary>
            Returns a new (deterministic) automaton that accepts any single codepoint.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeChar(System.Int32)">
            <summary>
            Returns a new (deterministic) automaton that accepts a single codepoint of
            the given value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeCharRange(System.Int32,System.Int32)">
            <summary>
            Returns a new (deterministic) automaton that accepts a single codepoint whose
            value is in the given interval (including both end points).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.AnyOfRightLength(System.String,System.Int32)">
            <summary>
            Constructs sub-automaton corresponding to decimal numbers of length
            <c>x.Substring(n).Length</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.AtLeast(System.String,System.Int32,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.State},System.Boolean)">
            <summary>
            Constructs sub-automaton corresponding to decimal numbers of value at least
            <c>x.Substring(n)</c> and length <c>x.Substring(n).Length</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.AtMost(System.String,System.Int32)">
            <summary>
            Constructs sub-automaton corresponding to decimal numbers of value at most
            <c>x.Substring(n)</c> and length <c>x.Substring(n).Length</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.Between(System.String,System.String,System.Int32,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.State},System.Boolean)">
            <summary>
            Constructs sub-automaton corresponding to decimal numbers of value between
            <c>x.Substring(n)</c> and <c>y.Substring(n)</c> and of length <c>x.Substring(n).Length</c>
            (which must be equal to <c>y.Substring(n).Length</c>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeInterval(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new automaton that accepts strings representing decimal
            non-negative integers in the given interval.
            </summary>
            <param name="min"> Minimal value of interval. </param>
            <param name="max"> Maximal value of interval (both end points are included in the
                     interval). </param>
            <param name="digits"> If &gt; 0, use fixed number of digits (strings must be prefixed
                     by 0's to obtain the right length) - otherwise, the number of
                     digits is not fixed. </param>
            <exception cref="T:System.ArgumentException"> If min &gt; max or if numbers in the
                         interval cannot be expressed with the given fixed number of
                         digits. </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeString(System.String)">
            <summary>
            Returns a new (deterministic) automaton that accepts the single given
            string.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeStringUnion(System.Collections.Generic.ICollection{Lucene.Net.Util.BytesRef})">
            <summary>
            Returns a new (deterministic and minimal) automaton that accepts the union
            of the given collection of <see cref="T:Lucene.Net.Util.BytesRef"/>s representing UTF-8 encoded
            strings.
            </summary>
            <param name="utf8Strings">
                     The input strings, UTF-8 encoded. The collection must be in sorted
                     order.
            </param>
            <returns> An <see cref="T:Lucene.Net.Util.Automaton.Automaton"/> accepting all input strings. The resulting
                    automaton is codepoint based (full unicode codepoints on
                    transitions). </returns>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.BasicOperations">
            <summary>
            Basic automata operations.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Concatenate(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns an automaton that accepts the concatenation of the languages of the
            given automata.
            <para/>
            Complexity: linear in number of states.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Concatenate(System.Collections.Generic.IList{Lucene.Net.Util.Automaton.Automaton})">
            <summary>
            Returns an automaton that accepts the concatenation of the languages of the
            given automata.
            <para/>
            Complexity: linear in total number of states.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Optional(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns an automaton that accepts the union of the empty string and the
            language of the given automaton.
            <para/>
            Complexity: linear in number of states.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Repeat(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns an automaton that accepts the Kleene star (zero or more
            concatenated repetitions) of the language of the given automaton. Never
            modifies the input automaton language.
            <para/>
            Complexity: linear in number of states.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Repeat(Lucene.Net.Util.Automaton.Automaton,System.Int32)">
            <summary>
            Returns an automaton that accepts <paramref name="min"/> or more concatenated
            repetitions of the language of the given automaton.
            <para/>
            Complexity: linear in number of states and in <paramref name="min"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Repeat(Lucene.Net.Util.Automaton.Automaton,System.Int32,System.Int32)">
            <summary>
            Returns an automaton that accepts between <paramref name="min"/> and
            <paramref name="max"/> (including both) concatenated repetitions of the language
            of the given automaton.
            <para/>
            Complexity: linear in number of states and in <paramref name="min"/> and
            <paramref name="max"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Complement(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns a (deterministic) automaton that accepts the complement of the
            language of the given automaton.
            <para/>
            Complexity: linear in number of states (if already deterministic).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Minus(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns a (deterministic) automaton that accepts the intersection of the
            language of <paramref name="a1"/> and the complement of the language of
            <paramref name="a2"/>. As a side-effect, the automata may be determinized, if not
            already deterministic.
            <para/>
            Complexity: quadratic in number of states (if already deterministic).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Intersection(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns an automaton that accepts the intersection of the languages of the
            given automata. Never modifies the input automata languages.
            <para/>
            Complexity: quadratic in number of states.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.SameLanguage(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns <c>true</c> if these two automata accept exactly the
            same language.  This is a costly computation!  Note
            also that <paramref name="a1"/> and <paramref name="a2"/> will be determinized as a side
            effect.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.SubsetOf(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns true if the language of <paramref name="a1"/> is a subset of the language
            of <paramref name="a2"/>. As a side-effect, <paramref name="a2"/> is determinized if
            not already marked as deterministic.
            <para/>
            Complexity: quadratic in number of states.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Union(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns an automaton that accepts the union of the languages of the given
            automata.
            <para/>
            Complexity: linear in number of states.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.Automaton})">
            <summary>
            Returns an automaton that accepts the union of the languages of the given
            automata.
            <para/>
            Complexity: linear in number of states.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Determinize(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Determinizes the given automaton.
            <para/>
            Worst case complexity: exponential in number of states.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.AddEpsilons(Lucene.Net.Util.Automaton.Automaton,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.StatePair})">
            <summary>
            Adds epsilon transitions to the given automaton. This method adds extra
            character interval transitions that are equivalent to the given set of
            epsilon transitions.
            </summary>
            <param name="a"> Automaton. </param>
            <param name="pairs"> Collection of <see cref="T:Lucene.Net.Util.Automaton.StatePair"/> objects representing pairs of
                     source/destination states where epsilon transitions should be
                     added. </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.IsEmptyString(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns <c>true</c> if the given automaton accepts the empty string and nothing
            else.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.IsEmpty(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns <c>true</c> if the given automaton accepts no strings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.IsTotal(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns <c>true</c> if the given automaton accepts all strings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.Run(Lucene.Net.Util.Automaton.Automaton,System.String)">
            <summary>
            Returns <c>true</c> if the given string is accepted by the automaton.
            <para/>
            Complexity: linear in the length of the string.
            <para/>
            <b>Note:</b> for full performance, use the <see cref="T:Lucene.Net.Util.Automaton.RunAutomaton"/> class.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.ByteRunAutomaton">
            <summary>
            Automaton representation for matching UTF-8 <see cref="T:byte[]"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.ByteRunAutomaton.#ctor(Lucene.Net.Util.Automaton.Automaton,System.Boolean)">
            <summary>
            Expert: if utf8 is true, the input is already byte-based </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.ByteRunAutomaton.Run(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns <c>true</c> if the given byte array is accepted by this automaton.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.CharacterRunAutomaton">
            <summary>
            Automaton representation for matching <see cref="T:char[]"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.CharacterRunAutomaton.Run(System.String)">
            <summary>
            Returns <c>true</c> if the given string is accepted by this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.CharacterRunAutomaton.Run(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns <c>true</c> if the given string is accepted by this automaton.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.CompiledAutomaton">
            <summary>
            Immutable class holding compiled details for a given
            <see cref="T:Lucene.Net.Util.Automaton.Automaton"/>.  The <see cref="T:Lucene.Net.Util.Automaton.Automaton"/> is deterministic, must not have
            dead states but is not necessarily minimal.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE">
            <summary>
            Automata are compiled into different internal forms for the
            most efficient execution depending upon the language they accept.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.NONE">
            <summary>
            Automaton that accepts no strings. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.ALL">
            <summary>
            Automaton that accepts all possible strings. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.SINGLE">
            <summary>
            Automaton that accepts only a single fixed string. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.PREFIX">
            <summary>
            Automaton that matches all strings with a constant prefix. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.NORMAL">
            <summary>
            Catch-all for any other automata. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.CompiledAutomaton.Term">
            <summary>
            For <see cref="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.PREFIX"/>, this is the prefix term;
            for <see cref="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.SINGLE"/> this is the singleton term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.CompiledAutomaton.RunAutomaton">
            <summary>
            Matcher for quickly determining if a <see cref="T:byte[]"/> is accepted.
            only valid for <see cref="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.NORMAL"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.CompiledAutomaton.SortedTransitions">
            <summary>
            Two dimensional array of transitions, indexed by state
            number for traversal. The state numbering is consistent with
            <see cref="P:Lucene.Net.Util.Automaton.CompiledAutomaton.RunAutomaton"/>.
            <para/>
            Only valid for <see cref="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.NORMAL"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.CompiledAutomaton.CommonSuffixRef">
            <summary>
            Shared common suffix accepted by the automaton. Only valid
            for <see cref="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.NORMAL"/>, and only when the
            automaton accepts an infinite language.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.CompiledAutomaton.Finite">
            <summary>
            Indicates if the automaton accepts a finite set of strings.
            Null if this was not computed.
            Only valid for <see cref="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.NORMAL"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.CompiledAutomaton.Floor(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Finds largest term accepted by this Automaton, that's
            &lt;= the provided input term.  The result is placed in
            output; it's fine for output and input to point to
            the same <see cref="T:Lucene.Net.Util.BytesRef"/>.  The returned result is either the
            provided output, or <c>null</c> if there is no floor term
            (ie, the provided input term is before the first term
            accepted by this <see cref="T:Lucene.Net.Util.Automaton.Automaton"/>).
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder">
            <summary>
            Builds a minimal, deterministic <see cref="T:Lucene.Net.Util.Automaton.Automaton"/> that accepts a set of
            strings. The algorithm requires sorted input data, but is very fast
            (nearly linear with the input size).
            </summary>
            <seealso cref="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Build(System.Collections.Generic.ICollection{Lucene.Net.Util.BytesRef})"/>
            <seealso cref="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeStringUnion(System.Collections.Generic.ICollection{Lucene.Net.Util.BytesRef})"/>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State">
            <summary>
            DFSA state with <see cref="T:System.Char"/> labels on transitions.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.NO_LABELS">
            <summary>
            An empty set of labels. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.NO_STATES">
            <summary>
            An empty set of states. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.labels">
            <summary>
            Labels of outgoing transitions. Indexed identically to <see cref="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.states"/>.
            Labels must be sorted lexicographically.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.states">
            <summary>
            States reachable from outgoing transitions. Indexed identically to
            <see cref="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.labels"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.is_final">
            <summary>
            <c>true</c> if this state corresponds to the end of at least one
            input sequence.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.GetState(System.Int32)">
            <summary>
            Returns the target state of a transition leaving this state and labeled
            with <paramref name="label"/>. If no such transition exists, returns
            <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.Equals(System.Object)">
            <summary>
            Two states are equal if:
            <list type="bullet">
                <item><description>They have an identical number of outgoing transitions, labeled with
                    the same labels.</description></item>
                <item><description>Corresponding outgoing transitions lead to the same states (to states
                    with an identical right-language).</description></item>
            </list>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.GetHashCode">
            <summary>
            Compute the hash code of the <i>current</i> status of this state.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.HasChildren">
            <summary>
            Return <c>true</c> if this state has any children (outgoing
            transitions).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.NewState(System.Int32)">
            <summary>
            Create a new outgoing transition labeled <paramref name="label"/> and return
            the newly created target state for this transition.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.LastChild">
            <summary>
            Return the most recent transitions's target state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.LastChild(System.Int32)">
            <summary>
            Return the associated state if the most recent transition is labeled with
            <paramref name="label"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.ReplaceLastChild(Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State)">
            <summary>
            Replace the last added outgoing transition's target state with the given
            <paramref name="state"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.ReferenceEquals(System.Object[],System.Object[])">
            <summary>
            Compare two lists of objects for reference-equality.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.stateRegistry">
            <summary>
            A "registry" for state interning.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.root">
            <summary>
            Root automaton state.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.previous">
            <summary>
            Previous sequence added to the automaton in <see cref="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Add(Lucene.Net.Util.CharsRef)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.comparer">
            <summary>
            A comparer used for enforcing sorted UTF8 order, used in assertions only.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Add(Lucene.Net.Util.CharsRef)">
            <summary>
            Add another character sequence to this automaton. The sequence must be
            lexicographically larger or equal compared to any previous sequences added
            to this automaton (the input must be sorted).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Complete">
            <summary>
            Finalize the automaton and return the root state. No more strings can be
            added to the builder after this call.
            </summary>
            <returns> Root automaton state. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Convert(Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State,System.Collections.Generic.IDictionary{Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State,Lucene.Net.Util.Automaton.State})">
            <summary>
            Internal recursive traversal for conversion.
            </summary>
            <param name="s"></param>
            <param name="visited">Must use a dictionary with <see cref="P:J2N.Runtime.CompilerServices.IdentityEqualityComparer`1.Default"/> passed into its constructor.</param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Build(System.Collections.Generic.ICollection{Lucene.Net.Util.BytesRef})">
            <summary>
            Build a minimal, deterministic automaton from a sorted list of <see cref="T:Lucene.Net.Util.BytesRef"/> representing
            strings in UTF-8. These strings must be binary-sorted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.SetPrevious(Lucene.Net.Util.CharsRef)">
            <summary>
            Copy <paramref name="current"/> into an internal buffer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.ReplaceOrRegister(Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State)">
            <summary>
            Replace last child of <paramref name="state"/> with an already registered state
            or stateRegistry the last child state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.AddSuffix(Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State,J2N.Text.ICharSequence,System.Int32)">
            <summary>
            Add a suffix of <paramref name="current"/> starting at <paramref name="fromIndex"/>
            (inclusive) to state <paramref name="state"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Lev1ParametricDescription">
            <summary>
            Parametric description for generating a Levenshtein automaton of degree 1 </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Lev1TParametricDescription">
            <summary>
            Parametric description for generating a Levenshtein automaton of degree 1,
               with transpositions as primitive edits
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Lev2ParametricDescription">
            <summary>
            Parametric description for generating a Levenshtein automaton of degree 2 </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Lev2TParametricDescription">
            <summary>
            Parametric description for generating a Levenshtein automaton of degree 2,
               with transpositions as primitive edits
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.LevenshteinAutomata">
            <summary>
            Class to construct DFAs that match a word within some edit distance.
            <para/>
            Implements the algorithm described in:
            Schulz and Mihov: Fast String Correction with Levenshtein Automata
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE">
            <summary>
            @lucene.internal </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.#ctor(System.String,System.Boolean)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Util.Automaton.LevenshteinAutomata"/> for some <paramref name="input"/> string.
            Optionally count transpositions as a primitive edit.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.#ctor(System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Expert: specify a custom maximum possible symbol
            (alphaMax); default is <see cref="F:J2N.Character.MaxCodePoint"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ToAutomaton(System.Int32)">
            <summary>
            Compute a DFA that accepts all strings within an edit distance of <paramref name="n"/>.
            <para>
            All automata have the following properties:
            <list type="bullet">
                <item><description>They are deterministic (DFA).</description></item>
                <item><description>There are no transitions to dead states.</description></item>
                <item><description>They are not minimal (some transitions could be combined).</description></item>
            </list>
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.GetVector(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the characteristic vector <c>X(x, V)</c>
            where V is <c>Substring(pos, end - pos)</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription">
            <summary>
            A <see cref="T:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription"/> describes the structure of a Levenshtein DFA for some degree <c>n</c>.
            <para/>
            There are four components of a parametric description, all parameterized on the length
            of the word <c>w</c>:
            <list type="number">
                <item><description>The number of states: <see cref="P:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.Count"/></description></item>
                <item><description>The set of final states: <see cref="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.IsAccept(System.Int32)"/></description></item>
                <item><description>The transition function: <see cref="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.Transition(System.Int32,System.Int32,System.Int32)"/></description></item>
                <item><description>Minimal boundary function: <see cref="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.GetPosition(System.Int32)"/></description></item>
            </list>
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.Count">
            <summary>
            Return the number of states needed to compute a Levenshtein DFA.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.IsAccept(System.Int32)">
            <summary>
            Returns <c>true</c> if the <c>state</c> in any Levenshtein DFA is an accept state (final state).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.GetPosition(System.Int32)">
            <summary>
            Returns the position in the input word for a given <c>state</c>.
            this is the minimal boundary for the state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.Transition(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the state number for a transition from the given <paramref name="state"/>,
            assuming <paramref name="position"/> and characteristic vector <paramref name="vector"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.MinimizationOperations">
            <summary>
            Operations for minimizing automata.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.MinimizationOperations.Minimize(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Minimizes (and determinizes if not already deterministic) the given
            automaton.
            </summary>
            <seealso cref="M:Lucene.Net.Util.Automaton.Automaton.SetMinimization(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.MinimizationOperations.MinimizeHopcroft(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Minimizes the given automaton using Hopcroft's algorithm.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.MinimizationOperations.Int32Pair">
            <summary>
            NOTE: This was IntPair in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.INTERSECTION">
            <summary>
            Syntax flag, enables intersection (<c>&amp;</c>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.COMPLEMENT">
            <summary>
            Syntax flag, enables complement (<c>~</c>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.EMPTY">
            <summary>
            Syntax flag, enables empty language (<c>#</c>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.ANYSTRING">
            <summary>
            Syntax flag, enables anystring (<c>@</c>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.AUTOMATON">
            <summary>
            Syntax flag, enables named automata (<c>&lt;</c>identifier<c>&gt;</c>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.INTERVAL">
            <summary>
            Syntax flag, enables numerical intervals (
            <c>&lt;<i>n</i>-<i>m</i>&gt;</c>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.ALL">
            <summary>
            Syntax flag, enables all optional regexp syntax.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.NONE">
            <summary>
            Syntax flag, enables no optional regexp syntax.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.RegExp">
            <summary>
            Regular Expression extension to <see cref="T:Lucene.Net.Util.Automaton.Automaton"/>.
            <para/>
            Regular expressions are built from the following abstract syntax:
            <para/>
            <list type="table">
                <item>
                    <term><i>regexp</i></term>
                    <term>::=</term>
                    <term><i>unionexp</i></term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term></term>
                    <term></term>
                    <term></term>
                </item>
                
                <item>
                    <term><i>unionexp</i></term>
                    <term>::=</term>
                    <term><i>interexp</i>&#160;<tt><b>|</b></tt>&#160;<i>unionexp</i></term>
                    <term>(union)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>interexp</i></term>
                    <term></term>
                    <term></term>
                </item>
                
                <item>
                    <term><i>interexp</i></term>
                    <term>::=</term>
                    <term><i>concatexp</i>&#160;<tt><b>&amp;</b></tt>&#160;<i>interexp</i></term>
                    <term>(intersection)</term>
                    <term><small>[OPTIONAL]</small></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>concatexp</i></term>
                    <term></term>
                    <term></term>
                </item>
                
                <item>
                    <term><i>concatexp</i></term>
                    <term>::=</term>
                    <term><i>repeatexp</i>&#160;<i>concatexp</i></term>
                    <term>(concatenation)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>repeatexp</i></term>
                    <term></term>
                    <term></term>
                </item>
                
                <item>
                    <term><i>repeatexp</i></term>
                    <term>::=</term>
                    <term><i>repeatexp</i>&#160;<tt><b>?</b></tt></term>
                    <term>(zero or one occurrence)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>repeatexp</i>&#160;<tt><b>*</b></tt></term>
                    <term>(zero or more occurrences)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>repeatexp</i>&#160;<tt><b>+</b></tt></term>
                    <term>(one or more occurrences)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>repeatexp</i>&#160;<tt><b>{</b><i>n</i><b>}</b></tt></term>
                    <term>(<tt><i>n</i></tt> occurrences)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>repeatexp</i>&#160;<tt><b>{</b><i>n</i><b>,}</b></tt></term>
                    <term>(<tt><i>n</i></tt> or more occurrences)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>repeatexp</i>&#160;<tt><b>{</b><i>n</i><b>,</b><i>m</i><b>}</b></tt></term>
                    <term>(<tt><i>n</i></tt> to <tt><i>m</i></tt> occurrences, including both)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>complexp</i></term>
                    <term></term>
                    <term></term>
                </item>
                
                <item>
                    <term><i>complexp</i></term>
                    <term>::=</term>
                    <term><tt><b>~</b></tt>&#160;<i>complexp</i></term>
                    <term>(complement)</term>
                    <term><small>[OPTIONAL]</small></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>charclassexp</i></term>
                    <term></term>
                    <term></term>
                </item>
                
                <item>
                    <term><i>charclassexp</i></term>
                    <term>::=</term>
                    <term><tt><b>[</b></tt>&#160;<i>charclasses</i>&#160;<tt><b>]</b></tt></term>
                    <term>(character class)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><tt><b>[^</b></tt>&#160;<i>charclasses</i>&#160;<tt><b>]</b></tt></term>
                    <term>(negated character class)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>simpleexp</i></term>
                    <term></term>
                    <term></term>
                </item>
                
                <item>
                    <term><i>charclasses</i></term>
                    <term>::=</term>
                    <term><i>charclass</i>&#160;<i>charclasses</i></term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>charclass</i></term>
                    <term></term>
                    <term></term>
                </item>
                
                <item>
                    <term><i>charclass</i></term>
                    <term>::=</term>
                    <term><i>charexp</i>&#160;<tt><b>-</b></tt>&#160;<i>charexp</i></term>
                    <term>(character range, including end-points)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><i>charexp</i></term>
                    <term></term>
                    <term></term>
                </item>
                
                <item>
                    <term><i>simpleexp</i></term>
                    <term>::=</term>
                    <term><i>charexp</i></term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><tt><b>.</b></tt></term>
                    <term>(any single character)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><tt><b>#</b></tt></term>
                    <term>(the empty language)</term>
                    <term><small>[OPTIONAL]</small></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><tt><b>@</b></tt></term>
                    <term>(any string)</term>
                    <term><small>[OPTIONAL]</small></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><tt><b>"</b></tt>&#160;&lt;Unicode string without double-quotes&gt;&#160; <tt><b>"</b></tt></term>
                    <term>(a string)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><tt><b>(</b></tt>&#160;<tt><b>)</b></tt></term>
                    <term>(the empty string)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><tt><b>(</b></tt>&#160;<i>unionexp</i>&#160;<tt><b>)</b></tt></term>
                    <term>(precedence override)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><tt><b>&lt;</b></tt>&#160;&lt;identifier&gt;&#160;<tt><b>&gt;</b></tt></term>
                    <term>(named automaton)</term>
                    <term><small>[OPTIONAL]</small></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><tt><b>&lt;</b><i>n</i>-<i>m</i><b>&gt;</b></tt></term>
                    <term>(numerical interval)</term>
                    <term><small>[OPTIONAL]</small></term>
                </item>
                
                <item>
                    <term><i>charexp</i></term>
                    <term>::=</term>
                    <term>&lt;Unicode character&gt;</term>
                    <term>(a single non-reserved character)</term>
                    <term></term>
                </item>
                <item>
                    <term></term>
                    <term>|</term>
                    <term><tt><b>\</b></tt>&#160;&lt;Unicode character&gt;&#160;</term>
                    <term>(a single character)</term>
                    <term></term>
                </item>
                
            </list>
            
            <para/>
            The productions marked <small>[OPTIONAL]</small> are only allowed if
            specified by the syntax flags passed to the <see cref="T:Lucene.Net.Util.Automaton.RegExp"/> constructor.
            The reserved characters used in the (enabled) syntax must be escaped with
            backslash (<c>\</c>) or double-quotes (<c>"..."</c>). (In
            contrast to other regexp syntaxes, this is required also in character
            classes.) Be aware that dash (<c>-</c>) has a special meaning in
            <i>charclass</i> expressions. An identifier is a string not containing right
            angle bracket (<c>&gt;</c>) or dash (<c>-</c>). Numerical
            intervals are specified by non-negative decimal integers and include both end
            points, and if <c>n</c> and <c>m</c> have the same number
            of digits, then the conforming strings must have that length (i.e. prefixed
            by 0's).
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.#ctor(System.String)">
            <summary>
            Constructs new <see cref="T:Lucene.Net.Util.Automaton.RegExp"/> from a string. Same as
            <c>RegExp(s, RegExpSyntax.ALL)</c>.
            </summary>
            <param name="s"> Regexp string. </param>
            <exception cref="T:System.ArgumentException"> If an error occured while parsing the
                         regular expression. </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.#ctor(System.String,Lucene.Net.Util.Automaton.RegExpSyntax)">
            <summary>
            Constructs new <see cref="T:Lucene.Net.Util.Automaton.RegExp"/> from a string.
            </summary>
            <param name="s"> Regexp string. </param>
            <param name="syntax_flags"> Boolean 'or' of optional <see cref="T:Lucene.Net.Util.Automaton.RegExpSyntax"/> constructs to be
                     enabled. </param>
            <exception cref="T:System.ArgumentException"> If an error occured while parsing the
                         regular expression </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.ToAutomaton">
            <summary>
            Constructs new <see cref="T:Lucene.Net.Util.Automaton.Automaton"/> from this <see cref="T:Lucene.Net.Util.Automaton.RegExp"/>. Same
            as <c>ToAutomaton(null)</c> (empty automaton map).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.ToAutomaton(Lucene.Net.Util.Automaton.IAutomatonProvider)">
            <summary>
            Constructs new <see cref="T:Lucene.Net.Util.Automaton.Automaton"/> from this <see cref="T:Lucene.Net.Util.Automaton.RegExp"/>. The
            constructed automaton is minimal and deterministic and has no transitions
            to dead states.
            </summary>
            <param name="automaton_provider"> Provider of automata for named identifiers. </param>
            <exception cref="T:System.ArgumentException"> If this regular expression uses a named
                         identifier that is not available from the automaton provider. </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.ToAutomaton(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Util.Automaton.Automaton})">
            <summary>
            Constructs new <see cref="T:Lucene.Net.Util.Automaton.Automaton"/> from this <see cref="T:Lucene.Net.Util.Automaton.RegExp"/>. The
            constructed automaton is minimal and deterministic and has no transitions
            to dead states.
            </summary>
            <param name="automata"> A map from automaton identifiers to automata (of type
                     <see cref="T:Lucene.Net.Util.Automaton.Automaton"/>). </param>
            <exception cref="T:System.ArgumentException"> If this regular expression uses a named
                         identifier that does not occur in the automaton map. </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.SetAllowMutate(System.Boolean)">
            <summary>
            Sets or resets allow mutate flag. If this flag is set, then automata
            construction uses mutable automata, which is slightly faster but not thread
            safe. By default, the flag is not set.
            </summary>
            <param name="flag"> If <c>true</c>, the flag is set </param>
            <returns> Previous value of the flag. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.ToString">
            <summary>
            Constructs string from parsed regular expression.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.GetIdentifiers">
            <summary>
            Returns set of automaton identifiers that occur in this regular expression.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.RunAutomaton">
            <summary>
            Finite-state automaton with fast run operation.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.ToString">
            <summary>
            Returns a string representation of this automaton.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.RunAutomaton.Count">
            <summary>
            Returns number of states in automaton.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.IsAccept(System.Int32)">
            <summary>
            Returns acceptance status for given state.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.RunAutomaton.InitialState">
            <summary>
            Returns initial state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.GetCharIntervals">
            <summary>
            Returns array of codepoint class interval start points. The array should
            not be modified by the caller.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.GetCharClass(System.Int32)">
            <summary>
            Gets character class of given codepoint.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.#ctor(Lucene.Net.Util.Automaton.Automaton,System.Int32,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:Lucene.Net.Util.Automaton.RunAutomaton"/> from a deterministic
            <see cref="T:Lucene.Net.Util.Automaton.Automaton"/>.
            </summary>
            <param name="a"> An automaton. </param>
            <param name="maxInterval"></param>
            <param name="tableize"></param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.Step(System.Int32,System.Int32)">
            <summary>
            Returns the state obtained by reading the given char from the given state.
            Returns -1 if not obtaining any such state. (If the original
            <see cref="T:Lucene.Net.Util.Automaton.Automaton"/> had no dead states, -1 is returned here if and only
            if a dead state is entered in an equivalent automaton with a total
            transition function.)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.SortedInt32Set">
            <summary>
            Just holds a set of <see cref="T:int[]"/> states, plus a corresponding
            <see cref="T:int[]"/> count per state.  Used by
            <see cref="M:Lucene.Net.Util.Automaton.BasicOperations.Determinize(Lucene.Net.Util.Automaton.Automaton)"/>.
            <para/>
            NOTE: This was SortedIntSet in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.SortedInt32Set.FrozenInt32Set">
            <summary>
            NOTE: This was FrozenIntSet in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.SpecialOperations">
            <summary>
            Special automata operations.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.FindIndex(System.Int32,System.Int32[])">
            <summary>
            Finds the largest entry whose value is less than or equal to <paramref name="c"/>, or 0 if
            there is no such entry.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.IsFinite(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns <c>true</c> if the language of this automaton is finite.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.IsFinite(Lucene.Net.Util.Automaton.State,Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Checks whether there is a loop containing <paramref name="s"/>. (This is sufficient since
            there are never transitions to dead states.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.GetCommonPrefix(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns the longest string that is a prefix of all accepted strings and
            visits each state at most once.
            </summary>
            <returns> Common prefix. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.GetCommonSuffix(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns the longest string that is a suffix of all accepted strings and
            visits each state at most once.
            </summary>
            <returns> Common suffix. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.Reverse(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Reverses the language of the given (non-singleton) automaton while returning
            the set of new initial states.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.GetFiniteStrings(Lucene.Net.Util.Automaton.Automaton,System.Int32)">
            <summary>
            Returns the set of accepted strings, assuming that at most
            <paramref name="limit"/> strings are accepted. If more than <paramref name="limit"/>
            strings are accepted, the first limit strings found are returned. If <paramref name="limit"/>&lt;0, then
            the limit is infinite.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.GetFiniteStrings(Lucene.Net.Util.Automaton.State,J2N.Collections.Generic.HashSet{Lucene.Net.Util.Automaton.State},J2N.Collections.Generic.HashSet{Lucene.Net.Util.Int32sRef},Lucene.Net.Util.Int32sRef,System.Int32)">
            <summary>
            Returns the strings that can be produced from the given state, or
            <c>false</c> if more than <paramref name="limit"/> strings are found.
            <paramref name="limit"/>&lt;0 means "infinite".
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.State">
            <summary>
            <see cref="T:Lucene.Net.Util.Automaton.Automaton"/> state.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.#ctor">
            <summary>
            Constructs a new state. Initially, the new state is a reject state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.ResetTransitions">
            <summary>
            Resets transition set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.GetTransitions">
            <summary>
            Returns the set of outgoing transitions. Subsequent changes are reflected
            in the automaton.
            </summary>
            <returns> Transition set. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.AddTransition(Lucene.Net.Util.Automaton.Transition)">
            <summary>
            Adds an outgoing transition.
            </summary>
            <param name="t"> Transition. </param>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.State.Accept">
            <summary>
            Sets acceptance for this state. If <c>true</c>, this state is an accept state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.Step(System.Int32)">
            <summary>
            Performs lookup in transitions, assuming determinism.
            </summary>
            <param name="c"> Codepoint to look up. </param>
            <returns> Destination state, <c>null</c> if no matching outgoing transition. </returns>
            <seealso cref="M:Lucene.Net.Util.Automaton.State.Step(System.Int32,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.State})"/>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.Step(System.Int32,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.State})">
            <summary>
            Performs lookup in transitions, allowing nondeterminism.
            </summary>
            <param name="c"> Codepoint to look up. </param>
            <param name="dest"> Collection where destination states are stored. </param>
            <seealso cref="M:Lucene.Net.Util.Automaton.State.Step(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.AddEpsilon(Lucene.Net.Util.Automaton.State)">
            <summary>
            Virtually adds an epsilon transition to the target
            <paramref name="to"/> state.  this is implemented by copying all
            transitions from <paramref name="to"/> to this state, and if 
            <paramref name="to"/> is an accept state then set accept for this state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.TrimTransitionsArray">
            <summary>
            Downsizes transitionArray to numTransitions. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.Reduce">
            <summary>
            Reduces this state. A state is "reduced" by combining overlapping
            and adjacent edge intervals with same destination.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.SortTransitions(System.Collections.Generic.IComparer{Lucene.Net.Util.Automaton.Transition})">
            <summary>
            Returns sorted list of outgoing transitions.
            </summary>
            <param name="comparer"> Comparer to sort with. </param>
            <returns> Transition list. </returns>
            <summary>
            Sorts transitions array in-place. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.State.Number">
            <summary>
            Return this state's number.
            <para/>
            Expert: Will be useless unless <see cref="M:Lucene.Net.Util.Automaton.Automaton.GetNumberedStates"/>
            has been called first to number the states. </summary>
            <returns> The number. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.ToString">
            <summary>
            Returns string describing this state. Normally invoked via
            <see cref="M:Lucene.Net.Util.Automaton.Automaton.ToString"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.CompareTo(Lucene.Net.Util.Automaton.State)">
            <summary>
            Compares this object with the specified object for order. States are
            ordered by the time of construction.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.StatePair">
            <summary>
            Pair of states.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.StatePair.#ctor(Lucene.Net.Util.Automaton.State,Lucene.Net.Util.Automaton.State)">
            <summary>
            Constructs a new state pair.
            </summary>
            <param name="s1"> First state. </param>
            <param name="s2"> Second state. </param>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.StatePair.FirstState">
            <summary>
            Returns first component of this pair.
            </summary>
            <returns> First state. </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.StatePair.SecondState">
            <summary>
            Returns second component of this pair.
            </summary>
            <returns> Second state. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.StatePair.Equals(System.Object)">
            <summary>
            Checks for equality.
            </summary>
            <param name="obj"> Object to compare with. </param>
            <returns> <c>true</c> if <paramref name="obj"/> represents the same pair of states as this
                    pair. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.StatePair.GetHashCode">
            <summary>
            Returns hash code.
            </summary>
            <returns> Hash code. </returns>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Transition">
            <summary>
            <see cref="T:Lucene.Net.Util.Automaton.Automaton"/> transition.
            <para/>
            A transition, which belongs to a source state, consists of a Unicode
            codepoint interval and a destination state.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.#ctor(System.Int32,Lucene.Net.Util.Automaton.State)">
            <summary>
            Constructs a new singleton interval transition.
            </summary>
            <param name="c"> Transition codepoint. </param>
            <param name="to"> Destination state. </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.#ctor(System.Int32,System.Int32,Lucene.Net.Util.Automaton.State)">
            <summary>
            Constructs a new transition. Both end points are included in the interval.
            </summary>
            <param name="min"> Transition interval minimum. </param>
            <param name="max"> Transition interval maximum. </param>
            <param name="to"> Destination state. </param>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Transition.Min">
            <summary>
            Returns minimum of this transition interval. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Transition.Max">
            <summary>
            Returns maximum of this transition interval. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Transition.Dest">
            <summary>
            Returns destination of this transition. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.Equals(System.Object)">
            <summary>
            Checks for equality.
            </summary>
            <param name="obj"> Object to compare with. </param>
            <returns> <c>true</c> if <paramref name="obj"/> is a transition with same character interval
                    and destination state as this transition. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.GetHashCode">
            <summary>
            Returns hash code. The hash code is based on the character interval (not
            the destination state).
            </summary>
            <returns> Hash code. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.Clone">
            <summary>
            Clones this transition.
            </summary>
            <returns> Clone with same character interval and destination state. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.ToString">
            <summary>
            Returns a string describing this state. Normally invoked via
            <seealso cref="M:Lucene.Net.Util.Automaton.Automaton.ToString"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.UTF32ToUTF8">
            <summary>
            Converts UTF-32 automata to the equivalent UTF-8 representation.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.UTF32ToUTF8.Convert(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Converts an incoming utf32 <see cref="T:Lucene.Net.Util.Automaton.Automaton"/> to an equivalent
            utf8 one.  The incoming automaton need not be
            deterministic.  Note that the returned automaton will
            not in general be deterministic, so you must
            determinize it if that's needed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IBits">
            <summary>
            Interface for Bitset-like structures.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IBits.Get(System.Int32)">
            <summary>
            Returns the value of the bit with the specified <paramref name="index"/>.
            </summary>
            <param name="index"> Index, should be non-negative and &lt; <see cref="P:Lucene.Net.Util.IBits.Length"/>.
                   The result of passing negative or out of bounds values is undefined
                   by this interface, <b>just don't do it!</b> </param>
            <returns> <c>true</c> if the bit is set, <c>false</c> otherwise. </returns>
        </member>
        <member name="P:Lucene.Net.Util.IBits.Length">
            <summary>
            Returns the number of bits in this set </summary>
        </member>
        <member name="T:Lucene.Net.Util.Bits.MatchAllBits">
            <summary>
            Bits impl of the specified length with all bits set.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Bits.MatchNoBits">
            <summary>
            Bits impl of the specified length with no bits set.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.BitUtil">
            <summary>
            A variety of high efficiency bit twiddling routines.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.BitUtil.BIT_LISTS">
             <summary>
             the python code that generated bitlist
             <code>
             def bits2int(val):
             arr=0
             for shift in range(8,0,-1):
              if val &amp; 0x80:
                arr = (arr &lt;&lt; 4) | shift
              val = val &lt;&lt; 1
             return arr
            
             def int_table():
              tbl = [ hex(bits2int(val)).strip('L') for val in range(256) ]
              return ','.join(tbl)
             </code>
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.BitCount(System.Byte)">
            <summary>
            Return the number of bits sets in <paramref name="b"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.BitList(System.Byte)">
            <summary>
            Return the list of bits which are set in <paramref name="b"/> encoded as followed:
            <code>(i >>> (4 * n)) &amp; 0x0F</code> is the offset of the n-th set bit of
            the given byte plus one, or 0 if there are n or less bits set in the given
            byte. For example <code>bitList(12)</code> returns 0x43:
            <list type="bullet">
                <item><description><code>0x43 &amp; 0x0F</code> is 3, meaning the the first bit set is at offset 3-1 = 2,</description></item>
                <item><description><code>(0x43 >>> 4) &amp; 0x0F</code> is 4, meaning there is a second bit set at offset 4-1=3,</description></item>
                <item><description><code>(0x43 >>> 8) &amp; 0x0F</code> is 0, meaning there is no more bit set in this byte.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.Pop_Array(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the number of set bits in an array of <see cref="T:System.Int64"/>s. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.Pop_Intersect(System.Int64[],System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the popcount or cardinality of the two sets after an intersection.
            Neither array is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.Pop_Union(System.Int64[],System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the popcount or cardinality of the union of two sets.
            Neither array is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.Pop_AndNot(System.Int64[],System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the popcount or cardinality of A &amp; ~B.
            Neither array is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.Pop_Xor(System.Int64[],System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the popcount or cardinality of A ^ B
            Neither array is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.NextHighestPowerOfTwo(System.Int32)">
            <summary>
            Returns the next highest power of two, or the current value if it's already a power of two or zero </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.NextHighestPowerOfTwo(System.Int64)">
            <summary>
            Returns the next highest power of two, or the current value if it's already a power of two or zero </summary>
        </member>
        <member name="T:Lucene.Net.Util.BroadWord">
            <summary>
            Methods and constants inspired by the article
            "Broadword Implementation of Rank/Select Queries" by Sebastiano Vigna, January 30, 2012:
            <list type="bullet">
                <item><description>algorithm 1: <see cref="M:Lucene.Net.Util.BroadWord.BitCount(System.Int64)"/>, count of set bits in a <see cref="T:System.Int64"/></description></item>
                <item><description>algorithm 2: <see cref="M:Lucene.Net.Util.BroadWord.Select(System.Int64,System.Int32)"/>, selection of a set bit in a <see cref="T:System.Int64"/>,</description></item>
                <item><description>bytewise signed smaller &lt;<sub><small>8</small></sub> operator: <see cref="M:Lucene.Net.Util.BroadWord.SmallerUpTo7_8(System.Int64,System.Int64)"/>.</description></item>
                <item><description>shortwise signed smaller &lt;<sub><small>16</small></sub> operator: <see cref="M:Lucene.Net.Util.BroadWord.SmallerUpto15_16(System.Int64,System.Int64)"/>.</description></item>
                <item><description>some of the Lk and Hk constants that are used by the above:
                    L8 <see cref="F:Lucene.Net.Util.BroadWord.L8_L"/>, H8 <see cref="F:Lucene.Net.Util.BroadWord.H8_L"/>, L9 <see cref="F:Lucene.Net.Util.BroadWord.L9_L"/>, L16 <see cref="F:Lucene.Net.Util.BroadWord.L16_L"/>and H16 <see cref="F:Lucene.Net.Util.BroadWord.H8_L"/>.</description></item>
            </list>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.BitCount(System.Int64)">
            <summary>
            Bit count of a <see cref="T:System.Int64"/>.
            Only here to compare the implementation with <see cref="M:Lucene.Net.Util.BroadWord.Select(System.Int64,System.Int32)"/>,
            normally <see cref="M:J2N.Numerics.BitOperation.PopCount(System.Int64)"/> is preferable. </summary>
            <returns> The total number of 1 bits in x. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.Select(System.Int64,System.Int32)">
            <summary>
            Select a 1-bit from a <see cref="T:System.Int64"/>. </summary>
            <returns> The index of the r-th 1 bit in x, or if no such bit exists, 72. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.SmallerUpTo7_8(System.Int64,System.Int64)">
            <summary>
            A signed bytewise smaller &lt;<sub><small>8</small></sub> operator, for operands 0L&lt;= x, y &lt;=0x7L.
            This uses the following numbers of basic <see cref="T:System.Int64"/> operations: 1 or, 2 and, 2 xor, 1 minus, 1 not. </summary>
            <returns> A <see cref="T:System.Int64"/> with bits set in the <see cref="F:Lucene.Net.Util.BroadWord.H8_L"/> positions corresponding to each input signed byte pair that compares smaller. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.Smalleru_8(System.Int64,System.Int64)">
            <summary>
            An unsigned bytewise smaller &lt;<sub><small>8</small></sub> operator.
            This uses the following numbers of basic <see cref="T:System.Int64"/> operations: 3 or, 2 and, 2 xor, 1 minus, 1 not. </summary>
            <returns> A <see cref="T:System.Int64"/> with bits set in the <see cref="F:Lucene.Net.Util.BroadWord.H8_L"/> positions corresponding to each input unsigned byte pair that compares smaller. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.NotEquals0_8(System.Int64)">
            <summary>
            An unsigned bytewise not equals 0 operator.
            This uses the following numbers of basic <see cref="T:System.Int64"/> operations: 2 or, 1 and, 1 minus. </summary>
            <returns> A <see cref="T:System.Int64"/> with bits set in the <see cref="F:Lucene.Net.Util.BroadWord.H8_L"/> positions corresponding to each unsigned byte that does not equal 0. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.SmallerUpto15_16(System.Int64,System.Int64)">
            <summary>
            A bytewise smaller &lt;<sub><small>16</small></sub> operator.
            This uses the following numbers of basic <see cref="T:System.Int64"/> operations: 1 or, 2 and, 2 xor, 1 minus, 1 not. </summary>
            <returns> A <see cref="T:System.Int64"/> with bits set in the <see cref="F:Lucene.Net.Util.BroadWord.H16_L"/> positions corresponding to each input signed short pair that compares smaller. </returns>
        </member>
        <member name="F:Lucene.Net.Util.BroadWord.L8_L">
            <summary>
            Lk denotes the constant whose ones are in position 0, k, 2k, . . .
            These contain the low bit of each group of k bits.
            The suffix _L indicates the <see cref="T:System.Int64"/> implementation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.BroadWord.H8_L">
            <summary>
            Hk = Lk &lt;&lt; (k-1) .
            These contain the high bit of each group of k bits.
            The suffix _L indicates the <see cref="T:System.Int64"/> implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.SelectNaive(System.Int64,System.Int32)">
            <summary>
            Naive implementation of <see cref="M:Lucene.Net.Util.BroadWord.Select(System.Int64,System.Int32)"/>, using <see cref="M:J2N.Numerics.BitOperation.TrailingZeroCount(System.Int64)"/> repetitively.
            Works relatively fast for low ranks. </summary>
            <returns> The index of the r-th 1 bit in x, or if no such bit exists, 72. </returns>
        </member>
        <member name="T:Lucene.Net.Util.ByteBlockPool">
            <summary>
            Class that Posting and PostingVector use to write byte
            streams into shared fixed-size <see cref="T:byte[]"/> arrays.  The idea
            is to allocate slices of increasing lengths. For
            example, the first slice is 5 bytes, the next slice is
            14, etc.  We start by writing our bytes into the first
            5 bytes.  When we hit the end of the slice, we allocate
            the next slice and then write the address of the new
            slice into the last 4 bytes of the previous slice (the
            "forwarding address").
            <para/>
            Each slice is filled with 0's initially, and we mark
            the end with a non-zero byte.  This way the methods
            that are writing into the slice don't need to record
            its length and instead allocate a new slice once they
            hit a non-zero byte.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ByteBlockPool.Allocator">
            <summary>
            Abstract class for allocating and freeing byte
            blocks.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ByteBlockPool.DirectAllocator">
            <summary>
            A simple <see cref="T:Lucene.Net.Util.ByteBlockPool.Allocator"/> that never recycles. </summary>
        </member>
        <member name="T:Lucene.Net.Util.ByteBlockPool.DirectTrackingAllocator">
            <summary>
            A simple <see cref="T:Lucene.Net.Util.ByteBlockPool.Allocator"/> that never recycles, but
            tracks how much total RAM is in use.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.ByteBlockPool.Buffers">
            <summary>
            Array of buffers currently used in the pool. Buffers are allocated if
            needed don't modify this outside of this class.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.bufferUpto">
            <summary>
            index into the buffers array pointing to the current buffer used as the head </summary>
        </member>
        <member name="P:Lucene.Net.Util.ByteBlockPool.ByteUpto">
            <summary>
            Where we are in head buffer </summary>
        </member>
        <member name="P:Lucene.Net.Util.ByteBlockPool.Buffer">
            <summary>
            Current head buffer
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.ByteBlockPool.ByteOffset">
            <summary>
            Current head offset </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.Reset">
            <summary>
            Resets the pool to its initial state reusing the first buffer and fills all
            buffers with <c>0</c> bytes before they reused or passed to
            <see cref="M:Lucene.Net.Util.ByteBlockPool.Allocator.RecycleByteBlocks(System.Byte[][],System.Int32,System.Int32)"/>. Calling
            <see cref="M:Lucene.Net.Util.ByteBlockPool.NextBuffer"/> is not needed after reset.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.Reset(System.Boolean,System.Boolean)">
            <summary>
            Expert: Resets the pool to its initial state reusing the first buffer. Calling
            <see cref="M:Lucene.Net.Util.ByteBlockPool.NextBuffer"/> is not needed after reset. </summary>
            <param name="zeroFillBuffers"> if <c>true</c> the buffers are filled with <tt>0</tt>.
                   this should be set to <c>true</c> if this pool is used with slices. </param>
            <param name="reuseFirst"> if <c>true</c> the first buffer will be reused and calling
                   <see cref="M:Lucene.Net.Util.ByteBlockPool.NextBuffer"/> is not needed after reset if the
                   block pool was used before ie. <see cref="M:Lucene.Net.Util.ByteBlockPool.NextBuffer"/> was called before. </param>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.NextBuffer">
            <summary>
            Advances the pool to its next buffer. This method should be called once
            after the constructor to initialize the pool. In contrast to the
            constructor a <see cref="M:Lucene.Net.Util.ByteBlockPool.Reset"/> call will advance the pool to
            its first buffer immediately.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.NewSlice(System.Int32)">
            <summary>
            Allocates a new slice with the given size.</summary>
            <seealso cref="F:Lucene.Net.Util.ByteBlockPool.FIRST_LEVEL_SIZE"/>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.NEXT_LEVEL_ARRAY">
            <summary>
            An array holding the offset into the <see cref="F:Lucene.Net.Util.ByteBlockPool.LEVEL_SIZE_ARRAY"/>
            to quickly navigate to the next slice level.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.LEVEL_SIZE_ARRAY">
            <summary>
            An array holding the level sizes for byte slices.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.FIRST_LEVEL_SIZE">
            <summary>
            The first level size for new slices </summary>
            <seealso cref="M:Lucene.Net.Util.ByteBlockPool.NewSlice(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.AllocSlice(System.Byte[],System.Int32)">
            <summary>
            Creates a new byte slice with the given starting size and
            returns the slices offset in the pool.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.Append(Lucene.Net.Util.BytesRef)">
            <summary>
            Appends the bytes in the provided <see cref="T:Lucene.Net.Util.BytesRef"/> at
            the current position.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.ReadBytes(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes bytes out of the pool starting at the given offset with the given
            length into the given byte array at offset <c>off</c>.
            <para>Note: this method allows to copy across block boundaries.</para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.BytesRef">
             <summary>
             Represents <see cref="T:byte[]"/>, as a slice (offset + length) into an
             existing <see cref="T:byte[]"/>.  The <see cref="P:Lucene.Net.Util.BytesRef.Bytes"/> property should never be <c>null</c>;
             use <see cref="F:Lucene.Net.Util.BytesRef.EMPTY_BYTES"/> if necessary.
            
             <para/><b>Important note:</b> Unless otherwise noted, Lucene uses this class to
             represent terms that are encoded as <b>UTF8</b> bytes in the index. To
             convert them to a .NET <see cref="T:System.String"/> (which is UTF16), use <see cref="M:Lucene.Net.Util.BytesRef.Utf8ToString"/>.
             Using code like <c>new String(bytes, offset, length)</c> to do this
             is <b>wrong</b>, as it does not respect the correct character set
             and may return wrong results (depending on the platform's defaults)!
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.BytesRef.EMPTY_BYTES">
            <summary>
            An empty byte array for convenience </summary>
        </member>
        <member name="P:Lucene.Net.Util.BytesRef.Bytes">
            <summary>
            The contents of the BytesRef. Should never be <c>null</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.BytesRef.Offset">
            <summary>
            Offset of first valid byte.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.BytesRef.Length">
            <summary>
            Length of used bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor">
            <summary>
            Create a <see cref="T:Lucene.Net.Util.BytesRef"/> with <see cref="F:Lucene.Net.Util.BytesRef.EMPTY_BYTES"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This instance will directly reference <paramref name="bytes"/> w/o making a copy.
            <paramref name="bytes"/> should not be <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(System.Byte[])">
            <summary>
            This instance will directly reference <paramref name="bytes"/> w/o making a copy.
            <paramref name="bytes"/> should not be <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(System.Int32)">
            <summary>
            Create a <see cref="T:Lucene.Net.Util.BytesRef"/> pointing to a new array of size <paramref name="capacity"/>.
            Offset and length will both be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(J2N.Text.ICharSequence)">
            <summary>
            Initialize the <see cref="T:byte[]"/> from the UTF8 bytes
            for the provided <see cref="T:J2N.Text.ICharSequence"/>.
            </summary>
            <param name="text"> This must be well-formed
            unicode text, with no unpaired surrogates. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(System.String)">
            <summary>
            Initialize the <see cref="T:byte[]"/> from the UTF8 bytes
            for the provided <see cref="T:System.String"/>.
            </summary>
            <param name="text"> This must be well-formed
            unicode text, with no unpaired surrogates. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.CopyChars(J2N.Text.ICharSequence)">
            <summary>
            Copies the UTF8 bytes for this <see cref="T:J2N.Text.ICharSequence"/>.
            </summary>
            <param name="text"> Must be well-formed unicode text, with no
            unpaired surrogates or invalid UTF16 code units. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.CopyChars(System.String)">
            <summary>
            Copies the UTF8 bytes for this <see cref="T:System.String"/>.
            </summary>
            <param name="text"> Must be well-formed unicode text, with no
            unpaired surrogates or invalid UTF16 code units. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.BytesEquals(Lucene.Net.Util.BytesRef)">
            <summary>
            Expert: Compares the bytes against another <see cref="T:Lucene.Net.Util.BytesRef"/>,
            returning <c>true</c> if the bytes are equal.
            <para/>
            @lucene.internal
            </summary>
            <param name="other"> Another <see cref="T:Lucene.Net.Util.BytesRef"/>, should not be <c>null</c>. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.Clone">
            <summary>
            Returns a shallow clone of this instance (the underlying bytes are
            <b>not</b> copied and will be shared by both the returned object and this
            object.
            </summary>
            <seealso cref="M:Lucene.Net.Util.BytesRef.DeepCopyOf(Lucene.Net.Util.BytesRef)"/>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.GetHashCode">
            <summary>
            Calculates the hash code as required by <see cref="T:Lucene.Net.Index.TermsHash"/> during indexing.
            <para/> This is currently implemented as MurmurHash3 (32
            bit), using the seed from 
            <see cref="F:Lucene.Net.Util.StringHelper.GOOD_FAST_HASH_SEED"/>, but is subject to
            change from release to release.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.Utf8ToString">
            <summary>
            Interprets stored bytes as UTF8 bytes, returning the
            resulting <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.ToString">
            <summary>
            Returns hex encoded bytes, eg [0x6c 0x75 0x63 0x65 0x6e 0x65] </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.CopyBytes(Lucene.Net.Util.BytesRef)">
            <summary>
            Copies the bytes from the given <see cref="T:Lucene.Net.Util.BytesRef"/>
            <para/>
            NOTE: if this would exceed the array size, this method creates a
            new reference array.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.Append(Lucene.Net.Util.BytesRef)">
            <summary>
            Appends the bytes from the given <see cref="T:Lucene.Net.Util.BytesRef"/>
            <para/>
            NOTE: if this would exceed the array size, this method creates a
            new reference array.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.Grow(System.Int32)">
            <summary>
            Used to grow the reference array.
            <para/>
            In general this should not be used as it does not take the offset into account.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.CompareTo(System.Object)">
            <summary>
            Unsigned byte order comparison </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.CompareTo(Lucene.Net.Util.BytesRef)">
            <summary>
            Unsigned byte order comparison </summary>
        </member>
        <member name="F:Lucene.Net.Util.BytesRef.utf8SortedAsUTF16SortOrder">
            @deprecated this comparer is only a transition mechanism
        </member>
        <member name="P:Lucene.Net.Util.BytesRef.UTF8SortedAsUTF16Comparer">
            @deprecated this comparer is only a transition mechanism
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.DeepCopyOf(Lucene.Net.Util.BytesRef)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.BytesRef"/> that points to a copy of the bytes from
            <paramref name="other"/>.
            <para/>
            The returned <see cref="T:Lucene.Net.Util.BytesRef"/> will have a length of <c>other.Length</c>
            and an offset of zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.IsValid">
            <summary>
            Performs internal consistency checks.
            Always returns true (or throws <see cref="T:System.InvalidOperationException"/>)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Utf8SortedAsUtf16Comparer">
            @deprecated this comparer is only a transition mechanism
        </member>
        <member name="T:Lucene.Net.Util.BytesRefArray">
            <summary>
            A simple append only random-access <see cref="T:Lucene.Net.Util.BytesRef"/> array that stores full
            copies of the appended bytes in a <see cref="T:Lucene.Net.Util.ByteBlockPool"/>.
            <para/>
            <b>Note: this class is not Thread-Safe!</b>
            <para/>
            @lucene.internal
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.#ctor(Lucene.Net.Util.Counter)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.BytesRefArray"/> with a counter to track allocated bytes
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.Clear">
            <summary>
            Clears this <see cref="T:Lucene.Net.Util.BytesRefArray"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.Append(Lucene.Net.Util.BytesRef)">
            <summary>
            Appends a copy of the given <see cref="T:Lucene.Net.Util.BytesRef"/> to this <see cref="T:Lucene.Net.Util.BytesRefArray"/>. </summary>
            <param name="bytes"> The bytes to append </param>
            <returns> The index of the appended bytes </returns>
        </member>
        <member name="P:Lucene.Net.Util.BytesRefArray.Length">
            <summary>
            Returns the current size of this <see cref="T:Lucene.Net.Util.BytesRefArray"/>.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
            <returns> The current size of this <see cref="T:Lucene.Net.Util.BytesRefArray"/> </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.Get(Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            Returns the <i>n'th</i> element of this <see cref="T:Lucene.Net.Util.BytesRefArray"/> </summary>
            <param name="spare"> A spare <see cref="T:Lucene.Net.Util.BytesRef"/> instance </param>
            <param name="index"> The elements index to retrieve </param>
            <returns> The <i>n'th</i> element of this <see cref="T:Lucene.Net.Util.BytesRefArray"/> </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.GetIterator">
            <summary>
            Sugar for <see cref="M:Lucene.Net.Util.BytesRefArray.GetIterator(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})"/> with a <c>null</c> comparer
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.GetIterator(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})">
            <summary>
            <para>
            Returns a <see cref="T:Lucene.Net.Util.IBytesRefIterator"/> with point in time semantics. The
            iterator provides access to all so far appended <see cref="T:Lucene.Net.Util.BytesRef"/> instances.
            </para>
            <para>
            If a non <c>null</c> <see cref="T:IComparer{BytesRef}"/> is provided the iterator will
            iterate the byte values in the order specified by the comparer. Otherwise
            the order is the same as the values were appended.
            </para>
            <para>
            This is a non-destructive operation.
            </para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefHash">
             <summary>
             <see cref="T:Lucene.Net.Util.BytesRefHash"/> is a special purpose hash-map like data-structure
             optimized for <see cref="T:Lucene.Net.Util.BytesRef"/> instances. <see cref="T:Lucene.Net.Util.BytesRefHash"/> maintains mappings of
             byte arrays to ids (Map&lt;BytesRef,int&gt;) storing the hashed bytes
             efficiently in continuous storage. The mapping to the id is
             encapsulated inside <see cref="T:Lucene.Net.Util.BytesRefHash"/> and is guaranteed to be increased
             for each added <see cref="T:Lucene.Net.Util.BytesRef"/>.
            
             <para>
             Note: The maximum capacity <see cref="T:Lucene.Net.Util.BytesRef"/> instance passed to
             <see cref="M:Lucene.Net.Util.BytesRefHash.Add(Lucene.Net.Util.BytesRef)"/> must not be longer than <see cref="F:Lucene.Net.Util.ByteBlockPool.BYTE_BLOCK_SIZE"/>-2.
             The internal storage is limited to 2GB total byte storage.
             </para>
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.#ctor">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.BytesRefHash"/> with a <see cref="T:Lucene.Net.Util.ByteBlockPool"/> using a
            <see cref="T:Lucene.Net.Util.ByteBlockPool.DirectAllocator"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.#ctor(Lucene.Net.Util.ByteBlockPool)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.BytesRefHash"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.#ctor(Lucene.Net.Util.ByteBlockPool,System.Int32,Lucene.Net.Util.BytesRefHash.BytesStartArray)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.BytesRefHash"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.BytesRefHash.Count">
            <summary>
            Returns the number of <see cref="T:Lucene.Net.Util.BytesRef"/> values in this <see cref="T:Lucene.Net.Util.BytesRefHash"/>.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
            <returns> The number of <see cref="T:Lucene.Net.Util.BytesRef"/> values in this <see cref="T:Lucene.Net.Util.BytesRefHash"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Get(System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Populates and returns a <see cref="T:Lucene.Net.Util.BytesRef"/> with the bytes for the given
            bytesID.
            <para/>
            Note: the given bytesID must be a positive integer less than the current
            size (<see cref="P:Lucene.Net.Util.BytesRefHash.Count"/>)
            </summary>
            <param name="bytesID">
                     The id </param>
            <param name="ref">
                     The <see cref="T:Lucene.Net.Util.BytesRef"/> to populate
            </param>
            <returns> The given <see cref="T:Lucene.Net.Util.BytesRef"/> instance populated with the bytes for the given
                    bytesID </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Compact">
            <summary>
            Returns the ids array in arbitrary order. Valid ids start at offset of 0
            and end at a limit of <see cref="P:Lucene.Net.Util.BytesRefHash.Count"/> - 1
            <para>
            Note: this is a destructive operation. <see cref="M:Lucene.Net.Util.BytesRefHash.Clear"/> must be called in
            order to reuse this <see cref="T:Lucene.Net.Util.BytesRefHash"/> instance.
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Sort(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})">
            <summary>
            Returns the values array sorted by the referenced byte values.
            <para>
            Note: this is a destructive operation. <see cref="M:Lucene.Net.Util.BytesRefHash.Clear"/> must be called in
            order to reuse this <see cref="T:Lucene.Net.Util.BytesRefHash"/> instance.
            </para>
            </summary>
            <param name="comp">
                     The <see cref="T:IComparer{BytesRef}"/> used for sorting </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Clear(System.Boolean)">
            <summary>
            Clears the <see cref="T:Lucene.Net.Util.BytesRef"/> which maps to the given <see cref="T:Lucene.Net.Util.BytesRef"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Dispose">
            <summary>
            Closes the <see cref="T:Lucene.Net.Util.BytesRefHash"/> and releases all internally used memory
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Add(Lucene.Net.Util.BytesRef)">
            <summary>
            Adds a new <see cref="T:Lucene.Net.Util.BytesRef"/>
            </summary>
            <param name="bytes">
                     The bytes to hash </param>
            <returns> The id the given bytes are hashed if there was no mapping for the
                    given bytes, otherwise <c>(-(id)-1)</c>. this guarantees
                    that the return value will always be &gt;= 0 if the given bytes
                    haven't been hashed before.
            </returns>
            <exception cref="T:Lucene.Net.Util.BytesRefHash.MaxBytesLengthExceededException">
                      if the given bytes are > 2 +
                      <see cref="F:Lucene.Net.Util.ByteBlockPool.BYTE_BLOCK_SIZE"/> </exception>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Find(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns the id of the given <see cref="T:Lucene.Net.Util.BytesRef"/>.
            </summary>
            <param name="bytes">
                     The bytes to look for
            </param>
            <returns> The id of the given bytes, or <c>-1</c> if there is no mapping for the
                    given bytes. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.AddByPoolOffset(System.Int32)">
            <summary>
            Adds a "arbitrary" int offset instead of a <see cref="T:Lucene.Net.Util.BytesRef"/>
            term.  This is used in the indexer to hold the hash for term
            vectors, because they do not redundantly store the <see cref="T:byte[]"/> term
            directly and instead reference the <see cref="T:byte[]"/> term
            already stored by the postings <see cref="T:Lucene.Net.Util.BytesRefHash"/>.  See
            <see cref="M:Lucene.Net.Index.TermsHashPerField.Add(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Rehash(System.Int32,System.Boolean)">
            <summary>
            Called when hash is too small (&gt; 50% occupied) or too large (&lt; 20%
            occupied).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Reinit">
            <summary>
            Reinitializes the <see cref="T:Lucene.Net.Util.BytesRefHash"/> after a previous <see cref="M:Lucene.Net.Util.BytesRefHash.Clear"/>
            call. If <see cref="M:Lucene.Net.Util.BytesRefHash.Clear"/> has not been called previously this method has no
            effect.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.ByteStart(System.Int32)">
            <summary>
            Returns the bytesStart offset into the internally used
            <see cref="T:Lucene.Net.Util.ByteBlockPool"/> for the given <paramref name="bytesID"/>
            </summary>
            <param name="bytesID">
                     The id to look up </param>
            <returns> The bytesStart offset into the internally used
                    <see cref="T:Lucene.Net.Util.ByteBlockPool"/> for the given id </returns>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefHash.MaxBytesLengthExceededException">
            <summary>
            Thrown if a <see cref="T:Lucene.Net.Util.BytesRef"/> exceeds the <see cref="T:Lucene.Net.Util.BytesRefHash"/> limit of
            <see cref="F:Lucene.Net.Util.ByteBlockPool.BYTE_BLOCK_SIZE"/>-2.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.MaxBytesLengthExceededException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefHash.BytesStartArray">
            <summary>
            Manages allocation of the per-term addresses. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.BytesStartArray.Init">
            <summary>
            Initializes the <see cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/>. This call will allocate memory.
            </summary>
            <returns> The initialized bytes start array. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.BytesStartArray.Grow">
            <summary>
            Grows the <see cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/>.
            </summary>
            <returns> The grown array. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.BytesStartArray.Clear">
            <summary>
            Clears the <see cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/> and returns the cleared instance.
            </summary>
            <returns> The cleared instance, this might be <c>null</c>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.BytesStartArray.BytesUsed">
            <summary>
            A <see cref="T:Lucene.Net.Util.Counter"/> reference holding the number of bytes used by this
            <see cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/>. The <see cref="T:Lucene.Net.Util.BytesRefHash"/> uses this reference to
            track it memory usage.
            </summary>
            <returns> a <see cref="T:J2N.Threading.Atomic.AtomicInt64"/> reference holding the number of bytes used
                    by this <see cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/>. </returns>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefHash.DirectBytesStartArray">
            <summary>
            A simple <see cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/> that tracks
            memory allocation using a private <see cref="T:Lucene.Net.Util.Counter"/>
            instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IBytesRefIterator">
            <summary>
            A simple iterator interface for <see cref="T:Lucene.Net.Util.BytesRef"/> iteration.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IBytesRefIterator.Next">
            <summary>
            Increments the iteration to the next <see cref="T:Lucene.Net.Util.BytesRef"/> in the iterator.
            Returns the resulting <see cref="T:Lucene.Net.Util.BytesRef"/> or <c>null</c> if the end of
            the iterator is reached. The returned <see cref="T:Lucene.Net.Util.BytesRef"/> may be re-used across calls
            to <see cref="M:Lucene.Net.Util.IBytesRefIterator.Next"/>. After this method returns <c>null</c>, do not call it again: the results
            are undefined.
            </summary>
            <returns> The next <see cref="T:Lucene.Net.Util.BytesRef"/> in the iterator or <c>null</c> if
                    the end of the iterator is reached. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="P:Lucene.Net.Util.IBytesRefIterator.Comparer">
            <summary>
            Return the <see cref="T:Lucene.Net.Util.BytesRef"/> Comparer used to sort terms provided by the
            iterator. This may return <c>null</c> if there are no items or the iterator is not
            sorted. Callers may invoke this method many times, so it's best to cache a
            single instance &amp; reuse it.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefIterator">
            <summary>
            LUCENENET specific class to make the syntax of creating an empty
            <see cref="T:Lucene.Net.Util.IBytesRefIterator"/> the same as it was in Lucene. Example:
            <code>
            var iter = BytesRefIterator.Empty;
            </code>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.BytesRefIterator.EMPTY">
            <summary>
            Singleton <see cref="T:Lucene.Net.Util.BytesRefIterator"/> that iterates over 0 BytesRefs.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.CharsRef">
            <summary>
            Represents <see cref="T:char[]"/>, as a slice (offset + Length) into an existing <see cref="T:char[]"/>.
            The <see cref="P:Lucene.Net.Util.CharsRef.Chars"/> property should never be <c>null</c>; use
            <see cref="F:Lucene.Net.Util.CharsRef.EMPTY_CHARS"/> if necessary.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.CharsRef.EMPTY_CHARS">
            <summary>
            An empty character array for convenience </summary>
        </member>
        <member name="P:Lucene.Net.Util.CharsRef.Chars">
            <summary>
            The contents of the <see cref="T:Lucene.Net.Util.CharsRef"/>. Should never be <c>null</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.CharsRef.Offset">
            <summary>
            Offset of first valid character. </summary>
        </member>
        <member name="P:Lucene.Net.Util.CharsRef.Length">
            <summary>
            Length of used characters. </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.#ctor">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.CharsRef"/> initialized an empty array zero-Length
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.CharsRef"/> initialized with an array of the given
            <paramref name="capacity"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.#ctor(System.Char[],System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.CharsRef"/> initialized with the given <paramref name="chars"/>, 
            <paramref name="offset"/> and <paramref name="length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.CharsRef"/> initialized with the given <see cref="T:System.String"/> character
            array.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.Clone">
            <summary>
            Returns a shallow clone of this instance (the underlying characters are
            <b>not</b> copied and will be shared by both the returned object and this
            object.
            </summary>
            <seealso cref="M:Lucene.Net.Util.CharsRef.DeepCopyOf(Lucene.Net.Util.CharsRef)"/>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.CompareTo(Lucene.Net.Util.CharsRef)">
            <summary>
            Signed <see cref="T:System.Int32"/> order comparison </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.CopyChars(Lucene.Net.Util.CharsRef)">
            <summary>
            Copies the given <see cref="T:Lucene.Net.Util.CharsRef"/> referenced content into this instance.
            </summary>
            <param name="other">
                     The <see cref="T:Lucene.Net.Util.CharsRef"/> to copy. </param>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.Grow(System.Int32)">
            <summary>
            Used to grow the reference array.
            <para/>
            In general this should not be used as it does not take the offset into account.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.CopyChars(System.Char[],System.Int32,System.Int32)">
            <summary>
            Copies the given array into this <see cref="T:Lucene.Net.Util.CharsRef"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.Append(System.Char[],System.Int32,System.Int32)">
            <summary>
            Appends the given array to this <see cref="T:Lucene.Net.Util.CharsRef"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.CharsRef.utf16SortedAsUTF8SortOrder">
            @deprecated this comparer is only a transition mechanism
        </member>
        <member name="P:Lucene.Net.Util.CharsRef.UTF16SortedAsUTF8Comparer">
            @deprecated this comparer is only a transition mechanism
        </member>
        <member name="T:Lucene.Net.Util.CharsRef.Utf16SortedAsUTF8Comparer">
            @deprecated this comparer is only a transition mechanism
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.DeepCopyOf(Lucene.Net.Util.CharsRef)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.CharsRef"/> that points to a copy of the chars from
            <paramref name="other"/>.
            <para/>
            The returned <see cref="T:Lucene.Net.Util.CharsRef"/> will have a Length of <c>other.Length</c>
            and an offset of zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.IsValid">
            <summary>
            Performs internal consistency checks.
            Always returns true (or throws <see cref="T:System.InvalidOperationException"/>)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.DisposableThreadLocal`1">
            <summary>
            Java's builtin ThreadLocal has a serious flaw:
            it can take an arbitrarily long amount of time to
            dereference the things you had stored in it, even once the
            ThreadLocal instance itself is no longer referenced.
            This is because there is single, master map stored for
            each thread, which all ThreadLocals share, and that
            master map only periodically purges "stale" entries.
            <para/>
            While not technically a memory leak, because eventually
            the memory will be reclaimed, it can take a long time
            and you can easily hit <see cref="T:System.OutOfMemoryException"/> because from the
            GC's standpoint the stale entries are not reclaimable.
            <para/>
            This class works around that, by only enrolling
            WeakReference values into the ThreadLocal, and
            separately holding a hard reference to each stored
            value.  When you call <see cref="M:Lucene.Net.Util.DisposableThreadLocal`1.Dispose"/>, these hard
            references are cleared and then GC is freely able to
            reclaim space by objects stored in it.
            <para/>
            You should not call <see cref="M:Lucene.Net.Util.DisposableThreadLocal`1.Dispose"/> until all
            threads are done using the instance.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.CollectionUtil">
            <summary>
            Methods for manipulating (sorting) collections.
            Sort methods work directly on the supplied lists and don't copy to/from arrays
            before/after. For medium size collections as used in the Lucene indexer that is
            much more efficient.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CollectionUtil.IntroSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> using the <see cref="T:System.Collections.Generic.IComparer`1"/>.
            This method uses the intro sort
            algorithm, but falls back to insertion sort for small lists. 
            </summary>
            <param name="list">This <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="comp">The <see cref="T:System.Collections.Generic.IComparer`1"/> to use for the sort.</param>
        </member>
        <member name="M:Lucene.Net.Util.CollectionUtil.IntroSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the given random access <see cref="T:System.Collections.Generic.IList`1"/> in natural order.
            This method uses the intro sort
            algorithm, but falls back to insertion sort for small lists. 
            </summary>
            <param name="list">This <see cref="T:System.Collections.Generic.IList`1"/></param>
        </member>
        <member name="M:Lucene.Net.Util.CollectionUtil.TimSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> using the <see cref="T:System.Collections.Generic.IComparer`1"/>.
            This method uses the Tim sort
            algorithm, but falls back to binary sort for small lists.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="comp">The <see cref="T:System.Collections.Generic.IComparer`1"/> to use for the sort.</param>
        </member>
        <member name="M:Lucene.Net.Util.CollectionUtil.TimSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> in natural order.
            This method uses the Tim sort
            algorithm, but falls back to binary sort for small lists. </summary>
            <param name="list">This <see cref="T:System.Collections.Generic.IList`1"/></param>
        </member>
        <member name="T:Lucene.Net.Util.CommandLineUtil">
            <summary>
            Class containing some useful methods used by command line tools
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CommandLineUtil.NewFSDirectory(System.String,System.IO.DirectoryInfo)">
            <summary>
            Creates a specific <see cref="T:Lucene.Net.Store.FSDirectory"/> instance starting from its class name. </summary>
            <param name="clazzName"> The name of the <see cref="T:Lucene.Net.Store.FSDirectory"/> class to load. </param>
            <param name="dir"> The <see cref="T:System.IO.DirectoryInfo"/> to be used as parameter constructor. </param>
            <returns> The new <see cref="T:Lucene.Net.Store.FSDirectory"/> instance </returns>
        </member>
        <member name="M:Lucene.Net.Util.CommandLineUtil.LoadDirectoryClass(System.String)">
            <summary>
            Loads a specific <see cref="T:Lucene.Net.Store.Directory"/> implementation. </summary>
            <param name="clazzName"> The name of the <see cref="T:Lucene.Net.Store.Directory"/> class to load. </param>
            <returns> The <see cref="T:Lucene.Net.Store.Directory"/> class loaded. </returns>
            <exception cref="T:System.TypeLoadException"> If the specified class cannot be found. </exception>
        </member>
        <member name="M:Lucene.Net.Util.CommandLineUtil.LoadFSDirectoryClass(System.String)">
            <summary>
            Loads a specific <see cref="T:Lucene.Net.Store.FSDirectory"/> implementation. </summary>
            <param name="clazzName"> The name of the <see cref="T:Lucene.Net.Store.FSDirectory"/> class to load. </param>
            <returns> The <see cref="T:Lucene.Net.Store.FSDirectory"/> class loaded. </returns>
            <exception cref="T:System.TypeLoadException"> If the specified class cannot be found. </exception>
        </member>
        <member name="M:Lucene.Net.Util.CommandLineUtil.NewFSDirectory(System.Type,System.IO.DirectoryInfo)">
            <summary>
            Creates a new specific <see cref="T:Lucene.Net.Store.FSDirectory"/> instance. </summary>
            <param name="clazz"> The class of the object to be created </param>
            <param name="dir"> The <see cref="T:System.IO.DirectoryInfo"/> to be used as parameter constructor </param>
            <returns> The new <see cref="T:Lucene.Net.Store.FSDirectory"/> instance. </returns>
            <exception cref="T:System.MissingMethodException"> If the <see cref="T:Lucene.Net.Store.Directory"/> does not have a constructor that takes <see cref="T:System.IO.DirectoryInfo"/>. </exception>
            <exception cref="T:System.MemberAccessException"> If the class is abstract or an interface. </exception>
            <exception cref="T:System.TypeLoadException"> If the constructor does not have public visibility. </exception>
            <exception cref="T:System.Reflection.TargetInvocationException"> If the constructor throws an exception </exception>
        </member>
        <member name="T:Lucene.Net.Util.Constants">
            <summary>
            Some useful constants.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.RUNTIME_VENDOR">
            <summary>
            NOTE: This was JAVA_VENDOR in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.OS_NAME">
            <summary>
            The value of System.Environment.OSVersion.VersionString, excluding the version number.</summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.LINUX">
            <summary>
            True iff running on Linux. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.WINDOWS">
            <summary>
            True iff running on Windows. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.SUN_OS">
            <summary>
            True iff running on SunOS. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.MAC_OS_X">
            <summary>
            True iff running on Mac OS X </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.FREE_BSD">
            <summary>
            True iff running on FreeBSD </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.RUNTIME_VERSION">
            <summary>
            The value of the currently installed .NET Framework version on Windows or <see cref="P:System.Environment.Version"/> on other operating systems.
            <para/>
            NOTE: This was JAVA_VERSION in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.RUNTIME_IS_64BIT">
            <summary>
            NOTE: This was JRE_IS_64BIT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.LUCENE_MAIN_VERSION">
            <summary>
            this is the internal Lucene version, recorded into each segment.
            NOTE: we track per-segment version as a <see cref="T:System.String"/> with the <c>"X.Y"</c> format
            (no minor version), e.g. <c>"4.0", "3.1", "3.0"</c>.
            <para/>Alpha and Beta versions will have numbers like <c>"X.Y.0.Z"</c>,
            anything else is not allowed. This is done to prevent people from
            using indexes created with ALPHA/BETA versions with the released version.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.LUCENE_VERSION">
            <summary>
            This is the Lucene version for display purposes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Constants.MainVersionWithoutAlphaBeta">
            <summary>
            Returns a LUCENE_MAIN_VERSION without any ALPHA/BETA qualifier
            Used by test only!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Constants.ExtractString(System.String,System.Text.RegularExpressions.Regex)">
            <summary>
            Extracts the first group matched with the regex as a new string.
            </summary>
            <param name="input">The string to examine</param>
            <param name="pattern">A regex object to use to extract the string</param>
        </member>
        <member name="T:Lucene.Net.Util.Counter">
            <summary>
            Simple counter class
            <para/>
            @lucene.internal
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Counter.AddAndGet(System.Int64)">
            <summary>
            Adds the given delta to the counters current value.
            </summary>
            <param name="delta">
                     The delta to add. </param>
            <returns> The counters updated value. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Counter.Get">
            <summary>
            Returns the counters current value.
            </summary>
            <returns> The counters current value. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Counter.NewCounter">
            <summary>
            Returns a new counter. The returned counter is not thread-safe.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Counter.NewCounter(System.Boolean)">
            <summary>
            Returns a new counter.
            </summary>
            <param name="threadSafe">
                     <c>true</c> if the returned counter can be used by multiple
                     threads concurrently. </param>
            <returns> A new counter. </returns>
        </member>
        <member name="T:Lucene.Net.Util.DocIdBitSet">
            <summary>
            Simple <see cref="T:Lucene.Net.Search.DocIdSet"/> and <see cref="T:Lucene.Net.Search.DocIdSetIterator"/> backed by a <see cref="T:System.Collections.BitArray"/> 
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.DocIdBitSet.IsCacheable">
            <summary>
            This DocIdSet implementation is cacheable. </summary>
        </member>
        <member name="P:Lucene.Net.Util.DocIdBitSet.BitSet">
            <summary>
            Returns the underlying <see cref="T:System.Collections.BitArray"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.DoubleBarrelLRUCache`2">
             <summary>
             Simple concurrent LRU cache, using a "double barrel"
             approach where two ConcurrentHashMaps record entries.
            
             <para>At any given time, one hash is primary and the other
             is secondary.  <see cref="M:Lucene.Net.Util.DoubleBarrelLRUCache`2.Get(`0)"/> first checks primary, and if
             that's a miss, checks secondary.  If secondary has the
             entry, it's promoted to primary (<b>NOTE</b>: the key is
             cloned at this point).  Once primary is full, the
             secondary is cleared and the two are swapped.</para>
            
             <para>This is not as space efficient as other possible
             concurrent approaches (see LUCENE-2075): to achieve
             perfect LRU(N) it requires 2*N storage.  But, this
             approach is relatively simple and seems in practice to
             not grow unbounded in size when under hideously high
             load.</para>
            
             @lucene.internal
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.DoubleBarrelLRUCache">
            <summary>
            LUCENENET specific class to nest the <see cref="T:Lucene.Net.Util.DoubleBarrelLRUCache.CloneableKey"/>
            so it can be accessed without referencing the generic closing types
            of <see cref="T:Lucene.Net.Util.DoubleBarrelLRUCache`2"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.DoubleBarrelLRUCache.CloneableKey">
            <summary>
            Object providing clone(); the key class must subclass this.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.FieldCacheSanityChecker">
            <summary>
            <para>
            Provides methods for sanity checking that entries in the FieldCache
            are not wasteful or inconsistent.
            </para>
            <para>
            Lucene 2.9 Introduced numerous enhancements into how the FieldCache
            is used by the low levels of Lucene searching (for Sorting and
            ValueSourceQueries) to improve both the speed for Sorting, as well
            as reopening of IndexReaders.  But these changes have shifted the
            usage of FieldCache from "top level" IndexReaders (frequently a
            MultiReader or DirectoryReader) down to the leaf level SegmentReaders.
            As a result, existing applications that directly access the FieldCache
            may find RAM usage increase significantly when upgrading to 2.9 or
            Later.  This class provides an API for these applications (or their
            Unit tests) to check at run time if the FieldCache contains "insane"
            usages of the FieldCache.
            </para>
            @lucene.experimental 
            </summary>
            <seealso cref="T:Lucene.Net.Search.IFieldCache"/>
            <seealso cref="T:Lucene.Net.Util.FieldCacheSanityChecker.Insanity"/>
            <seealso cref="T:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType"/>
        </member>
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.#ctor(System.Boolean)">
            <param name="estimateRam">If set, estimate size for all <see cref="T:Lucene.Net.Search.FieldCache.CacheEntry"/> objects will be calculated.</param>
        </member>
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.CheckSanity(Lucene.Net.Search.IFieldCache)">
            <summary>
            Quick and dirty convenience method </summary>
            <seealso cref="M:Lucene.Net.Util.FieldCacheSanityChecker.Check(Lucene.Net.Search.FieldCache.CacheEntry[])"/>
        </member>
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.CheckSanity(Lucene.Net.Search.FieldCache.CacheEntry[])">
            <summary>
            Quick and dirty convenience method that instantiates an instance with
            "good defaults" and uses it to test the <see cref="T:Lucene.Net.Search.FieldCache.CacheEntry"/>s </summary>
            <seealso cref="M:Lucene.Net.Util.FieldCacheSanityChecker.Check(Lucene.Net.Search.FieldCache.CacheEntry[])"/>
        </member>
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.Check(Lucene.Net.Search.FieldCache.CacheEntry[])">
            <summary>
            Tests a CacheEntry[] for indication of "insane" cache usage.
            <para>
            <b>NOTE:</b>FieldCache CreationPlaceholder objects are ignored.
            (:TODO: is this a bad idea? are we masking a real problem?)
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.CheckValueMismatch(Lucene.Net.Util.MapOfSets{System.Int32,Lucene.Net.Search.FieldCache.CacheEntry},Lucene.Net.Util.MapOfSets{Lucene.Net.Util.FieldCacheSanityChecker.ReaderField,System.Int32},System.Collections.Generic.ISet{Lucene.Net.Util.FieldCacheSanityChecker.ReaderField})">
            <summary>
            Internal helper method used by check that iterates over
            <paramref name="valMismatchKeys"/> and generates a <see cref="T:System.Collections.Generic.ICollection`1"/> of <see cref="T:Lucene.Net.Util.FieldCacheSanityChecker.Insanity"/>
            instances accordingly.  The <see cref="T:Lucene.Net.Util.MapOfSets`2"/> are used to populate
            the <see cref="T:Lucene.Net.Util.FieldCacheSanityChecker.Insanity"/> objects. </summary>
            <seealso cref="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.VALUEMISMATCH"/>
        </member>
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.CheckSubreaders(Lucene.Net.Util.MapOfSets{System.Int32,Lucene.Net.Search.FieldCache.CacheEntry},Lucene.Net.Util.MapOfSets{Lucene.Net.Util.FieldCacheSanityChecker.ReaderField,System.Int32})">
            <summary>
            Internal helper method used by check that iterates over
            the keys of <paramref name="readerFieldToValIds"/> and generates a <see cref="T:System.Collections.Generic.ICollection`1"/>
            of <see cref="T:Lucene.Net.Util.FieldCacheSanityChecker.Insanity"/> instances whenever two (or more) <see cref="T:Lucene.Net.Util.FieldCacheSanityChecker.ReaderField"/> instances are
            found that have an ancestry relationships.
            </summary>
            <seealso cref="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.SUBREADER"/>
        </member>
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.GetAllDescendantReaderKeys(System.Object)">
            <summary>
            Checks if the <paramref name="seed"/> is an <see cref="T:Lucene.Net.Index.IndexReader"/>, and if so will walk
            the hierarchy of subReaders building up a list of the objects
            returned by <c>seed.CoreCacheKey</c>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.FieldCacheSanityChecker.ReaderField">
            <summary>
            Simple pair object for using "readerKey + fieldName" a Map key
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.FieldCacheSanityChecker.Insanity">
            <summary>
            Simple container for a collection of related <see cref="T:Lucene.Net.Search.FieldCache.CacheEntry"/> objects that
            in conjunction with each other represent some "insane" usage of the
            <see cref="T:Lucene.Net.Search.IFieldCache"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.FieldCacheSanityChecker.Insanity.Type">
            <summary>
            Type of insane behavior this object represents
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.FieldCacheSanityChecker.Insanity.Msg">
            <summary>
            Description of the insane behavior
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.FieldCacheSanityChecker.Insanity.CacheEntries">
            <summary>
            <see cref="T:Lucene.Net.Search.FieldCache.CacheEntry"/> objects which suggest a problem
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.Insanity.ToString">
            <summary>
            Multi-Line representation of this <see cref="T:Lucene.Net.Util.FieldCacheSanityChecker.Insanity"/> object, starting with
            the Type and Msg, followed by each CacheEntry.ToString() on it's
            own line prefaced by a tab character
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType">
            <summary>
            An Enumeration of the different types of "insane" behavior that
            may be detected in a <see cref="T:Lucene.Net.Search.IFieldCache"/>.
            </summary>
            <seealso cref="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.SUBREADER"/>
            <seealso cref="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.VALUEMISMATCH"/>
            <seealso cref="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.EXPECTED"/>
        </member>
        <member name="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.SUBREADER">
            <summary>
            Indicates an overlap in cache usage on a given field
            in sub/super readers.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.VALUEMISMATCH">
            <summary>
            <para>
            Indicates entries have the same reader+fieldname but
            different cached values.  This can happen if different datatypes,
            or parsers are used -- and while it's not necessarily a bug
            it's typically an indication of a possible problem.
            </para>
            <para>
            <b>NOTE:</b> Only the reader, fieldname, and cached value are actually
            tested -- if two cache entries have different parsers or datatypes but
            the cached values are the same Object (== not just Equal()) this method
            does not consider that a red flag.  This allows for subtle variations
            in the way a Parser is specified (null vs DEFAULT_INT64_PARSER, etc...)
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.EXPECTED">
            <summary>
            Indicates an expected bit of "insanity".  This may be useful for
            clients that wish to preserve/log information about insane usage
            but indicate that it was expected.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.FilterIterator`1">
            <summary>
            An <see cref="T:System.Collections.Generic.IEnumerator`1"/> implementation that filters elements with a boolean predicate. </summary>
            <seealso cref="M:Lucene.Net.Util.FilterIterator`1.PredicateFunction(`0)"/>
        </member>
        <member name="M:Lucene.Net.Util.FilterIterator`1.PredicateFunction(`0)">
            <summary>
            Returns <c>true</c>, if this element should be set to <see cref="P:Lucene.Net.Util.FilterIterator`1.Current"/> by <see cref="M:Lucene.Net.Util.FilterIterator`1.SetNext"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.FixedBitSet">
            <summary>
            BitSet of fixed length (numBits), backed by accessible (<see cref="M:Lucene.Net.Util.FixedBitSet.GetBits"/>)
            long[], accessed with an int index, implementing <see cref="M:Lucene.Net.Util.FixedBitSet.GetBits"/> and
            <see cref="T:Lucene.Net.Search.DocIdSet"/>. If you need to manage more than 2.1B bits, use
            <see cref="T:Lucene.Net.Util.Int64BitSet"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.FixedBitSet.FixedBitSetIterator">
            <summary>
            A <see cref="T:Lucene.Net.Search.DocIdSetIterator"/> which iterates over set bits in a
            <see cref="T:Lucene.Net.Util.FixedBitSet"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.FixedBitSetIterator.#ctor(Lucene.Net.Util.FixedBitSet)">
            <summary>
            Creates an iterator over the given <see cref="T:Lucene.Net.Util.FixedBitSet"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.FixedBitSetIterator.#ctor(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Creates an iterator over the given array of bits. </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.EnsureCapacity(Lucene.Net.Util.FixedBitSet,System.Int32)">
             <summary>
             If the given <see cref="T:Lucene.Net.Util.FixedBitSet"/> is large enough to hold <paramref name="numBits"/>,
             returns the given bits, otherwise returns a new <see cref="T:Lucene.Net.Util.FixedBitSet"/> which
             can hold the requested number of bits.
            
             <para/>
             <b>NOTE:</b> the returned bitset reuses the underlying <see cref="T:long[]"/> of
             the given <paramref name="bits"/> if possible. Also, calling <see cref="P:Lucene.Net.Util.FixedBitSet.Length"/> on the
             returned bits may return a value greater than <paramref name="numBits"/>.
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Bits2words(System.Int32)">
            <summary>
            Returns the number of 64 bit words it would take to hold <paramref name="numBits"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.IntersectionCount(Lucene.Net.Util.FixedBitSet,Lucene.Net.Util.FixedBitSet)">
            <summary>
            Returns the popcount or cardinality of the intersection of the two sets.
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.UnionCount(Lucene.Net.Util.FixedBitSet,Lucene.Net.Util.FixedBitSet)">
            <summary>
            Returns the popcount or cardinality of the union of the two sets. Neither
            set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.AndNotCount(Lucene.Net.Util.FixedBitSet,Lucene.Net.Util.FixedBitSet)">
            <summary>
            Returns the popcount or cardinality of "a and not b" or
            "intersection(a, not(b))". Neither set is modified.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.FixedBitSet.IsCacheable">
            <summary>
            This DocIdSet implementation is cacheable. </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.GetBits">
            <summary>
            Expert. </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Cardinality">
            <summary>
            Returns number of set bits.  NOTE: this visits every
            <see cref="T:System.Int64"/> in the backing bits array, and the result is not
            internally cached!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.NextSetBit(System.Int32)">
            <summary>
            Returns the index of the first set bit starting at the index specified.
            -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.PrevSetBit(System.Int32)">
            <summary>
            Returns the index of the last set bit before or on the index specified.
            -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Or(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Does in-place OR of the bits provided by the
            iterator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Or(Lucene.Net.Util.FixedBitSet)">
            <summary>
            this = this OR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Xor(Lucene.Net.Util.FixedBitSet)">
            <summary>
            this = this XOR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Xor(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Does in-place XOR of the bits provided by the iterator. </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.And(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Does in-place AND of the bits provided by the
            iterator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Intersects(Lucene.Net.Util.FixedBitSet)">
            <summary>
            Returns true if the sets have any elements in common </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.And(Lucene.Net.Util.FixedBitSet)">
            <summary>
            this = this AND other </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.AndNot(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Does in-place AND NOT of the bits provided by the
            iterator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.AndNot(Lucene.Net.Util.FixedBitSet)">
            <summary>
            this = this AND NOT other </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Flip(System.Int32,System.Int32)">
            <summary>
            Flips a range of bits
            </summary>
            <param name="startIndex"> Lower index </param>
            <param name="endIndex"> One-past the last bit to flip </param>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Set(System.Int32,System.Int32)">
            <summary>
            Sets a range of bits
            </summary>
            <param name="startIndex"> Lower index </param>
            <param name="endIndex"> One-past the last bit to set </param>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Clear(System.Int32,System.Int32)">
            <summary>
            Clears a range of bits.
            </summary>
            <param name="startIndex"> Lower index </param>
            <param name="endIndex"> One-past the last bit to clear </param>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if both sets have the same bits set </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder`1">
             <summary>
             Builds a minimal FST (maps an <see cref="T:Lucene.Net.Util.Int32sRef"/> term to an arbitrary
             output) from pre-sorted terms with outputs.  The FST
             becomes an FSA if you use NoOutputs.  The FST is written
             on-the-fly into a compact serialized format byte array, which can
             be saved to / loaded from a Directory or used directly
             for traversal.  The FST is always finite (no cycles).
            
             <para/>NOTE: The algorithm is described at
             http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.3698
            
             <para/>The parameterized type <typeparam name="T"/> is the output type.  See the
             subclasses of <see cref="T:Lucene.Net.Util.Fst.Outputs`1"/>.
            
             <para/>FSTs larger than 2.1GB are now possible (as of Lucene
             4.2).  FSTs containing more than 2.1B nodes are also now
             possible, however they cannot be packed.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Builder`1.#ctor(Lucene.Net.Util.Fst.FST.INPUT_TYPE,Lucene.Net.Util.Fst.Outputs{`0})">
            <summary>
            Instantiates an FST/FSA builder without any pruning. A shortcut
            to <see cref="M:Lucene.Net.Util.Fst.Builder`1.#ctor(Lucene.Net.Util.Fst.FST.INPUT_TYPE,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32,Lucene.Net.Util.Fst.Outputs{`0},Lucene.Net.Util.Fst.Builder.FreezeTail{`0},System.Boolean,System.Single,System.Boolean,System.Int32)"/>
            with pruning options turned off.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Builder`1.#ctor(Lucene.Net.Util.Fst.FST.INPUT_TYPE,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32,Lucene.Net.Util.Fst.Outputs{`0},Lucene.Net.Util.Fst.Builder.FreezeTail{`0},System.Boolean,System.Single,System.Boolean,System.Int32)">
            <summary>
            Instantiates an FST/FSA builder with all the possible tuning and construction
            tweaks. Read parameter documentation carefully.
            </summary>
            <param name="inputType">
               The input type (transition labels). Can be anything from <see cref="T:Lucene.Net.Util.Fst.FST.INPUT_TYPE"/>
               enumeration. Shorter types will consume less memory. Strings (character sequences) are
               represented as <see cref="F:Lucene.Net.Util.Fst.FST.INPUT_TYPE.BYTE4"/> (full unicode codepoints).
            </param>
            <param name="minSuffixCount1">
               If pruning the input graph during construction, this threshold is used for telling
               if a node is kept or pruned. If transition_count(node) &gt;= minSuffixCount1, the node
               is kept.
            </param>
            <param name="minSuffixCount2">
               (Note: only Mike McCandless knows what this one is really doing...)
            </param>
            <param name="doShareSuffix">
               If <c>true</c>, the shared suffixes will be compacted into unique paths.
               this requires an additional RAM-intensive hash map for lookups in memory. Setting this parameter to
               <c>false</c> creates a single suffix path for all input sequences. this will result in a larger
               FST, but requires substantially less memory and CPU during building.
            </param>
            <param name="doShareNonSingletonNodes">
               Only used if <paramref name="doShareSuffix"/> is <c>true</c>.  Set this to
               true to ensure FST is fully minimal, at cost of more
               CPU and more RAM during building.
            </param>
            <param name="shareMaxTailLength">
               Only used if <paramref name="doShareSuffix"/> is <c>true</c>.  Set this to
               <see cref="F:System.Int32.MaxValue"/> to ensure FST is fully minimal, at cost of more
               CPU and more RAM during building.
            </param>
            <param name="outputs"> The output type for each input sequence. Applies only if building an FST. For
               FSA, use <see cref="P:Lucene.Net.Util.Fst.NoOutputs.Singleton"/> and <see cref="P:Lucene.Net.Util.Fst.NoOutputs.NoOutput"/> as the
               singleton output object.
            </param>
            <param name="doPackFST"> Pass <c>true</c> to create a packed FST.
            </param>
            <param name="acceptableOverheadRatio"> How to trade speed for space when building the FST. this option 
               is only relevant when doPackFST is true. <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetMutable(System.Int32,System.Int32,System.Single)"/>
            </param>
            <param name="allowArrayArcs"> Pass false to disable the array arc optimization
               while building the FST; this will make the resulting
               FST smaller but slower to traverse.
            </param>
            <param name="bytesPageBits"> How many bits wide to make each
               <see cref="T:byte[]"/> block in the <see cref="T:Lucene.Net.Util.Fst.BytesStore"/>; if you know the FST
               will be large then make this larger.  For example 15
               bits = 32768 byte pages. </param>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Builder`1.Add(Lucene.Net.Util.Int32sRef,`0)">
            <summary>
            It's OK to add the same input twice in a row with
            different outputs, as long as outputs impls the merge
            method. Note that input is fully consumed after this
            method is returned (so caller is free to reuse), but
            output is not.  So if your outputs are changeable (eg
            <see cref="T:Lucene.Net.Util.Fst.ByteSequenceOutputs"/> or 
            <see cref="T:Lucene.Net.Util.Fst.Int32SequenceOutputs"/>) then you cannot reuse across
            calls.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Builder`1.Finish">
            <summary>
            Returns final FST.  NOTE: this will return null if
            nothing is accepted by the FST.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder">
            <summary>
            LUCENENET specific type used to access nested types of <see cref="T:Lucene.Net.Util.Fst.Builder`1"/>
            without referring to its generic closing type.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder.FreezeTail`1">
            <summary>
            Expert: this is invoked by Builder whenever a suffix
             is serialized.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder.Arc`1">
            <summary>
            Expert: holds a pending (seen but not yet serialized) arc. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder.UnCompiledNode`1">
            <summary>
            Expert: holds a pending (seen but not yet serialized) Node. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.Builder.UnCompiledNode`1.Depth">
            <summary>
            this node's depth, starting from the automaton root. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Builder.UnCompiledNode`1.#ctor(Lucene.Net.Util.Fst.Builder{`0},System.Int32)">
            <param name="depth">
                     The node's depth starting from the automaton root. Needed for
                     LUCENE-2934 (node expansion based on conditions other than the
                     fanout size). </param>
        </member>
        <member name="T:Lucene.Net.Util.Fst.ByteSequenceOutputs">
            <summary>
            An FST <see cref="T:Outputs{BytesRef}"/> implementation where each output
            is a sequence of bytes.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.BytesRefFSTEnum`1">
             <summary>
             Enumerates all input (<see cref="T:Lucene.Net.Util.BytesRef"/>) + output pairs in an
             FST.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.#ctor(Lucene.Net.Util.Fst.FST{`0})">
            <summary>
            doFloor controls the behavior of advance: if it's true
            doFloor is true, advance positions to the biggest
            term before target.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekCeil(Lucene.Net.Util.BytesRef)">
            <summary>
            Seeks to smallest term that's &gt;= target. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekFloor(Lucene.Net.Util.BytesRef)">
            <summary>
            Seeks to biggest term that's &lt;= target. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekExact(Lucene.Net.Util.BytesRef)">
            <summary>
            Seeks to exactly this term, returning <c>null</c> if the term
            doesn't exist.  This is faster than using
            <see cref="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekFloor(Lucene.Net.Util.BytesRef)"/> or <see cref="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekCeil(Lucene.Net.Util.BytesRef)"/> because it
            short-circuits as soon the match is not found.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.BytesRefFSTEnum">
            <summary>
            LUCENENET specific. This class is to mimic Java's ability to specify
            nested classes of Generics without having to specify the generic type
            (i.e. BytesRefFSTEnum.InputOutput{T} rather than BytesRefFSTEnum{T}.InputOutput{T})
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.BytesRefFSTEnum.InputOutput`1">
            <summary>
            Holds a single input (<see cref="T:Lucene.Net.Util.BytesRef"/>) + output pair. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.#ctor(Lucene.Net.Store.DataInput,System.Int64,System.Int32)">
            <summary>
            Pulls bytes from the provided <see cref="T:Lucene.Net.Store.IndexInput"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.WriteByte(System.Int32,System.Byte)">
            <summary>
            Absolute write byte; you must ensure dest is &lt; max
            position written so far.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.WriteBytes(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Absolute writeBytes without changing the current
            position.  Note: this cannot "grow" the bytes, so you
            must only call it on already written parts.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.CopyBytes(System.Int64,System.Int64,System.Int32)">
            <summary>
            Absolute copy bytes self to self, without changing the
            position. Note: this cannot "grow" the bytes, so must
            only call it on already written parts.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.WriteInt32(System.Int64,System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> at the absolute position without
            changing the current pointer.
            <para/>
            NOTE: This was writeInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.Reverse(System.Int64,System.Int64)">
            <summary>
            Reverse from <paramref name="srcPos"/>, inclusive, to <paramref name="destPos"/>, inclusive. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.Truncate(System.Int64)">
            <summary>
            Pos must be less than the max position written so far!
            i.e., you cannot "grow" the file with this!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.WriteTo(Lucene.Net.Store.DataOutput)">
            <summary>
            Writes all of our bytes to the target <see cref="T:Lucene.Net.Store.DataOutput"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.CharSequenceOutputs">
            <summary>
            An FST <see cref="T:Lucene.Net.Util.Fst.Outputs`1"/> implementation where each output
            is a sequence of characters.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.ForwardBytesReader">
            <summary>
            Reads from a single <see cref="T:byte[]"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST`1">
             <summary>
             Represents an finite state machine (FST), using a
             compact <see cref="T:byte[]"/> format.
             <para/> The format is similar to what's used by Morfologik
             (http://sourceforge.net/projects/morfologik).
            
             <para/> See the <a href="https://lucene.apache.org/core/4_8_0/core/org/apache/lucene/util/fst/package-summary.html">
             FST package documentation</a> for some simple examples.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.#ctor(Lucene.Net.Store.DataInput,Lucene.Net.Util.Fst.Outputs{`0})">
            <summary>
            Load a previously saved FST. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.#ctor(Lucene.Net.Store.DataInput,Lucene.Net.Util.Fst.Outputs{`0},System.Int32)">
            <summary>
            Load a previously saved FST; <paramref name="maxBlockBits"/> allows you to
            control the size of the <see cref="T:byte[]"/> pages used to hold the FST bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.GetSizeInBytes">
            <summary>
            Returns bytes used to represent the FST </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.Save(System.IO.FileInfo)">
            <summary>
            Writes an automaton to a file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.TargetHasArcs(Lucene.Net.Util.Fst.FST.Arc{`0})">
            <summary>
            returns <c>true</c> if the node at this address has any
            outgoing arcs
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.GetFirstArc(Lucene.Net.Util.Fst.FST.Arc{`0})">
            <summary>
            Fills virtual 'start' arc, ie, an empty incoming arc to
            the FST's start node
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadLastTargetArc(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Follows the <paramref name="follow"/> arc and reads the last
            arc of its target; this changes the provided
            <paramref name="arc"/> (2nd arg) in-place and returns it.
            </summary>
            <returns> Returns the second argument
            (<paramref name="arc"/>).  </returns>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadFirstTargetArc(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Follow the <paramref name="follow"/> arc and read the first arc of its target;
            this changes the provided <paramref name="arc"/> (2nd arg) in-place and returns
            it.
            </summary>
            <returns> Returns the second argument (<paramref name="arc"/>). </returns>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.IsExpandedTarget(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Checks if arc's target state is in expanded (or vector) format.
            </summary>
            <returns> Returns <c>true</c> if arc points to a state in an
            expanded array format. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadNextArc(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            In-place read; returns the arc. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadNextArcLabel(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Peeks at next arc's label; does not alter <paramref name="arc"/>.  Do
            not call this if arc.IsLast!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadNextRealArc(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Never returns <c>null</c>, but you should never call this if
            arc.IsLast is <c>true</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.FindTargetArc(System.Int32,Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Finds an arc leaving the incoming <paramref name="arc"/>, replacing the arc in place.
            this returns <c>null</c> if the arc was not found, else the incoming <paramref name="arc"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ShouldExpand(Lucene.Net.Util.Fst.Builder.UnCompiledNode{`0})">
             <summary>
             Nodes will be expanded if their depth (distance from the root node) is
             &lt;= this value and their number of arcs is &gt;=
             <see cref="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_NUM_ARCS_SHALLOW"/>.
            
             <para/>
             Fixed array consumes more RAM but enables binary search on the arcs
             (instead of a linear scan) on lookup by arc label.
             </summary>
             <returns> <c>true</c> if <paramref name="node"/> should be stored in an
                     expanded (array) form.
             </returns>
             <seealso cref="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_NUM_ARCS_DEEP"/>
             <seealso cref="P:Lucene.Net.Util.Fst.Builder.UnCompiledNode`1.Depth"/>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.GetBytesReader">
            <summary>
            Returns a <see cref="T:Lucene.Net.Util.Fst.FST.BytesReader"/> for this FST, positioned at
            position 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.#ctor(Lucene.Net.Util.Fst.FST.INPUT_TYPE,Lucene.Net.Util.Fst.Outputs{`0},System.Int32)">
            <summary>
            Creates a packed FST
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.Pack(System.Int32,System.Int32,System.Single)">
             <summary>
             Expert: creates an FST by packing this one.  This
             process requires substantial additional RAM (currently
             up to ~8 bytes per node depending on
             <c>acceptableOverheadRatio</c>), but then should
             produce a smaller FST.
            
             <para/>The implementation of this method uses ideas from
             <a target="_blank" href="http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf">Smaller Representation of Finite State Automata</a>,
             which describes techniques to reduce the size of a FST.
             However, this is not a strict implementation of the
             algorithms described in this paper.
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST">
            <summary>
            LUCENENET specific: This new base class is to mimic Java's ability to use nested types without specifying
            a type parameter. i.e. FST.BytesReader instead of FST&lt;BytesRef&gt;.BytesReader
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_SHALLOW_DISTANCE">
            <summary>
            <see cref="T:Lucene.Net.Util.Fst.Builder.UnCompiledNode`1"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_NUM_ARCS_SHALLOW">
            <summary>
            <see cref="T:Lucene.Net.Util.Fst.Builder.UnCompiledNode`1"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_NUM_ARCS_DEEP">
            <summary>
            <see cref="T:Lucene.Net.Util.Fst.Builder.UnCompiledNode`1"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.VERSION_INT32_NUM_BYTES_PER_ARC">
            <summary>
            Changed numBytesPerArc for array'd case from byte to <see cref="T:System.Int32"/>.
            <para/>
            NOTE: This was VERSION_INT_NUM_BYTES_PER_ARC in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.VERSION_INT16_BYTE2_LABELS">
            <summary>
            Write BYTE2 labels as 2-byte <see cref="T:System.Int16"/>, not v<see cref="T:System.Int32"/>.
            <para/>
            NOTE: This was VERSION_SHORT_BYTE2_LABELS in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.VERSION_PACKED">
            <summary>
            Added optional packed format.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.VERSION_VINT32_TARGET">
            <summary>
            Changed from <see cref="T:System.Int32"/> to v<see cref="T:System.Int32"/> for encoding arc targets.
            Also changed maxBytesPerArc from int to v<see cref="T:System.Int32"/> in the array case.
            <para/>
            NOTE: This was VERSION_VINT_TARGET in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.FINAL_END_NODE">
            <summary>
            Never serialized; just used to represent the virtual
            final node w/ no arcs:
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.NON_FINAL_END_NODE">
            <summary>
            Never serialized; just used to represent the virtual
            non-final node w/ no arcs:
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.END_LABEL">
            <summary>
            If arc has this label then that arc is final/accepted </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST.TargetHasArcs``1(Lucene.Net.Util.Fst.FST.Arc{``0})">
            <summary>
            returns <c>true</c> if the node at this address has any
            outgoing arcs
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST.Read``1(System.IO.FileInfo,Lucene.Net.Util.Fst.Outputs{``0})">
            <summary>
            Reads an automaton from a file.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST.BytesReader">
            <summary>
            Reads bytes stored in an FST.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.BytesReader.Position">
            <summary>
            Current read position
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.BytesReader.IsReversed">
            <summary>
            Returns <c>true</c> if this reader uses reversed bytes
            under-the-hood.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST.BytesReader.SkipBytes(System.Int32)">
            <summary>
            Skips bytes.
            </summary>
            <param name="count"></param>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST.INPUT_TYPE">
            <summary>
            Specifies allowed range of each int input label for this FST.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST.Arc`1">
            <summary>
            Represents a single arc.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.Arc`1.Node">
            <summary>
            From node (ord or address); currently only used when
            building an FST w/ willPackFST=true:
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.Arc`1.Target">
            <summary>
            To node (ord or address)
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.Arc`1.NextArc">
            <summary>
            address (into the byte[]), or ord/address if label == END_LABEL
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.Arc`1.PosArcsStart">
            <summary>
            This is non-zero if current arcs are fixed array:
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST.Arc`1.CopyFrom(Lucene.Net.Util.Fst.FST.Arc{`0})">
            <summary>
            Return this
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FSTEnum`1">
            <summary>
            Can Next() and Advance() through the terms in an FST
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.#ctor(Lucene.Net.Util.Fst.FST{`0})">
            <summary>
            doFloor controls the behavior of advance: if it's true
            doFloor is true, advance positions to the biggest
            term before target.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.RewindPrefix">
            <summary>
            Rewinds enum state to match the shared prefix between
            current term and target term
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.DoSeekCeil">
            <summary>
            Seeks to smallest term that's &gt;= target. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.DoSeekFloor">
            <summary>
            Seeks to largest term that's &lt;= target. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.DoSeekExact">
            <summary>
            Seeks to exactly target term. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.PushFirst">
            <summary>
            Appends current arc, and then recurses from its target,
            appending first arc all the way to the final node
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.PushLast">
            <summary>
            Recurses from current arc, appending last arc all the
            way to the first final node
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Int32SequenceOutputs">
            <summary>
            An FST <see cref="T:Lucene.Net.Util.Fst.Outputs`1"/> implementation where each output
            is a sequence of <see cref="T:System.Int32"/>s.
            <para/>
            NOTE: This was IntSequenceOutputs in Lucene
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1">
            <summary>
            Enumerates all input (<see cref="T:Lucene.Net.Util.Int32sRef"/>) + output pairs in an
            FST.
            <para/>
            NOTE: This was IntsRefFSTEnum{T} in Lucene
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1.#ctor(Lucene.Net.Util.Fst.FST{`0})">
            <summary>
            doFloor controls the behavior of advance: if it's true
            doFloor is true, advance positions to the biggest
            term before target.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1.SeekCeil(Lucene.Net.Util.Int32sRef)">
            <summary>
            Seeks to smallest term that's &gt;= target. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1.SeekFloor(Lucene.Net.Util.Int32sRef)">
            <summary>
            Seeks to biggest term that's &lt;= target. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1.SeekExact(Lucene.Net.Util.Int32sRef)">
            <summary>
            Seeks to exactly this term, returning <c>null</c> if the term
            doesn't exist.  This is faster than using 
            <see cref="M:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1.SeekFloor(Lucene.Net.Util.Int32sRef)"/> or <see cref="M:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1.SeekCeil(Lucene.Net.Util.Int32sRef)"/> because it
            short-circuits as soon the match is not found.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Int32sRefFSTEnum">
            <summary>
            LUCENENET specific. This class is to mimic Java's ability to specify
            nested classes of Generics without having to specify the generic type
            (i.e. <c>Int32sRefFSTEnum.InputOutput{T}</c> rather than <c>Int32sRefFSTEnum{T}.InputOutput{T}</c>)
            <para/>
            NOTE: This was Int32sRefFSTEnum{T} in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Int32sRefFSTEnum.InputOutput`1">
            <summary>
            Holds a single input (<see cref="T:Lucene.Net.Util.Int32sRef"/>) + output pair. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.NodeHash`1">
            <summary>
            Used to dedup states (lookup already-frozen states)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.NodeHash`1.Hash(Lucene.Net.Util.Fst.Builder.UnCompiledNode{`0})">
            <summary>
            hash code for an unfrozen node.  this must be identical
            to the frozen case (below)!!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.NodeHash`1.Hash(System.Int64)">
            <summary>
            hash code for a frozen node
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.NodeHash`1.AddNew(System.Int64)">
            <summary>
            called only by rehash
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.NoOutputs">
            <summary>
            A null FST <see cref="T:Lucene.Net.Util.Fst.Outputs`1"/> implementation; use this if
            you just want to build an FSA.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.NoOutputs.ObjectAnonymousInnerClassHelper.GetHashCode">
            <summary>
            NodeHash calls hashCode for this output; we fix this
            so we get deterministic hashing.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Outputs`1">
             <summary>
             Represents the outputs for an FST, providing the basic
             algebra required for building and traversing the FST.
            
             <para>Note that any operation that returns NO_OUTPUT must
             return the same singleton object from
             <see cref="P:Lucene.Net.Util.Fst.Outputs`1.NoOutput"/>.</para>
             
             <para>LUCENENET IMPORTANT: If <typeparamref name="T"/> is a collection type,
             it must implement <see cref="T:System.Collections.IStructuralEquatable"/>
             in order to properly compare its nested values.</para>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Common(`0,`0)">
            <summary>
            Eg common("foobar", "food") -> "foo" </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Subtract(`0,`0)">
            <summary>
            Eg subtract("foobar", "foo") -> "bar" </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Add(`0,`0)">
            <summary>
            Eg add("foo", "bar") -> "foobar" </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Write(`0,Lucene.Net.Store.DataOutput)">
            <summary>
            Encode an output value into a <see cref="T:Lucene.Net.Store.DataOutput"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.WriteFinalOutput(`0,Lucene.Net.Store.DataOutput)">
            <summary>
            Encode an final node output value into a
            <see cref="T:Lucene.Net.Store.DataOutput"/>.  By default this just calls 
            <see cref="M:Lucene.Net.Util.Fst.Outputs`1.Write(`0,Lucene.Net.Store.DataOutput)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Read(Lucene.Net.Store.DataInput)">
            <summary>
            Decode an output value previously written with
            <see cref="M:Lucene.Net.Util.Fst.Outputs`1.Write(`0,Lucene.Net.Store.DataOutput)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.ReadFinalOutput(Lucene.Net.Store.DataInput)">
            <summary>
            Decode an output value previously written with
            <see cref="M:Lucene.Net.Util.Fst.Outputs`1.WriteFinalOutput(`0,Lucene.Net.Store.DataOutput)"/>.  By default this
            just calls <see cref="M:Lucene.Net.Util.Fst.Outputs`1.Read(Lucene.Net.Store.DataInput)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.Outputs`1.NoOutput">
            <summary>
            NOTE: this output is compared with == so you must
            ensure that all methods return the single object if
            it's really no output
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.PairOutputs`2">
            <summary>
            An FST <see cref="T:Lucene.Net.Util.Fst.Outputs`1"/> implementation, holding two other outputs.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.PairOutputs`2.Pair">
            <summary>
            Holds a single pair of two outputs. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.PairOutputs`2.NewPair(`0,`1)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Util.Fst.PairOutputs`2.Pair"/> </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.PositiveInt32Outputs">
            <summary>
            An FST <see cref="T:Lucene.Net.Util.Fst.Outputs`1"/> implementation where each output
            is a non-negative <see cref="T:long?"/> value.
            <para/>
            NOTE: This was PositiveIntOutputs in Lucene
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.ReverseBytesReader">
            <summary>
            Reads in reverse from a single <see cref="T:byte[]"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util">
            <summary>
            Static helper methods.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.Get``1(Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.Int32sRef)">
            <summary>
            Looks up the output for this input, or <c>null</c> if the
            input is not accepted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.Get``1(Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.BytesRef)">
            <summary>
            Looks up the output for this input, or <c>null</c> if the
            input is not accepted
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.GetByOutput(Lucene.Net.Util.Fst.FST{System.Nullable{System.Int64}},System.Int64)">
             <summary>
             Reverse lookup (lookup by output instead of by input),
             in the special case when your FSTs outputs are
             strictly ascending.  This locates the input/output
             pair where the output is equal to the target, and will
             return <c>null</c> if that output does not exist.
            
             <para/>NOTE: this only works with <see cref="T:FST{long?}"/>, only
             works when the outputs are ascending in order with
             the inputs.
             For example, simple ordinals (0, 1,
             2, ...), or file offets (when appending to a file)
             fit this.
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.GetByOutput(Lucene.Net.Util.Fst.FST{System.Nullable{System.Int64}},System.Int64,Lucene.Net.Util.Fst.FST.BytesReader,Lucene.Net.Util.Fst.FST.Arc{System.Nullable{System.Int64}},Lucene.Net.Util.Fst.FST.Arc{System.Nullable{System.Int64}},Lucene.Net.Util.Int32sRef)">
            <summary>
            Expert: like <see cref="M:Lucene.Net.Util.Fst.Util.GetByOutput(Lucene.Net.Util.Fst.FST{System.Nullable{System.Int64}},System.Int64)"/> except reusing
            <see cref="T:Lucene.Net.Util.Fst.FST.BytesReader"/>, initial and scratch Arc, and result.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.FSTPath`1">
            <summary>
            Represents a path in TopNSearcher.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.FSTPath`1.#ctor(`0,Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Int32sRef)">
            <summary>
            Sole constructor </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.TieBreakByInputComparer`1">
            <summary>
            Compares first by the provided comparer, and then
            tie breaks by <see cref="P:Lucene.Net.Util.Fst.Util.FSTPath`1.Input"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.TopNSearcher`1">
            <summary>
            Utility class to find top N shortest paths from start
            point(s).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.TopNSearcher`1.#ctor(Lucene.Net.Util.Fst.FST{`0},System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates an unbounded TopNSearcher </summary>
            <param name="fst"> the <see cref="T:Lucene.Net.Util.Fst.FST`1"/> to search on </param>
            <param name="topN"> the number of top scoring entries to retrieve </param>
            <param name="maxQueueDepth"> the maximum size of the queue of possible top entries </param>
            <param name="comparer"> the comparer to select the top N </param>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.TopNSearcher`1.AddIfCompetitive(Lucene.Net.Util.Fst.Util.FSTPath{`0})">
            <summary>
            If back plus this arc is competitive then add to queue:
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.TopNSearcher`1.AddStartPaths(Lucene.Net.Util.Fst.FST.Arc{`0},`0,System.Boolean,Lucene.Net.Util.Int32sRef)">
            <summary>
            Adds all leaving arcs, including 'finished' arc, if
            the node is final, from this node into the queue.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.Result`1">
            <summary>
            Holds a single input (<see cref="T:Lucene.Net.Util.Int32sRef"/>) + output, returned by
            <see cref="M:Lucene.Net.Util.Fst.Util.ShortestPaths``1(Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.Fst.FST.Arc{``0},``0,System.Collections.Generic.IComparer{``0},System.Int32,System.Boolean)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.TopResults`1">
            <summary>
            Holds the results for a top N search using <see cref="T:Lucene.Net.Util.Fst.Util.TopNSearcher`1"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.Util.TopResults`1.IsComplete">
            <summary>
            <c>true</c> iff this is a complete result ie. if
            the specified queue size was large enough to find the complete list of results. this might
            be <c>false</c> if the <see cref="T:Lucene.Net.Util.Fst.Util.TopNSearcher`1"/> rejected too many results.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.Util.TopResults`1.TopN">
            <summary>
            The top results
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ShortestPaths``1(Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.Fst.FST.Arc{``0},``0,System.Collections.Generic.IComparer{``0},System.Int32,System.Boolean)">
            <summary>
            Starting from node, find the top N min cost
            completions to a final node.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToDot``1(Lucene.Net.Util.Fst.FST{``0},System.IO.TextWriter,System.Boolean,System.Boolean)">
             <summary>
             Dumps an <see cref="T:Lucene.Net.Util.Fst.FST`1"/> to a GraphViz's <c>dot</c> language description
             for visualization. Example of use:
            
             <code>
             using (TextWriter sw = new StreamWriter(&quot;out.dot&quot;))
             {
                 Util.ToDot(fst, sw, true, true);
             }
             </code>
            
             and then, from command line:
            
             <code>
             dot -Tpng -o out.png out.dot
             </code>
            
             <para/>
             Note: larger FSTs (a few thousand nodes) won't even
             render, don't bother.  If the FST is &gt; 2.1 GB in size
             then this method will throw strange exceptions.
             <para/>
             See also <a href="http://www.graphviz.org/">http://www.graphviz.org/</a>.
             </summary>
             <param name="sameRank">
                      If <c>true</c>, the resulting <c>dot</c> file will try
                      to order states in layers of breadth-first traversal. This may
                      mess up arcs, but makes the output FST's structure a bit clearer.
             </param>
             <param name="labelStates">
                      If <c>true</c> states will have labels equal to their offsets in their
                      binary format. Expands the graph considerably.
             </param>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.EmitDotState(System.IO.TextWriter,System.String,System.String,System.String,System.String)">
            <summary>
            Emit a single state in the <c>dot</c> language.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.PrintableLabel(System.Int32)">
            <summary>
            Ensures an arc's label is indeed printable (dot uses US-ASCII).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToUTF16(System.String,Lucene.Net.Util.Int32sRef)">
            <summary>
            Just maps each UTF16 unit (char) to the <see cref="T:System.Int32"/>s in an
            <see cref="T:Lucene.Net.Util.Int32sRef"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToUTF32(System.String,Lucene.Net.Util.Int32sRef)">
            <summary>
            Decodes the Unicode codepoints from the provided
            <see cref="T:J2N.Text.ICharSequence"/> and places them in the provided scratch
            <see cref="T:Lucene.Net.Util.Int32sRef"/>, which must not be <c>null</c>, returning it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToUTF32(System.Char[],System.Int32,System.Int32,Lucene.Net.Util.Int32sRef)">
            <summary>
            Decodes the Unicode codepoints from the provided
            <see cref="T:char[]"/> and places them in the provided scratch
            <see cref="T:Lucene.Net.Util.Int32sRef"/>, which must not be <c>null</c>, returning it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToInt32sRef(Lucene.Net.Util.BytesRef,Lucene.Net.Util.Int32sRef)">
            <summary>
            Just takes unsigned byte values from the <see cref="T:Lucene.Net.Util.BytesRef"/> and
            converts into an <see cref="T:Lucene.Net.Util.Int32sRef"/>.
            <para/>
            NOTE: This was toIntsRef() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToBytesRef(Lucene.Net.Util.Int32sRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Just converts <see cref="T:Lucene.Net.Util.Int32sRef"/> to <see cref="T:Lucene.Net.Util.BytesRef"/>; you must ensure the
            <see cref="T:System.Int32"/> values fit into a <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ReadCeilArc``1(System.Int32,Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.Fst.FST.Arc{``0},Lucene.Net.Util.Fst.FST.Arc{``0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Reads the first arc greater or equal that the given label into the provided
            arc in place and returns it iff found, otherwise return <c>null</c>.
            </summary>
            <param name="label"> the label to ceil on </param>
            <param name="fst"> the fst to operate on </param>
            <param name="follow"> the arc to follow reading the label from </param>
            <param name="arc"> the arc to read into in place </param>
            <param name="in"> the fst's <see cref="T:Lucene.Net.Util.Fst.FST.BytesReader"/> </param>
        </member>
        <member name="T:Lucene.Net.Util.GrowableByteArrayDataOutput">
            <summary>
            A <see cref="T:Lucene.Net.Store.DataOutput"/> that can be used to build a <see cref="T:byte[]"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.GrowableByteArrayDataOutput.Bytes">
            <summary>
            The bytes </summary>
        </member>
        <member name="P:Lucene.Net.Util.GrowableByteArrayDataOutput.Length">
            <summary>
            The length </summary>
        </member>
        <member name="M:Lucene.Net.Util.GrowableByteArrayDataOutput.#ctor(System.Int32)">
            <summary>
            Create a <see cref="T:Lucene.Net.Util.GrowableByteArrayDataOutput"/> with the given initial capacity. </summary>
        </member>
        <member name="T:Lucene.Net.Util.IndexableBinaryStringTools">
            <summary>
            Provides support for converting byte sequences to <see cref="T:System.String"/>s and back again.
            The resulting <see cref="T:System.String"/>s preserve the original byte sequences' sort order.
            <para/>
            The <see cref="T:System.String"/>s are constructed using a Base 8000h encoding of the original
            binary data - each char of an encoded <see cref="T:System.String"/> represents a 15-bit chunk
            from the byte sequence.  Base 8000h was chosen because it allows for all
            lower 15 bits of char to be used without restriction; the surrogate range
            [U+D8000-U+DFFF] does not represent valid chars, and would require
            complicated handling to avoid them and allow use of char's high bit.
            <para/>
            Although unset bits are used as padding in the final char, the original
            byte sequence could contain trailing bytes with no set bits (null bytes):
            padding is indistinguishable from valid information.  To overcome this
            problem, a char is appended, indicating the number of encoded bytes in the
            final content char.
            <para/>
            @lucene.experimental 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.GetEncodedLength(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns the number of chars required to encode the given <see cref="T:System.Byte"/>s.
            </summary>
            <param name="inputArray"> Byte sequence to be encoded </param>
            <param name="inputOffset"> Initial offset into <paramref name="inputArray"/> </param>
            <param name="inputLength"> Number of bytes in <paramref name="inputArray"/> </param>
            <returns> The number of chars required to encode the number of <see cref="T:System.Byte"/>s. </returns>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.GetEncodedLength(System.SByte[],System.Int32,System.Int32)">
            <summary>
            Returns the number of chars required to encode the given <see cref="T:System.SByte"/>s.
            </summary>
            <param name="inputArray"> <see cref="T:System.SByte"/> sequence to be encoded </param>
            <param name="inputOffset"> Initial offset into <paramref name="inputArray"/> </param>
            <param name="inputLength"> Number of sbytes in <paramref name="inputArray"/> </param>
            <returns> The number of chars required to encode the number of <see cref="T:System.SByte"/>s. </returns>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.GetDecodedLength(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns the number of <see cref="T:System.Byte"/>s required to decode the given char sequence.
            </summary>
            <param name="encoded"> Char sequence to be decoded </param>
            <param name="offset"> Initial offset </param>
            <param name="length"> Number of characters </param>
            <returns> The number of <see cref="T:System.Byte"/>s required to decode the given char sequence </returns>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.Encode(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Encodes the input <see cref="T:System.Byte"/> sequence into the output char sequence.  Before
            calling this method, ensure that the output array has sufficient
            capacity by calling <see cref="M:Lucene.Net.Util.IndexableBinaryStringTools.GetEncodedLength(System.Byte[],System.Int32,System.Int32)"/>.
            </summary>
            <param name="inputArray"> <see cref="T:System.Byte"/> sequence to be encoded </param>
            <param name="inputOffset"> Initial offset into <paramref name="inputArray"/> </param>
            <param name="inputLength"> Number of bytes in <paramref name="inputArray"/> </param>
            <param name="outputArray"> <see cref="T:System.Char"/> sequence to store encoded result </param>
            <param name="outputOffset"> Initial offset into outputArray </param>
            <param name="outputLength"> Length of output, must be GetEncodedLength(inputArray, inputOffset, inputLength) </param>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.Encode(System.SByte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Encodes the input <see cref="T:System.SByte"/> sequence into the output char sequence.  Before
            calling this method, ensure that the output array has sufficient
            capacity by calling <see cref="M:Lucene.Net.Util.IndexableBinaryStringTools.GetEncodedLength(System.SByte[],System.Int32,System.Int32)"/>.
            </summary>
            <param name="inputArray"> <see cref="T:System.SByte"/> sequence to be encoded </param>
            <param name="inputOffset"> Initial offset into <paramref name="inputArray"/> </param>
            <param name="inputLength"> Number of bytes in <paramref name="inputArray"/> </param>
            <param name="outputArray"> <see cref="T:System.Char"/> sequence to store encoded result </param>
            <param name="outputOffset"> Initial offset into outputArray </param>
            <param name="outputLength"> Length of output, must be getEncodedLength </param>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.Decode(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decodes the input <see cref="T:System.Char"/> sequence into the output <see cref="T:System.Byte"/> sequence. Before
            calling this method, ensure that the output array has sufficient capacity
            by calling <see cref="M:Lucene.Net.Util.IndexableBinaryStringTools.GetDecodedLength(System.Char[],System.Int32,System.Int32)"/>.
            </summary>
            <param name="inputArray"> <see cref="T:System.Char"/> sequence to be decoded </param>
            <param name="inputOffset"> Initial offset into <paramref name="inputArray"/> </param>
            <param name="inputLength"> Number of chars in <paramref name="inputArray"/> </param>
            <param name="outputArray"> <see cref="T:System.Byte"/> sequence to store encoded result </param>
            <param name="outputOffset"> Initial offset into outputArray </param>
            <param name="outputLength"> Length of output, must be
                   GetDecodedLength(inputArray, inputOffset, inputLength) </param>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.Decode(System.Char[],System.Int32,System.Int32,System.SByte[],System.Int32,System.Int32)">
            <summary>
            Decodes the input char sequence into the output sbyte sequence. Before
            calling this method, ensure that the output array has sufficient capacity
            by calling <see cref="M:Lucene.Net.Util.IndexableBinaryStringTools.GetDecodedLength(System.Char[],System.Int32,System.Int32)"/>.
            </summary>
            <param name="inputArray"> <see cref="T:System.Char"/> sequence to be decoded </param>
            <param name="inputOffset"> Initial offset into <paramref name="inputArray"/> </param>
            <param name="inputLength"> Number of chars in <paramref name="inputArray"/> </param>
            <param name="outputArray"> <see cref="T:System.Byte"/> sequence to store encoded result </param>
            <param name="outputOffset"> Initial offset into outputArray </param>
            <param name="outputLength"> Length of output, must be
                   GetDecodedLength(inputArray, inputOffset, inputLength) </param>
        </member>
        <member name="T:Lucene.Net.Util.InfoStream">
            <summary>
            Debugging API for Lucene classes such as <see cref="T:Lucene.Net.Index.IndexWriter"/>
            and <see cref="T:Lucene.Net.Index.SegmentInfos"/>.
            <para>
            NOTE: Enabling infostreams may cause performance degradation
            in some components.
            </para>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.InfoStream.NO_OUTPUT">
            <summary>
            Instance of <see cref="T:Lucene.Net.Util.InfoStream"/> that does no logging at all. </summary>
        </member>
        <member name="M:Lucene.Net.Util.InfoStream.Message(System.String,System.String)">
            <summary>
            Prints a message </summary>
        </member>
        <member name="M:Lucene.Net.Util.InfoStream.IsEnabled(System.String)">
            <summary>
            Returns <c>true</c> if messages are enabled and should be posted to <see cref="M:Lucene.Net.Util.InfoStream.Message(System.String,System.String)"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Util.InfoStream.Default">
            <summary>
            Gets or Sets the default <see cref="T:Lucene.Net.Util.InfoStream"/> used by a newly instantiated classes. </summary>
        </member>
        <member name="M:Lucene.Net.Util.InfoStream.Dispose">
            <summary>
            Disposes this <see cref="T:Lucene.Net.Util.InfoStream"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.InfoStream.Dispose(System.Boolean)">
            <summary>
            Disposes this <see cref="T:Lucene.Net.Util.InfoStream"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.InfoStream.Clone">
            <summary>
            Clones this <see cref="T:Lucene.Net.Util.InfoStream"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.InPlaceMergeSorter">
            <summary>
            <see cref="T:Lucene.Net.Util.Sorter"/> implementation based on the merge-sort algorithm that merges
            in place (no extra memory will be allocated). Small arrays are sorted with
            insertion sort.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.InPlaceMergeSorter.#ctor">
            <summary>
            Create a new <see cref="T:Lucene.Net.Util.InPlaceMergeSorter"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.InPlaceMergeSorter.Sort(System.Int32,System.Int32)">
            <summary>
            Sort the slice which starts at <paramref name="from"/> (inclusive) and ends at
            <paramref name="to"/> (exclusive).
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int32BlockPool">
            <summary>
            A pool for <see cref="T:System.Int32"/> blocks similar to <see cref="T:Lucene.Net.Util.ByteBlockPool"/>.
            <para/>
            NOTE: This was IntBlockPool in Lucene
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.INT32_BLOCK_SHIFT">
            <summary>
            NOTE: This was INT_BLOCK_SHIFT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.INT32_BLOCK_SIZE">
            <summary>
            NOTE: This was INT_BLOCK_SIZE in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.INT32_BLOCK_MASK">
            <summary>
            NOTE: This was INT_BLOCK_MASK in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int32BlockPool.Allocator">
            <summary>
            Abstract class for allocating and freeing <see cref="T:System.Int32"/>
            blocks.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.Allocator.RecycleInt32Blocks(System.Int32[][],System.Int32,System.Int32)">
            <summary>
            NOTE: This was recycleIntBlocks() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.Allocator.GetInt32Block">
            <summary>
            NOTE: This was getIntBlock() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int32BlockPool.DirectAllocator">
            <summary>
            A simple <see cref="T:Lucene.Net.Util.Int32BlockPool.Allocator"/> that never recycles. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.DirectAllocator.#ctor">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.Int32BlockPool.DirectAllocator"/> with a default block size
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.DirectAllocator.RecycleInt32Blocks(System.Int32[][],System.Int32,System.Int32)">
            <summary>
            NOTE: This was recycleIntBlocks() in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32BlockPool.Buffers">
            <summary>
            Array of buffers currently used in the pool. Buffers are allocated if needed don't modify this outside of this class. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.bufferUpto">
            <summary>
            Index into the buffers array pointing to the current buffer used as the head. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32BlockPool.Int32Upto">
            <summary>
            Pointer to the current position in head buffer
            <para/>
            NOTE: This was intUpto in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32BlockPool.Buffer">
            <summary>
            Current head buffer. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32BlockPool.Int32Offset">
            <summary>
            Current head offset. 
            <para/>
            NOTE: This was intOffset in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.#ctor">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.Int32BlockPool"/> with a default <see cref="T:Lucene.Net.Util.Int32BlockPool.Allocator"/>. </summary>
            <seealso cref="M:Lucene.Net.Util.Int32BlockPool.NextBuffer"/>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.#ctor(Lucene.Net.Util.Int32BlockPool.Allocator)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.Int32BlockPool"/> with the given <see cref="T:Lucene.Net.Util.Int32BlockPool.Allocator"/>. </summary>
            <seealso cref="M:Lucene.Net.Util.Int32BlockPool.NextBuffer"/>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.Reset">
            <summary>
            Resets the pool to its initial state reusing the first buffer. Calling
            <see cref="M:Lucene.Net.Util.Int32BlockPool.NextBuffer"/> is not needed after reset.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.Reset(System.Boolean,System.Boolean)">
            <summary>
            Expert: Resets the pool to its initial state reusing the first buffer. </summary>
            <param name="zeroFillBuffers"> If <c>true</c> the buffers are filled with <c>0</c>.
                   this should be set to <c>true</c> if this pool is used with
                   <see cref="T:Lucene.Net.Util.Int32BlockPool.SliceWriter"/>. </param>
            <param name="reuseFirst"> If <c>true</c> the first buffer will be reused and calling
                   <see cref="M:Lucene.Net.Util.Int32BlockPool.NextBuffer"/> is not needed after reset if the
                   block pool was used before ie. <see cref="M:Lucene.Net.Util.Int32BlockPool.NextBuffer"/> was called before. </param>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.NextBuffer">
            <summary>
            Advances the pool to its next buffer. This method should be called once
            after the constructor to initialize the pool. In contrast to the
            constructor a <see cref="M:Lucene.Net.Util.Int32BlockPool.Reset"/> call will advance the pool to
            its first buffer immediately.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.NewSlice(System.Int32)">
            <summary>
            Creates a new <see cref="T:System.Int32"/> slice with the given starting size and returns the slices offset in the pool. </summary>
            <seealso cref="T:Lucene.Net.Util.Int32BlockPool.SliceReader"/>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.NEXT_LEVEL_ARRAY">
            <summary>
            An array holding the offset into the <see cref="F:Lucene.Net.Util.Int32BlockPool.LEVEL_SIZE_ARRAY"/>
            to quickly navigate to the next slice level.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.LEVEL_SIZE_ARRAY">
            <summary>
            An array holding the level sizes for <see cref="T:System.Int32"/> slices.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.FIRST_LEVEL_SIZE">
            <summary>
            The first level size for new slices.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.AllocSlice(System.Int32[],System.Int32)">
            <summary>
            Allocates a new slice from the given offset.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int32BlockPool.SliceWriter">
            <summary>
            A <see cref="T:Lucene.Net.Util.Int32BlockPool.SliceWriter"/> that allows to write multiple integer slices into a given <see cref="T:Lucene.Net.Util.Int32BlockPool"/>.
            <para/>
            @lucene.internal
            </summary>
            <seealso cref="T:Lucene.Net.Util.Int32BlockPool.SliceReader"/> 
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.SliceWriter.Reset(System.Int32)">
            
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.SliceWriter.WriteInt32(System.Int32)">
            <summary>
            Writes the given value into the slice and resizes the slice if needed
            <para/>
            NOTE: This was writeInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.SliceWriter.StartNewSlice">
            <summary>
            Starts a new slice and returns the start offset. The returned value
            should be used as the start offset to initialize a <see cref="T:Lucene.Net.Util.Int32BlockPool.SliceReader"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32BlockPool.SliceWriter.CurrentOffset">
            <summary>
            Returns the offset of the currently written slice. The returned value
            should be used as the end offset to initialize a <see cref="T:Lucene.Net.Util.Int32BlockPool.SliceReader"/> once
            this slice is fully written or to reset the this writer if another slice
            needs to be written.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int32BlockPool.SliceReader">
            <summary>
            A <see cref="T:Lucene.Net.Util.Int32BlockPool.SliceReader"/> that can read <see cref="T:System.Int32"/> slices written by a <see cref="T:Lucene.Net.Util.Int32BlockPool.SliceWriter"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.SliceReader.#ctor(Lucene.Net.Util.Int32BlockPool)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.Int32BlockPool.SliceReader"/> on the given pool.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.SliceReader.Reset(System.Int32,System.Int32)">
            <summary>
            Resets the reader to a slice give the slices absolute start and end offset in the pool.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32BlockPool.SliceReader.IsEndOfSlice">
            <summary>
            Returns <c>true</c> if the current slice is fully read. If this
            method returns <c>true</c> <seealso cref="M:Lucene.Net.Util.Int32BlockPool.SliceReader.ReadInt32"/> should not
            be called again on this slice.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.SliceReader.ReadInt32">
            <summary>
            Reads the next <see cref="T:System.Int32"/> from the current slice and returns it. 
            <para/>
            NOTE: This was readInt() in Lucene
            </summary>
            <seealso cref="P:Lucene.Net.Util.Int32BlockPool.SliceReader.IsEndOfSlice"/>
        </member>
        <member name="T:Lucene.Net.Util.IntroSorter">
            <summary>
            <see cref="T:Lucene.Net.Util.Sorter"/> implementation based on a variant of the quicksort algorithm
            called <a href="http://en.wikipedia.org/wiki/Introsort">introsort</a>: when
            the recursion level exceeds the log of the length of the array to sort, it
            falls back to heapsort. This prevents quicksort from running into its
            worst-case quadratic runtime. Small arrays are sorted with
            insertion sort.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntroSorter.#ctor">
            <summary>
            Create a new <see cref="T:Lucene.Net.Util.IntroSorter"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntroSorter.Sort(System.Int32,System.Int32)">
            <summary>
            Sort the slice which starts at <paramref name="from"/> (inclusive) and ends at
            <paramref name="to"/> (exclusive).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntroSorter.SetPivot(System.Int32)">
            <summary>
            Save the value at slot <paramref name="i"/> so that it can later be used as a
            pivot, see <see cref="M:Lucene.Net.Util.IntroSorter.ComparePivot(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntroSorter.ComparePivot(System.Int32)">
            <summary>
            Compare the pivot with the slot at <paramref name="j"/>, similarly to
            Compare(i, j) (<see cref="M:Lucene.Net.Util.Sorter.Compare(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int32sRef">
            <summary>
            Represents <see cref="T:int[]"/>, as a slice (offset + length) into an
            existing <see cref="T:int[]"/>.  The <see cref="P:Lucene.Net.Util.Int32sRef.Int32s"/> member should never be <c>null</c>; use
            <see cref="F:Lucene.Net.Util.Int32sRef.EMPTY_INT32S"/> if necessary.
            <para/>
            NOTE: This was IntsRef in Lucene
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32sRef.EMPTY_INT32S">
            <summary>
            An empty integer array for convenience.
            <para/>
            NOTE: This was EMPTY_INTS in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32sRef.Int32s">
            <summary>
            The contents of the <see cref="T:Lucene.Net.Util.Int32sRef"/>. Should never be <c>null</c>. 
            <para/>
            NOTE: This was ints (field) in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32sRef.Offset">
            <summary>
            Offset of first valid integer. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32sRef.Length">
            <summary>
            Length of used <see cref="T:System.Int32"/>s. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.#ctor">
            <summary>
            Create a <see cref="T:Lucene.Net.Util.Int32sRef"/> with <see cref="F:Lucene.Net.Util.Int32sRef.EMPTY_INT32S"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.#ctor(System.Int32)">
            <summary>
            Create a <see cref="T:Lucene.Net.Util.Int32sRef"/> pointing to a new array of size <paramref name="capacity"/>.
            Offset and length will both be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.#ctor(System.Int32[],System.Int32,System.Int32)">
            <summary>
            This instance will directly reference <paramref name="ints"/> w/o making a copy.
            <paramref name="ints"/> should not be <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.Clone">
            <summary>
            Returns a shallow clone of this instance (the underlying <see cref="T:System.Int32"/>s are
            <b>not</b> copied and will be shared by both the returned object and this
            object.
            </summary>
            <seealso cref="M:Lucene.Net.Util.Int32sRef.DeepCopyOf(Lucene.Net.Util.Int32sRef)"/>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.Int32sEquals(Lucene.Net.Util.Int32sRef)">
            <summary>
            NOTE: This was intsEquals() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.CompareTo(Lucene.Net.Util.Int32sRef)">
            <summary>
            Signed <see cref="T:System.Int32"/> order comparison. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.CopyInt32s(Lucene.Net.Util.Int32sRef)">
            <summary>
            NOTE: This was copyInts() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.Grow(System.Int32)">
            <summary>
            Used to grow the reference array.
            <para/>
            In general this should not be used as it does not take the offset into account.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.DeepCopyOf(Lucene.Net.Util.Int32sRef)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.Int32sRef"/> that points to a copy of the <see cref="T:System.Int32"/>s from
            <paramref name="other"/>
            <para/>
            The returned <see cref="T:Lucene.Net.Util.Int32sRef"/> will have a length of <c>other.Length</c>
            and an offset of zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.IsValid">
            <summary>
            Performs internal consistency checks.
            Always returns true (or throws <see cref="T:System.InvalidOperationException"/>)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IOUtils">
            <summary>
            This class emulates the new Java 7 "Try-With-Resources" statement.
            Remove once Lucene is on Java 7.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.IOUtils.CHARSET_UTF_8">
            <summary>
            UTF-8 <see cref="T:System.Text.Encoding"/> instance to prevent repeated
            <see cref="P:System.Text.Encoding.UTF8"/> lookups </summary>
        </member>
        <member name="F:Lucene.Net.Util.IOUtils.UTF_8">
            <summary>
            UTF-8 charset string.
            <para/>Where possible, use <see cref="P:System.Text.Encoding.UTF8"/> instead,
            as using the <see cref="T:System.String"/> constant may slow things down. </summary>
            <seealso cref="P:System.Text.Encoding.UTF8"/>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.CloseWhileHandlingException(System.Exception,System.IDisposable[])">
            <summary>
            <para>Disposes all given <c>IDisposable</c>s, suppressing all thrown exceptions. Some of the <c>IDisposable</c>s
            may be <c>null</c>, they are ignored. After everything is disposed, method either throws <paramref name="priorException"/>,
            if one is supplied, or the first of suppressed exceptions, or completes normally.</para>
            <para>Sample usage:
            <code>
            IDisposable resource1 = null, resource2 = null, resource3 = null;
            ExpectedException priorE = null;
            try 
            {
                resource1 = ...; resource2 = ...; resource3 = ...; // Acquisition may throw ExpectedException
                ..do..stuff.. // May throw ExpectedException
            } 
            catch (ExpectedException e) 
            {
                priorE = e;
            } 
            finally 
            {
                IOUtils.CloseWhileHandlingException(priorE, resource1, resource2, resource3);
            }
            </code>
            </para> 
            </summary>
            <param name="priorException">  <c>null</c> or an exception that will be rethrown after method completion. </param>
            <param name="objects">         Objects to call <see cref="M:System.IDisposable.Dispose"/> on. </param>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.CloseWhileHandlingException(System.Exception,System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Disposes all given <see cref="T:System.IDisposable"/>s, suppressing all thrown exceptions. </summary>
            <seealso cref="M:Lucene.Net.Util.IOUtils.DisposeWhileHandlingException(System.Exception,System.IDisposable[])"/>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.Close(System.IDisposable[])">
            <summary>
            Disposes all given <see cref="T:System.IDisposable"/>s.  Some of the
            <see cref="T:System.IDisposable"/>s may be <c>null</c>; they are
            ignored.  After everything is closed, the method either
            throws the first exception it hit while closing, or
            completes normally if there were no exceptions.
            </summary>
            <param name="objects">
                     Objects to call <see cref="M:System.IDisposable.Dispose"/> on </param>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.Close(System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Disposes all given <see cref="T:System.IDisposable"/>s. </summary>
            <seealso cref="M:Lucene.Net.Util.IOUtils.Dispose(System.IDisposable[])"/>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.CloseWhileHandlingException(System.IDisposable[])">
            <summary>
            Disposes all given <see cref="T:System.IDisposable"/>s, suppressing all thrown exceptions.
            Some of the <see cref="T:System.IDisposable"/>s may be <c>null</c>, they are ignored.
            </summary>
            <param name="objects">
                     Objects to call <see cref="M:System.IDisposable.Dispose"/> on </param>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.CloseWhileHandlingException(System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Disposes all given <see cref="T:System.IDisposable"/>s, suppressing all thrown exceptions. </summary>
            <seealso cref="M:Lucene.Net.Util.IOUtils.DisposeWhileHandlingException(System.Collections.Generic.IEnumerable{System.IDisposable})"/>
            <seealso cref="M:Lucene.Net.Util.IOUtils.DisposeWhileHandlingException(System.IDisposable[])"/>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.DisposeWhileHandlingException(System.Exception,System.IDisposable[])">
            <summary>
            <para>Disposes all given <c>IDisposable</c>s, suppressing all thrown exceptions. Some of the <c>IDisposable</c>s
            may be <c>null</c>, they are ignored. After everything is disposed, method either throws <paramref name="priorException"/>,
            if one is supplied, or the first of suppressed exceptions, or completes normally.</para>
            <para>Sample usage:
            <code>
            IDisposable resource1 = null, resource2 = null, resource3 = null;
            ExpectedException priorE = null;
            try 
            {
                resource1 = ...; resource2 = ...; resource3 = ...; // Acquisition may throw ExpectedException
                ..do..stuff.. // May throw ExpectedException
            } 
            catch (ExpectedException e) 
            {
                priorE = e;
            } 
            finally 
            {
                IOUtils.DisposeWhileHandlingException(priorE, resource1, resource2, resource3);
            }
            </code>
            </para> 
            </summary>
            <param name="priorException">  <c>null</c> or an exception that will be rethrown after method completion. </param>
            <param name="objects">         Objects to call <see cref="M:System.IDisposable.Dispose"/> on. </param>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.DisposeWhileHandlingException(System.Exception,System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Disposes all given <see cref="T:System.IDisposable"/>s, suppressing all thrown exceptions. </summary>
            <seealso cref="M:Lucene.Net.Util.IOUtils.DisposeWhileHandlingException(System.Exception,System.IDisposable[])"/>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.Dispose(System.IDisposable[])">
            <summary>
            Disposes all given <see cref="T:System.IDisposable"/>s.  Some of the
            <see cref="T:System.IDisposable"/>s may be <c>null</c>; they are
            ignored.  After everything is closed, the method either
            throws the first exception it hit while closing, or
            completes normally if there were no exceptions.
            </summary>
            <param name="objects">
                     Objects to call <see cref="M:System.IDisposable.Dispose"/> on </param>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.Dispose(System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Disposes all given <see cref="T:System.IDisposable"/>s. </summary>
            <seealso cref="M:Lucene.Net.Util.IOUtils.Dispose(System.IDisposable[])"/>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.DisposeWhileHandlingException(System.IDisposable[])">
            <summary>
            Disposes all given <see cref="T:System.IDisposable"/>s, suppressing all thrown exceptions.
            Some of the <see cref="T:System.IDisposable"/>s may be <c>null</c>, they are ignored.
            </summary>
            <param name="objects">
                     Objects to call <see cref="M:System.IDisposable.Dispose"/> on </param>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.DisposeWhileHandlingException(System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Disposes all given <see cref="T:System.IDisposable"/>s, suppressing all thrown exceptions. </summary>
            <seealso cref="M:Lucene.Net.Util.IOUtils.DisposeWhileHandlingException(System.IDisposable[])"/>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.AddSuppressed(System.Exception,System.Exception)">
            <summary>
            Since there's no C# equivalent of Java's Exception.AddSuppressed, we add the
            suppressed exceptions to a data field via the 
            <see cref="M:Lucene.Net.Util.ExceptionExtensions.AddSuppressed(System.Exception,System.Exception)"/> method.
            <para/>
            The exceptions can be retrieved by calling <see cref="M:Lucene.Net.Util.ExceptionExtensions.GetSuppressed(System.Exception)"/>
            or <see cref="M:Lucene.Net.Util.ExceptionExtensions.GetSuppressedAsList(System.Exception)"/>.
            </summary>
            <param name="exception"> this exception should get the suppressed one added </param>
            <param name="suppressed"> the suppressed exception </param>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.GetDecodingReader(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Wrapping the given <see cref="T:System.IO.Stream"/> in a reader using a <see cref="T:System.Text.Encoding"/>.
            Unlike Java's defaults this reader will throw an exception if your it detects
            the read charset doesn't match the expected <see cref="T:System.Text.Encoding"/>.
            <para/>
            Decoding readers are useful to load configuration files, stopword lists or synonym files
            to detect character set problems. However, its not recommended to use as a common purpose
            reader.
            </summary>
            <param name="stream"> The stream to wrap in a reader </param>
            <param name="charSet"> The expected charset </param>
            <returns> A wrapping reader </returns>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.GetDecodingReader(System.IO.FileInfo,System.Text.Encoding)">
            <summary>
            Opens a <see cref="T:System.IO.TextReader"/> for the given <see cref="T:System.IO.FileInfo"/> using a <see cref="T:System.Text.Encoding"/>.
            Unlike Java's defaults this reader will throw an exception if your it detects
            the read charset doesn't match the expected <see cref="T:System.Text.Encoding"/>.
            <para/>
            Decoding readers are useful to load configuration files, stopword lists or synonym files
            to detect character set problems. However, its not recommended to use as a common purpose
            reader. </summary>
            <param name="file"> The file to open a reader on </param>
            <param name="charSet"> The expected charset </param>
            <returns> A reader to read the given file </returns>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.GetDecodingReader(System.Type,System.String,System.Text.Encoding)">
            <summary>
            Opens a <see cref="T:System.IO.TextReader"/> for the given resource using a <see cref="T:System.Text.Encoding"/>.
            Unlike Java's defaults this reader will throw an exception if your it detects
            the read charset doesn't match the expected <see cref="T:System.Text.Encoding"/>.
            <para/>
            Decoding readers are useful to load configuration files, stopword lists or synonym files
            to detect character set problems. However, its not recommended to use as a common purpose
            reader. </summary>
            <param name="clazz"> The class used to locate the resource </param>
            <param name="resource"> The resource name to load </param>
            <param name="charSet"> The expected charset </param>
            <returns> A reader to read the given file </returns>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.DeleteFilesIgnoringExceptions(Lucene.Net.Store.Directory,System.String[])">
            <summary>
            Deletes all given files, suppressing all thrown <see cref="T:System.Exception"/>s.
            <para/>
            Note that the files should not be <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.Copy(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Copy one file's contents to another file. The target will be overwritten
            if it exists. The source must exist.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.ReThrow(System.Exception)">
            <summary>
            Simple utilty method that takes a previously caught
            <see cref="T:System.Exception"/> and rethrows either 
            <see cref="T:System.IO.IOException"/> or an unchecked exception.  If the
            argument is <c>null</c> then this method does nothing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.ReThrowUnchecked(System.Exception)">
            <summary>
            Simple utilty method that takes a previously caught
            <see cref="T:System.Exception"/> and rethrows it as an unchecked exception.
            If the argument is <c>null</c> then this method does nothing.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int64BitSet">
            <summary>
            BitSet of fixed length (<see cref="F:Lucene.Net.Util.Int64BitSet.numBits"/>), backed by accessible (<see cref="M:Lucene.Net.Util.Int64BitSet.GetBits"/>)
            <see cref="T:long[]"/>, accessed with a <see cref="T:System.Int64"/> index. Use it only if you intend to store more
            than 2.1B bits, otherwise you should use <see cref="T:Lucene.Net.Util.FixedBitSet"/>.
            <para/>
            NOTE: This was LongBitSet in Lucene
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.EnsureCapacity(Lucene.Net.Util.Int64BitSet,System.Int64)">
             <summary>
             If the given <see cref="T:Lucene.Net.Util.Int64BitSet"/> is large enough to hold
             <paramref name="numBits"/>, returns the given <paramref name="bits"/>, otherwise returns a new
             <see cref="T:Lucene.Net.Util.Int64BitSet"/> which can hold the requested number of bits.
            
             <para/>
             <b>NOTE:</b> the returned bitset reuses the underlying <see cref="T:long[]"/> of
             the given <paramref name="bits"/> if possible. Also, reading <see cref="P:Lucene.Net.Util.Int64BitSet.Length"/> on the
             returned bits may return a value greater than <paramref name="numBits"/>.
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Bits2words(System.Int64)">
            <summary>
            Returns the number of 64 bit words it would take to hold <paramref name="numBits"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int64BitSet.Length">
            <summary>
            Returns the number of bits stored in this bitset. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.GetBits">
            <summary>
            Expert. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Cardinality">
            <summary>
            Returns number of set bits.  NOTE: this visits every
            long in the backing bits array, and the result is not
            internally cached!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.NextSetBit(System.Int64)">
            <summary>
            Returns the index of the first set bit starting at the <paramref name="index"/> specified.
            -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.PrevSetBit(System.Int64)">
            <summary>
            Returns the index of the last set bit before or on the <paramref name="index"/> specified.
            -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Or(Lucene.Net.Util.Int64BitSet)">
            <summary>
            this = this OR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Xor(Lucene.Net.Util.Int64BitSet)">
            <summary>
            this = this XOR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Intersects(Lucene.Net.Util.Int64BitSet)">
            <summary>
            Returns <c>true</c> if the sets have any elements in common </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.And(Lucene.Net.Util.Int64BitSet)">
            <summary>
            this = this AND other </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.AndNot(Lucene.Net.Util.Int64BitSet)">
            <summary>
            this = this AND NOT other </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Flip(System.Int64,System.Int64)">
            <summary>
            Flips a range of bits
            </summary>
            <param name="startIndex"> Lower index </param>
            <param name="endIndex"> One-past the last bit to flip </param>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Set(System.Int64,System.Int64)">
            <summary>
            Sets a range of bits
            </summary>
            <param name="startIndex"> Lower index </param>
            <param name="endIndex"> One-past the last bit to set </param>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Clear(System.Int64,System.Int64)">
            <summary>
            Clears a range of bits.
            </summary>
            <param name="startIndex"> Lower index </param>
            <param name="endIndex"> One-past the last bit to clear </param>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if both sets have the same bits set </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int64sRef">
            <summary>
            Represents <see cref="T:long[]"/>, as a slice (offset + length) into an
            existing <see cref="T:long[]"/>.  The <see cref="P:Lucene.Net.Util.Int64sRef.Int64s"/> member should never be <c>null</c>; use
            <see cref="F:Lucene.Net.Util.Int64sRef.EMPTY_INT64S"/> if necessary.
            <para/>
            NOTE: This was LongsRef in Lucene
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int64sRef.EMPTY_INT64S">
            <summary>
            An empty <see cref="T:System.Int64"/> array for convenience
            <para/>
            NOTE: This was EMPTY_LONGS in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int64sRef.Int64s">
            <summary>
            The contents of the <see cref="T:Lucene.Net.Util.Int64sRef"/>. Should never be <c>null</c>. 
            <para/>
            NOTE: This was longs (field) in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int64sRef.Offset">
            <summary>
            Offset of first valid long. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int64sRef.Length">
            <summary>
            Length of used longs. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.#ctor">
            <summary>
            Create a <see cref="T:Lucene.Net.Util.Int64sRef"/> with <see cref="F:Lucene.Net.Util.Int64sRef.EMPTY_INT64S"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.#ctor(System.Int32)">
            <summary>
            Create a <see cref="T:Lucene.Net.Util.Int64sRef"/> pointing to a new array of size <paramref name="capacity"/>.
            Offset and length will both be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.#ctor(System.Int64[],System.Int32,System.Int32)">
            <summary>
            This instance will directly reference <paramref name="longs"/> w/o making a copy.
            <paramref name="longs"/> should not be <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.Clone">
            <summary>
            Returns a shallow clone of this instance (the underlying <see cref="T:System.Int64"/>s are
            <b>not</b> copied and will be shared by both the returned object and this
            object.
            </summary>
            <seealso cref="M:Lucene.Net.Util.Int64sRef.DeepCopyOf(Lucene.Net.Util.Int64sRef)"/>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.Int64sEquals(Lucene.Net.Util.Int64sRef)">
            <summary>
            NOTE: This was longsEquals() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.CompareTo(Lucene.Net.Util.Int64sRef)">
            <summary>
            Signed <see cref="T:System.Int32"/> order comparison </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.CopyInt64s(Lucene.Net.Util.Int64sRef)">
            <summary>
            NOTE: This was copyLongs() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.Grow(System.Int32)">
            <summary>
            Used to grow the reference array.
            <para/>
            In general this should not be used as it does not take the offset into account.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.DeepCopyOf(Lucene.Net.Util.Int64sRef)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.Int64sRef"/> that points to a copy of the <see cref="T:System.Int64"/>s from
            <paramref name="other"/>.
            <para/>
            The returned <see cref="T:Lucene.Net.Util.Int64sRef"/> will have a length of <c>other.Length</c>
            and an offset of zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.IsValid">
            <summary>
            Performs internal consistency checks.
            Always returns <c>true</c> (or throws <see cref="T:System.InvalidOperationException"/>)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int64Values">
            <summary>
            Abstraction over an array of <see cref="T:System.Int64"/>s.
            This class extends <see cref="T:Lucene.Net.Index.NumericDocValues"/> so that we don't need to add another
            level of abstraction every time we want eg. to use the <see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>
            utility classes to represent a <see cref="T:Lucene.Net.Index.NumericDocValues"/> instance.
            <para/>
            NOTE: This was LongValues in Lucene
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64Values.Get(System.Int64)">
            <summary>
            Get value at <paramref name="index"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64Values.Get(System.Int32)">
            <summary>
            Get value at <paramref name="idx"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.MapOfSets`2">
            <summary>
            Helper class for keeping Lists of Objects associated with keys. <b>WARNING: this CLASS IS NOT THREAD SAFE</b>
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.MapOfSets`2.#ctor(System.Collections.Generic.IDictionary{`0,System.Collections.Generic.ISet{`1}})">
            <param name="m"> The backing store for this object. </param>
        </member>
        <member name="P:Lucene.Net.Util.MapOfSets`2.Map">
            <returns> Direct access to the map backing this object. </returns>
        </member>
        <member name="M:Lucene.Net.Util.MapOfSets`2.Put(`0,`1)">
            <summary>
            Adds <paramref name="val"/> to the <see cref="T:System.Collections.Generic.ISet`1"/> associated with key in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.  
            If <paramref name="key"/> is not
            already in the map, a new <see cref="T:System.Collections.Generic.ISet`1"/> will first be created. </summary>
            <returns> The size of the <see cref="T:System.Collections.Generic.ISet`1"/> associated with key once val is added to it. </returns>
        </member>
        <member name="M:Lucene.Net.Util.MapOfSets`2.PutAll(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Adds multiple <paramref name="vals"/> to the <see cref="T:System.Collections.Generic.ISet`1"/> associated with key in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            If <paramref name="key"/> is not
            already in the map, a new <see cref="T:System.Collections.Generic.ISet`1"/> will first be created. </summary>
            <returns> The size of the <see cref="T:System.Collections.Generic.ISet`1"/> associated with key once val is added to it. </returns>
        </member>
        <member name="T:Lucene.Net.Util.MathUtil">
            <summary>
            Math static utility methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.MathUtil.Log(System.Int64,System.Int32)">
            <summary>
            Returns <c>x &lt;= 0 ? 0 : Math.Floor(Math.Log(x) / Math.Log(base))</c>. </summary>
            <param name="base"> Must be <c>&gt; 1</c>.</param>
        </member>
        <member name="M:Lucene.Net.Util.MathUtil.Log(System.Double,System.Double)">
            <summary>
            Calculates logarithm in a given <paramref name="base"/> with doubles.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.MathUtil.Gcd(System.Int64,System.Int64)">
            <summary>
            Return the greatest common divisor of <paramref name="a"/> and <paramref name="b"/>,
            consistently with <c>System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger, System.Numerics.BigInteger)</c>.
            <para/><b>NOTE</b>: A greatest common divisor must be positive, but
            <c>2^64</c> cannot be expressed as a <see cref="T:System.Int64"/> although it
            is the GCD of <see cref="F:System.Int64.MinValue"/> and <c>0</c> and the GCD of
            <see cref="F:System.Int64.MinValue"/> and <see cref="F:System.Int64.MinValue"/>. So in these 2 cases,
            and only them, this method will return <see cref="F:System.Int64.MinValue"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.MathUtil.Asinh(System.Double)">
            <summary>
            Calculates inverse hyperbolic sine of a <see cref="T:System.Double"/> value.
            <para/>
            Special cases:
            <list type="bullet">
               <item><description>If the argument is NaN, then the result is NaN.</description></item>
               <item><description>If the argument is zero, then the result is a zero with the same sign as the argument.</description></item>
               <item><description>If the argument is infinite, then the result is infinity with the same sign as the argument.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.MathUtil.Acosh(System.Double)">
            <summary>
            Calculates inverse hyperbolic cosine of a <see cref="T:System.Double"/> value.
            <para/>
            Special cases:
            <list type="bullet">
               <item><description>If the argument is NaN, then the result is NaN.</description></item>
               <item><description>If the argument is +1, then the result is a zero.</description></item>
               <item><description>If the argument is positive infinity, then the result is positive infinity.</description></item>
               <item><description>If the argument is less than 1, then the result is NaN.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.MathUtil.Atanh(System.Double)">
            <summary>
            Calculates inverse hyperbolic tangent of a <see cref="T:System.Double"/> value.
            <para/>
            Special cases:
            <list type="bullet">
               <item><description>If the argument is NaN, then the result is NaN.</description></item>
               <item><description>If the argument is zero, then the result is a zero with the same sign as the argument.</description></item>
               <item><description>If the argument is +1, then the result is positive infinity.</description></item>
               <item><description>If the argument is -1, then the result is negative infinity.</description></item>
               <item><description>If the argument's absolute value is greater than 1, then the result is NaN.</description></item>
            </list>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.MergedIterator`1">
            <summary>
            Provides a merged sorted view from several sorted iterators.
            <para/>
            If built with <see cref="F:Lucene.Net.Util.MergedIterator`1.removeDuplicates"/> set to <c>true</c> and an element
            appears in multiple iterators then it is deduplicated, that is this iterator
            returns the sorted union of elements.
            <para/>
            If built with <see cref="F:Lucene.Net.Util.MergedIterator`1.removeDuplicates"/> set to <c>false</c> then all elements
            in all iterators are returned.
            <para/>
            Caveats:
            <list type="bullet">
              <item><description>The behavior is undefined if the iterators are not actually sorted.</description></item>
              <item><description>Null elements are unsupported.</description></item>
              <item><description>If <see cref="F:Lucene.Net.Util.MergedIterator`1.removeDuplicates"/> is set to <c>true</c> and if a single iterator contains
                  duplicates then they will not be deduplicated.</description></item>
              <item><description>When elements are deduplicated it is not defined which one is returned.</description></item>
              <item><description>If <see cref="F:Lucene.Net.Util.MergedIterator`1.removeDuplicates"/> is set to <c>false</c> then the order in which duplicates
                  are returned isn't defined.</description></item>
            </list>
            <para/>
            The caller is responsible for disposing the <see cref="T:System.Collections.Generic.IEnumerator`1"/> instances that are passed
            into the constructor, <see cref="T:Lucene.Net.Util.MergedIterator`1"/> doesn't do it automatically.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IMutableBits">
            <summary>
            Extension of <see cref="T:Lucene.Net.Util.IBits"/> for live documents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IMutableBits.Clear(System.Int32)">
            <summary>
            Sets the bit specified by <paramref name="index"/> to <c>false</c>. </summary>
            <param name="index"> index, should be non-negative and &lt; <see cref="P:Lucene.Net.Util.IBits.Length"/>.
                   The result of passing negative or out of bounds values is undefined
                   by this interface, <b>just don't do it!</b> </param>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValue">
            <summary>
            Base class for all mutable values.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueBool">
            <summary>
            <see cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueDate">
            <summary>
            <see cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueDouble">
            <summary>
            <see cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueSingle">
            <summary>
            <see cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type <see cref="T:System.Single"/>.
            <para/>
            NOTE: This was MutableValueFloat in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueInt32">
            <summary>
            <see cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type <see cref="T:System.Int32"/>.
            <para/>
            NOTE: This was MutableValueInt in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueInt64">
            <summary>
            <see cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type <see cref="T:System.Int64"/>.
            <para/>
            NOTE: This was MutableValueLong in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueStr">
            <summary>
            <see cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.NumericUtils">
             <summary>
             This is a helper class to generate prefix-encoded representations for numerical values
             and supplies converters to represent float/double values as sortable integers/longs.
            
             <para/>To quickly execute range queries in Apache Lucene, a range is divided recursively
             into multiple intervals for searching: The center of the range is searched only with
             the lowest possible precision in the trie, while the boundaries are matched
             more exactly. this reduces the number of terms dramatically.
            
             <para/>This class generates terms to achieve this: First the numerical integer values need to
             be converted to bytes. For that integer values (32 bit or 64 bit) are made unsigned
             and the bits are converted to ASCII chars with each 7 bit. The resulting byte[] is
             sortable like the original integer value (even using UTF-8 sort order). Each value is also
             prefixed (in the first char) by the <c>shift</c> value (number of bits removed) used
             during encoding.
            
             <para/>To also index floating point numbers, this class supplies two methods to convert them
             to integer values by changing their bit layout: <see cref="M:Lucene.Net.Util.NumericUtils.DoubleToSortableInt64(System.Double)"/>,
             <see cref="M:Lucene.Net.Util.NumericUtils.SingleToSortableInt32(System.Single)"/>. You will have no precision loss by
             converting floating point numbers to integers and back (only that the integer form
             is not usable). Other data types like dates can easily converted to <see cref="T:System.Int64"/>s or <see cref="T:System.Int32"/>s (e.g.
             date to long: <see cref="P:System.DateTime.Ticks"/>).
            
             <para/>For easy usage, the trie algorithm is implemented for indexing inside
             <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/> that can index <see cref="T:System.Int32"/>, <see cref="T:System.Int64"/>,
             <see cref="T:System.Single"/>, and <see cref="T:System.Double"/>. For querying,
             <see cref="T:Lucene.Net.Search.NumericRangeQuery"/> and <see cref="T:Lucene.Net.Search.NumericRangeFilter"/> implement the query part
             for the same data types.
            
             <para/>This class can also be used, to generate lexicographically sortable (according to
             <see cref="P:Lucene.Net.Util.BytesRef.UTF8SortedAsUTF16Comparer"/>) representations of numeric data
             types for other usages (e.g. sorting).
            
             <para/>
             @lucene.internal
             @since 2.9, API changed non backwards-compliant in 4.0
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT">
            <summary>
            The default precision step used by <see cref="T:Lucene.Net.Documents.Int32Field"/>,
            <see cref="T:Lucene.Net.Documents.SingleField"/>, <see cref="T:Lucene.Net.Documents.Int64Field"/>, 
            <see cref="T:Lucene.Net.Documents.DoubleField"/>, <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>,
            <see cref="T:Lucene.Net.Search.NumericRangeQuery"/>, and <see cref="T:Lucene.Net.Search.NumericRangeFilter"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.NumericUtils.SHIFT_START_INT64">
            <summary>
            Longs are stored at lower precision by shifting off lower bits. The shift count is
            stored as <c>SHIFT_START_INT64+shift</c> in the first byte
            <para/>
            NOTE: This was SHIFT_START_LONG in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.NumericUtils.BUF_SIZE_INT64">
            <summary>
            The maximum term length (used for <see cref="T:byte[]"/> buffer size)
            for encoding <see cref="T:System.Int64"/> values.
            <para/>
            NOTE: This was BUF_SIZE_LONG in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Util.NumericUtils.Int64ToPrefixCodedBytes(System.Int64,System.Int32,Lucene.Net.Util.BytesRef)"/>
        </member>
        <member name="F:Lucene.Net.Util.NumericUtils.SHIFT_START_INT32">
            <summary>
            Integers are stored at lower precision by shifting off lower bits. The shift count is
            stored as <c>SHIFT_START_INT32+shift</c> in the first byte
            <para/>
            NOTE: This was SHIFT_START_INT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.NumericUtils.BUF_SIZE_INT32">
            <summary>
            The maximum term length (used for <see cref="T:byte[]"/> buffer size)
            for encoding <see cref="T:System.Int32"/> values.
            <para/>
            NOTE: This was BUF_SIZE_INT in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Util.NumericUtils.Int32ToPrefixCodedBytes(System.Int32,System.Int32,Lucene.Net.Util.BytesRef)"/>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int64ToPrefixCoded(System.Int64,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns prefix coded bits after reducing the precision by <paramref name="shift"/> bits.
            This is method is used by <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>.
            After encoding, <c>bytes.Offset</c> will always be 0. 
            <para/>
            NOTE: This was longToPrefixCoded() in Lucene
            </summary>
            <param name="val"> The numeric value </param>
            <param name="shift"> How many bits to strip from the right </param>
            <param name="bytes"> Will contain the encoded value </param>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int32ToPrefixCoded(System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns prefix coded bits after reducing the precision by <paramref name="shift"/> bits.
            This is method is used by <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>.
            After encoding, <c>bytes.Offset</c> will always be 0. 
            <para/>
            NOTE: This was intToPrefixCoded() in Lucene
            </summary>
            <param name="val"> The numeric value </param>
            <param name="shift"> How many bits to strip from the right </param>
            <param name="bytes"> Will contain the encoded value </param>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int64ToPrefixCodedBytes(System.Int64,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns prefix coded bits after reducing the precision by <paramref name="shift"/> bits.
            This is method is used by <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>.
            After encoding, <c>bytes.Offset</c> will always be 0. 
            <para/>
            NOTE: This was longToPrefixCodedBytes() in Lucene
            </summary>
            <param name="val"> The numeric value </param>
            <param name="shift"> How many bits to strip from the right </param>
            <param name="bytes"> Will contain the encoded value </param>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int32ToPrefixCodedBytes(System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns prefix coded bits after reducing the precision by <paramref name="shift"/> bits.
            This is method is used by <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>.
            After encoding, <c>bytes.Offset</c> will always be 0. 
            <para/>
            NOTE: This was intToPrefixCodedBytes() in Lucene
            </summary>
            <param name="val"> The numeric value </param>
            <param name="shift"> How many bits to strip from the right </param>
            <param name="bytes"> Will contain the encoded value </param>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.GetPrefixCodedInt64Shift(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns the shift value from a prefix encoded <see cref="T:System.Int64"/>. 
            <para/>
            NOTE: This was getPrefixCodedLongShift() in Lucene
            </summary>
            <exception cref="T:System.FormatException"> if the supplied <see cref="T:Lucene.Net.Util.BytesRef"/> is
            not correctly prefix encoded. </exception>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.GetPrefixCodedInt32Shift(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns the shift value from a prefix encoded <see cref="T:System.Int32"/>. 
            <para/>
            NOTE: This was getPrefixCodedIntShift() in Lucene
            </summary>
            <exception cref="T:System.FormatException"> if the supplied <see cref="T:Lucene.Net.Util.BytesRef"/> is
            not correctly prefix encoded. </exception>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.PrefixCodedToInt64(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns a <see cref="T:System.Int64"/> from prefixCoded bytes.
            Rightmost bits will be zero for lower precision codes.
            This method can be used to decode a term's value. 
            <para/>
            NOTE: This was prefixCodedToLong() in Lucene
            </summary>
            <exception cref="T:System.FormatException"> if the supplied <see cref="T:Lucene.Net.Util.BytesRef"/> is
            not correctly prefix encoded. </exception>
            <seealso cref="M:Lucene.Net.Util.NumericUtils.Int64ToPrefixCodedBytes(System.Int64,System.Int32,Lucene.Net.Util.BytesRef)"/>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.PrefixCodedToInt32(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns an <see cref="T:System.Int32"/> from prefixCoded bytes.
            Rightmost bits will be zero for lower precision codes.
            This method can be used to decode a term's value. 
            <para/>
            NOTE: This was prefixCodedToInt() in Lucene
            </summary>
            <exception cref="T:System.FormatException"> if the supplied <see cref="T:Lucene.Net.Util.BytesRef"/> is
            not correctly prefix encoded. </exception>
            <seealso cref="M:Lucene.Net.Util.NumericUtils.Int32ToPrefixCodedBytes(System.Int32,System.Int32,Lucene.Net.Util.BytesRef)"/>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.DoubleToSortableInt64(System.Double)">
            <summary>
            Converts a <see cref="T:System.Double"/> value to a sortable signed <see cref="T:System.Int64"/>.
            The value is converted by getting their IEEE 754 floating-point &quot;double format&quot;
            bit layout and then some bits are swapped, to be able to compare the result as <see cref="T:System.Int64"/>.
            By this the precision is not reduced, but the value can easily used as a <see cref="T:System.Int64"/>.
            The sort order (including <see cref="F:System.Double.NaN"/>) is defined by
            <see cref="M:System.Double.CompareTo(System.Double)"/>; <c>NaN</c> is greater than positive infinity. 
            <para/>
            NOTE: This was doubleToSortableLong() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Util.NumericUtils.SortableInt64ToDouble(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.SortableInt64ToDouble(System.Int64)">
            <summary>
            Converts a sortable <see cref="T:System.Int64"/> back to a <see cref="T:System.Double"/>. 
            <para/>
            NOTE: This was sortableLongToDouble() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Util.NumericUtils.DoubleToSortableInt64(System.Double)"/>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.SingleToSortableInt32(System.Single)">
            <summary>
            Converts a <see cref="T:System.Single"/> value to a sortable signed <see cref="T:System.Int32"/>.
            The value is converted by getting their IEEE 754 floating-point &quot;float format&quot;
            bit layout and then some bits are swapped, to be able to compare the result as <see cref="T:System.Int32"/>.
            By this the precision is not reduced, but the value can easily used as an <see cref="T:System.Int32"/>.
            The sort order (including <see cref="F:System.Single.NaN"/>) is defined by
            <seealso cref="M:System.Single.CompareTo(System.Single)"/>; <c>NaN</c> is greater than positive infinity. 
            <para/>
            NOTE: This was floatToSortableInt() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Util.NumericUtils.SortableInt32ToSingle(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.SortableInt32ToSingle(System.Int32)">
            <summary>
            Converts a sortable <see cref="T:System.Int32"/> back to a <see cref="T:System.Single"/>. 
            <para/>
            NOTE: This was sortableIntToFloat() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Util.NumericUtils.SingleToSortableInt32(System.Single)"/>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.SplitInt64Range(Lucene.Net.Util.NumericUtils.Int64RangeBuilder,System.Int32,System.Int64,System.Int64)">
            <summary>
            Splits a long range recursively.
            You may implement a builder that adds clauses to a
            <see cref="T:Lucene.Net.Search.BooleanQuery"/> for each call to its
            <see cref="M:Lucene.Net.Util.NumericUtils.Int64RangeBuilder.AddRange(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)"/>
            method.
            <para/>
            This method is used by <see cref="T:Lucene.Net.Search.NumericRangeQuery"/>.
            <para/>
            NOTE: This was splitLongRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.SplitInt32Range(Lucene.Net.Util.NumericUtils.Int32RangeBuilder,System.Int32,System.Int32,System.Int32)">
            <summary>
            Splits an <see cref="T:System.Int32"/> range recursively.
            You may implement a builder that adds clauses to a
            <see cref="T:Lucene.Net.Search.BooleanQuery"/> for each call to its
            <see cref="M:Lucene.Net.Util.NumericUtils.Int32RangeBuilder.AddRange(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)"/>
            method.
            <para/>
            This method is used by <see cref="T:Lucene.Net.Search.NumericRangeQuery"/>.
            <para/>
            NOTE: This was splitIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.SplitRange(System.Object,System.Int32,System.Int32,System.Int64,System.Int64)">
            <summary>
            This helper does the splitting for both 32 and 64 bit. </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.AddRange(System.Object,System.Int32,System.Int64,System.Int64,System.Int32)">
            <summary>
            Helper that delegates to correct range builder. </summary>
        </member>
        <member name="T:Lucene.Net.Util.NumericUtils.Int64RangeBuilder">
            <summary>
            Callback for <see cref="M:Lucene.Net.Util.NumericUtils.SplitInt64Range(Lucene.Net.Util.NumericUtils.Int64RangeBuilder,System.Int32,System.Int64,System.Int64)"/>.
            You need to override only one of the methods.
            <para/>
            NOTE: This was LongRangeBuilder in Lucene
            <para/>
            @lucene.internal
            @since 2.9, API changed non backwards-compliant in 4.0
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int64RangeBuilder.AddRange(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Override this method, if you like to receive the already prefix encoded range bounds.
            You can directly build classical (inclusive) range queries from them.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int64RangeBuilder.AddRange(System.Int64,System.Int64,System.Int32)">
            <summary>
            Override this method, if you like to receive the raw long range bounds.
            You can use this for e.g. debugging purposes (print out range bounds).
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.NumericUtils.Int32RangeBuilder">
            <summary>
            Callback for <see cref="M:Lucene.Net.Util.NumericUtils.SplitInt32Range(Lucene.Net.Util.NumericUtils.Int32RangeBuilder,System.Int32,System.Int32,System.Int32)"/>.
            You need to override only one of the methods.
            <para/>
            NOTE: This was IntRangeBuilder in Lucene
            
            @lucene.internal
            @since 2.9, API changed non backwards-compliant in 4.0
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int32RangeBuilder.AddRange(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Override this method, if you like to receive the already prefix encoded range bounds.
            You can directly build classical range (inclusive) queries from them.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int32RangeBuilder.AddRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Override this method, if you like to receive the raw int range bounds.
            You can use this for e.g. debugging purposes (print out range bounds).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.FilterPrefixCodedInt64s(Lucene.Net.Index.TermsEnum)">
            <summary>
            Filters the given <see cref="T:Lucene.Net.Index.TermsEnum"/> by accepting only prefix coded 64 bit
            terms with a shift value of <c>0</c>.
            <para/>
            NOTE: This was filterPrefixCodedLongs() in Lucene
            </summary>
            <param name="termsEnum">
                     The terms enum to filter </param>
            <returns> A filtered <see cref="T:Lucene.Net.Index.TermsEnum"/> that only returns prefix coded 64 bit
                    terms with a shift value of <c>0</c>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.FilterPrefixCodedInt32s(Lucene.Net.Index.TermsEnum)">
            <summary>
            Filters the given <see cref="T:Lucene.Net.Index.TermsEnum"/> by accepting only prefix coded 32 bit
            terms with a shift value of <c>0</c>.
            <para/>
            NOTE: This was filterPrefixCodedInts() in Lucene
            </summary>
            <param name="termsEnum">
                     The terms enum to filter </param>
            <returns> A filtered <see cref="T:Lucene.Net.Index.TermsEnum"/> that only returns prefix coded 32 bit
                    terms with a shift value of <c>0</c>. </returns>
        </member>
        <member name="T:Lucene.Net.Util.OfflineSorter">
            <summary>
            On-disk sorting of byte arrays. Each byte array (entry) is a composed of the following
            fields:
            <list type="bullet">
              <item><description>(two bytes) length of the following byte array,</description></item>
              <item><description>exactly the above count of bytes for the sequence to be sorted.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.OfflineSorter.MB">
            <summary>
            Convenience constant for megabytes </summary>
        </member>
        <member name="F:Lucene.Net.Util.OfflineSorter.GB">
            <summary>
            Convenience constant for gigabytes </summary>
        </member>
        <member name="F:Lucene.Net.Util.OfflineSorter.MIN_BUFFER_SIZE_MB">
            <summary>
            Minimum recommended buffer size for sorting.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.OfflineSorter.ABSOLUTE_MIN_SORT_BUFFER_SIZE">
            <summary>
            Absolute minimum required buffer size for sorting.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.OfflineSorter.MAX_TEMPFILES">
            <summary>
            Maximum number of temporary files before doing an intermediate merge.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.OfflineSorter.BufferSize">
            <summary>
            A bit more descriptive unit for constructors.
            </summary>
            <seealso cref="M:Lucene.Net.Util.OfflineSorter.BufferSize.Automatic"/>
            <seealso cref="M:Lucene.Net.Util.OfflineSorter.BufferSize.Megabytes(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.BufferSize.Megabytes(System.Int64)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Util.OfflineSorter.BufferSize"/> in MB. The given
            values must be &gt; 0 and &lt; 2048.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.BufferSize.Automatic">
            <summary>
            Approximately half of the currently available free heap, but no less
            than <see cref="F:Lucene.Net.Util.OfflineSorter.ABSOLUTE_MIN_SORT_BUFFER_SIZE"/>. However if current heap allocation
            is insufficient or if there is a large portion of unallocated heap-space available
            for sorting consult with max allowed heap size.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.OfflineSorter.SortInfo">
            <summary>
            Sort info (debugging mostly).
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.TempMergeFiles">
            <summary>
            Number of temporary files created when merging partitions </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.MergeRounds">
            <summary>
            Number of partition merges </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.Lines">
            <summary>
            Number of lines of data read </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.MergeTime">
            <summary>
            Time spent merging sorted partitions (in milliseconds) </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.SortTime">
            <summary>
            Time spent sorting data (in milliseconds) </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.TotalTime">
            <summary>
            Total time spent (in milliseconds) </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.ReadTime">
            <summary>
            Time spent in i/o read (in milliseconds) </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.BufferSize">
            <summary>
            Read buffer size (in bytes) </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.SortInfo.#ctor(Lucene.Net.Util.OfflineSorter)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Util.OfflineSorter.SortInfo"/> (with empty statistics) for debugging. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.SortInfo.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.OfflineSorter.DEFAULT_COMPARER">
            <summary>
            Default comparer: sorts in binary (codepoint) order </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.#ctor">
            <summary>
            Defaults constructor.
            </summary>
            <seealso cref="M:Lucene.Net.Util.OfflineSorter.DefaultTempDir"/>
            <seealso cref="M:Lucene.Net.Util.OfflineSorter.BufferSize.Automatic"/>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.#ctor(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})">
            <summary>
            Defaults constructor with a custom comparer.
            </summary>
            <seealso cref="M:Lucene.Net.Util.OfflineSorter.DefaultTempDir"/>
            <seealso cref="M:Lucene.Net.Util.OfflineSorter.BufferSize.Automatic"/>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.#ctor(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef},Lucene.Net.Util.OfflineSorter.BufferSize,System.IO.DirectoryInfo,System.Int32)">
            <summary>
            All-details constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.Sort(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Sort input to output, explicit hint for the buffer size. The amount of allocated
            memory may deviate from the hint (may be smaller or larger).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.DefaultTempDir">
            <summary>
            Returns the default temporary directory. By default, the System's temp folder. If not accessible
            or not available, an <see cref="T:System.IO.IOException"/> is thrown.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.Copy(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Copies one file to another.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.SortPartition(System.Int32)">
            <summary>
            Sort a single partition in-memory. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.MergePartitions(System.Collections.Generic.IList{System.IO.FileInfo},System.IO.FileInfo)">
            <summary>
            Merge a list of sorted temporary files (partitions) into an output file. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ReadPartition(Lucene.Net.Util.OfflineSorter.ByteSequencesReader)">
            <summary>
            Read in a single partition of data. </summary>
        </member>
        <member name="T:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter">
            <summary>
            Utility class to emit length-prefixed <see cref="T:byte[]"/> entries to an output stream for sorting.
            Complementary to <see cref="T:Lucene.Net.Util.OfflineSorter.ByteSequencesReader"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.#ctor(System.IO.FileInfo)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter"/> to the provided <see cref="T:System.IO.FileInfo"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.#ctor(Lucene.Net.Store.DataOutput)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter"/> to the provided <see cref="T:Lucene.Net.Store.DataOutput"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.NewBinaryWriterDataOutput(System.IO.FileInfo)">
            <summary>
            LUCENENET specific - ensures the file has been created with no BOM
            if it doesn't already exist and opens the file for writing.
            Java doesn't use a BOM by default.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Write(Lucene.Net.Util.BytesRef)">
            <summary>
            Writes a <see cref="T:Lucene.Net.Util.BytesRef"/>. </summary>
            <seealso cref="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Write(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Write(System.Byte[])">
            <summary>
            Writes a byte array. </summary>
            <seealso cref="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Write(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a byte array.
            <para/>
            The length is written as a <see cref="T:System.Int16"/>, followed
            by the bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Dispose">
            <summary>
            Disposes the provided <see cref="T:Lucene.Net.Store.DataOutput"/> if it is <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.OfflineSorter.ByteSequencesReader">
            <summary>
            Utility class to read length-prefixed <see cref="T:byte[]"/> entries from an input.
            Complementary to <see cref="T:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesReader.#ctor(System.IO.FileInfo)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Util.OfflineSorter.ByteSequencesReader"/> from the provided <see cref="T:System.IO.FileInfo"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesReader.#ctor(Lucene.Net.Store.DataInput)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Util.OfflineSorter.ByteSequencesReader"/> from the provided <see cref="T:Lucene.Net.Store.DataInput"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesReader.Read(Lucene.Net.Util.BytesRef)">
            <summary>
            Reads the next entry into the provided <see cref="T:Lucene.Net.Util.BytesRef"/>. The internal
            storage is resized if needed.
            </summary>
            <returns> Returns <c>false</c> if EOF occurred when trying to read
            the header of the next sequence. Returns <c>true</c> otherwise. </returns>
            <exception cref="T:System.IO.EndOfStreamException"> If the file ends before the full sequence is read. </exception>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesReader.Read">
            <summary>
            Reads the next entry and returns it if successful.
            </summary>
            <seealso cref="M:Lucene.Net.Util.OfflineSorter.ByteSequencesReader.Read(Lucene.Net.Util.BytesRef)"/>
            <returns> Returns <c>null</c> if EOF occurred before the next entry
            could be read. </returns>
            <exception cref="T:System.IO.EndOfStreamException"> If the file ends before the full sequence is read. </exception>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesReader.Dispose">
            <summary>
            Disposes the provided <see cref="T:Lucene.Net.Store.DataInput"/> if it is <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.Comparer">
            <summary>
            Returns the comparer in use to sort entries </summary>
        </member>
        <member name="T:Lucene.Net.Util.OpenBitSet">
             <summary>
             An "open" BitSet implementation that allows direct access to the array of words
             storing the bits.
             <para/>
             NOTE: This can be used in .NET any place where a <c>java.util.BitSet</c> is used in Java.
             <para/>
             Unlike <c>java.util.BitSet</c>, the fact that bits are packed into an array of longs
             is part of the interface.  This allows efficient implementation of other algorithms
             by someone other than the author.  It also allows one to efficiently implement
             alternate serialization or interchange formats.
             <para/>
             <see cref="T:Lucene.Net.Util.OpenBitSet"/> is faster than <c>java.util.BitSet</c> in most operations
             and *much* faster at calculating cardinality of sets and results of set operations.
             It can also handle sets of larger cardinality (up to 64 * 2**32-1)
             <para/>
             The goals of <see cref="T:Lucene.Net.Util.OpenBitSet"/> are the fastest implementation possible, and
             maximum code reuse.  Extra safety and encapsulation
             may always be built on top, but if that's built in, the cost can never be removed (and
             hence people re-implement their own version in order to get better performance).
             <para/>
             <h3>Performance Results</h3>
            
             Test system: Pentium 4, Sun Java 1.5_06 -server -Xbatch -Xmx64M
             <para/>BitSet size = 1,000,000
             <para/>Results are java.util.BitSet time divided by OpenBitSet time.
             <list type="table">
                 <listheader>
                     <term></term> <term>cardinality</term> <term>IntersectionCount</term> <term>Union</term> <term>NextSetBit</term> <term>Get</term> <term>GetIterator</term>
                 </listheader>
                 <item>
                     <term>50% full</term> <description>3.36</description> <description>3.96</description> <description>1.44</description> <description>1.46</description> <description>1.99</description> <description>1.58</description>
                 </item>
                 <item>
                     <term>1% full</term> <description>3.31</description> <description>3.90</description> <description>&#160;</description> <description>1.04</description> <description>&#160;</description> <description>0.99</description>
                 </item>
             </list>
             <para/>
             <para/>
             Test system: AMD Opteron, 64 bit linux, Sun Java 1.5_06 -server -Xbatch -Xmx64M
             <para/>BitSet size = 1,000,000
             <para/>Results are java.util.BitSet time divided by OpenBitSet time.
             <list type="table">
                 <listheader>
                     <term></term> <term>cardinality</term> <term>IntersectionCount</term> <term>Union</term> <term>NextSetBit</term> <term>Get</term> <term>GetIterator</term>
                 </listheader>
                 <item>
                     <term>50% full</term> <description>2.50</description> <description>3.50</description> <description>1.00</description> <description>1.03</description> <description>1.12</description> <description>1.25</description>
                 </item>
                 <item>
                     <term>1% full</term> <description>2.51</description> <description>3.49</description> <description>&#160;</description> <description>1.00</description> <description>&#160;</description> <description>1.02</description>
                 </item>
             </list>
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.#ctor(System.Int64)">
            <summary>
            Constructs an <see cref="T:Lucene.Net.Util.OpenBitSet"/> large enough to hold <paramref name="numBits"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.#ctor">
            <summary>
            Constructor: allocates enough space for 64 bits. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.#ctor(System.Int64[],System.Int32)">
            <summary>
            Constructs an <see cref="T:Lucene.Net.Util.OpenBitSet"/> from an existing <see cref="T:long[]"/>.
            <para/>
            The first 64 bits are in long[0], with bit index 0 at the least significant
            bit, and bit index 63 at the most significant. Given a bit index, the word
            containing it is long[index/64], and it is at bit number index%64 within
            that word.
            <para/>
            <paramref name="numWords"/> are the number of elements in the array that contain set bits
            (non-zero longs). <paramref name="numWords"/> should be &lt;= bits.Length, and any existing
            words in the array at position &gt;= numWords should be zero.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.IsCacheable">
            <summary>
            This DocIdSet implementation is cacheable. </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.Capacity">
            <summary>
            Returns the current capacity in bits (1 greater than the index of the last bit). </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.Length">
            <summary>
            Returns the current capacity of this set. This is *not* equal to <see cref="M:Lucene.Net.Util.OpenBitSet.Cardinality"/>.
            <para/>
            NOTE: This is equivalent to size() or length() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.IsEmpty">
            <summary>
            Returns <c>true</c> if there are no set bits </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetBits">
            <summary>
            Expert: returns the <see cref="T:long[]"/> storing the bits. </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.NumWords">
            <summary>
            Expert: gets the number of <see cref="T:System.Int64"/>s in the array that are in use. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Get(System.Int32)">
            <summary>
            Returns <c>true</c> or <c>false</c> for the specified bit <paramref name="index"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastGet(System.Int32)">
            <summary>
            Returns <c>true</c> or <c>false</c> for the specified bit <paramref name="index"/>.
            The index should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Get(System.Int64)">
            <summary>
            Returns <c>true</c> or <c>false</c> for the specified bit <paramref name="index"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastGet(System.Int64)">
            <summary>
            Returns <c>true</c> or <c>false</c> for the specified bit <paramref name="index"/>.
            The index should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetBit(System.Int32)">
            <summary>
            Returns 1 if the bit is set, 0 if not.
            The <paramref name="index"/> should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Set(System.Int64)">
            <summary>
            Sets a bit, expanding the set size if necessary. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastSet(System.Int32)">
            <summary>
            Sets the bit at the specified <paramref name="index"/>.
            The <paramref name="index"/> should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastSet(System.Int64)">
            <summary>
            Sets the bit at the specified <paramref name="index"/>.
            The <paramref name="index"/> should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Set(System.Int64,System.Int64)">
            <summary>
            Sets a range of bits, expanding the set size if necessary.
            </summary>
            <param name="startIndex"> Lower index </param>
            <param name="endIndex"> One-past the last bit to set </param>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastClear(System.Int32)">
            <summary>
            Clears a bit.
            The <paramref name="index"/> should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastClear(System.Int64)">
            <summary>
            Clears a bit.
            The <paramref name="index"/> should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Clear(System.Int64)">
            <summary>
            Clears a bit, allowing access beyond the current set size without changing the size. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Clear(System.Int32,System.Int32)">
            <summary>
            Clears a range of bits.  Clearing past the end does not change the size of the set.
            </summary>
            <param name="startIndex"> Lower index </param>
            <param name="endIndex"> One-past the last bit to clear </param>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Clear(System.Int64,System.Int64)">
            <summary>
            Clears a range of bits.  Clearing past the end does not change the size of the set.
            </summary>
            <param name="startIndex"> Lower index </param>
            <param name="endIndex"> One-past the last bit to clear </param>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetAndSet(System.Int32)">
            <summary>
            Sets a bit and returns the previous value.
            The <paramref name="index"/> should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetAndSet(System.Int64)">
            <summary>
            Sets a bit and returns the previous value.
            The <paramref name="index"/> should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastFlip(System.Int32)">
            <summary>
            Flips a bit.
            The <paramref name="index"/> should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastFlip(System.Int64)">
            <summary>
            Flips a bit.
            The <paramref name="index"/> should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Flip(System.Int64)">
            <summary>
            Flips a bit, expanding the set size if necessary. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FlipAndGet(System.Int32)">
            <summary>
            Flips a bit and returns the resulting bit value.
            The <paramref name="index"/> should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FlipAndGet(System.Int64)">
            <summary>
            Flips a bit and returns the resulting bit value.
            The <paramref name="index"/> should be less than the <see cref="P:Lucene.Net.Util.OpenBitSet.Length"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Flip(System.Int64,System.Int64)">
            <summary>
            Flips a range of bits, expanding the set size if necessary.
            </summary>
            <param name="startIndex"> Lower index </param>
            <param name="endIndex"> One-past the last bit to flip </param>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Cardinality">
            <summary>
            Get the number of set bits.
            </summary>
            <returns> The number of set bits. </returns>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.IntersectionCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Returns the popcount or cardinality of the intersection of the two sets.
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.UnionCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Returns the popcount or cardinality of the union of the two sets.
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.AndNotCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Returns the popcount or cardinality of "a and not b"
            or "intersection(a, not(b))".
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.XorCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Returns the popcount or cardinality of the exclusive-or of the two sets.
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.NextSetBit(System.Int32)">
            <summary>
            Returns the index of the first set bit starting at the <paramref name="index"/> specified.
            -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.NextSetBit(System.Int64)">
            <summary>
            Returns the index of the first set bit starting at the <paramref name="index"/> specified.
            -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.PrevSetBit(System.Int32)">
            <summary>
            Returns the index of the first set bit starting downwards at
            the <paramref name="index"/> specified.
            -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.PrevSetBit(System.Int64)">
            <summary>
            Returns the index of the first set bit starting downwards at
            the <paramref name="index"/> specified.
            -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Intersect(Lucene.Net.Util.OpenBitSet)">
            <summary>
            this = this AND other </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Union(Lucene.Net.Util.OpenBitSet)">
            <summary>
            this = this OR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Remove(Lucene.Net.Util.OpenBitSet)">
            <summary>
            Remove all elements set in other. this = this AND_NOT other. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Xor(Lucene.Net.Util.OpenBitSet)">
            <summary>
            this = this XOR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.And(Lucene.Net.Util.OpenBitSet)">
            <summary>see <see cref="M:Lucene.Net.Util.OpenBitSet.Intersect(Lucene.Net.Util.OpenBitSet)"/></summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Or(Lucene.Net.Util.OpenBitSet)">
            <summary>see <see cref="M:Lucene.Net.Util.OpenBitSet.Union(Lucene.Net.Util.OpenBitSet)"/></summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.AndNot(Lucene.Net.Util.OpenBitSet)">
            <summary>see <see cref="M:Lucene.Net.Util.OpenBitSet.AndNot(Lucene.Net.Util.OpenBitSet)"/></summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Intersects(Lucene.Net.Util.OpenBitSet)">
            <summary>
            returns <c>true</c> if the sets have any elements in common. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.EnsureCapacityWords(System.Int32)">
            <summary>
            Expand the <see cref="T:long[]"/> with the size given as a number of words (64 bit longs). </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.EnsureCapacity(System.Int64)">
            <summary>
            Ensure that the <see cref="T:long[]"/> is big enough to hold numBits, expanding it if
            necessary.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.TrimTrailingZeros">
            <summary>
            Lowers numWords, the number of words in use,
            by checking for trailing zero words.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Bits2words(System.Int64)">
            <summary>
            Returns the number of 64 bit words it would take to hold <paramref name="numBits"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if both sets have the same bits set. </summary>
        </member>
        <member name="T:Lucene.Net.Util.OpenBitSetDISI">
            <summary>
            <see cref="T:Lucene.Net.Util.OpenBitSet"/> with added methods to bulk-update the bits
            from a <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>. (DISI stands for <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.#ctor(Lucene.Net.Search.DocIdSetIterator,System.Int32)">
            <summary>
            Construct an <see cref="T:Lucene.Net.Util.OpenBitSetDISI"/> with its bits set
            from the doc ids of the given <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>.
            Also give a maximum size one larger than the largest doc id for which a
            bit may ever be set on this <see cref="T:Lucene.Net.Util.OpenBitSetDISI"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.#ctor(System.Int32)">
            <summary>
            Construct an <see cref="T:Lucene.Net.Util.OpenBitSetDISI"/> with no bits set, and a given maximum size
            one larger than the largest doc id for which a bit may ever be set
            on this <see cref="T:Lucene.Net.Util.OpenBitSetDISI"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceOr(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Perform an inplace OR with the doc ids from a given <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>,
            setting the bit for each such doc id.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceAnd(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Perform an inplace AND with the doc ids from a given <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>,
            leaving only the bits set for which the doc ids are in common.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceNot(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Perform an inplace NOT with the doc ids from a given <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>,
            clearing all the bits for each such doc id.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceXor(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Perform an inplace XOR with the doc ids from a given <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>,
            flipping all the bits for each such doc id.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.OpenBitSetIterator">
            <summary>
            An iterator to iterate over set bits in an <see cref="T:Lucene.Net.Util.OpenBitSet"/>.
            this is faster than <see cref="M:Lucene.Net.Util.OpenBitSet.NextSetBit(System.Int64)"/> for iterating over the complete set of bits,
            especially when the density of the bits set is high.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer">
            <summary>
            Common functionality shared by <see cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer"/> and <see cref="T:Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer"/>. 
            <para/>
            NOTE: This was AbstractAppendingLongBuffer in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Count">
            <summary>
            Get the number of values that have been added to the buffer.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Add(System.Int64)">
            <summary>
            Append a value to this buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Get(System.Int64,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Bulk get: read at least one and at most <paramref name="len"/> <see cref="T:System.Int64"/>s starting
            from <paramref name="index"/> into <c>arr[off:off+len]</c> and return
            the actual number of values that have been read.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.GetIterator">
            <summary>
            Return an iterator over the values of this buffer. 
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Iterator.HasNext">
            <summary>
            Whether or not there are remaining values. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Iterator.Next">
            <summary>
            Return the next long in the buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.RamBytesUsed">
            <summary>
            Return the number of bytes used by this instance. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Freeze">
            <summary>
            Pack all pending values in this buffer. Subsequent calls to <see cref="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Add(System.Int64)"/> will fail. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.WriteVInt64(Lucene.Net.Store.DataOutput,System.Int64)">
            <summary>
            NOTE: This was writeVLong() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.#ctor(Lucene.Net.Store.DataOutput,System.Int32)">
            <summary>
            Sole constructor. </summary>
            <param name="blockSize"> the number of values of a single block, must be a multiple of <c>64</c>. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Reset(Lucene.Net.Store.DataOutput)">
            <summary>
            Reset this writer to wrap <paramref name="out"/>. The block size remains unchanged. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Add(System.Int64)">
            <summary>
            Append a new long. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Finish">
            <summary>
            Flush all buffered data to disk. This instance is not usable anymore
            after this method has been called until <see cref="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Reset(Lucene.Net.Store.DataOutput)"/> has
            been called.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Ord">
            <summary>
            Return the number of values which have been added. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.AbstractPagedMutable`1">
            <summary>
            Base implementation for <see cref="T:Lucene.Net.Util.Packed.PagedMutable"/> and <see cref="T:Lucene.Net.Util.Packed.PagedGrowableWriter"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Count">
            <summary>
            The number of values.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Set(System.Int64,System.Int64)">
            <summary>
            Set value at <paramref name="index"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.RamBytesUsed">
            <summary>
            Return the number of bytes used by this object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Resize(System.Int64)">
            <summary>
            Create a new copy of size <paramref name="newSize"/> based on the content of
            this buffer. This method is much more efficient than creating a new
            instance and copying values one by one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Grow(System.Int64)">
            <summary>
            Similar to <see cref="M:Lucene.Net.Util.ArrayUtil.Grow(System.Int64[],System.Int32)"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Grow">
            <summary>
            Similar to <see cref="M:Lucene.Net.Util.ArrayUtil.Grow(System.Int64[])"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer">
            <summary>
            Utility class to buffer a list of signed longs in memory. This class only
            supports appending and is optimized for the case where values are close to
            each other.
            <para/>
            NOTE: This was AppendingDeltaPackedLongBuffer in Lucene
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Create <see cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer"/>. </summary>
            <param name="initialPageCount">        The initial number of pages. </param>
            <param name="pageSize">                The size of a single page. </param>
            <param name="acceptableOverheadRatio"> An acceptable overhead ratio per value. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer.#ctor">
            <summary>
            Create an <see cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer"/> with initialPageCount=16,
            pageSize=1024 and acceptableOverheadRatio=<see cref="F:Lucene.Net.Util.Packed.PackedInt32s.DEFAULT"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer.#ctor(System.Single)">
            <summary>
            Create an <see cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer"/> with initialPageCount=16,
            pageSize=1024.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer">
            <summary>
            Utility class to buffer a list of signed longs in memory. This class only
            supports appending and is optimized for non-negative numbers with a uniform distribution over a fixed (limited) range.
            <para/>
            NOTE: This was AppendingPackedLongBuffer in Lucene
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Initialize a <see cref="T:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer"/>. </summary>
            <param name="initialPageCount">        The initial number of pages. </param>
            <param name="pageSize">                The size of a single page. </param>
            <param name="acceptableOverheadRatio"> An acceptable overhead ratio per value. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer.#ctor">
            <summary>
            Create an <see cref="T:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer"/> with initialPageCount=16,
            pageSize=1024 and acceptableOverheadRatio=<see cref="F:Lucene.Net.Util.Packed.PackedInt32s.DEFAULT"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer.#ctor(System.Single)">
            <summary>
            Create an <see cref="T:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer"/> with initialPageCount=16,
            pageSize=1024.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BlockPackedReader">
            <summary>
            Provides random access to a stream written with <see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32,System.Int64,System.Boolean)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BlockPackedReaderIterator">
            <summary>
            Reader for sequences of <see cref="T:System.Int64"/>s written with <see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>. 
            <para/>
            @lucene.internal
            </summary>
            <seealso cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.ReadVInt64(Lucene.Net.Store.DataInput)">
            <summary>
            NOTE: This was readVLong() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.#ctor(Lucene.Net.Store.DataInput,System.Int32,System.Int32,System.Int64)">
            <summary>
            Sole constructor. </summary>
            <param name="blockSize"> The number of values of a block, must be equal to the
                             block size of the <see cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/> which has
                             been used to write the stream. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Reset(Lucene.Net.Store.DataInput,System.Int64)">
            <summary>
            Reset the current reader to wrap a stream of <paramref name="valueCount"/>
            values contained in <paramref name="in"/>. The block size remains unchanged.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Skip(System.Int64)">
            <summary>
            Skip exactly <paramref name="count"/> values. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Next">
            <summary>
            Read the next value. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Next(System.Int32)">
            <summary>
            Read between <c>1</c> and <paramref name="count"/> values. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Ord">
            <summary>
            Return the offset of the next value to read. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BlockPackedWriter">
            <summary>
            A writer for large sequences of longs.
            <para/>
            The sequence is divided into fixed-size blocks and for each block, the
            difference between each value and the minimum value of the block is encoded
            using as few bits as possible. Memory usage of this class is proportional to
            the block size. Each block has an overhead between 1 and 10 bytes to store
            the minimum value and the number of bits per value of the block.
            <para/>
            Format:
            <list type="bullet">
            <item><description>&lt;BLock&gt;<sup>BlockCount</sup></description></item>
            <item><description>BlockCount: &#8968; ValueCount / BlockSize &#8969;</description></item>
            <item><description>Block: &lt;Header, (Ints)&gt;</description></item>
            <item><description>Header: &lt;Token, (MinValue)&gt;</description></item>
            <item><description>Token: a byte (<see cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>), first 7 bits are the
                number of bits per value (<c>bitsPerValue</c>). If the 8th bit is 1,
                then MinValue (see next) is <c>0</c>, otherwise MinValue and needs to
                be decoded</description></item>
            <item><description>MinValue: a
                <a href="https://developers.google.com/protocol-buffers/docs/encoding#types">zigzag-encoded</a>
                 variable-length <see cref="T:System.Int64"/> (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>) whose value
                should be added to every int from the block to restore the original
                values</description></item>
            <item><description>Ints: If the number of bits per value is <c>0</c>, then there is
                nothing to decode and all ints are equal to MinValue. Otherwise: BlockSize
                packed ints (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>) encoded on exactly <c>bitsPerValue</c>
                bits per value. They are the subtraction of the original values and
                MinValue</description></item>
            </list>
            <para/>
            @lucene.internal
            </summary>
            <seealso cref="T:Lucene.Net.Util.Packed.BlockPackedReaderIterator"/>
            <seealso cref="T:Lucene.Net.Util.Packed.BlockPackedReader"/>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedWriter.#ctor(Lucene.Net.Store.DataOutput,System.Int32)">
            <summary>
            Sole constructor. </summary>
            <param name="blockSize"> the number of values of a single block, must be a power of 2 </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperation">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BulkOperation.Int64ValueCount">
            <summary>
            NOTE: This was longValueCount() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BulkOperation.Int64BlockCount">
            <summary>
            NOTE: This was longBlockCount() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BulkOperation.WriteInt64(System.Int64,System.Byte[],System.Int32)">
            <summary>
            NOTE: This was writeLong() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BulkOperation.ComputeIterations(System.Int32,System.Int32)">
            <summary>
            For every number of bits per value, there is a minimum number of
            blocks (b) / values (v) you need to write in order to reach the next block
            boundary:
             - 16 bits per value -> b=2, v=1
             - 24 bits per value -> b=3, v=1
             - 50 bits per value -> b=25, v=4
             - 63 bits per value -> b=63, v=8
             - ...
            <para/>
            A bulk read consists in copying <c>iterations*v</c> values that are
            contained in <c>iterations*b</c> blocks into a <c>long[]</c>
            (higher values of <c>iterations</c> are likely to yield a better
            throughput) => this requires n * (b + 8v) bytes of memory.
            <para/>
            This method computes <c>iterations</c> as
            <c>ramBudget / (b + 8v)</c> (since a long is 8 bytes).
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked">
            <summary>
            Non-specialized <see cref="T:Lucene.Net.Util.Packed.BulkOperation"/> for <see cref="F:Lucene.Net.Util.Packed.PackedInt32s.Format.PACKED"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BulkOperationPacked.Int64BlockCount">
            <summary>
            NOTE: This was longBlockCount() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BulkOperationPacked.Int64ValueCount">
            <summary>
            NOTE: This was longValueCount() in Lucene.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked1">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked10">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked11">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked12">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked13">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked14">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked15">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked16">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked17">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked18">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked19">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked2">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked20">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked21">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked22">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked23">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked24">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked3">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked4">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked5">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked6">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked7">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked8">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked9">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPackedSingleBlock">
            <summary>
            Non-specialized <see cref="T:Lucene.Net.Util.Packed.BulkOperation"/> for <see cref="F:Lucene.Net.Util.Packed.PackedInt32s.Format.PACKED_SINGLE_BLOCK"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BulkOperationPackedSingleBlock.Int64BlockCount">
            <summary>
            NOTE: This was longBlockCount() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BulkOperationPackedSingleBlock.Int64ValueCount">
            <summary>
            NOTE: This was longValueCount() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BulkOperationPackedSingleBlock.ReadInt64(System.Byte[],System.Int32)">
            <summary>
            NOTE: This was readLong() in Lucene.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Direct16">
            <summary>
            Direct wrapping of 16-bits values to a backing array.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Direct32">
            <summary>
            Direct wrapping of 32-bits values to a backing array.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Direct64">
            <summary>
            Direct wrapping of 64-bits values to a backing array.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Direct8">
            <summary>
            Direct wrapping of 8-bits values to a backing array.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.EliasFanoDecoder">
            <summary>
            A decoder for an <see cref="T:Lucene.Net.Util.Packed.EliasFanoEncoder"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.EliasFanoDecoder.LOG2_INT64_SIZE">
            <summary>
            NOTE: This was LOG2_LONG_SIZE in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.#ctor(Lucene.Net.Util.Packed.EliasFanoEncoder)">
            <summary>
            Construct a decoder for a given <see cref="T:Lucene.Net.Util.Packed.EliasFanoEncoder"/>.
            The decoding index is set to just before the first encoded value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDecoder.EliasFanoEncoder">
            <returns> The Elias-Fano encoder that is decoded. </returns>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDecoder.NumEncoded">
            <summary>
            The number of values encoded by the encoder. </summary>
            <returns> The number of values encoded by the encoder. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentIndex">
            <summary>
            The current decoding index.
            The first value encoded by <see cref="M:Lucene.Net.Util.Packed.EliasFanoEncoder.EncodeNext(System.Int64)"/> has index 0.
            Only valid directly after
            <see cref="M:Lucene.Net.Util.Packed.EliasFanoDecoder.NextValue"/>, <see cref="M:Lucene.Net.Util.Packed.EliasFanoDecoder.AdvanceToValue(System.Int64)"/>,
            <see cref="M:Lucene.Net.Util.Packed.EliasFanoDecoder.PreviousValue"/>, or <see cref="M:Lucene.Net.Util.Packed.EliasFanoDecoder.BackToValue(System.Int64)"/>
            returned another value than <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.NO_MORE_VALUES"/>,
            or <see cref="M:Lucene.Net.Util.Packed.EliasFanoDecoder.AdvanceToIndex(System.Int64)"/> returned <c>true</c>. </summary>
            <returns> The decoding index of the last decoded value, or as last set by <see cref="M:Lucene.Net.Util.Packed.EliasFanoDecoder.AdvanceToIndex(System.Int64)"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentValue">
            <summary>
            The value at the current decoding index.
            Only valid when <see cref="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentIndex"/> would return a valid result.
            <para/>
            This is only intended for use after <see cref="M:Lucene.Net.Util.Packed.EliasFanoDecoder.AdvanceToIndex(System.Int64)"/> returned <c>true</c>. </summary>
            <returns> The value encoded at <see cref="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentIndex"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentHighValue">
             <returns> The high value for the current decoding index. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.UnPackValue(System.Int64[],System.Int32,System.Int64,System.Int64)">
            <summary>
            See also <see cref="M:Lucene.Net.Util.Packed.EliasFanoEncoder.PackValue(System.Int64,System.Int64[],System.Int32,System.Int64)"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentLowValue">
             <returns> The low value for the current decoding index. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CombineHighLowValues(System.Int64,System.Int64)">
             <returns> The given <paramref name="highValue"/> shifted left by the number of low bits from by the EliasFanoSequence,
                      logically OR-ed with the given <paramref name="lowValue"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToBeforeSequence">
            <summary>
            Set the decoding index to just before the first encoded value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentRightShift">
            <returns> The number of bits in a <see cref="T:System.Int64"/> after (<see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/> modulo <c>sizeof(long)</c>). </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToAfterCurrentHighBit">
            <summary>
            Increment <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.efIndex"/> and <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/> and
            shift <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.curHighLong"/> so that it does not contain the high bits before <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/>. </summary>
            <returns> <c>true</c> if <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.efIndex"/> still smaller than <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.numEncoded"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToNextHighInt64">
            <summary>
            The current high long has been determined to not contain the set bit that is needed.
            Increment <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/> to the next high long and set <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.curHighLong"/> accordingly.
            <para/>
            NOTE: this was toNextHighLong() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToNextHighValue">
            <summary>
            <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/> and <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.efIndex"/> have just been incremented, scan to the next high set bit
            by incrementing <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/>, and by setting <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.curHighLong"/> accordingly.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.NextHighValue">
            <summary>
            <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/> and <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.efIndex"/> have just been incremented, scan to the next high set bit
            by incrementing <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/>, and by setting <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.curHighLong"/> accordingly. </summary>
            <returns> The next encoded high value. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.NextValue">
            <summary>
            If another value is available after the current decoding index, return this value and
            and increase the decoding index by 1. Otherwise return <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.NO_MORE_VALUES"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.AdvanceToIndex(System.Int64)">
            <summary>
            Advance the decoding index to a given <paramref name="index"/>.
            and return <c>true</c> iff it is available.
            <para/>See also <see cref="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentValue"/>.
            <para/>The current implementation does not use the index on the upper bit zero bit positions.
            <para/>Note: there is currently no implementation of <c>BackToIndex()</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.AdvanceToValue(System.Int64)">
            <summary>
            Given a <paramref name="target"/> value, advance the decoding index to the first bigger or equal value
            and return it if it is available. Otherwise return <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.NO_MORE_VALUES"/>.
            <para/>
            The current implementation uses the index on the upper zero bit positions.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToAfterSequence">
            <summary>
            Set the decoding index to just after the last encoded value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentLeftShift">
            <returns> the number of bits in a long before (<see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/> modulo <c>sizeof(long)</c>) </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToBeforeCurrentHighBit">
            <summary>
            Decrement <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.efIndex"/> and <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/> and
            shift <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.curHighLong"/> so that it does not contain the high bits after <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/>. </summary>
            <returns> <c>true</c> if <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.efIndex"/> still >= 0. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToPreviousHighInt64">
            <summary>
            The current high long has been determined to not contain the set bit that is needed.
            Decrement <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/> to the previous high long and set <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.curHighLong"/> accordingly.
            <para/>
            NOTE: this was toPreviousHighLong() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.PreviousHighValue">
            <summary>
            <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/> and <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.efIndex"/> have just been decremented, scan to the previous high set bit
            by decrementing <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/> and by setting <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.curHighLong"/> accordingly. </summary>
            <returns> The previous encoded high value. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.PreviousValue">
            <summary>
            If another value is available before the current decoding index, return this value
            and decrease the decoding index by 1. Otherwise return <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.NO_MORE_VALUES"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.BackToHighValue(System.Int64)">
            <summary>
            <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/> and <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.efIndex"/> have just been decremented, scan backward to the high set bit
            of at most a given high value
            by decrementing <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.setBitForIndex"/> and by setting <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.curHighLong"/> accordingly.
            <para/>
            The current implementation does not use the index on the upper zero bit positions. 
            </summary>
            <returns> The largest encoded high value that is at most the given one. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.BackToValue(System.Int64)">
            <summary>
            Given a target value, go back to the first smaller or equal value
            and return it if it is available. Otherwise return <see cref="F:Lucene.Net.Util.Packed.EliasFanoDecoder.NO_MORE_VALUES"/>.
            <para/>
            The current implementation does not use the index on the upper zero bit positions.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.EliasFanoDocIdSet">
            <summary>
            A DocIdSet in Elias-Fano encoding.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDocIdSet.#ctor(System.Int32,System.Int32)">
            <summary>
            Construct an EliasFanoDocIdSet. For efficient encoding, the parameters should be chosen as low as possible. </summary>
            <param name="numValues"> At least the number of document ids that will be encoded. </param>
            <param name="upperBound">  At least the highest document id that will be encoded. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDocIdSet.SufficientlySmallerThanBitSet(System.Int64,System.Int64)">
            <summary>
            Provide an indication that is better to use an <see cref="T:Lucene.Net.Util.Packed.EliasFanoDocIdSet"/> than a <see cref="T:Lucene.Net.Util.FixedBitSet"/>
            to encode document identifiers. </summary>
            <param name="numValues"> The number of document identifiers that is to be encoded. Should be non negative. </param>
            <param name="upperBound"> The maximum possible value for a document identifier. Should be at least <paramref name="numValues"/>. </param>
            <returns> See <see cref="M:Lucene.Net.Util.Packed.EliasFanoEncoder.SufficientlySmallerThanBitSet(System.Int64,System.Int64)"/> </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDocIdSet.EncodeFromDisi(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Encode the document ids from a DocIdSetIterator. </summary>
            <param name="disi"> This DocIdSetIterator should provide document ids that are consistent
                         with <c>numValues</c> and <c>upperBound</c> as provided to the constructor.   </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDocIdSet.GetIterator">
            <summary>
            Provides a <see cref="T:Lucene.Net.Search.DocIdSetIterator"/> to access encoded document ids.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDocIdSet.IsCacheable">
            <summary>
            This DocIdSet implementation is cacheable. </summary>
            <returns> <c>true</c> </returns>
        </member>
        <member name="T:Lucene.Net.Util.Packed.EliasFanoEncoder">
             <summary>
             Encode a non decreasing sequence of non negative whole numbers in the Elias-Fano encoding
             that was introduced in the 1970's by Peter Elias and Robert Fano.
             <para/>
             The Elias-Fano encoding is a high bits / low bits representation of
             a monotonically increasing sequence of <c>numValues > 0</c> natural numbers <c>x[i]</c>
             <para/>
             <c>0 &lt;= x[0] &lt;= x[1] &lt;= ... &lt;= x[numValues-2] &lt;= x[numValues-1] &lt;= upperBound</c>
             <para/>
             where <c>upperBound > 0</c> is an upper bound on the last value.
             <para/>
             The Elias-Fano encoding uses less than half a bit per encoded number more
             than the smallest representation
             that can encode any monotone sequence with the same bounds.
             <para/>
             The lower <c>L</c> bits of each <c>x[i]</c> are stored explicitly and contiguously
             in the lower-bits array, with <c>L</c> chosen as (<c>Log()</c> base 2):
             <para/>
             <c>L = max(0, floor(log(upperBound/numValues)))</c>
             <para/>
             The upper bits are stored in the upper-bits array as a sequence of unary-coded gaps (<c>x[-1] = 0</c>):
             <para/>
             <c>(x[i]/2**L) - (x[i-1]/2**L)</c>
             <para/>
             The unary code encodes a natural number <c>n</c> by <c>n</c> 0 bits followed by a 1 bit:
             <c>0...01</c>. 
             <para/>
             In the upper bits the total the number of 1 bits is <c>numValues</c>
             and the total number of 0 bits is:
             <para/>
             <c>floor(x[numValues-1]/2**L) &lt;= upperBound/(2**max(0, floor(log(upperBound/numValues)))) &lt;= 2*numValues</c>
             <para/>
             The Elias-Fano encoding uses at most
             <para/>
             <c>2 + Ceil(Log(upperBound/numValues))</c>
             <para/>
             bits per encoded number. With <c>upperBound</c> in these bounds (<c>p</c> is an integer):
             <para/>
             <c>2**p &lt; x[numValues-1] &lt;= upperBound &lt;= 2**(p+1)</c>
             <para/>
             the number of bits per encoded number is minimized.
             <para/>
             In this implementation the values in the sequence can be given as <c>long</c>,
             <c>numValues = 0</c> and <c>upperBound = 0</c> are allowed,
             and each of the upper and lower bit arrays should fit in a <c>long[]</c>.
             <para/>
             An index of positions of zero's in the upper bits is also built.
             <para/>
             this implementation is based on this article:
             <para/>
             Sebastiano Vigna, "Quasi Succinct Indices", June 19, 2012, sections 3, 4 and 9.
             Retrieved from http://arxiv.org/pdf/1206.4300 .
            
             <para/>The articles originally describing the Elias-Fano representation are:
             <para/>Peter Elias, "Efficient storage and retrieval by content and address of static files",
             J. Assoc. Comput. Mach., 21(2):246â€"260, 1974.
             <para/>Robert M. Fano, "On the number of bits required to implement an associative memory",
              Memorandum 61, Computer Structures Group, Project MAC, MIT, Cambridge, Mass., 1971.
             <para/>
             @lucene.internal
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.EliasFanoEncoder.LOG2_INT64_SIZE">
            <summary>
            NOTE: This was LOG2_LONG_SIZE in Lucene.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.EliasFanoEncoder.DEFAULT_INDEX_INTERVAL">
            <summary>
            The default index interval for zero upper bits. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.EliasFanoEncoder.upperZeroBitPositionIndex">
            <summary>
            upperZeroBitPositionIndex[i] (filled using packValue) will contain the bit position
            just after the zero bit ((i+1) * indexInterval) in the upper bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoEncoder.#ctor(System.Int64,System.Int64,System.Int64)">
            <summary>
            Construct an Elias-Fano encoder.
            After construction, call <see cref="M:Lucene.Net.Util.Packed.EliasFanoEncoder.EncodeNext(System.Int64)"/> <paramref name="numValues"/> times to encode
            a non decreasing sequence of non negative numbers. 
            </summary>
            <param name="numValues"> The number of values that is to be encoded. </param>
            <param name="upperBound">  At least the highest value that will be encoded.
                           For space efficiency this should not exceed the power of two that equals
                           or is the first higher than the actual maximum.
                           <para/>When <c>numValues >= (upperBound/3)</c>
                           a <see cref="T:Lucene.Net.Util.FixedBitSet"/> will take less space. </param>
            <param name="indexInterval"> The number of high zero bits for which a single index entry is built.
                           The index will have at most <c>2 * numValues / indexInterval</c> entries
                           and each index entry will use at most <c>Ceil(Log2(3 * numValues))</c> bits,
                           see <see cref="T:Lucene.Net.Util.Packed.EliasFanoEncoder"/>. </param>
            <exception cref="T:System.ArgumentException"> when:
                    <list type="bullet">
                    <item><description><paramref name="numValues"/> is negative, or</description></item>
                    <item><description><paramref name="numValues"/> is non negative and <paramref name="upperBound"/> is negative, or</description></item>
                    <item><description>the low bits do not fit in a <c>long[]</c>:
                        <c>(L * numValues / 64) > System.Int32.MaxValue</c>, or</description></item>
                    <item><description>the high bits do not fit in a <c>long[]</c>:
                        <c>(2 * numValues / 64) > System.Int32.MaxValue</c>, or</description></item>
                    <item><description><c>indexInterval &lt; 2</c>,</description></item>
                    <item><description>the index bits do not fit in a <c>long[]</c>:
                        <c>(numValues / indexInterval * ceil(2log(3 * numValues)) / 64) > System.Int32.MaxValue</c>.</description></item>
                    </list> </exception>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoEncoder.#ctor(System.Int64,System.Int64)">
            <summary>
            Construct an Elias-Fano encoder using <see cref="F:Lucene.Net.Util.Packed.EliasFanoEncoder.DEFAULT_INDEX_INTERVAL"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoEncoder.NumInt64sForBits(System.Int64)">
            <summary>
            NOTE: This was numLongsForBits() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoEncoder.EncodeNext(System.Int64)">
            <summary>
            Call at most <see cref="F:Lucene.Net.Util.Packed.EliasFanoEncoder.numValues"/> times to encode a non decreasing sequence of non negative numbers. </summary>
            <param name="x"> The next number to be encoded. </param>
            <exception cref="T:System.InvalidOperationException"> when called more than <see cref="F:Lucene.Net.Util.Packed.EliasFanoEncoder.numValues"/> times. </exception>
            <exception cref="T:System.ArgumentException"> when:
                    <list type="bullet">
                    <item><description><paramref name="x"/> is smaller than an earlier encoded value, or</description></item>
                    <item><description><paramref name="x"/> is larger than <see cref="F:Lucene.Net.Util.Packed.EliasFanoEncoder.upperBound"/>.</description></item>
                    </list> </exception>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoEncoder.SufficientlySmallerThanBitSet(System.Int64,System.Int64)">
            <summary>
            Provide an indication that it is better to use an <see cref="T:Lucene.Net.Util.Packed.EliasFanoEncoder"/> than a <see cref="T:Lucene.Net.Util.FixedBitSet"/>
            to encode document identifiers.
            This indication is not precise and may change in the future.
            <para/>An <see cref="T:Lucene.Net.Util.Packed.EliasFanoEncoder"/> is favored when the size of the encoding by the <see cref="T:Lucene.Net.Util.Packed.EliasFanoEncoder"/>
            (including some space for its index) is at most about 5/6 of the size of the <see cref="T:Lucene.Net.Util.FixedBitSet"/>,
            this is the same as comparing estimates of the number of bits accessed by a pair of <see cref="T:Lucene.Net.Util.FixedBitSet"/>s and
            by a pair of non indexed <see cref="T:Lucene.Net.Util.Packed.EliasFanoDocIdSet"/>s when determining the intersections of the pairs.
            <para/>A bit set is preferred when <c>upperbound &lt;= 256</c>.
            <para/>It is assumed that <see cref="F:Lucene.Net.Util.Packed.EliasFanoEncoder.DEFAULT_INDEX_INTERVAL"/> is used. 
            </summary>
            <param name="numValues"> The number of document identifiers that is to be encoded. Should be non negative. </param>
            <param name="upperBound"> The maximum possible value for a document identifier. Should be at least <paramref name="numValues"/>. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoEncoder.GetDecoder">
            <summary>
            Returns an <see cref="T:Lucene.Net.Util.Packed.EliasFanoDecoder"/> to access the encoded values.
            Perform all calls to <see cref="M:Lucene.Net.Util.Packed.EliasFanoEncoder.EncodeNext(System.Int64)"/> before calling <see cref="M:Lucene.Net.Util.Packed.EliasFanoEncoder.GetDecoder"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoEncoder.LowerBits">
            <summary>
            Expert. The low bits. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoEncoder.UpperBits">
            <summary>
            Expert. The high bits. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoEncoder.IndexBits">
            <summary>
            Expert. The index bits. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.GrowableWriter">
            <summary>
            Implements <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Mutable"/>, but grows the
            bit count of the underlying packed ints on-demand.
            <para/>Beware that this class will accept to set negative values but in order
            to do this, it will grow the number of bits per value to 64.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.GrowableWriter.#ctor(System.Int32,System.Int32,System.Single)">
            <param name="startBitsPerValue">       the initial number of bits per value, may grow depending on the data </param>
            <param name="valueCount">              the number of values </param>
            <param name="acceptableOverheadRatio"> an acceptable overhead ratio </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer">
            <summary>
            Utility class to buffer signed longs in memory, which is optimized for the
            case where the sequence is monotonic, although it can encode any sequence of
            arbitrary longs. It only supports appending.
            <para/>
            NOTE: This was MonotonicAppendingLongBuffer in Lucene.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer.#ctor(System.Int32,System.Int32,System.Single)">
            <param name="initialPageCount">        The initial number of pages. </param>
            <param name="pageSize">                The size of a single page. </param>
            <param name="acceptableOverheadRatio"> An acceptable overhead ratio per value. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer.#ctor">
            <summary>
            Create an <see cref="T:Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer"/> with initialPageCount=16,
            pageSize=1024 and acceptableOverheadRatio=<see cref="F:Lucene.Net.Util.Packed.PackedInt32s.DEFAULT"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer.#ctor(System.Single)">
            <summary>
            Create an <see cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer"/> with initialPageCount=16,
            pageSize=1024.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.MonotonicBlockPackedReader">
            <summary>
            Provides random access to a stream written with
            <see cref="T:Lucene.Net.Util.Packed.MonotonicBlockPackedWriter"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicBlockPackedReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32,System.Int64,System.Boolean)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.MonotonicBlockPackedReader.Count">
            <summary>
            Returns the number of values.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicBlockPackedReader.RamBytesUsed">
            <summary>
            Returns the approximate RAM bytes used. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.MonotonicBlockPackedWriter">
            <summary>
            A writer for large monotonically increasing sequences of positive <see cref="T:System.Int64"/>s.
            <para/>
            The sequence is divided into fixed-size blocks and for each block, values
            are modeled after a linear function f: x &#8594; A &#215; x + B. The block
            encodes deltas from the expected values computed from this function using as
            few bits as possible. Each block has an overhead between 6 and 14 bytes.
            <para/>
            Format:
            <list type="bullet">
            <item><description>&lt;BLock&gt;<sup>BlockCount</sup></description></item>
            <item><description>BlockCount: &#8968; ValueCount / BlockSize &#8969;</description></item>
            <item><description>Block: &lt;Header, (Ints)&gt;</description></item>
            <item><description>Header: &lt;B, A, BitsPerValue&gt;</description></item>
            <item><description>B: the B from f: x &#8594; A &#215; x + B using a
                variable-length <see cref="T:System.Int64"/> (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>)</description></item>
            <item><description>A: the A from f: x &#8594; A &#215; x + B encoded using
                <see cref="M:J2N.BitConversion.SingleToInt32Bits(System.Single)"/> on
                4 bytes (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>)</description></item>
            <item><description>BitsPerValue: a variable-length <see cref="T:System.Int32"/> (<see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>)</description></item>
            <item><description>Ints: if BitsPerValue is <c>0</c>, then there is nothing to read and
                all values perfectly match the result of the function. Otherwise, these
                are the
                <a href="https://developers.google.com/protocol-buffers/docs/encoding#types">zigzag-encoded</a>
                packed (<see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>) deltas from the expected value (computed from
                the function) using exaclty BitsPerValue bits per value</description></item>
            </list> 
            <para/>
            @lucene.internal
            </summary>
            <seealso cref="T:Lucene.Net.Util.Packed.MonotonicBlockPackedReader"/>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicBlockPackedWriter.#ctor(Lucene.Net.Store.DataOutput,System.Int32)">
            <summary>
            Sole constructor. </summary>
            <param name="blockSize"> The number of values of a single block, must be a power of 2. </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Packed16ThreeBlocks">
            <summary>
            Packs integers into 3 shorts (48 bits per value).
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Packed64">
            <summary>
            Space optimized random access capable array of values with a fixed number of
            bits/value. Values are packed contiguously.
            <para/>
            The implementation strives to perform af fast as possible under the
            constraint of contiguous bits, by avoiding expensive operations. This comes
            at the cost of code clarity.
            <para/>
            Technical details: this implementation is a refinement of a non-branching
            version. The non-branching get and set methods meant that 2 or 4 atomics in
            the underlying array were always accessed, even for the cases where only
            1 or 2 were needed. Even with caching, this had a detrimental effect on
            performance.
            Related to this issue, the old implementation used lookup tables for shifts
            and masks, which also proved to be a bit slower than calculating the shifts
            and masks on the fly.
            See https://issues.apache.org/jira/browse/LUCENE-4062 for details.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.Packed64.blocks">
            <summary>
            Values are stores contiguously in the blocks array.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.Packed64.maskRight">
            <summary>
            A right-aligned mask of width BitsPerValue used by <see cref="M:Lucene.Net.Util.Packed.Packed64.Get(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.Packed64.bpvMinusBlockSize">
            <summary>
            Optimization: Saves one lookup in <see cref="M:Lucene.Net.Util.Packed.Packed64.Get(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.Packed64.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates an array with the internal structures adjusted for the given
            limits and initialized to 0. </summary>
            <param name="valueCount">   The number of elements. </param>
            <param name="bitsPerValue"> The number of bits available for any given value. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.Packed64.#ctor(System.Int32,Lucene.Net.Store.DataInput,System.Int32,System.Int32)">
            <summary>
            Creates an array with content retrieved from the given <see cref="T:Lucene.Net.Store.DataInput"/>. </summary>
            <param name="in">       A <see cref="T:Lucene.Net.Store.DataInput"/>, positioned at the start of Packed64-content. </param>
            <param name="valueCount">  The number of elements. </param>
            <param name="bitsPerValue"> The number of bits available for any given value. </param>
            <exception cref="T:System.IO.IOException"> If the values for the backing array could not
                                        be retrieved. </exception>
        </member>
        <member name="M:Lucene.Net.Util.Packed.Packed64.Get(System.Int32)">
            <param name="index"> The position of the value. </param>
            <returns> The value at the given index. </returns>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Packed64SingleBlock">
            <summary>
            This class is similar to <see cref="T:Lucene.Net.Util.Packed.Packed64"/> except that it trades space for
            speed by ensuring that a single block needs to be read/written in order to
            read/write a value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Packed8ThreeBlocks">
            <summary>
            Packs integers into 3 bytes (24 bits per value).
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedDataInput">
            <summary>
            A <see cref="T:Lucene.Net.Store.DataInput"/> wrapper to read unaligned, variable-length packed
            integers. This API is much slower than the <see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/> fixed-length
            API but can be convenient to save space. 
            <para/>
            @lucene.internal
            </summary>
            <seealso cref="T:Lucene.Net.Util.Packed.PackedDataOutput"/>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataInput.#ctor(Lucene.Net.Store.DataInput)">
            <summary>
            Create a new instance that wraps <paramref name="in"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataInput.ReadInt64(System.Int32)">
            <summary>
            Read the next <see cref="T:System.Int64"/> using exactly <paramref name="bitsPerValue"/> bits.
            <para/>
            NOTE: This was readLong() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataInput.SkipToNextByte">
            <summary>
            If there are pending bits (at most 7), they will be ignored and the next
            value will be read starting at the next byte.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedDataOutput">
            <summary>
            A <see cref="T:Lucene.Net.Store.DataOutput"/> wrapper to write unaligned, variable-length packed
            integers.
            <para/>
            @lucene.internal
            </summary>
            <seealso cref="T:Lucene.Net.Util.Packed.PackedDataInput"/>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataOutput.#ctor(Lucene.Net.Store.DataOutput)">
            <summary>
            Create a new instance that wraps <paramref name="out"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataOutput.WriteInt64(System.Int64,System.Int32)">
            <summary>
            Write a value using exactly <paramref name="bitsPerValue"/> bits.
            <para/>
            NOTE: This was writeLong() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataOutput.Flush">
            <summary>
            Flush pending bits to the underlying <see cref="T:Lucene.Net.Store.DataOutput"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s">
            <summary>
            Simplistic compression for array of unsigned long values.
            Each value is >= 0 and &lt;= a specified maximum value.  The
            values are stored as packed ints, with each value
            consuming a fixed number of bits.
            <para/>
            NOTE: This was PackedInts in Lucene.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInt32s.FASTEST">
            <summary>
            At most 700% memory overhead, always select a direct implementation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInt32s.FAST">
            <summary>
            At most 50% memory overhead, always select a reasonably fast implementation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInt32s.DEFAULT">
            <summary>
            At most 20% memory overhead.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInt32s.COMPACT">
            <summary>
            No memory overhead at all, but the returned implementation may be slow.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInt32s.DEFAULT_BUFFER_SIZE">
            <summary>
            Default amount of memory to use for bulk operations.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.CheckVersion(System.Int32)">
            <summary>
            Check the validity of a version number.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.PackedFormat.ByteCount(System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes how many <see cref="T:System.Byte"/> blocks are needed to store <paramref name="valueCount"/>
            values of size <paramref name="bitsPerValue"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.PackedSingleBlockFormat.Int64Count(System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes how many <see cref="T:System.Int64"/> blocks are needed to store <paramref name="valueCount"/>
            values of size <paramref name="bitsPerValue"/>.
            <para/>
            NOTE: This was longCount() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.PackedSingleBlockFormat.IsSupported(System.Int32)">
            <summary>
            Tests whether the provided number of bits per value is supported by the
            format.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.PackedSingleBlockFormat.OverheadPerValue(System.Int32)">
            <summary>
            Returns the overhead per value, in bits.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.Format">
            <summary>
            A format to write packed <see cref="T:System.Int32"/>s.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInt32s.Format.PACKED">
            <summary>
            Compact format, all bits are written contiguously.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInt32s.Format.PACKED_SINGLE_BLOCK">
            <summary>
            A format that may insert padding bits to improve encoding and decoding
            speed. Since this format doesn't support all possible bits per value, you
            should never use it directly, but rather use
            <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.FastestFormatAndBits(System.Int32,System.Int32,System.Single)"/> to find the
            format that best suits your needs.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Format.ById(System.Int32)">
            <summary>
            Get a format according to its ID.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Format.Id">
            <summary>
            Returns the ID of the format.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Format.ByteCount(System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes how many <see cref="T:System.Byte"/> blocks are needed to store <paramref name="valueCount"/>
            values of size <paramref name="bitsPerValue"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Format.Int64Count(System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes how many <see cref="T:System.Int64"/> blocks are needed to store <paramref name="valueCount"/>
            values of size <paramref name="bitsPerValue"/>.
            <para/>
            NOTE: This was longCount() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Format.IsSupported(System.Int32)">
            <summary>
            Tests whether the provided number of bits per value is supported by the
            format.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Format.OverheadPerValue(System.Int32)">
            <summary>
            Returns the overhead per value, in bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Format.OverheadRatio(System.Int32)">
            <summary>
            Returns the overhead ratio (<c>overhead per value / bits per value</c>).
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.FormatAndBits">
            <summary>
            Simple class that holds a format and a number of bits per value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.FastestFormatAndBits(System.Int32,System.Int32,System.Single)">
            <summary>
            Try to find the <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Format"/> and number of bits per value that would
            restore from disk the fastest reader whose overhead is less than
            <paramref name="acceptableOverheadRatio"/>.
            <para/>
            The <paramref name="acceptableOverheadRatio"/> parameter makes sense for
            random-access <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/>s. In case you only plan to perform
            sequential access on this stream later on, you should probably use
            <see cref="F:Lucene.Net.Util.Packed.PackedInt32s.COMPACT"/>.
            <para/>
            If you don't know how many values you are going to write, use
            <c><paramref name="valueCount"/> = -1</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.IDecoder">
            <summary>
            A decoder for packed integers.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Int64BlockCount">
            <summary>
            The minimum number of <see cref="T:System.Int64"/> blocks to encode in a single iteration, when
            using long encoding.
            <para/>
            NOTE: This was longBlockCount() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Int64ValueCount">
            <summary>
            The number of values that can be stored in <see cref="P:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Int64BlockCount"/> <see cref="T:System.Int64"/>
            blocks.
            <para/>
            NOTE: This was longValueCount() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.ByteBlockCount">
            <summary>
            The minimum number of <see cref="T:System.Byte"/> blocks to encode in a single iteration, when
            using byte encoding.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.ByteValueCount">
            <summary>
            The number of values that can be stored in <see cref="P:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.ByteBlockCount"/> <see cref="T:System.Byte"/>
            blocks.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Decode(System.Int64[],System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Read <c>iterations * BlockCount</c> blocks from <paramref name="blocks"/>,
            decode them and write <c>iterations * ValueCount</c> values into
            <paramref name="values"/>.
            </summary>
            <param name="blocks">       The long blocks that hold packed integer values. </param>
            <param name="blocksOffset"> The offset where to start reading blocks. </param>
            <param name="values">       The values buffer. </param>
            <param name="valuesOffset"> The offset where to start writing values. </param>
            <param name="iterations">   Controls how much data to decode. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Decode(System.Byte[],System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Read <c>8 * iterations * BlockCount</c> blocks from <paramref name="blocks"/>,
            decode them and write <c>iterations * ValueCount</c> values into
            <paramref name="values"/>.
            </summary>
            <param name="blocks">       The long blocks that hold packed integer values. </param>
            <param name="blocksOffset"> The offset where to start reading blocks. </param>
            <param name="values">       The values buffer. </param>
            <param name="valuesOffset"> The offset where to start writing values. </param>
            <param name="iterations">   Controls how much data to decode. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Decode(System.Int64[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Read <c>iterations * BlockCount</c> blocks from <paramref name="blocks"/>,
            decode them and write <c>iterations * ValueCount</c> values into
            <paramref name="values"/>.
            </summary>
            <param name="blocks">       The long blocks that hold packed integer values. </param>
            <param name="blocksOffset"> The offset where to start reading blocks. </param>
            <param name="values">       The values buffer. </param>
            <param name="valuesOffset"> The offset where to start writing values. </param>
            <param name="iterations">   Controls how much data to decode. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Decode(System.Byte[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Read <c>8 * iterations * BlockCount</c> blocks from <paramref name="blocks"/>,
            decode them and write <c>iterations * ValueCount</c> values into
            <paramref name="values"/>.
            </summary>
            <param name="blocks">       The long blocks that hold packed integer values. </param>
            <param name="blocksOffset"> The offset where to start reading blocks. </param>
            <param name="values">       The values buffer. </param>
            <param name="valuesOffset"> The offset where to start writing values. </param>
            <param name="iterations">   Controls how much data to decode. </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.IEncoder">
            <summary>
            An encoder for packed integers.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Int64BlockCount">
            <summary>
            The minimum number of long blocks to encode in a single iteration, when
            using long encoding.
            <para/>
            NOTE: This was longBlockCount() in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Int64ValueCount">
            <summary>
            The number of values that can be stored in <see cref="P:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Int64BlockCount"/> long
            blocks.
            <para/>
            NOTE: This was longValueCount() in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.ByteBlockCount">
            <summary>
            The minimum number of byte blocks to encode in a single iteration, when
            using byte encoding.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.ByteValueCount">
            <summary>
            The number of values that can be stored in <see cref="P:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.ByteBlockCount"/> byte
            blocks.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Encode(System.Int64[],System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Read <c>iterations * ValueCount</c> values from <paramref name="values"/>,
            encode them and write <c>iterations * BlockCount</c> blocks into
            <paramref name="blocks"/>.
            </summary>
            <param name="blocks">       The long blocks that hold packed integer values. </param>
            <param name="blocksOffset"> The offset where to start writing blocks. </param>
            <param name="values">       The values buffer. </param>
            <param name="valuesOffset"> The offset where to start reading values. </param>
            <param name="iterations">   Controls how much data to encode. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Encode(System.Int64[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read <c>iterations * ValueCount</c> values from <paramref name="values"/>,
            encode them and write <c>8 * iterations * BlockCount</c> blocks into
            <paramref name="blocks"/>.
            </summary>
            <param name="blocks">       The long blocks that hold packed integer values. </param>
            <param name="blocksOffset"> The offset where to start writing blocks. </param>
            <param name="values">       The values buffer. </param>
            <param name="valuesOffset"> The offset where to start reading values. </param>
            <param name="iterations">   Controls how much data to encode. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Encode(System.Int32[],System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Read <c>iterations * ValueCount</c> values from <paramref name="values"/>,
            encode them and write <c>iterations * BlockCount</c> blocks into
            <paramref name="blocks"/>.
            </summary>
            <param name="blocks">       The long blocks that hold packed integer values. </param>
            <param name="blocksOffset"> The offset where to start writing blocks. </param>
            <param name="values">       The values buffer. </param>
            <param name="valuesOffset"> The offset where to start reading values. </param>
            <param name="iterations">   Controls how much data to encode. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Encode(System.Int32[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read <c>iterations * ValueCount</c> values from <paramref name="values"/>,
            encode them and write <c>8 * iterations * BlockCount</c> blocks into
            <paramref name="blocks"/>.
            </summary>
            <param name="blocks">       The long blocks that hold packed integer values. </param>
            <param name="blocksOffset"> The offset where to start writing blocks. </param>
            <param name="values">       The values buffer. </param>
            <param name="valuesOffset"> The offset where to start reading values. </param>
            <param name="iterations">   Controls how much data to encode. </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.Reader">
            <summary>
            A read-only random access array of positive integers.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Reader.Get(System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Bulk get: read at least one and at most <paramref name="len"/> longs starting
            from <paramref name="index"/> into <c>arr[off:off+len]</c> and return
            the actual number of values that have been read.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Reader.BitsPerValue">
            <returns> The number of bits used to store any given value.
                    Note: this does not imply that memory usage is
                    <c>bitsPerValue * #values</c> as implementations are free to
                    use non-space-optimal packing of bits. </returns>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Reader.Count">
            <summary>
            The number of values.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Reader.RamBytesUsed">
            <summary>
            Return the in-memory size in bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Reader.GetArray">
            <summary>
            Expert: if the bit-width of this reader matches one of
            .NET's native types, returns the underlying array
            (ie, byte[], short[], int[], long[]); else, returns
            <c>null</c>.  Note that when accessing the array you must
            upgrade the type (bitwise AND with all ones), to
            interpret the full value as unsigned.  Ie,
            bytes[idx]&amp;0xFF, shorts[idx]&amp;0xFFFF, etc.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Reader.HasArray">
            <summary>
            Returns <c>true</c> if this implementation is backed by a
            native .NET array.
            </summary>
            <seealso cref="M:Lucene.Net.Util.Packed.PackedInt32s.Reader.GetArray"/>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator">
            <summary>
            Run-once iterator interface, to decode previously saved <see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator.Next">
            <summary>
            Returns next value. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator.Next(System.Int32)">
            <summary>
            Returns at least 1 and at most <paramref name="count"/> next values,
            the returned ref MUST NOT be modified.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator.BitsPerValue">
            <summary>
            Returns number of bits per value. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator.Count">
            <summary>
            Returns number of values.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator.Ord">
            <summary>
            Returns the current position. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.Mutable">
            <summary>
            A packed integer array that can be modified.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Mutable.Set(System.Int32,System.Int64)">
            <summary>
            Set the value at the given index in the array. </summary>
            <param name="index"> Where the value should be positioned. </param>
            <param name="value"> A value conforming to the constraints set by the array. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Mutable.Set(System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Bulk set: set at least one and at most <paramref name="len"/> longs starting
            at <paramref name="off"/> in <paramref name="arr"/> into this mutable, starting at
            <paramref name="index"/>. Returns the actual number of values that have been
            set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Mutable.Fill(System.Int32,System.Int32,System.Int64)">
            <summary>
            Fill the mutable from <paramref name="fromIndex"/> (inclusive) to
            <paramref name="toIndex"/> (exclusive) with <paramref name="val"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Mutable.Clear">
            <summary>
            Sets all values to 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Mutable.Save(Lucene.Net.Store.DataOutput)">
            <summary>
            Save this mutable into <paramref name="out"/>. Instantiating a reader from
            the generated data will return a reader with the same number of bits
            per value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Mutable.Format">
            <summary>
            The underlying format. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.ReaderImpl">
            <summary>
            A simple base for <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/>s that keeps track of valueCount and bitsPerValue.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.NullReader">
            <summary>
            A <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/> which has all its values equal to 0 (bitsPerValue = 0). </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.NullReader.#ctor(System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.Writer">
            <summary>
            A write-once Writer.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Writer.Format">
            <summary>
            The format used to serialize values. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Writer.Add(System.Int64)">
            <summary>
            Add a value to the stream. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Writer.BitsPerValue">
            <summary>
            The number of bits per value. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Writer.Finish">
            <summary>
            Perform end-of-stream operations. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Writer.Ord">
            <summary>
            Returns the current ord in the stream (number of values that have been
            written so far minus one).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetDecoder(Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32)">
            <summary>
            Get a <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.IDecoder"/>.
            </summary>
            <param name="format">         The format used to store packed <see cref="T:System.Int32"/>s. </param>
            <param name="version">        The compatibility version. </param>
            <param name="bitsPerValue">   The number of bits per value. </param>
            <returns> A decoder. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetEncoder(Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32)">
            <summary>
            Get an <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.IEncoder"/>.
            </summary>
            <param name="format">         The format used to store packed <see cref="T:System.Int32"/>s. </param>
            <param name="version">        The compatibility version. </param>
            <param name="bitsPerValue">   The number of bits per value. </param>
            <returns> An encoder. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetReaderNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expert: Restore a <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/> from a stream without reading metadata at
            the beginning of the stream. This method is useful to restore data from
            streams which have been created using
            <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetWriterNoHeader(Lucene.Net.Store.DataOutput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="in">           The stream to read data from, positioned at the beginning of the packed values. </param>
            <param name="format">       The format used to serialize. </param>
            <param name="version">      The version used to serialize the data. </param>
            <param name="valueCount">   How many values the stream holds. </param>
            <param name="bitsPerValue"> The number of bits per value. </param>
            <returns>             A <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/>. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
            <seealso cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetWriterNoHeader(Lucene.Net.Store.DataOutput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetReaderNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInt32s.Header)">
            <summary>
            Expert: Restore a <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/> from a stream without reading metadata at
            the beginning of the stream. this method is useful to restore data when
            metadata has been previously read using <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.ReadHeader(Lucene.Net.Store.DataInput)"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="in">           The stream to read data from, positioned at the beginning of the packed values. </param>
            <param name="header">       Metadata result from <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.ReadHeader(Lucene.Net.Store.DataInput)"/>. </param>
            <returns>             A <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/>. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
            <seealso cref="M:Lucene.Net.Util.Packed.PackedInt32s.ReadHeader(Lucene.Net.Store.DataInput)"/>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetReader(Lucene.Net.Store.DataInput)">
            <summary>
            Restore a <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/> from a stream.
            <para/>
            @lucene.internal
            </summary>
            <param name="in">           The stream to read data from. </param>
            <returns>             A <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/>. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetReaderIteratorNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expert: Restore a <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator"/> from a stream without reading
            metadata at the beginning of the stream. This method is useful to restore
            data from streams which have been created using
            <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetWriterNoHeader(Lucene.Net.Store.DataOutput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="in">           The stream to read data from, positioned at the beginning of the packed values. </param>
            <param name="format">       The format used to serialize. </param>
            <param name="version">      The version used to serialize the data. </param>
            <param name="valueCount">   How many values the stream holds. </param>
            <param name="bitsPerValue"> the number of bits per value. </param>
            <param name="mem">          How much memory the iterator is allowed to use to read-ahead (likely to speed up iteration). </param>
            <returns>             A <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator"/>. </returns>
            <seealso cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetWriterNoHeader(Lucene.Net.Store.DataOutput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetReaderIterator(Lucene.Net.Store.DataInput,System.Int32)">
            <summary>
            Retrieve <see cref="T:Lucene.Net.Util.Packed.PackedInt32s"/> as a <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator"/>. 
            <para/>
            @lucene.internal
            </summary>
            <param name="in"> Positioned at the beginning of a stored packed int structure. </param>
            <param name="mem"> How much memory the iterator is allowed to use to read-ahead (likely to speed up iteration). </param>
            <returns> An iterator to access the values. </returns>
            <exception cref="T:System.IO.IOException"> If the structure could not be retrieved. </exception>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetDirectReaderNoHeader(Lucene.Net.Store.IndexInput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expert: Construct a direct <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/> from a stream without reading
            metadata at the beginning of the stream. This method is useful to restore
            data from streams which have been created using
            <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetWriterNoHeader(Lucene.Net.Store.DataOutput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)"/>.
            <para/>
            The returned reader will have very little memory overhead, but every call
            to <see cref="M:Lucene.Net.Index.NumericDocValues.Get(System.Int32)"/> is likely to perform a disk seek.
            <para/>
            @lucene.internal
            </summary>
            <param name="in">           The stream to read data from. </param>
            <param name="format">       The format used to serialize. </param>
            <param name="version">      The version used to serialize the data. </param>
            <param name="valueCount">   How many values the stream holds. </param>
            <param name="bitsPerValue"> The number of bits per value. </param>
            <returns> A direct <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetDirectReaderNoHeader(Lucene.Net.Store.IndexInput,Lucene.Net.Util.Packed.PackedInt32s.Header)">
            <summary>
            Expert: Construct a direct <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/> from an <see cref="T:Lucene.Net.Store.IndexInput"/>
            without reading metadata at the beginning of the stream. this method is
            useful to restore data when metadata has been previously read using
            <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.ReadHeader(Lucene.Net.Store.DataInput)"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="in">           The stream to read data from, positioned at the beginning of the packed values. </param>
            <param name="header">       Metadata result from <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.ReadHeader(Lucene.Net.Store.DataInput)"/>. </param>
            <returns>             A <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/>. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
            <seealso cref="M:Lucene.Net.Util.Packed.PackedInt32s.ReadHeader(Lucene.Net.Store.DataInput)"/>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetDirectReader(Lucene.Net.Store.IndexInput)">
            <summary>
            Construct a direct <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/> from an <see cref="T:Lucene.Net.Store.IndexInput"/>. this method
            is useful to restore data from streams which have been created using
            <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetWriter(Lucene.Net.Store.DataOutput,System.Int32,System.Int32,System.Single)"/>.
            <para/>
            The returned reader will have very little memory overhead, but every call
            to <see cref="M:Lucene.Net.Index.NumericDocValues.Get(System.Int32)"/> is likely to perform a disk seek.
            <para/>
            @lucene.internal
            </summary>
            <param name="in">           The stream to read data from. </param>
            <returns> A direct <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/>. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetMutable(System.Int32,System.Int32,System.Single)">
            <summary>
            Create a packed integer array with the given amount of values initialized
            to 0. The <paramref name="valueCount"/> and the <paramref name="bitsPerValue"/> cannot be changed after creation.
            All Mutables known by this factory are kept fully in RAM.
            <para/>
            Positive values of <paramref name="acceptableOverheadRatio"/> will trade space
            for speed by selecting a faster but potentially less memory-efficient
            implementation. An <paramref name="acceptableOverheadRatio"/> of
            <see cref="F:Lucene.Net.Util.Packed.PackedInt32s.COMPACT"/> will make sure that the most memory-efficient
            implementation is selected whereas <see cref="F:Lucene.Net.Util.Packed.PackedInt32s.FASTEST"/> will make sure
            that the fastest implementation is selected.
            <para/>
            @lucene.internal
            </summary>
            <param name="valueCount">   The number of elements. </param>
            <param name="bitsPerValue"> The number of bits available for any given value. </param>
            <param name="acceptableOverheadRatio"> An acceptable overhead
                   ratio per value. </param>
            <returns> A mutable packed integer array. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetMutable(System.Int32,System.Int32,Lucene.Net.Util.Packed.PackedInt32s.Format)">
            <summary>
            Same as <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetMutable(System.Int32,System.Int32,System.Single)"/> with a pre-computed number
            of bits per value and format.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetWriterNoHeader(Lucene.Net.Store.DataOutput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expert: Create a packed integer array writer for the given output, format,
            value count, and number of bits per value.
            <para/>
            The resulting stream will be long-aligned. this means that depending on
            the format which is used, up to 63 bits will be wasted. An easy way to
            make sure that no space is lost is to always use a <paramref name="valueCount"/>
            that is a multiple of 64.
            <para/>
            This method does not write any metadata to the stream, meaning that it is
            your responsibility to store it somewhere else in order to be able to
            recover data from the stream later on:
            <list type="bullet">
              <item><description><paramref name="format"/> (using <see cref="P:Lucene.Net.Util.Packed.PackedInt32s.Format.Id"/>),</description></item>
              <item><description><paramref name="valueCount"/>,</description></item>
              <item><description><paramref name="bitsPerValue"/>,</description></item>
              <item><description><see cref="F:Lucene.Net.Util.Packed.PackedInt32s.VERSION_CURRENT"/>.</description></item>
            </list>
            <para/>
            It is possible to start writing values without knowing how many of them you
            are actually going to write. To do this, just pass <c>-1</c> as
            <paramref name="valueCount"/>. On the other hand, for any positive value of
            <paramref name="valueCount"/>, the returned writer will make sure that you don't
            write more values than expected and pad the end of stream with zeros in
            case you have written less than <paramref name="valueCount"/> when calling
            <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.Writer.Finish"/>.
            <para/>
            The <paramref name="mem"/> parameter lets you control how much memory can be used
            to buffer changes in memory before flushing to disk. High values of
            <paramref name="mem"/> are likely to improve throughput. On the other hand, if
            speed is not that important to you, a value of <c>0</c> will use as
            little memory as possible and should already offer reasonable throughput.
            <para/>
            @lucene.internal
            </summary>
            <param name="out">          The data output. </param>
            <param name="format">       The format to use to serialize the values. </param>
            <param name="valueCount">   The number of values. </param>
            <param name="bitsPerValue"> The number of bits per value. </param>
            <param name="mem">          How much memory (in bytes) can be used to speed up serialization. </param>
            <returns>             A <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Writer"/>. </returns>
            <seealso cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetReaderIteratorNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetReaderNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetWriter(Lucene.Net.Store.DataOutput,System.Int32,System.Int32,System.Single)">
            <summary>
            Create a packed integer array writer for the given output, format, value
            count, and number of bits per value.
            <para/>
            The resulting stream will be long-aligned. this means that depending on
            the format which is used under the hoods, up to 63 bits will be wasted.
            An easy way to make sure that no space is lost is to always use a
            <paramref name="valueCount"/> that is a multiple of 64.
            <para/>
            This method writes metadata to the stream, so that the resulting stream is
            sufficient to restore a <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/> from it. You don't need to track
            <paramref name="valueCount"/> or <paramref name="bitsPerValue"/> by yourself. In case
            this is a problem, you should probably look at
            <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetWriterNoHeader(Lucene.Net.Store.DataOutput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)"/>.
            <para/>
            The <paramref name="acceptableOverheadRatio"/> parameter controls how
            readers that will be restored from this stream trade space
            for speed by selecting a faster but potentially less memory-efficient
            implementation. An <paramref name="acceptableOverheadRatio"/> of
            <see cref="F:Lucene.Net.Util.Packed.PackedInt32s.COMPACT"/> will make sure that the most memory-efficient
            implementation is selected whereas <see cref="F:Lucene.Net.Util.Packed.PackedInt32s.FASTEST"/> will make sure
            that the fastest implementation is selected. In case you are only interested
            in reading this stream sequentially later on, you should probably use
            <see cref="F:Lucene.Net.Util.Packed.PackedInt32s.COMPACT"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="out">          The data output. </param>
            <param name="valueCount">   The number of values. </param>
            <param name="bitsPerValue"> The number of bits per value. </param>
            <param name="acceptableOverheadRatio"> An acceptable overhead ratio per value. </param>
            <returns>             A <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Writer"/>. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.BitsRequired(System.Int64)">
            <summary>
            Returns how many bits are required to hold values up
            to and including <paramref name="maxValue"/>. 
            <para/>
            @lucene.internal
            </summary>
            <param name="maxValue"> The maximum value that should be representable. </param>
            <returns> The amount of bits needed to represent values from 0 to <paramref name="maxValue"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.MaxValue(System.Int32)">
            <summary>
            Calculates the maximum unsigned long that can be expressed with the given
            number of bits. 
            <para/>
            @lucene.internal
            </summary>
            <param name="bitsPerValue"> The number of bits available for any given value. </param>
            <returns> The maximum value for the given bits. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Copy(Lucene.Net.Util.Packed.PackedInt32s.Reader,System.Int32,Lucene.Net.Util.Packed.PackedInt32s.Mutable,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy <c>src[srcPos:srcPos+len]</c> into
            <c>dest[destPos:destPos+len]</c> using at most <paramref name="mem"/>
            bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Copy(Lucene.Net.Util.Packed.PackedInt32s.Reader,System.Int32,Lucene.Net.Util.Packed.PackedInt32s.Mutable,System.Int32,System.Int32,System.Int64[])">
            <summary>
            Same as <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.Copy(Lucene.Net.Util.Packed.PackedInt32s.Reader,System.Int32,Lucene.Net.Util.Packed.PackedInt32s.Mutable,System.Int32,System.Int32,System.Int32)"/> but using a pre-allocated buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.ReadHeader(Lucene.Net.Store.DataInput)">
            <summary>
            Expert: reads only the metadata from a stream. This is useful to later
            restore a stream or open a direct reader via
            <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetReaderNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInt32s.Header)"/>
            or <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetDirectReaderNoHeader(Lucene.Net.Store.IndexInput,Lucene.Net.Util.Packed.PackedInt32s.Header)"/>. </summary>
            <param name="in"> The stream to read data. </param>
            <returns>   Packed integer metadata. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
            <seealso cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetReaderNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInt32s.Header)"/>
            <seealso cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetDirectReaderNoHeader(Lucene.Net.Store.IndexInput,Lucene.Net.Util.Packed.PackedInt32s.Header)"/>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.Header">
            <summary>
            Header identifying the structure of a packed integer array. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.CheckBlockSize(System.Int32,System.Int32,System.Int32)">
            <summary>
            Check that the block size is a power of 2, in the right bounds, and return
            its log in base 2.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.NumBlocks(System.Int64,System.Int32)">
            <summary>
            Return the number of blocks required to store <paramref name="size"/> values on
            <paramref name="blockSize"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PagedGrowableWriter">
            <summary>
            A <see cref="T:Lucene.Net.Util.Packed.PagedGrowableWriter"/>. This class slices data into fixed-size blocks
            which have independent numbers of bits per value and grow on-demand.
            <para/>
            You should use this class instead of the <see cref="T:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer"/> related ones only when
            you need random write-access. Otherwise this class will likely be slower and
            less memory-efficient.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PagedGrowableWriter.#ctor(System.Int64,System.Int32,System.Int32,System.Single)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Util.Packed.PagedGrowableWriter"/> instance.
            </summary>
            <param name="size"> The number of values to store. </param>
            <param name="pageSize"> The number of values per page. </param>
            <param name="startBitsPerValue"> The initial number of bits per value. </param>
            <param name="acceptableOverheadRatio"> An acceptable overhead ratio. </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PagedMutable">
            <summary>
            A <see cref="T:Lucene.Net.Util.Packed.PagedMutable"/>. This class slices data into fixed-size blocks
            which have the same number of bits per value. It can be a useful replacement
            for <see cref="T:Lucene.Net.Util.Packed.PackedInt32s.Mutable"/> to store more than 2B values.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PagedMutable.#ctor(System.Int64,System.Int32,System.Int32,System.Single)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Util.Packed.PagedMutable"/> instance.
            </summary>
            <param name="size"> The number of values to store. </param>
            <param name="pageSize"> The number of values per page. </param>
            <param name="bitsPerValue"> The number of bits per value. </param>
            <param name="acceptableOverheadRatio"> An acceptable overhead ratio. </param>
        </member>
        <member name="T:Lucene.Net.Util.PagedBytes">
            <summary>
            Represents a logical <see cref="T:byte[]"/> as a series of pages.  You
            can write-once into the logical <see cref="T:byte[]"/> (append only),
            using copy, and then retrieve slices (<see cref="T:Lucene.Net.Util.BytesRef"/>) into it
            using fill.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.PagedBytes.Reader">
            <summary>
            Provides methods to read <see cref="T:Lucene.Net.Util.BytesRef"/>s from a frozen
            <see cref="T:Lucene.Net.Util.PagedBytes"/>.
            </summary>
            <seealso cref="M:Lucene.Net.Util.PagedBytes.Freeze(System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.Reader.FillSlice(Lucene.Net.Util.BytesRef,System.Int64,System.Int32)">
            <summary>
            Gets a slice out of <see cref="T:Lucene.Net.Util.PagedBytes"/> starting at <paramref name="start"/> with a
            given length. If the slice spans across a block border this method will
            allocate sufficient resources and copy the paged data.
            <para>
            Slices spanning more than two blocks are not supported.
            </para>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.Reader.Fill(Lucene.Net.Util.BytesRef,System.Int64)">
            <summary>
            Reads length as 1 or 2 byte vInt prefix, starting at <paramref name="start"/>.
            <para>
            <b>Note:</b> this method does not support slices spanning across block
            borders.
            </para>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.Reader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.#ctor(System.Int32)">
            <summary>
            1&lt;&lt;blockBits must be bigger than biggest single
            <see cref="T:Lucene.Net.Util.BytesRef"/> slice that will be pulled.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.Copy(Lucene.Net.Store.IndexInput,System.Int64)">
            <summary>
            Read this many bytes from <paramref name="in"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.Copy(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Copy <see cref="T:Lucene.Net.Util.BytesRef"/> in, setting <see cref="T:Lucene.Net.Util.BytesRef"/> out to the result.
            Do not use this if you will use <c>Freeze(true)</c>.
            This only supports <c>bytes.Length &lt;= blockSize</c>/
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.Freeze(System.Boolean)">
            <summary>
            Commits final <see cref="T:byte[]"/>, trimming it if necessary and if <paramref name="trim"/>=true. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.RamBytesUsed">
            <summary>
            Return approx RAM usage in bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(Lucene.Net.Util.BytesRef)">
            <summary>
            Copy bytes in, writing the length as a 1 or 2 byte
            vInt prefix.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.PagedBytesDataInput.GetPosition">
            <summary>
            Returns the current byte position. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.PagedBytesDataInput.SetPosition(System.Int64)">
            <summary>
            Seek to a position previously obtained from <see cref="M:Lucene.Net.Util.PagedBytes.PagedBytesDataInput.GetPosition"/>.
            </summary>
            <param name="position"></param>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.PagedBytesDataOutput.GetPosition">
            <summary>
            Return the current byte position. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.GetDataInput">
            <summary>
            Returns a <see cref="T:Lucene.Net.Store.DataInput"/> to read values from this
            <see cref="T:Lucene.Net.Util.PagedBytes"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.GetDataOutput">
            <summary>
            Returns a <see cref="T:Lucene.Net.Store.DataOutput"/> that you may use to write into
            this <see cref="T:Lucene.Net.Util.PagedBytes"/> instance.  If you do this, you should
            not call the other writing methods (eg, copy);
            results are undefined.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.PForDeltaDocIdSet">
            <summary>
            <see cref="T:Lucene.Net.Search.DocIdSet"/> implementation based on pfor-delta encoding.
            <para>This implementation is inspired from LinkedIn's Kamikaze
            (http://data.linkedin.com/opensource/kamikaze) and Daniel Lemire's JavaFastPFOR
            (https://github.com/lemire/JavaFastPFOR).</para>
            <para>On the contrary to the original PFOR paper, exceptions are encoded with
            FOR instead of Simple16.</para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.PForDeltaDocIdSet.Builder">
            <summary>
            A builder for <see cref="T:Lucene.Net.Util.PForDeltaDocIdSet"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.SetIndexInterval(System.Int32)">
            <summary>
            Set the index interval. Every <paramref name="indexInterval"/>-th block will
            be stored in the index. Set to <see cref="F:System.Int32.MaxValue"/> to disable indexing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.Add(System.Int32)">
            <summary>
            Add a document to this builder. Documents must be added in order. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.Add(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Convenience method to add the content of a <see cref="T:Lucene.Net.Search.DocIdSetIterator"/> to this builder. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.Build">
            <summary>
            Build the <see cref="T:Lucene.Net.Util.PForDeltaDocIdSet"/> instance. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Cardinality">
            <summary>
            Return the number of documents in this <see cref="T:Lucene.Net.Search.DocIdSet"/> in constant time. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.RamBytesUsed">
            <summary>
            Return the memory usage of this instance. </summary>
        </member>
        <member name="T:Lucene.Net.Util.PrintStreamInfoStream">
            <summary>
            LUCENENET specific stub to assist with migration to <see cref="T:Lucene.Net.Util.TextWriterInfoStream"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.TextWriterInfoStream">
            <summary>
            <see cref="T:Lucene.Net.Util.InfoStream"/> implementation over a <see cref="T:System.IO.TextWriter"/>
            such as <see cref="P:System.Console.Out"/>.
            <para/>
            NOTE: This is analogous to PrintStreamInfoStream in Lucene.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.PriorityQueue`1">
             <summary>
             A <see cref="T:Lucene.Net.Util.PriorityQueue`1"/> maintains a partial ordering of its elements such that the
             element with least priority can always be found in constant time. Put()'s and Pop()'s
             require log(size) time.
            
             <para/><b>NOTE</b>: this class will pre-allocate a full array of
             length <c>maxSize+1</c> if instantiated via the
             <see cref="M:Lucene.Net.Util.PriorityQueue`1.#ctor(System.Int32,System.Boolean)"/> constructor with
             <c>prepopulate</c> set to <c>true</c>. That maximum
             size can grow as we insert elements over the time.
             <para/>
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.LessThan(`0,`0)">
            <summary>
            Determines the ordering of objects in this priority queue.  Subclasses
            must define this one method. </summary>
            <returns> <c>true</c> if parameter <paramref name="a"/> is less than parameter <paramref name="b"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.GetSentinelObject">
             <summary>
             This method can be overridden by extending classes to return a sentinel
             object which will be used by the <see cref="M:Lucene.Net.Util.PriorityQueue`1.#ctor(System.Int32,System.Boolean)"/>
             constructor to fill the queue, so that the code which uses that queue can always
             assume it's full and only change the top without attempting to insert any new
             object.
             <para/>
             Those sentinel values should always compare worse than any non-sentinel
             value (i.e., <see cref="M:Lucene.Net.Util.PriorityQueue`1.LessThan(`0,`0)"/> should always favor the
             non-sentinel values).
             <para/>
             By default, this method returns <c>false</c>, which means the queue will not be
             filled with sentinel values. Otherwise, the value returned will be used to
             pre-populate the queue. Adds sentinel values to the queue.
             <para/>
             If this method is extended to return a non-null value, then the following
             usage pattern is recommended:
            
             <code>
             // extends GetSentinelObject() to return a non-null value.
             PriorityQueue&lt;MyObject&gt; pq = new MyQueue&lt;MyObject&gt;(numHits);
             // save the 'top' element, which is guaranteed to not be null.
             MyObject pqTop = pq.Top;
             &lt;...&gt;
             // now in order to add a new element, which is 'better' than top (after
             // you've verified it is better), it is as simple as:
             pqTop.Change().
             pqTop = pq.UpdateTop();
             </code>
             <para/>
             <b>NOTE:</b> if this method returns a non-<c>null</c> value, it will be called by
             the <see cref="M:Lucene.Net.Util.PriorityQueue`1.#ctor(System.Int32,System.Boolean)"/> constructor
             <see cref="P:Lucene.Net.Util.PriorityQueue`1.Count"/> times, relying on a new object to be returned and will not
             check if it's <c>null</c> again. Therefore you should ensure any call to this
             method creates a new instance and behaves consistently, e.g., it cannot
             return <c>null</c> if it previously returned non-<c>null</c>.
             </summary>
             <returns> The sentinel object to use to pre-populate the queue, or <c>null</c> if
                     sentinel objects are not supported. </returns>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.Add(`0)">
            <summary>
            Adds an Object to a <see cref="T:Lucene.Net.Util.PriorityQueue`1"/> in log(size) time. If one tries to add
            more objects than <see cref="F:Lucene.Net.Util.PriorityQueue`1.maxSize"/> from initialize and it is not possible to resize
            the heap, an <see cref="T:System.IndexOutOfRangeException"/> is thrown.
            </summary>
            <returns> The new 'top' element in the queue. </returns>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.InsertWithOverflow(`0)">
            <summary>
            Adds an Object to a <see cref="T:Lucene.Net.Util.PriorityQueue`1"/> in log(size) time.
            It returns the object (if any) that was
            dropped off the heap because it was full. This can be
            the given parameter (in case it is smaller than the
            full heap's minimum, and couldn't be added), or another
            object that was previously the smallest value in the
            heap and now has been replaced by a larger one, or <c>null</c>
            if the queue wasn't yet full with <see cref="F:Lucene.Net.Util.PriorityQueue`1.maxSize"/> elements.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.PriorityQueue`1.Top">
            <summary>
            Returns the least element of the <see cref="T:Lucene.Net.Util.PriorityQueue`1"/> in constant time.
            Returns <c>null</c> if the queue is empty. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.Pop">
            <summary>
            Removes and returns the least element of the <see cref="T:Lucene.Net.Util.PriorityQueue`1"/> in log(size)
            time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.UpdateTop">
             <summary>
             Should be called when the Object at top changes values. Still log(n) worst
             case, but it's at least twice as fast to
            
             <code>
             pq.Top.Change();
             pq.UpdateTop();
             </code>
            
             instead of
            
             <code>
             o = pq.Pop();
             o.Change();
             pq.Push(o);
             </code>
             </summary>
             <returns> The new 'top' element. </returns>
        </member>
        <member name="P:Lucene.Net.Util.PriorityQueue`1.Count">
            <summary>
            Returns the number of elements currently stored in the <see cref="T:Lucene.Net.Util.PriorityQueue`1"/>.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.Clear">
            <summary>
            Removes all entries from the <see cref="T:Lucene.Net.Util.PriorityQueue`1"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Util.PriorityQueue`1.HeapArray">
            <summary>
            This method returns the internal heap array as T[].
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.QueryBuilder">
            <summary>
            Creates queries from the <see cref="P:Lucene.Net.Util.QueryBuilder.Analyzer"/> chain.
            <para/>
            Example usage:
            <code>
                QueryBuilder builder = new QueryBuilder(analyzer);
                Query a = builder.CreateBooleanQuery("body", "just a test");
                Query b = builder.CreatePhraseQuery("body", "another test");
                Query c = builder.CreateMinShouldMatchQuery("body", "another test", 0.5f);
            </code>
            <para/>
            This can also be used as a subclass for query parsers to make it easier
            to interact with the analysis chain. Factory methods such as <see cref="M:Lucene.Net.Util.QueryBuilder.NewTermQuery(Lucene.Net.Index.Term)"/>
            are provided so that the generated queries can be customized.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.QueryBuilder.#ctor(Lucene.Net.Analysis.Analyzer)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.QueryBuilder"/> using the given analyzer. </summary>
        </member>
        <member name="M:Lucene.Net.Util.QueryBuilder.CreateBooleanQuery(System.String,System.String)">
            <summary>
            Creates a boolean query from the query text.
            <para/>
            This is equivalent to <c>CreateBooleanQuery(field, queryText, Occur.SHOULD)</c> </summary>
            <param name="field"> Field name. </param>
            <param name="queryText"> Text to be passed to the analyzer. </param>
            <returns> <see cref="T:Lucene.Net.Search.TermQuery"/> or <see cref="T:Lucene.Net.Search.BooleanQuery"/>, based on the analysis
                    of <paramref name="queryText"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.QueryBuilder.CreateBooleanQuery(System.String,System.String,Lucene.Net.Search.Occur)">
            <summary>
            Creates a boolean query from the query text.
            </summary>
            <param name="field"> Field name </param>
            <param name="queryText"> Text to be passed to the analyzer. </param>
            <param name="operator"> Operator used for clauses between analyzer tokens. </param>
            <returns> <see cref="T:Lucene.Net.Search.TermQuery"/> or <see cref="T:Lucene.Net.Search.BooleanQuery"/>, based on the analysis
                    of <paramref name="queryText"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.QueryBuilder.CreatePhraseQuery(System.String,System.String)">
            <summary>
            Creates a phrase query from the query text.
            <para/>
            This is equivalent to <c>CreatePhraseQuery(field, queryText, 0)</c> </summary>
            <param name="field"> Field name. </param>
            <param name="queryText"> Text to be passed to the analyzer. </param>
            <returns> <see cref="T:Lucene.Net.Search.TermQuery"/>, <see cref="T:Lucene.Net.Search.BooleanQuery"/>, <see cref="T:Lucene.Net.Search.PhraseQuery"/>, or
                    <see cref="T:Lucene.Net.Search.MultiPhraseQuery"/>, based on the analysis of <paramref name="queryText"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.QueryBuilder.CreatePhraseQuery(System.String,System.String,System.Int32)">
            <summary>
            Creates a phrase query from the query text.
            </summary>
            <param name="field"> Field name. </param>
            <param name="queryText"> Text to be passed to the analyzer. </param>
            <param name="phraseSlop"> number of other words permitted between words in query phrase </param>
            <returns> <see cref="T:Lucene.Net.Search.TermQuery"/>, <see cref="T:Lucene.Net.Search.BooleanQuery"/>, <see cref="T:Lucene.Net.Search.PhraseQuery"/>, or
                    <see cref="T:Lucene.Net.Search.MultiPhraseQuery"/>, based on the analysis of <paramref name="queryText"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.QueryBuilder.CreateMinShouldMatchQuery(System.String,System.String,System.Single)">
            <summary>
            Creates a minimum-should-match query from the query text.
            </summary>
            <param name="field"> Field name. </param>
            <param name="queryText"> Text to be passed to the analyzer. </param>
            <param name="fraction"> of query terms <c>[0..1]</c> that should match </param>
            <returns> <see cref="T:Lucene.Net.Search.TermQuery"/> or <see cref="T:Lucene.Net.Search.BooleanQuery"/>, based on the analysis
                    of <paramref name="queryText"/>. </returns>
        </member>
        <member name="P:Lucene.Net.Util.QueryBuilder.Analyzer">
            <summary>
            Gets or Sets the analyzer. </summary>
        </member>
        <member name="P:Lucene.Net.Util.QueryBuilder.EnablePositionIncrements">
            <summary>
            Gets or Sets whether position increments are enabled.
            <para/>
            When <c>true</c>, result phrase and multi-phrase queries will
            be aware of position increments.
            Useful when e.g. a StopFilter increases the position increment of
            the token that follows an omitted token.
            <para/>
            Default: true.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.QueryBuilder.CreateFieldQuery(Lucene.Net.Analysis.Analyzer,Lucene.Net.Search.Occur,System.String,System.String,System.Boolean,System.Int32)">
            <summary>
            Creates a query from the analysis chain.
            <para/>
            Expert: this is more useful for subclasses such as queryparsers.
            If using this class directly, just use <see cref="M:Lucene.Net.Util.QueryBuilder.CreateBooleanQuery(System.String,System.String)"/>
            and <see cref="M:Lucene.Net.Util.QueryBuilder.CreatePhraseQuery(System.String,System.String)"/>. </summary>
            <param name="analyzer"> Analyzer used for this query. </param>
            <param name="operator"> Default boolean operator used for this query. </param>
            <param name="field"> Field to create queries against. </param>
            <param name="queryText"> Text to be passed to the analysis chain. </param>
            <param name="quoted"> <c>true</c> if phrases should be generated when terms occur at more than one position. </param>
            <param name="phraseSlop"> Slop factor for phrase/multiphrase queries. </param>
        </member>
        <member name="M:Lucene.Net.Util.QueryBuilder.NewBooleanQuery(System.Boolean)">
            <summary>
            Builds a new <see cref="T:Lucene.Net.Search.BooleanQuery"/> instance.
            <para/>
            This is intended for subclasses that wish to customize the generated queries. 
            </summary>
            <param name="disableCoord"> Disable coord. </param>
            <returns> New <see cref="T:Lucene.Net.Search.BooleanQuery"/> instance. </returns>
        </member>
        <member name="M:Lucene.Net.Util.QueryBuilder.NewTermQuery(Lucene.Net.Index.Term)">
            <summary>
            Builds a new <see cref="T:Lucene.Net.Search.TermQuery"/> instance.
            <para/>
            This is intended for subclasses that wish to customize the generated queries. 
            </summary>
            <param name="term"> Term. </param>
            <returns> New <see cref="T:Lucene.Net.Search.TermQuery"/> instance. </returns>
        </member>
        <member name="M:Lucene.Net.Util.QueryBuilder.NewPhraseQuery">
            <summary>
            Builds a new <see cref="T:Lucene.Net.Search.PhraseQuery"/> instance.
            <para/>
            This is intended for subclasses that wish to customize the generated queries. 
            </summary>
            <returns> New <see cref="T:Lucene.Net.Search.PhraseQuery"/> instance. </returns>
        </member>
        <member name="M:Lucene.Net.Util.QueryBuilder.NewMultiPhraseQuery">
            <summary>
            Builds a new <see cref="T:Lucene.Net.Search.MultiPhraseQuery"/> instance.
            <para/>
            This is intended for subclasses that wish to customize the generated queries. 
            </summary>
            <returns> New <see cref="T:Lucene.Net.Search.MultiPhraseQuery"/> instance. </returns>
        </member>
        <member name="T:Lucene.Net.Util.RamUsageEstimator">
            <summary>
            Estimates the size (memory representation) of .NET objects.
            <para/>
            @lucene.internal
            </summary>
            <seealso cref="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Object)"/>
            <seealso cref="M:Lucene.Net.Util.RamUsageEstimator.ShallowSizeOf(System.Object)"/>
            <seealso cref="M:Lucene.Net.Util.RamUsageEstimator.ShallowSizeOfInstance(System.Type)"/>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.ONE_KB">
            <summary>
            One kilobyte bytes. </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.ONE_MB">
            <summary>
            One megabyte bytes. </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.ONE_GB">
            <summary>
            One gigabyte bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.#ctor">
            <summary>
            No instantiation. </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_INT16">
            <summary>
            NOTE: This was NUM_BYTES_SHORT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_INT32">
            <summary>
            NOTE: This was NUM_BYTES_INT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_SINGLE">
            <summary>
            NOTE: This was NUM_BYTES_FLOAT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_INT64">
            <summary>
            NOTE: This was NUM_BYTES_LONG in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_OBJECT_REF">
            <summary>
            Number of bytes this .NET runtime uses to represent an object reference.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_OBJECT_HEADER">
            <summary>
            Number of bytes to represent an object header (no fields, no alignments).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_ARRAY_HEADER">
            <summary>
            Number of bytes to represent an array header (no content, but with alignments).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_OBJECT_ALIGNMENT">
            <summary>
            A constant specifying the object alignment boundary inside the .NET runtime. Objects will
            always take a full multiple of this constant, possibly wasting some space.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.primitiveSizes">
            <summary>
            Sizes of primitive classes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.RamUsageEstimator.ClassCache">
            <summary>
            Cached information about a given class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.AlignObjectSize(System.Int64)">
            <summary>
            Aligns an object size to be the next multiple of <see cref="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_OBJECT_ALIGNMENT"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Byte[])">
            <summary>
            Returns the size in bytes of the <see cref="T:byte[]"/> object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.SByte[])">
            <summary>
            Returns the size in bytes of the <see cref="T:sbyte[]"/> object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Boolean[])">
            <summary>
            Returns the size in bytes of the <see cref="T:bool[]"/> object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Char[])">
            <summary>
            Returns the size in bytes of the <see cref="T:char[]"/> object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Int16[])">
            <summary>
            Returns the size in bytes of the <see cref="T:short[]"/> object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Int32[])">
            <summary>
            Returns the size in bytes of the <see cref="T:int[]"/> object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Single[])">
            <summary>
            Returns the size in bytes of the <see cref="T:float[]"/> object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Int64[])">
            <summary>
            Returns the size in bytes of the <see cref="T:long[]"/> object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Double[])">
            <summary>
            Returns the size in bytes of the <see cref="T:double[]"/> object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.UInt64[])">
            <summary>
            Returns the size in bytes of the <see cref="T:ulong[]"/> object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.UInt32[])">
            <summary>
            Returns the size in bytes of the <see cref="T:uint[]"/> object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.UInt16[])">
            <summary>
            Returns the size in bytes of the <see cref="T:ushort[]"/> object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Object)">
             <summary>
             Estimates the RAM usage by the given object. It will
             walk the object tree and sum up all referenced objects.
            
             <para><b>Resource Usage:</b> this method internally uses a set of
             every object seen during traversals so it does allocate memory
             (it isn't side-effect free). After the method exits, this memory
             should be GCed.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.ShallowSizeOf(System.Object)">
            <summary>
            Estimates a "shallow" memory usage of the given object. For arrays, this will be the
            memory taken by array storage (no subreferences will be followed). For objects, this
            will be the memory taken by the fields.
            <para/>
            .NET object alignments are also applied.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.ShallowSizeOfInstance(System.Type)">
            <summary>
            Returns the shallow instance size in bytes an instance of the given class would occupy.
            This works with all conventional classes and primitive types, but not with arrays
            (the size then depends on the number of elements and varies from object to object).
            </summary>
            <seealso cref="M:Lucene.Net.Util.RamUsageEstimator.ShallowSizeOf(System.Object)"/>
            <exception cref="T:System.ArgumentException"> if <paramref name="clazz"/> is an array class. </exception>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.ShallowSizeOfArray(System.Array)">
            <summary>
            Return shallow size of any <paramref name="array"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.CreateCacheEntry(System.Type)">
            <summary>
            Create a cached information about shallow size and reference fields for
            a given class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.AdjustForField(System.Int64,System.Reflection.FieldInfo)">
             <summary>
             This method returns the maximum representation size of an object. <paramref name="sizeSoFar"/>
             is the object's size measured so far. <paramref name="f"/> is the field being probed.
            
             <para/>The returned offset will be the maximum of whatever was measured so far and
             <paramref name="f"/> field's offset and representation size (unaligned).
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.HumanReadableUnits(System.Int64)">
            <summary>
            Returns <c>size</c> in human-readable units (GB, MB, KB or bytes).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.HumanReadableUnits(System.Int64,System.IFormatProvider)">
            <summary>
            Returns <c>size</c> in human-readable units (GB, MB, KB or bytes).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.HumanSizeOf(System.Object)">
            <summary>
            Return a human-readable size of a given object. </summary>
            <seealso cref="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Object)"/>
            <seealso cref="M:Lucene.Net.Util.RamUsageEstimator.HumanReadableUnits(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.HumanSizeOf(System.Object,System.IFormatProvider)">
            <summary>
            Return a human-readable size of a given object. </summary>
            <seealso cref="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Object)"/>
            <seealso cref="M:Lucene.Net.Util.RamUsageEstimator.HumanReadableUnits(System.Int64)"/>
        </member>
        <member name="T:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1">
            <summary>
            An identity hash set implemented using open addressing. No null keys are allowed.
            <para/>
            TODO: If this is useful outside this class, make it public - needs some work
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.DEFAULT_LOAD_FACTOR">
            <summary>
            Default load factor.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.MIN_CAPACITY">
            <summary>
            Minimum capacity for the set.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Keys">
            <summary>
            All of set entries. Always of power of two length.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Assigned">
            <summary>
            Cached number of assigned slots.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.LoadFactor">
            <summary>
            The load factor for this set (fraction of allocated or deleted slots before
            the buffers must be rehashed or reallocated).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.resizeThreshold">
            <summary>
            Cached capacity threshold at which we must resize the buffers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.#ctor">
            <summary>
            Creates a hash set with the default capacity of 16,
            load factor of <see cref="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.DEFAULT_LOAD_FACTOR"/>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.#ctor(System.Int32)">
            <summary>
            Creates a hash set with the given capacity, load factor of
            <see cref="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.DEFAULT_LOAD_FACTOR"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.#ctor(System.Int32,System.Single)">
            <summary>
            Creates a hash set with the given capacity and load factor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Add(`0)">
            <summary>
            Adds a reference to the set. Null keys are not allowed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Contains(`0)">
            <summary>
            Checks if the set contains a given ref.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Rehash(System.Object)">
             <summary>
             Rehash via MurmurHash.
            
             <para/>The implementation is based on the
             finalization step from Austin Appleby's
             <c>MurmurHash3</c>.
             
             See <a target="_blank" href="http://sites.google.com/site/murmurhash/">http://sites.google.com/site/murmurhash/</a>.
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.ExpandAndRehash">
            <summary>
            Expand the internal storage buffers (capacity) or rehash current keys and
            values if there are a lot of deleted slots.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.AllocateBuffers(System.Int32)">
            <summary>
            Allocate internal buffers for a given <paramref name="capacity"/>.
            </summary>
            <param name="capacity">
                     New capacity (must be a power of two). </param>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.NextCapacity(System.Int32)">
            <summary>
            Return the next possible capacity, counting from the current buffers' size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.RoundCapacity(System.Int32)">
            <summary>
            Round the capacity to the next allowed value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.RecyclingByteBlockAllocator">
            <summary>
            A <see cref="T:Lucene.Net.Util.ByteBlockPool.Allocator"/> implementation that recycles unused byte
            blocks in a buffer and reuses them in subsequent calls to
            <see cref="M:Lucene.Net.Util.RecyclingByteBlockAllocator.GetByteBlock"/>.
            <para>
            Note: this class is not thread-safe.
            </para>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.#ctor(System.Int32,System.Int32,Lucene.Net.Util.Counter)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.RecyclingByteBlockAllocator"/>
            </summary>
            <param name="blockSize">
                     The block size in bytes. </param>
            <param name="maxBufferedBlocks">
                     Maximum number of buffered byte block. </param>
            <param name="bytesUsed">
                     <see cref="T:Lucene.Net.Util.Counter"/> reference counting internally allocated bytes. </param>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.RecyclingByteBlockAllocator"/>.
            </summary>
            <param name="blockSize">
                     The block size in bytes. </param>
            <param name="maxBufferedBlocks">
                     Maximum number of buffered byte block. </param>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.#ctor">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.RecyclingByteBlockAllocator"/> with a block size of
            <see cref="F:Lucene.Net.Util.ByteBlockPool.BYTE_BLOCK_SIZE"/>, upper buffered docs limit of
            <see cref="F:Lucene.Net.Util.RecyclingByteBlockAllocator.DEFAULT_BUFFERED_BLOCKS"/> (64).
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RecyclingByteBlockAllocator.NumBufferedBlocks">
            <returns> The number of currently buffered blocks. </returns>
        </member>
        <member name="P:Lucene.Net.Util.RecyclingByteBlockAllocator.BytesUsed">
            <returns> The number of bytes currently allocated by this <see cref="T:Lucene.Net.Util.ByteBlockPool.Allocator"/>. </returns>
        </member>
        <member name="P:Lucene.Net.Util.RecyclingByteBlockAllocator.MaxBufferedBlocks">
            <returns> The maximum number of buffered byte blocks. </returns>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.FreeBlocks(System.Int32)">
            <summary>
            Removes the given number of byte blocks from the buffer if possible.
            </summary>
            <param name="num">
                     The number of byte blocks to remove. </param>
            <returns> The number of actually removed buffers. </returns>
        </member>
        <member name="T:Lucene.Net.Util.RecyclingInt32BlockAllocator">
            <summary>
            A <see cref="T:Lucene.Net.Util.Int32BlockPool.Allocator"/> implementation that recycles unused <see cref="T:System.Int32"/>
            blocks in a buffer and reuses them in subsequent calls to
            <see cref="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.GetInt32Block"/>.
            <para>
            Note: this class is not thread-safe.
            </para>
            <para>
            NOTE: This was RecyclingIntBlockAllocator in Lucene
            </para>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.#ctor(System.Int32,System.Int32,Lucene.Net.Util.Counter)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.RecyclingInt32BlockAllocator"/>.
            </summary>
            <param name="blockSize">
                     The block size in bytes. </param>
            <param name="maxBufferedBlocks">
                     Maximum number of buffered int block. </param>
            <param name="bytesUsed">
                     <see cref="T:Lucene.Net.Util.Counter"/> reference counting internally allocated bytes. </param>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.RecyclingInt32BlockAllocator"/>.
            </summary>
            <param name="blockSize">
                     The size of each block returned by this allocator. </param>
            <param name="maxBufferedBlocks">
                     Maximum number of buffered int blocks. </param>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.#ctor">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Util.RecyclingInt32BlockAllocator"/> with a block size of
            <see cref="F:Lucene.Net.Util.Int32BlockPool.INT32_BLOCK_SIZE"/>, upper buffered docs limit of
            <see cref="F:Lucene.Net.Util.RecyclingInt32BlockAllocator.DEFAULT_BUFFERED_BLOCKS"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.GetInt32Block">
            <summary>
            NOTE: This was getIntBlock() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.RecycleInt32Blocks(System.Int32[][],System.Int32,System.Int32)">
            <summary>
            NOTE: This was recycleIntBlocks in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RecyclingInt32BlockAllocator.NumBufferedBlocks">
            <returns> The number of currently buffered blocks. </returns>
        </member>
        <member name="P:Lucene.Net.Util.RecyclingInt32BlockAllocator.BytesUsed">
            <returns> The number of bytes currently allocated by this <see cref="T:Lucene.Net.Util.Int32BlockPool.Allocator"/>. </returns>
        </member>
        <member name="P:Lucene.Net.Util.RecyclingInt32BlockAllocator.MaxBufferedBlocks">
            <returns> The maximum number of buffered byte blocks. </returns>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.FreeBlocks(System.Int32)">
            <summary>
            Removes the given number of int blocks from the buffer if possible.
            </summary>
            <param name="num">
                     The number of int blocks to remove. </param>
            <returns> The number of actually removed buffers. </returns>
        </member>
        <member name="T:Lucene.Net.Util.RefCount`1">
            <summary>
            Manages reference counting for a given object. Extensions can override
            <see cref="M:Lucene.Net.Util.RefCount`1.Release"/> to do custom logic when reference counting hits 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RefCount`1.Release">
            <summary>
            Called when reference counting hits 0. By default this method does nothing,
            but extensions can override to e.g. release resources attached to object
            that is managed by this class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RefCount`1.DecRef">
            <summary>
            Decrements the reference counting of this object. When reference counting
            hits 0, calls <see cref="M:Lucene.Net.Util.RefCount`1.Release"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RefCount`1.GetRefCount">
            <summary>
            Returns the current reference count. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RefCount`1.IncRef">
            <summary>
            Increments the reference count. Calls to this method must be matched with
            calls to <see cref="M:Lucene.Net.Util.RefCount`1.DecRef"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.RollingBuffer">
            <summary>
            LUCENENET specific class to allow referencing static members of
            <see cref="T:Lucene.Net.Util.RollingBuffer`1"/> without referencing its generic closing type.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.RollingBuffer.IResettable">
            <summary>
            Implement to reset an instance
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.RollingBuffer`1">
            <summary>
            Acts like forever growing <see cref="T:T[]"/>, but internally uses a
            circular buffer to reuse instances of <typeparam name="T"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RollingBuffer`1.Get(System.Int32)">
            <summary>
            Get <typeparamref name="T"/> instance for this absolute position;
            This is allowed to be arbitrarily far "in the
            future" but cannot be before the last <see cref="M:Lucene.Net.Util.RollingBuffer`1.FreeBefore(System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RollingBuffer`1.MaxPos">
            <summary>
            Returns the maximum position looked up, or -1 if no
            position has been looked up since <see cref="M:Lucene.Net.Util.RollingBuffer`1.Reset"/>/init.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.SentinelInt32Set">
            <summary>
            A native <see cref="T:System.Int32"/> hash-based set where one value is reserved to mean "EMPTY" internally. The space overhead is fairly low
            as there is only one power-of-two sized <see cref="T:int[]"/> to hold the values.  The set is re-hashed when adding a value that
            would make it >= 75% full.  Consider extending and over-riding <see cref="M:Lucene.Net.Util.SentinelInt32Set.Hash(System.Int32)"/> if the values might be poor
            hash keys; Lucene docids should be fine.
            The internal fields are exposed publicly to enable more efficient use at the expense of better O-O principles.
            <para/>
            To iterate over the integers held in this set, simply use code like this:
            <code>
            SentinelIntSet set = ...
            foreach (int v in set.keys) 
            {
                if (v == set.EmptyVal)
                    continue;
                //use v...
            }
            </code>
            <para/>
            NOTE: This was SentinelIntSet in Lucene
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.SentinelInt32Set.Keys">
            <summary>
            A power-of-2 over-sized array holding the integers in the set along with empty values. </summary>
        </member>
        <member name="P:Lucene.Net.Util.SentinelInt32Set.Count">
            <summary>
            The number of integers in this set. </summary>
        </member>
        <member name="P:Lucene.Net.Util.SentinelInt32Set.RehashCount">
            <summary>
            The count at which a rehash should be done. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.#ctor(System.Int32,System.Int32)">
            
             <param name="size">  The minimum number of elements this set should be able to hold without rehashing
                          (i.e. the slots are guaranteed not to change). </param>
             <param name="emptyVal"> The integer value to use for EMPTY. </param>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.Hash(System.Int32)">
            <summary>
            (internal) Return the hash for the key. The default implementation just returns the key,
            which is not appropriate for general purpose use.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.GetSlot(System.Int32)">
            <summary>
            (internal) Returns the slot for this key. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.Find(System.Int32)">
            <summary>
            (internal) Returns the slot for this key, or -slot-1 if not found. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.Exists(System.Int32)">
            <summary>
            Does this set contain the specified integer? </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.Put(System.Int32)">
            <summary>
            Puts this integer (key) in the set, and returns the slot index it was added to.
            It rehashes if adding it would make the set more than 75% full.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.Rehash">
            <summary>
            (internal) Rehashes by doubling key (<see cref="T:int[]"/>) and filling with the old values. </summary>
        </member>
        <member name="T:Lucene.Net.Util.SetOnce`1">
            <summary>
            A convenient class which offers a semi-immutable object wrapper
            implementation which allows one to set the value of an object exactly once,
            and retrieve it many times. If <see cref="M:Lucene.Net.Util.SetOnce`1.Set(`0)"/> is called more than once,
            <see cref="T:Lucene.Net.Util.AlreadySetException"/> is thrown and the operation
            will fail.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SetOnce`1.#ctor">
            <summary>
            A default constructor which does not set the internal object, and allows
            setting it by calling <see cref="M:Lucene.Net.Util.SetOnce`1.Set(`0)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SetOnce`1.#ctor(`0)">
            <summary>
            Creates a new instance with the internal object set to the given object.
            Note that any calls to <see cref="M:Lucene.Net.Util.SetOnce`1.Set(`0)"/> afterwards will result in
            <see cref="T:Lucene.Net.Util.AlreadySetException"/>
            </summary>
            <exception cref="T:Lucene.Net.Util.AlreadySetException"> if called more than once </exception>
            <seealso cref="M:Lucene.Net.Util.SetOnce`1.Set(`0)"/>
        </member>
        <member name="M:Lucene.Net.Util.SetOnce`1.Set(`0)">
            <summary>
            Sets the given object. If the object has already been set, an exception is thrown. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SetOnce`1.Get">
            <summary>
            Returns the object set by <see cref="M:Lucene.Net.Util.SetOnce`1.Set(`0)"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.AlreadySetException">
            <summary>
            Thrown when <see cref="M:Lucene.Net.Util.SetOnce`1.Set(`0)"/> is called more than once. </summary>
        </member>
        <member name="M:Lucene.Net.Util.AlreadySetException.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:Lucene.Net.Util.AlreadySetException"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AlreadySetException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Util.SloppyMath">
            <summary>
            Math functions that trade off accuracy for speed. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SloppyMath.Haversin(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance in kilometers between two points
            specified in decimal degrees (latitude/longitude). </summary>
            <param name="lat1"> Latitude of the first point. </param>
            <param name="lon1"> Longitude of the first point. </param>
            <param name="lat2"> Latitude of the second point. </param>
            <param name="lon2"> Longitude of the second point. </param>
            <returns> distance in kilometers. </returns>
        </member>
        <member name="M:Lucene.Net.Util.SloppyMath.Cos(System.Double)">
            <summary>
            Returns the trigonometric cosine of an angle.
            <para/>
            Error is around 1E-15.
            <para/>
            Special cases:
            <list type="bullet">
                <item><description>If the argument is <see cref="F:System.Double.NaN"/> or an infinity, then the result is <see cref="F:System.Double.NaN"/>.</description></item>
            </list> 
            </summary>
            <param name="a"> An angle, in radians. </param>
            <returns> The cosine of the argument. </returns>
            <seealso cref="M:System.Math.Cos(System.Double)"/>
        </member>
        <member name="M:Lucene.Net.Util.SloppyMath.Asin(System.Double)">
            <summary>
            Returns the arc sine of a value.
            <para/>
            The returned angle is in the range <i>-pi</i>/2 through <i>pi</i>/2.
            Error is around 1E-7.
            <para/>
            Special cases:
            <list type="bullet">
                <item><description>If the argument is <see cref="F:System.Double.NaN"/> or its absolute value is greater than 1, then the result is <see cref="F:System.Double.NaN"/>.</description></item>
            </list> 
            </summary>
            <param name="a"> the value whose arc sine is to be returned. </param>
            <returns> arc sine of the argument </returns>
            <seealso cref="M:System.Math.Asin(System.Double)"/>
        </member>
        <member name="M:Lucene.Net.Util.SloppyMath.EarthDiameter(System.Double)">
            <summary>
            Return an approximate value of the diameter of the earth at the given latitude, in kilometers. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SloppyMath.#cctor">
            <summary>
            Initializes look-up tables. </summary>
        </member>
        <member name="T:Lucene.Net.Util.SmallSingle">
            <summary>
            Floating point numbers smaller than 32 bits.
            <para/>
            NOTE: This was SmallFloat in Lucene
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.#ctor">
            <summary>
            No instance </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SingleToByte(System.Single,System.Int32,System.Int32)">
            <summary>
            Converts a 32 bit <see cref="T:System.Single"/> to an 8 bit <see cref="T:System.Single"/>.
            <para/>Values less than zero are all mapped to zero.
            <para/>Values are truncated (rounded down) to the nearest 8 bit value.
            <para/>Values between zero and the smallest representable value
            are rounded up.
            </summary>
            <param name="f"> The 32 bit <see cref="T:System.Single"/> to be converted to an 8 bit <see cref="T:System.Single"/> (<see cref="T:System.Byte"/>).  </param>
            <param name="numMantissaBits"> The number of mantissa bits to use in the byte, with the remainder to be used in the exponent. </param>
            <param name="zeroExp"> The zero-point in the range of exponent values. </param>
            <returns> The 8 bit float representation. </returns>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SingleToSByte(System.Single,System.Int32,System.Int32)">
            <summary>
            Converts a 32 bit <see cref="T:System.Single"/> to an 8 bit <see cref="T:System.Single"/>.
            <para/>Values less than zero are all mapped to zero.
            <para/>Values are truncated (rounded down) to the nearest 8 bit value.
            <para/>Values between zero and the smallest representable value
            are rounded up.
            <para/>
            NOTE: This was floatToByte() in Lucene
            </summary>
            <param name="f"> The 32 bit <see cref="T:System.Single"/> to be converted to an 8 bit <see cref="T:System.Single"/> (<see cref="T:System.SByte"/>). </param>
            <param name="numMantissaBits"> The number of mantissa bits to use in the byte, with the remainder to be used in the exponent. </param>
            <param name="zeroExp"> The zero-point in the range of exponent values. </param>
            <returns> The 8 bit float representation. </returns>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.ByteToSingle(System.Byte,System.Int32,System.Int32)">
            <summary>
            Converts an 8 bit <see cref="T:System.Single"/> to a 32 bit <see cref="T:System.Single"/>. 
            <para/>
            NOTE: This was byteToFloat() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SByteToSingle(System.SByte,System.Int32,System.Int32)">
            <summary>
            Converts an 8 bit <see cref="T:System.Single"/> to a 32 bit <see cref="T:System.Single"/>. 
            <para/>
            NOTE: This was byteToFloat() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SingleToByte315(System.Single)">
            <summary>
            SingleToSByte((byte)b, mantissaBits=3, zeroExponent=15)
            <para/>smallest non-zero value = 5.820766E-10
            <para/>largest value = 7.5161928E9
            <para/>epsilon = 0.125
            <para/>
            NOTE: This was floatToByte315() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SingleToSByte315(System.Single)">
            <summary>
            SingleToSByte(b, mantissaBits=3, zeroExponent=15)
            <para/>smallest non-zero value = 5.820766E-10
            <para/>largest value = 7.5161928E9
            <para/>epsilon = 0.125
            <para/>
            NOTE: This was floatToByte315() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.Byte315ToSingle(System.Byte)">
            <summary>
            ByteToSingle(b, mantissaBits=3, zeroExponent=15) 
            <para/>
            NOTE: This was byte315ToFloat() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SByte315ToSingle(System.SByte)">
            <summary>
            SByteToSingle(b, mantissaBits=3, zeroExponent=15) 
            <para/>
            NOTE: This was byte315ToFloat() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SingleToByte52(System.Single)">
            <summary>
            SingleToByte(b, mantissaBits=5, zeroExponent=2)
            <para/>smallest nonzero value = 0.033203125
            <para/>largest value = 1984.0
            <para/>epsilon = 0.03125
            <para/>
            NOTE: This was floatToByte52() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SingleToSByte52(System.Single)">
            <summary>
            SingleToSByte(b, mantissaBits=5, zeroExponent=2)
            <para/>smallest nonzero value = 0.033203125
            <para/>largest value = 1984.0
            <para/>epsilon = 0.03125
            <para/>
            NOTE: This was floatToByte52() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.Byte52ToSingle(System.Byte)">
            <summary>
            ByteToFloat(b, mantissaBits=5, zeroExponent=2) 
            <para/>
            NOTE: This was byte52ToFloat() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SByte52ToSingle(System.SByte)">
            <summary>
            SByteToFloat(b, mantissaBits=5, zeroExponent=2) 
            <para/>
            NOTE: This was byte52ToFloat() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Sorter">
            <summary>
            Base class for sorting algorithms implementations.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Sorter.#ctor">
            <summary>
            Sole constructor, used for inheritance. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Sorter.Compare(System.Int32,System.Int32)">
            <summary>
            Compare entries found in slots <paramref name="i"/> and <paramref name="j"/>.
            The contract for the returned value is the same as
            <see cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Sorter.Swap(System.Int32,System.Int32)">
            <summary>
            Swap values at slots <paramref name="i"/> and <paramref name="j"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Sorter.Sort(System.Int32,System.Int32)">
            <summary>
            Sort the slice which starts at <paramref name="from"/> (inclusive) and ends at
            <paramref name="to"/> (exclusive).
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.SPIClassIterator`1">
            <summary>
            Helper class for loading SPI classes from classpath (META-INF files).
            This is a light impl of <c>java.util.ServiceLoader</c> but is guaranteed to
            be bug-free regarding classpath order and does not instantiate or initialize
            the classes found.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.StringHelper">
            <summary>
            Methods for manipulating strings.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.StringHelper.GOOD_FAST_HASH_SEED">
            <summary>
            Pass this as the seed to <see cref="M:Lucene.Net.Util.StringHelper.Murmurhash3_x86_32(System.Byte[],System.Int32,System.Int32,System.Int32)"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.BytesDifference(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Compares two <see cref="T:Lucene.Net.Util.BytesRef"/>, element by element, and returns the
            number of elements common to both arrays.
            </summary>
            <param name="left"> The first <see cref="T:Lucene.Net.Util.BytesRef"/> to compare. </param>
            <param name="right"> The second <see cref="T:Lucene.Net.Util.BytesRef"/> to compare. </param>
            <returns> The number of common elements. </returns>
        </member>
        <member name="P:Lucene.Net.Util.StringHelper.VersionComparer">
            <summary> Returns a <see cref="T:IComparer{string}"/> over versioned strings such as X.YY.Z
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.StartsWith(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns <c>true</c> if the <paramref name="ref"/> starts with the given <paramref name="prefix"/>.
            Otherwise <c>false</c>.
            </summary>
            <param name="ref">
                     The <see cref="T:Lucene.Net.Util.BytesRef"/> to test. </param>
            <param name="prefix">
                     The expected prefix </param>
            <returns> Returns <c>true</c> if the <paramref name="ref"/> starts with the given <paramref name="prefix"/>.
                    Otherwise <c>false</c>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.EndsWith(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns <c>true</c> if the <paramref name="ref"/> ends with the given <paramref name="suffix"/>. Otherwise
            <c>false</c>.
            </summary>
            <param name="ref">
                     The <see cref="T:Lucene.Net.Util.BytesRef"/> to test. </param>
            <param name="suffix">
                     The expected suffix </param>
            <returns> Returns <c>true</c> if the <paramref name="ref"/> ends with the given <paramref name="suffix"/>.
                    Otherwise <c>false</c>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.Murmurhash3_x86_32(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the MurmurHash3_x86_32 hash.
            Original source/tests at <a href="https://github.com/yonik/java_util/">https://github.com/yonik/java_util/</a>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.Murmurhash3_x86_32(Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            Returns the MurmurHash3_x86_32 hash.
            Original source/tests at <a href="https://github.com/yonik/java_util/">https://github.com/yonik/java_util/</a>. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.TimSorter">
            <summary>
            <see cref="T:Lucene.Net.Util.Sorter"/> implementation based on the
            <a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">TimSort</a>
            algorithm.
            <para/>This implementation is especially good at sorting partially-sorted
            arrays and sorts small arrays with binary sort.
            <para/><b>NOTE</b>:There are a few differences with the original implementation:
            <list type="bullet">
                <item><description><a name="maxTempSlots"/>The extra amount of memory to perform merges is
                    configurable. This allows small merges to be very fast while large merges
                    will be performed in-place (slightly slower). You can make sure that the
                    fast merge routine will always be used by having <c>maxTempSlots</c>
                    equal to half of the length of the slice of data to sort.</description></item>
                <item><description>Only the fast merge routine can gallop (the one that doesn't run
                    in-place) and it only gallops on the longest slice.</description></item>
            </list>
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.#ctor(System.Int32)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Util.TimSorter"/>. </summary>
            <param name="maxTempSlots"> The <a href="#maxTempSlots">maximum amount of extra memory to run merges</a> </param>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.MinRun(System.Int32)">
            <summary>
            Minimum run length for an array of length <paramref name="length"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.NextRun">
            <summary>
            Compute the length of the next run, make the run sorted and return its
            length.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.Sort(System.Int32,System.Int32)">
            <summary>
            Sort the slice which starts at <paramref name="from"/> (inclusive) and ends at
            <paramref name="to"/> (exclusive).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.Copy(System.Int32,System.Int32)">
            <summary>
            Copy data from slot <paramref name="src"/> to slot <paramref name="dest"/>>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.Save(System.Int32,System.Int32)">
            <summary>
            Save all elements between slots <paramref name="i"/> and <paramref name="i"/>+<paramref name="len"/>
            into the temporary storage.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.Restore(System.Int32,System.Int32)">
            <summary>
            Restore element <paramref name="j"/> from the temporary storage into slot <paramref name="i"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.CompareSaved(System.Int32,System.Int32)">
            <summary>
            Compare element <paramref name="i"/> from the temporary storage with element
            <paramref name="j"/> from the slice to sort, similarly to
            <see cref="M:Lucene.Net.Util.Sorter.Compare(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ToStringUtils">
            <summary>
            Helper methods to ease implementing <see cref="M:System.Object.ToString"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ToStringUtils.Boost(System.Single)">
            <summary>
            For printing boost only if not 1.0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ToStringUtils.Int64Hex(System.Int64)">
            <summary>
            NOTE: This was longHex() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.UnicodeUtil">
            <summary>
            Class to encode .NET's UTF16 <see cref="T:char[]"/> into UTF8 <see cref="T:byte[]"/>
            without always allocating a new <see cref="T:byte[]"/> as
            <see cref="M:System.Text.Encoding.GetBytes(System.String)"/> of <see cref="P:System.Text.Encoding.UTF8"/> does.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.BIG_TERM">
            <summary>
            A binary term consisting of a number of 0xff bytes, likely to be bigger than other terms
            (e.g. collation keys) one would normally encounter, and definitely bigger than any UTF-8 terms.
            <para/>
            WARNING: this is not a valid UTF8 Term
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF16toUTF8(System.Char[],System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Encode characters from a <see cref="T:char[]"/> <paramref name="source"/>, starting at
            <paramref name="offset"/> for <paramref name="length"/> chars. After encoding, <c>result.Offset</c> will always be 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF16toUTF8(J2N.Text.ICharSequence,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Encode characters from this <see cref="T:J2N.Text.ICharSequence"/>, starting at <paramref name="offset"/>
            for <paramref name="length"/> characters. After encoding, <c>result.Offset</c> will always be 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF16toUTF8(System.String,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Encode characters from this <see cref="T:System.String"/>, starting at <paramref name="offset"/>
            for <paramref name="length"/> characters. After encoding, <c>result.Offset</c> will always be 0.
            <para/>
            LUCENENET specific.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.CodePointCount(Lucene.Net.Util.BytesRef)">
             <summary>
             Returns the number of code points in this UTF8 sequence.
            
             <para/>This method assumes valid UTF8 input. This method
             <b>does not perform</b> full UTF8 validation, it will check only the
             first byte of each codepoint (for multi-byte sequences any bytes after
             the head are skipped).
             </summary>
             <exception cref="T:System.ArgumentException"> If invalid codepoint header byte occurs or the
                content is prematurely truncated. </exception>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF8toUTF32(Lucene.Net.Util.BytesRef,Lucene.Net.Util.Int32sRef)">
            <summary>
            This method assumes valid UTF8 input. This method
            <b>does not perform</b> full UTF8 validation, it will check only the
            first byte of each codepoint (for multi-byte sequences any bytes after
            the head are skipped).
            </summary>
            <exception cref="T:System.ArgumentException"> If invalid codepoint header byte occurs or the
               content is prematurely truncated. </exception>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.LEAD_SURROGATE_SHIFT_">
            <summary>
            Shift value for lead surrogate to form a supplementary character. </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.TRAIL_SURROGATE_MASK_">
            <summary>
            Mask to retrieve the significant value from a trail surrogate. </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.TRAIL_SURROGATE_MIN_VALUE">
            <summary>
            Trail surrogate minimum value. </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.LEAD_SURROGATE_MIN_VALUE">
            <summary>
            Lead surrogate minimum value. </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.SUPPLEMENTARY_MIN_VALUE">
            <summary>
            The minimum value for Supplementary code points. </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.LEAD_SURROGATE_OFFSET_">
            <summary>
            Value that all lead surrogate starts with. </summary>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.NewString(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Cover JDK 1.5 API. Create a String from an array of <paramref name="codePoints"/>.
            </summary>
            <param name="codePoints"> The code array. </param>
            <param name="offset"> The start of the text in the code point array. </param>
            <param name="count"> The number of code points. </param>
            <returns> a String representing the code points between offset and count. </returns>
            <exception cref="T:System.ArgumentException"> If an invalid code point is encountered. </exception>
            <exception cref="T:System.IndexOutOfRangeException"> If the offset or count are out of bounds. </exception>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.ToCharArray(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Generates char array that represents the provided input code points.
            <para/>
            LUCENENET specific.
            </summary>
            <param name="codePoints"> The code array. </param>
            <param name="offset"> The start of the text in the code point array. </param>
            <param name="count"> The number of code points. </param>
            <returns> a char array representing the code points between offset and count. </returns>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF8toUTF16(System.Byte[],System.Int32,System.Int32,Lucene.Net.Util.CharsRef)">
            <summary>
            Interprets the given byte array as UTF-8 and converts to UTF-16. The <see cref="T:Lucene.Net.Util.CharsRef"/> will be extended if
            it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.
            <para/>
            NOTE: Full characters are read, even if this reads past the length passed (and
            can result in an <see cref="T:System.IndexOutOfRangeException"/> if invalid UTF-8 is passed).
            Explicit checks for valid UTF-8 are not performed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF8toUTF16(Lucene.Net.Util.BytesRef,Lucene.Net.Util.CharsRef)">
            <summary>
            Utility method for <see cref="M:Lucene.Net.Util.UnicodeUtil.UTF8toUTF16(System.Byte[],System.Int32,System.Int32,Lucene.Net.Util.CharsRef)"/> </summary>
            <seealso cref="M:Lucene.Net.Util.UnicodeUtil.UTF8toUTF16(System.Byte[],System.Int32,System.Int32,Lucene.Net.Util.CharsRef)"/>
        </member>
        <member name="T:Lucene.Net.Util.LuceneVersion">
             <summary>
             Use by certain classes to match version compatibility
             across releases of Lucene.
            
             <para><b>WARNING</b>: When changing the version parameter
             that you supply to components in Lucene, do not simply
             change the version at search-time, but instead also adjust
             your indexing code to match, and re-index.</para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_30">
            <summary>
            Match settings and bugs in Lucene's 3.0 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_31">
            <summary>
            Match settings and bugs in Lucene's 3.1 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_32">
            <summary>
            Match settings and bugs in Lucene's 3.2 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_33">
            <summary>
            Match settings and bugs in Lucene's 3.3 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_34">
            <summary>
            Match settings and bugs in Lucene's 3.4 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_35">
            <summary>
            Match settings and bugs in Lucene's 3.5 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_36">
            <summary>
            Match settings and bugs in Lucene's 3.6 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_40">
            <summary>
            Match settings and bugs in Lucene's 3.6 release. </summary>
            @deprecated (4.1) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_41">
            <summary>
            Match settings and bugs in Lucene's 4.1 release. </summary>
            @deprecated (4.2) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_42">
            <summary>
            Match settings and bugs in Lucene's 4.2 release. </summary>
            @deprecated (4.3) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_43">
            <summary>
            Match settings and bugs in Lucene's 4.3 release. </summary>
            @deprecated (4.4) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_44">
            <summary>
            Match settings and bugs in Lucene's 4.4 release. </summary>
            @deprecated (4.5) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_45">
            <summary>
            Match settings and bugs in Lucene's 4.5 release. </summary>
            @deprecated (4.6) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_46">
            <summary>
            Match settings and bugs in Lucene's 4.6 release. </summary>
            @deprecated (4.7) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_47">
            <summary>
            Match settings and bugs in Lucene's 4.7 release. </summary>
            @deprecated (4.8) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_48">
            <summary>
            Match settings and bugs in Lucene's 4.8 release.
            <para/>
            Use this to get the latest &amp; greatest settings, bug
            fixes, etc, for Lucene.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_CURRENT">
            <summary>
            <para/><b>WARNING</b>: if you use this setting, and then
            upgrade to a newer release of Lucene, sizable changes
            may happen.  If backwards compatibility is important
            then you should instead explicitly specify an actual
            version.
            <para/>
            If you use this constant then you  may need to
            <b>re-index all of your documents</b> when upgrading
            Lucene, as the way text is indexed may have changed.
            Additionally, you may need to <b>re-test your entire
            application</b> to ensure it behaves as expected, as
            some defaults may have changed and may break functionality
            in your application. </summary>
            @deprecated Use an actual version instead.
        </member>
        <member name="T:Lucene.Net.Util.LuceneVersionExtensions">
            <summary>
            Extension methods to the <see cref="T:Lucene.Net.Util.LuceneVersion"/> enumeration to provide
            version comparison and parsing functionality.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.VirtualMethod">
             <summary>
             A utility for keeping backwards compatibility on previously abstract methods
             (or similar replacements).
             <para>Before the replacement method can be made abstract, the old method must kept deprecated.
             If somebody still overrides the deprecated method in a non-sealed class,
             you must keep track, of this and maybe delegate to the old method in the subclass.
             The cost of reflection is minimized by the following usage of this class:</para>
             <para>Define <strong>static readonly</strong> fields in the base class (<c>BaseClass</c>),
             where the old and new method are declared:</para>
             <code>
             internal static readonly VirtualMethod newMethod =
                 new VirtualMethod(typeof(BaseClass), "newName", parameters...);
             internal static readonly VirtualMethod oldMethod =
                 new VirtualMethod(typeof(BaseClass), "oldName", parameters...);
             </code>
             <para>this enforces the singleton status of these objects, as the maintenance of the cache would be too costly else.
             If you try to create a second instance of for the same method/<c>baseClass</c> combination, an exception is thrown.</para>
             <para>To detect if e.g. the old method was overridden by a more far subclass on the inheritance path to the current
             instance's class, use a <strong>non-static</strong> field:</para>
             <code>
              bool isDeprecatedMethodOverridden =
                  oldMethod.GetImplementationDistance(this.GetType()) > newMethod.GetImplementationDistance(this.GetType());
            
              <em>// alternatively (more readable):</em>
              bool isDeprecatedMethodOverridden =
                  VirtualMethod.CompareImplementationDistance(this.GetType(), oldMethod, newMethod) > 0
             </code>
             <para><seealso cref="M:Lucene.Net.Util.VirtualMethod.GetImplementationDistance(System.Type)"/> returns the distance of the subclass that overrides this method.
             The one with the larger distance should be used preferable.
             this way also more complicated method rename scenarios can be handled
             (think of 2.9 <see cref="T:Lucene.Net.Analysis.TokenStream"/> deprecations).</para>
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.VirtualMethod.#ctor(System.Type,System.String,System.Type[])">
            <summary>
            Creates a new instance for the given <paramref name="baseClass"/> and method declaration. </summary>
            <exception cref="T:System.InvalidOperationException"> if you create a second instance of the same
            <paramref name="baseClass"/> and method declaration combination. This enforces the singleton status. </exception>
            <exception cref="T:System.ArgumentException"> If <paramref name="baseClass"/> does not declare the given method. </exception>
        </member>
        <member name="M:Lucene.Net.Util.VirtualMethod.GetImplementationDistance(System.Type)">
            <summary>
            Returns the distance from the <c>baseClass</c> in which this method is overridden/implemented
            in the inheritance path between <c>baseClass</c> and the given subclass <paramref name="subclazz"/>. </summary>
            <returns> 0 if and only if not overridden, else the distance to the base class. </returns>
        </member>
        <member name="M:Lucene.Net.Util.VirtualMethod.IsOverriddenAsOf(System.Type)">
            <summary>
            Returns, if this method is overridden/implemented in the inheritance path between
            <c>baseClass</c> and the given subclass <paramref name="subclazz"/>.
            <para/>You can use this method to detect if a method that should normally be final was overridden
            by the given instance's class. </summary>
            <returns> <c>false</c> if and only if not overridden. </returns>
        </member>
        <member name="M:Lucene.Net.Util.VirtualMethod.CompareImplementationDistance(System.Type,Lucene.Net.Util.VirtualMethod,Lucene.Net.Util.VirtualMethod)">
            <summary>
            Utility method that compares the implementation/override distance of two methods. </summary>
            <returns> 
            <list type="bullet">
                <item><description>&gt; 1, iff <paramref name="m1"/> is overridden/implemented in a subclass of the class overriding/declaring <paramref name="m2"/></description></item>
                <item><description>&lt; 1, iff <paramref name="m2"/> is overridden in a subclass of the class overriding/declaring <paramref name="m1"/></description></item>
                <item><description>0, iff both methods are overridden in the same class (or are not overridden at all)</description></item>
            </list>
            </returns>
        </member>
        <member name="T:Lucene.Net.Util.WAH8DocIdSet">
            <summary>
            <see cref="T:Lucene.Net.Search.DocIdSet"/> implementation based on word-aligned hybrid encoding on
            words of 8 bits.
            <para>This implementation doesn't support random-access but has a fast
            <see cref="T:Lucene.Net.Search.DocIdSetIterator"/> which can advance in logarithmic time thanks to
            an index.</para>
            <para>The compression scheme is simplistic and should work well with sparse and
            very dense doc id sets while being only slightly larger than a
            <see cref="T:Lucene.Net.Util.FixedBitSet"/> for incompressible sets (overhead&lt;2% in the worst
            case) in spite of the index.</para>
            <para><b>Format</b>: The format is byte-aligned. An 8-bits word is either clean,
            meaning composed only of zeros or ones, or dirty, meaning that it contains
            between 1 and 7 bits set. The idea is to encode sequences of clean words
            using run-length encoding and to leave sequences of dirty words as-is.</para>
            <list type="table">
                <listheader><term>Token</term><term>Clean length+</term><term>Dirty length+</term><term>Dirty words</term></listheader>
                <item><term>1 byte</term><term>0-n bytes</term><term>0-n bytes</term><term>0-n bytes</term></item>
            </list>
            <list type="bullet">
                <item><term><b>Token</b></term><description> encodes whether clean means full of zeros or ones in the
                    first bit, the number of clean words minus 2 on the next 3 bits and the
                    number of dirty words on the last 4 bits. The higher-order bit is a
                    continuation bit, meaning that the number is incomplete and needs additional
                    bytes to be read.</description></item>
                <item><term><b>Clean length+</b>:</term><description> If clean length has its higher-order bit set,
                    you need to read a vint (<see cref="M:Lucene.Net.Store.DataInput.ReadVInt32"/>), shift it by 3 bits on
                    the left side and add it to the 3 bits which have been read in the token.</description></item>
                <item><term><b>Dirty length+</b></term><description> works the same way as <b>Clean length+</b> but
                    on 4 bits and for the length of dirty words.</description></item>
                <item><term><b>Dirty words</b></term><description>are the dirty words, there are <b>Dirty length</b>
                    of them.</description></item>
            </list>
            <para>This format cannot encode sequences of less than 2 clean words and 0 dirty
            word. The reason is that if you find a single clean word, you should rather
            encode it as a dirty word. This takes the same space as starting a new
            sequence (since you need one byte for the token) but will be lighter to
            decode. There is however an exception for the first sequence. Since the first
            sequence may start directly with a dirty word, the clean length is encoded
            directly, without subtracting 2.</para>
            <para>There is an additional restriction on the format: the sequence of dirty
            words is not allowed to contain two consecutive clean words. This restriction
            exists to make sure no space is wasted and to make sure iterators can read
            the next doc ID by reading at most 2 dirty words.</para>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.WAH8DocIdSet.DEFAULT_INDEX_INTERVAL">
            <summary>
            Default index interval. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Intersect(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet})">
            <summary>
            Same as <see cref="M:Lucene.Net.Util.WAH8DocIdSet.Intersect(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet},System.Int32)"/> with the default index interval. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Intersect(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet},System.Int32)">
            <summary>
            Compute the intersection of the provided sets. This method is much faster than
            computing the intersection manually since it operates directly at the byte level.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet})">
            <summary>
            Same as <see cref="M:Lucene.Net.Util.WAH8DocIdSet.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet},System.Int32)"/> with the default index interval. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet},System.Int32)">
            <summary>
            Compute the union of the provided sets. This method is much faster than
            computing the union manually since it operates directly at the byte level.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.WAH8DocIdSet.WordBuilder">
            <summary>
            Word-based builder. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.WordBuilder.SetIndexInterval(System.Int32)">
            <summary>
            Set the index interval. Smaller index intervals improve performance of
            <see cref="M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)"/> but make the <see cref="T:Lucene.Net.Search.DocIdSet"/>
            larger. An index interval <c>i</c> makes the index add an overhead
            which is at most <c>4/i</c>, but likely much less. The default index
            interval is <c>8</c>, meaning the index has an overhead of at most
            50%. To disable indexing, you can pass <see cref="F:System.Int32.MaxValue"/> as an
            index interval.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.WordBuilder.Build">
            <summary>
            Build a new <see cref="T:Lucene.Net.Util.WAH8DocIdSet"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.WAH8DocIdSet.Builder">
            <summary>
            A builder for <see cref="T:Lucene.Net.Util.WAH8DocIdSet"/>s. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Builder.#ctor">
            <summary>
            Sole constructor </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Builder.Add(System.Int32)">
            <summary>
            Add a document to this builder. Documents must be added in order. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Builder.Add(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Add the content of the provided <see cref="T:Lucene.Net.Search.DocIdSetIterator"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Cardinality">
            <summary>
            Return the number of documents in this <see cref="T:Lucene.Net.Search.DocIdSet"/> in constant time. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.RamBytesUsed">
            <summary>
            Return the memory usage of this class in bytes. </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
    </members>
</doc>
