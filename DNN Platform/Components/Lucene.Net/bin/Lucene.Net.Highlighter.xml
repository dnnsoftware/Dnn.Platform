<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lucene.Net.Highlighter</name>
    </assembly>
    <members>
        <member name="T:Lucene.Net.Search.Highlight.DefaultEncoder">
            <summary>Simple <see cref="T:Lucene.Net.Search.Highlight.IEncoder"/> implementation that does not modify the output</summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.GradientFormatter">
            <summary>
            Formats text with different color intensity depending on the score of the term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.GradientFormatter.#ctor(System.Single,System.String,System.String,System.String,System.String)">
            <summary> Sets the color range for the IDF scores</summary>
            <param name="maxScore">
            The score (and above) displayed as maxColor (See <see cref="P:Lucene.Net.Search.Highlight.QueryScorer.MaxTermWeight"/>
            which can be used to callibrate scoring scale)
            </param>
            <param name="minForegroundColor">
            The hex color used for representing IDF scores of zero eg
            #FFFFFF (white) or null if no foreground color required
            </param>
            <param name="maxForegroundColor">
            The largest hex color used for representing IDF scores eg
            #000000 (black) or null if no foreground color required
            </param>
            <param name="minBackgroundColor">
            The hex color used for representing IDF scores of zero eg
            #FFFFFF (white) or null if no background color required
            </param>
            <param name="maxBackgroundColor">
            The largest hex color used for representing IDF scores eg
            #000000 (black) or null if no background color required
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.GradientFormatter.Int32ToHex(System.Int32)">
            <summary>
            NOTE: This was intToHex() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.GradientFormatter.HexToInt32(System.String)">
            <summary> 
            Converts a hex string into an <see cref="T:System.Int32"/>.
            <para/>
            NOTE: This was hexToInt() in Lucene
            </summary>
            <param name="hex">
            A string in capital or lower case hex, of no more then 16
            characters.
            </param>
            <exception cref="T:System.FormatException">if the string is more than 16 characters long, or if any
            character is not in the set [0-9a-fA-f]</exception>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.Highlighter">
            <summary>
            Class used to markup highlighted terms found in the best sections of a
            text, using configurable <see cref="T:Lucene.Net.Search.Highlight.IFragmenter"/>, <see cref="T:Lucene.Net.Search.Scorer"/>, <see cref="T:Lucene.Net.Search.Highlight.IFormatter"/>,
            <see cref="T:Lucene.Net.Search.Highlight.IEncoder"/> and tokenizers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragment(Lucene.Net.Analysis.Analyzer,System.String,System.String)">
            <summary>
            Highlights chosen terms in a text, extracting the most relevant section.
            This is a convenience method that calls <see cref="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragment(Lucene.Net.Analysis.TokenStream,System.String)"/>
            </summary>
            <param name="analyzer">the analyzer that will be used to split <paramref name="text"/> into chunks</param>
            <param name="fieldName">Name of field used to influence analyzer's tokenization policy</param>
            <param name="text">text to highlight terms in</param>
            <returns>highlighted text fragment or null if no terms found</returns>
            <exception cref="T:Lucene.Net.Search.Highlight.InvalidTokenOffsetsException">thrown if any token's EndOffset exceeds the provided text's length</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragment(Lucene.Net.Analysis.TokenStream,System.String)">
            <summary>
            Highlights chosen terms in a text, extracting the most relevant section.
            The document text is analysed in chunks to record hit statistics
            across the document. After accumulating stats, the fragment with the highest score
            is returned
            </summary>
            <param name="tokenStream">
            A stream of tokens identified in the text parameter, including offset information.
            This is typically produced by an analyzer re-parsing a document's
            text. Some work may be done on retrieving TokenStreams more efficiently
            by adding support for storing original text position data in the Lucene
            index but this support is not currently available (as of Lucene 1.4 rc2).
            </param>
            <param name="text">text to highlight terms in</param>
            <returns>highlighted text fragment or null if no terms found</returns>
            <exception cref="T:Lucene.Net.Search.Highlight.InvalidTokenOffsetsException">thrown if any token's EndOffset exceeds the provided text's length</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragments(Lucene.Net.Analysis.Analyzer,System.String,System.String,System.Int32)">
            <summary>
            Highlights chosen terms in a text, extracting the most relevant sections.
            This is a convenience method that calls <see cref="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragments(Lucene.Net.Analysis.TokenStream,System.String,System.Int32)"/>
            </summary>
            <param name="analyzer">the analyzer that will be used to split <paramref name="text"/> into chunks</param>
            <param name="fieldName">the name of the field being highlighted (used by analyzer)</param>
            <param name="text">text to highlight terms in</param>
            <param name="maxNumFragments">the maximum number of fragments.</param>
            <returns>highlighted text fragments (between 0 and <paramref name="maxNumFragments"/> number of fragments)</returns>
            <exception cref="T:Lucene.Net.Search.Highlight.InvalidTokenOffsetsException">thrown if any token's EndOffset exceeds the provided text's length</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragments(Lucene.Net.Analysis.TokenStream,System.String,System.Int32)">
            <summary>
            Highlights chosen terms in a text, extracting the most relevant sections.
            The document text is analysed in chunks to record hit statistics
            across the document. After accumulating stats, the fragments with the highest scores
            are returned as an array of strings in order of score (contiguous fragments are merged into
            one in their original order to improve readability)
            </summary>
            <param name="tokenStream"></param>
            <param name="text">text to highlight terms in</param>
            <param name="maxNumFragments">the maximum number of fragments.</param>
            <returns>highlighted text fragments (between 0 and <paramref name="maxNumFragments"/> number of fragments)</returns>
            <exception cref="T:Lucene.Net.Search.Highlight.InvalidTokenOffsetsException">thrown if any token's EndOffset exceeds the provided text's length</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.GetBestTextFragments(Lucene.Net.Analysis.TokenStream,System.String,System.Boolean,System.Int32)">
            <summary>
            Low level api to get the most relevant (formatted) sections of the document.
            This method has been made public to allow visibility of score information held in <see cref="T:Lucene.Net.Search.Highlight.TextFragment"/> objects.
            Thanks to Jason Calabrese for help in redefining the interface.
            </summary>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
            <exception cref="T:Lucene.Net.Search.Highlight.InvalidTokenOffsetsException">thrown if any token's EndOffset exceeds the provided text's length</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.MergeContiguousFragments(Lucene.Net.Search.Highlight.TextFragment[])">
            <summary>
            Improves readability of a score-sorted list of TextFragments by merging any fragments
            that were contiguous in the original text into one larger fragment with the correct order.
            This will leave a "null" in the array entry for the lesser scored fragment. 
            </summary>
            <param name="frag">An array of document fragments in descending score</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragments(Lucene.Net.Analysis.TokenStream,System.String,System.Int32,System.String)">
            <summary>
            Highlights terms in the <paramref name="text"/>, extracting the most relevant sections
            and concatenating the chosen fragments with a separator (typically "...").
            The document text is analysed in chunks to record hit statistics
            across the document. After accumulating stats, the fragments with the highest scores
            are returned in order as "separator" delimited strings.
            </summary>
            <param name="tokenStream"></param>
            <param name="text">text to highlight terms in</param>
            <param name="maxNumFragments">the maximum number of fragments.</param>
            <param name="separator">the separator used to intersperse the document fragments (typically "...")</param>
            <returns>highlighted text</returns>
            <exception cref="T:Lucene.Net.Search.Highlight.InvalidTokenOffsetsException">thrown if any token's EndOffset exceeds the provided text's length</exception>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.IEncoder">
            <summary>Encodes original text. The <see cref="T:Lucene.Net.Search.Highlight.IEncoder"/> works with the <see cref="T:Lucene.Net.Search.Highlight.IFormatter"/> to generate the output.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IEncoder.EncodeText(System.String)">
            <param name="originalText">The section of text being output</param>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.IFormatter">
            <summary> Processes terms found in the original text, typically by applying some form 
            of mark-up to highlight terms in HTML search results pages.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IFormatter.HighlightTerm(System.String,Lucene.Net.Search.Highlight.TokenGroup)">
            <param name="originalText">The section of text being considered for markup</param>
            <param name="tokenGroup">contains one or several overlapping Tokens along with
            their scores and positions.</param>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.IFragmenter">
            <summary> Implements the policy for breaking text into multiple fragments for consideration
            by the <see cref="T:Lucene.Net.Search.Highlight.Highlighter"/> class. A sophisticated implementation may do this on the basis
            of detecting end of sentences in the text. 
            </summary>
            <author>  mark@searcharea.co.uk </author>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IFragmenter.Start(System.String,Lucene.Net.Analysis.TokenStream)">
             <summary>
             Initializes the Fragmenter. You can grab references to the Attributes you are
             interested in from <paramref name="tokenStream"/> and then access the values in <see cref="M:Lucene.Net.Search.Highlight.IFragmenter.IsNewFragment"/>.
             </summary>
             <param name="originalText">the original source text</param>
            <param name="tokenStream">tokenStream the <see cref="T:Lucene.Net.Analysis.TokenStream" /> to be fragmented</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IFragmenter.IsNewFragment">
            <summary>
            Test to see if this token from the stream should be held in a new
            <see cref="T:Lucene.Net.Search.Highlight.TextFragment"/>. Every time this is called, the TokenStream
            passed to <see cref="M:Lucene.Net.Search.Highlight.IFragmenter.Start(System.String,Lucene.Net.Analysis.TokenStream)"/> will have been incremented.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.InvalidTokenOffsetsException">
            <summary>
            Exception thrown if TokenStream Tokens are incompatible with provided text
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.InvalidTokenOffsetsException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.IScorer">
            <summary>
            A <see cref="T:Lucene.Net.Search.Highlight.IScorer"/> is responsible for scoring a stream of tokens. These token scores
            can then be used to compute <see cref="T:Lucene.Net.Search.Highlight.TextFragment"/> scores.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IScorer.Init(Lucene.Net.Analysis.TokenStream)">
            <summary>
            Called to init the Scorer with a <see cref="T:Lucene.Net.Analysis.TokenStream"/>. You can grab references to
            the attributes you are interested in here and access them from <see cref="M:Lucene.Net.Search.Highlight.IScorer.GetTokenScore"/>.
            </summary>
            <param name="tokenStream">the <see cref="T:Lucene.Net.Analysis.TokenStream"/> that will be scored.</param>
            <returns>
            either a <see cref="T:Lucene.Net.Analysis.TokenStream"/> that the <see cref="T:Lucene.Net.Search.Highlight.Highlighter"/> should continue using (eg
            if you read the tokenSream in this method) or null to continue
            using the same <see cref="T:Lucene.Net.Analysis.TokenStream"/> that was passed in.
            </returns> 
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IScorer.StartFragment(Lucene.Net.Search.Highlight.TextFragment)">
            <summary>
            Called when a new fragment is started for consideration.
            </summary>
            <param name="newFragment">the fragment that will be scored next</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IScorer.GetTokenScore">
            <summary>
            Called for each token in the current fragment. The <see cref="T:Lucene.Net.Search.Highlight.Highlighter"/> will
            increment the <see cref="T:Lucene.Net.Analysis.TokenStream"/> passed to init on every call.
            </summary>
            <returns>a score which is passed to the <see cref="T:Lucene.Net.Search.Highlight.Highlighter"/> class to influence the
            mark-up of the text (this return value is NOT used to score the
            fragment)</returns> 
        </member>
        <member name="P:Lucene.Net.Search.Highlight.IScorer.FragmentScore">
            <summary>
             Called when the <see cref="T:Lucene.Net.Search.Highlight.Highlighter"/> has no more tokens for the current fragment -
             the <see cref="T:Lucene.Net.Search.Highlight.IScorer"/> returns the weighting it has derived for the most recent
             fragment, typically based on the results of <see cref="M:Lucene.Net.Search.Highlight.IScorer.GetTokenScore"/>.
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.NullFragmenter">
            <summary> <see cref="T:Lucene.Net.Search.Highlight.IFragmenter"/> implementation which does not fragment the text.
            This is useful for highlighting the entire content of a document or field.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.OffsetLimitTokenFilter">
            <summary>
            This <see cref="T:Lucene.Net.Analysis.TokenFilter"/> limits the number of tokens while indexing by adding up the
            current offset.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.PositionSpan">
            <summary>
            Utility class to record Positions Spans
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.QueryScorer">
            <summary>
             <see cref="T:Lucene.Net.Search.Highlight.IScorer"/> implementation which scores text fragments by the number of
             unique query terms found. This class converts appropriate <see cref="T:Lucene.Net.Search.Query"/>s to
             <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/>s and attempts to score only those terms that participated in
             generating the 'hit' on the document.
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.#ctor(Lucene.Net.Search.Query)">
            <summary>
            Constructs a new <see cref="T:Lucene.Net.Search.Highlight.QueryScorer"/> instance
            </summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> to use for highlighting</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.#ctor(Lucene.Net.Search.Query,System.String)">
            <summary>
            Constructs a new <see cref="T:Lucene.Net.Search.Highlight.QueryScorer"/> instance
            </summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> to use for highlighting</param>
            <param name="field">Field to highlight - pass null to ignore fields</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.#ctor(Lucene.Net.Search.Query,Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Constructs a new <see cref="T:Lucene.Net.Search.Highlight.QueryScorer"/> instance
            </summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> to use for highlighting</param>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> to use for quasi tf/idf scoring</param>
            <param name="field">Field to highlight - pass null to ignore fields</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.#ctor(Lucene.Net.Search.Query,Lucene.Net.Index.IndexReader,System.String,System.String)">
            <summary>
            Constructs a new <see cref="T:Lucene.Net.Search.Highlight.QueryScorer"/> instance
            </summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> to use for highlighting</param>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> to use for quasi tf/idf scoring</param>
            <param name="field">Field to highlight - pass null to ignore fields</param>
            <param name="defaultField">The default field for queries with the field name unspecified</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.#ctor(Lucene.Net.Search.Query,System.String,System.String)">
            <summary>
            Constructs a new <see cref="T:Lucene.Net.Search.Highlight.QueryScorer"/> instance
            </summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> to use for highlighting</param>
            <param name="field">Field to highlight - pass null to ignore fields</param>
            <param name="defaultField">The default field for queries with the field name unspecified</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.#ctor(Lucene.Net.Search.Highlight.WeightedSpanTerm[])">
            <summary>
            Constructs a new <see cref="T:Lucene.Net.Search.Highlight.QueryScorer"/> instance
            </summary>
            <param name="weightedTerms">an array of pre-created <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s</param>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.QueryScorer.FragmentScore">
            <seealso cref="P:Lucene.Net.Search.Highlight.IScorer.FragmentScore"/>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.QueryScorer.MaxTermWeight">
            <summary>
            The highest weighted term (useful for passing to <see cref="T:Lucene.Net.Search.Highlight.GradientFormatter"/> to set top end of coloring scale).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.GetTokenScore">
            <seealso cref="M:Lucene.Net.Search.Highlight.IScorer.GetTokenScore"/>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.Init(Lucene.Net.Analysis.TokenStream)">
            <seealso cref="M:Lucene.Net.Search.Highlight.IScorer.Init(Lucene.Net.Analysis.TokenStream)"/>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.GetWeightedSpanTerm(System.String)">
            <summary>
            Retrieve the <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/> for the specified token. Useful for passing
            Span information to a <see cref="T:Lucene.Net.Search.Highlight.IFragmenter"/>.
            </summary>
            <param name="token">token to get <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/> for</param>
            <returns><see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/> for token</returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.StartFragment(Lucene.Net.Search.Highlight.TextFragment)">
            <seealso cref="M:Lucene.Net.Search.Highlight.IScorer.StartFragment(Lucene.Net.Search.Highlight.TextFragment)"/>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.QueryScorer.ExpandMultiTermQuery">
            <summary>
            Controls whether or not multi-term queries are expanded
            against a <see cref="T:Lucene.Net.Index.Memory.MemoryIndex"/> <see cref="T:Lucene.Net.Index.IndexReader"/>.
            <c>true</c> if multi-term queries should be expanded
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.SetWrapIfNotCachingTokenFilter(System.Boolean)">
            <summary>
            By default, <see cref="T:Lucene.Net.Analysis.TokenStream"/>s that are not of the type
            <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/> are wrapped in a <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/> to
            ensure an efficient reset - if you are already using a different caching
            <see cref="T:Lucene.Net.Analysis.TokenStream"/> impl and you don't want it to be wrapped, set this to
            false.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.QueryTermExtractor">
            <summary> 
            Utility class used to extract the terms used in a query, plus any weights.
            This class will not find terms for <see cref="T:Lucene.Net.Search.MultiTermQuery"/>, RangeQuery and <see cref="T:Lucene.Net.Search.PrefixQuery"/> classes
            so the caller must pass a rewritten query (see <see cref="M:Lucene.Net.Search.Query.Rewrite(Lucene.Net.Index.IndexReader)"/>) to obtain a list of 
            expanded terms.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermExtractor.GetTerms(Lucene.Net.Search.Query)">
            <summary> 
            Extracts all terms texts of a given <see cref="T:Lucene.Net.Search.Query"/> into an array of WeightedTerms
            </summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> to extract term texts from</param>
            <returns> an array of the terms used in a query, plus their weights.</returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermExtractor.GetIdfWeightedTerms(Lucene.Net.Search.Query,Lucene.Net.Index.IndexReader,System.String)">
            <summary> 
            Extracts all terms texts of a given <see cref="T:Lucene.Net.Search.Query"/> into an array of WeightedTerms
            </summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> to extract term texts from</param>
            <param name="reader">used to compute IDF which can be used to a) score selected fragments better 
            b) use graded highlights eg chaning intensity of font color</param>
            <param name="fieldName">the field on which Inverse Document Frequency (IDF) calculations are based</param>
            <returns> an array of the terms used in a query, plus their weights.</returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermExtractor.GetTerms(Lucene.Net.Search.Query,System.Boolean,System.String)">
            <summary>Extracts all terms texts of a given <see cref="T:Lucene.Net.Search.Query"/> into an array of WeightedTerms</summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> to extract term texts from</param>
            <param name="prohibited"><c>true</c> to extract "prohibited" terms, too </param>
            <param name="fieldName"> The fieldName used to filter query terms</param>
            <returns>an array of the terms used in a query, plus their weights.</returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermExtractor.GetTerms(Lucene.Net.Search.Query,System.Boolean)">
            <summary> 
            Extracts all terms texts of a given <see cref="T:Lucene.Net.Search.Query"/> into an array of WeightedTerms
            </summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> to extract term texts from</param>
            <param name="prohibited"><c>true</c> to extract "prohibited" terms, too</param>
            <returns> an array of the terms used in a query, plus their weights.</returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermExtractor.GetTermsFromBooleanQuery(Lucene.Net.Search.BooleanQuery,System.Collections.Generic.ISet{Lucene.Net.Search.Highlight.WeightedTerm},System.Boolean,System.String)">
            <summary> extractTerms is currently the only query-independent means of introspecting queries but it only reveals
            a list of terms for that query - not the boosts each individual term in that query may or may not have.
            "Container" queries such as BooleanQuery should be unwrapped to get at the boost info held
            in each child element. 
            Some discussion around this topic here:
            http://www.gossamer-threads.com/lists/lucene/java-dev/34208?search_string=introspection;#34208
            Unfortunately there seemed to be limited interest in requiring all <see cref="T:Lucene.Net.Search.Query"/> objects to implement
            something common which would allow access to child queries so what follows here are query-specific
            implementations for accessing embedded query elements. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.QueryTermScorer">
            <summary>
            <see cref="T:Lucene.Net.Search.Highlight.IScorer"/> implementation which scores text fragments by the number of
            unique query terms found. This class uses the <see cref="T:Lucene.Net.Search.Highlight.QueryTermExtractor"/>
            class to process determine the query terms and their boosts to be used.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermScorer.#ctor(Lucene.Net.Search.Query)">
            <param name="query">
            a Lucene query (ideally rewritten using <see cref="M:Lucene.Net.Search.Query.Rewrite(Lucene.Net.Index.IndexReader)"/> before
            being passed to this class and the searcher)
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermScorer.#ctor(Lucene.Net.Search.Query,System.String)">
            <param name="query">
            a Lucene query (ideally rewritten using <see cref="M:Lucene.Net.Search.Query.Rewrite(Lucene.Net.Index.IndexReader)"/> before
            being passed to this class and the searcher)
            </param>
            <param name="fieldName">the Field name which is used to match Query terms</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermScorer.#ctor(Lucene.Net.Search.Query,Lucene.Net.Index.IndexReader,System.String)">
            <param name="query">
            a Lucene query (ideally rewritten using <see cref="M:Lucene.Net.Search.Query.Rewrite(Lucene.Net.Index.IndexReader)"/> before
            being passed to this class and the searcher)
            </param>
            <param name="reader">
            used to compute IDF which can be used to a) score selected
            fragments better b) use graded highlights eg set font color
            intensity
            </param>
            <param name="fieldName">
            the field on which Inverse Document Frequency (IDF)
            calculations are based
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermScorer.Init(Lucene.Net.Analysis.TokenStream)">
            <summary>
            <seealso cref="M:Lucene.Net.Search.Highlight.IScorer.Init(Lucene.Net.Analysis.TokenStream)"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermScorer.GetTokenScore">
            <summary>
            <seealso cref="M:Lucene.Net.Search.Highlight.IScorer.GetTokenScore"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.QueryTermScorer.FragmentScore">
            <summary>
            <seealso cref="P:Lucene.Net.Search.Highlight.IScorer.FragmentScore"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.QueryTermScorer.MaxTermWeight">
            <summary>
            The highest weighted term (useful for passing to <see cref="T:Lucene.Net.Search.Highlight.GradientFormatter"/> 
            to set top end of coloring scale.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.SimpleFragmenter">
            <summary>
            <see cref="T:Lucene.Net.Search.Highlight.IFragmenter"/> implementation which breaks text up into same-size
            fragments with no concerns over spotting sentence boundaries.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleFragmenter.#ctor(System.Int32)">
            <param name="fragmentSize">size in number of characters of each fragment</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleFragmenter.Start(System.String,Lucene.Net.Analysis.TokenStream)">
            <summary>
            <seealso cref="M:Lucene.Net.Search.Highlight.IFragmenter.Start(System.String,Lucene.Net.Analysis.TokenStream)"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleFragmenter.IsNewFragment">
            <summary>
            <seealso cref="M:Lucene.Net.Search.Highlight.IFragmenter.IsNewFragment"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.SimpleFragmenter.FragmentSize">
            <summary>
            Gets or Sets size in number of characters of each fragment
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.SimpleHTMLEncoder">
            <summary>
            Simple <see cref="T:Lucene.Net.Search.Highlight.IEncoder"/> implementation to escape text for HTML output
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleHTMLEncoder.HtmlEncode(System.String)">
            <summary>
            Encode string into HTML
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.SimpleHTMLFormatter">
            <summary> Simple <see cref="T:Lucene.Net.Search.Highlight.IFormatter"/> implementation to highlight terms with a pre and post tag</summary>
            <author>  MAHarwood </author>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleHTMLFormatter.#ctor">
            <summary> 
            Default constructor uses HTML: &lt;B&gt; tags to markup terms
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleHTMLFormatter.HighlightTerm(System.String,Lucene.Net.Search.Highlight.TokenGroup)">
            <summary>
            <seealso cref="M:Lucene.Net.Search.Highlight.IFormatter.HighlightTerm(System.String,Lucene.Net.Search.Highlight.TokenGroup)"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.SimpleSpanFragmenter">
            <summary>
            <see cref="T:Lucene.Net.Search.Highlight.IFragmenter"/> implementation which breaks text up into same-size
            fragments but does not split up <see cref="T:Lucene.Net.Search.Spans.Spans"/>. This is a simple sample class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleSpanFragmenter.#ctor(Lucene.Net.Search.Highlight.QueryScorer)">
            <param name="queryScorer"><see cref="T:Lucene.Net.Search.Highlight.QueryScorer"/> that was used to score hits</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleSpanFragmenter.#ctor(Lucene.Net.Search.Highlight.QueryScorer,System.Int32)">
            <param name="queryScorer"><see cref="T:Lucene.Net.Search.Highlight.QueryScorer"/> that was used to score hits</param>
            <param name="fragmentSize">size in bytes of each fragment</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleSpanFragmenter.IsNewFragment">
            <seealso cref="M:Lucene.Net.Search.Highlight.IFragmenter.IsNewFragment"/>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleSpanFragmenter.Start(System.String,Lucene.Net.Analysis.TokenStream)">
            <seealso cref="M:Lucene.Net.Search.Highlight.IFragmenter.Start(System.String,Lucene.Net.Analysis.TokenStream)"/>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.SpanGradientFormatter">
            <summary>
            Formats text with different color intensity depending on the score of the
            term using the span tag. <see cref="T:Lucene.Net.Search.Highlight.GradientFormatter"/> uses a bgcolor argument to the font tag which
            doesn't work in Mozilla, thus this class.
            </summary>
            <seealso cref="T:Lucene.Net.Search.Highlight.GradientFormatter"/>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.TextFragment">
            <summary> 
            Low-level class used to record information about a section of a document 
            with a score.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.TextFragment.FragNum">
            <summary>
            the fragment sequence number
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TextFragment.Merge(Lucene.Net.Search.Highlight.TextFragment)">
            <param name="frag2">Fragment to be merged into this one</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TextFragment.Follows(Lucene.Net.Search.Highlight.TextFragment)">
            <summary>
            true if this fragment follows the one passed
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TextFragment.ToString">
            <summary>
            Returns the marked-up text for this text fragment 
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.TokenGroup">
            <summary>
            One, or several overlapping tokens, along with the score(s) and the scope of
            the original text
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.TokenGroup.NumTokens">
            <summary>
            the number of tokens in this group
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.TokenGroup.StartOffset">
            <summary>
            the start position in the original text
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.TokenGroup.EndOffset">
            <summary>
            the end position in the original text
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.TokenGroup.TotalScore">
            <summary>
            all tokens' scores summed up
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TokenGroup.GetToken(System.Int32)">
            <summary>
            the "n"th token
            </summary>
            <param name="index">a value between 0 and numTokens -1</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TokenGroup.GetScore(System.Int32)">
            <summary>
            the "n"th score
            </summary>
            <param name="index">a value between 0 and numTokens -1</param>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.TokenSources">
            <summary>
             Hides implementation issues associated with obtaining a <see cref="T:Lucene.Net.Analysis.TokenStream"/> for use with 
             the <see cref="T:Lucene.Net.Search.Highlight.Highlighter"/> - can obtain from
             term vectors with offsets and positions or from an Analyzer re-parsing the stored content.
             see TokenStreamFromTermVector
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TokenSources.GetAnyTokenStream(Lucene.Net.Index.IndexReader,System.Int32,System.String,Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            <summary>
            A convenience method that tries to first get a TermPositionVector for the specified docId, then, falls back to
            using the passed in <see cref="T:Lucene.Net.Documents.Document"/> to retrieve the <see cref="T:Lucene.Net.Analysis.TokenStream"/>.  This is useful when
            you already have the document, but would prefer to use the vector first.
            </summary>
            <param name="reader">The <see cref="T:Lucene.Net.Index.IndexReader"/> to use to try and get the vector from</param>
            <param name="docId">The docId to retrieve.</param>
            <param name="field">The field to retrieve on the document</param>
            <param name="doc">The document to fall back on</param>
            <param name="analyzer">The analyzer to use for creating the TokenStream if the vector doesn't exist</param>
            <returns>The <see cref="T:Lucene.Net.Analysis.TokenStream"/> for the <see cref="T:Lucene.Net.Index.IIndexableField"/> on the <see cref="T:Lucene.Net.Documents.Document"/></returns>
            <exception cref="T:System.IO.IOException">if there was an error loading</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TokenSources.GetAnyTokenStream(Lucene.Net.Index.IndexReader,System.Int32,System.String,Lucene.Net.Analysis.Analyzer)">
            <summary>
            A convenience method that tries a number of approaches to getting a token stream.
            The cost of finding there are no termVectors in the index is minimal (1000 invocations still 
            registers 0 ms). So this "lazy" (flexible?) approach to coding is probably acceptable
            </summary>
            <returns>null if field not stored correctly</returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TokenSources.GetTokenStream(Lucene.Net.Index.Terms,System.Boolean)">
            <summary>
            Low level api. Returns a token stream generated from a <see cref="T:Lucene.Net.Index.Terms"/>. This
            can be used to feed the highlighter with a pre-parsed token
            stream.  The <see cref="T:Lucene.Net.Index.Terms"/> must have offsets available.
            <para/>
            In my tests the speeds to recreate 1000 token streams using this method are:
            <list type="bullet">
                <item><description>
                with TermVector offset only data stored - 420  milliseconds 
                </description></item>
                <item><description>
                with TermVector offset AND position data stored - 271 milliseconds
                (nb timings for TermVector with position data are based on a tokenizer with contiguous
                positions - no overlaps or gaps)
                </description></item>
                <item><description>
                The cost of not using TermPositionVector to store
                pre-parsed content and using an analyzer to re-parse the original content:
                - reanalyzing the original content - 980 milliseconds
                </description></item>
            </list>
            
            The re-analyze timings will typically vary depending on -
            <list type="number">
                <item><description>
                The complexity of the analyzer code (timings above were using a
                stemmer/lowercaser/stopword combo)
                </description></item>
                <item><description>
                The  number of other fields (Lucene reads ALL fields off the disk 
                when accessing just one document field - can cost dear!)
                </description></item>
                <item><description>
                Use of compression on field storage - could be faster due to compression (less disk IO)
                or slower (more CPU burn) depending on the content.
                </description></item>
            </list>
            </summary>
            <param name="tpv"></param>
            <param name="tokenPositionsGuaranteedContiguous">true if the token position numbers have no overlaps or gaps. If looking
            to eek out the last drops of performance, set to true. If in doubt, set to false.</param>
            <exception cref="T:System.ArgumentException">if no offsets are available</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TokenSources.GetTokenStreamWithOffsets(Lucene.Net.Index.IndexReader,System.Int32,System.String)">
            <summary>
             Returns a <see cref="T:Lucene.Net.Analysis.TokenStream"/> with positions and offsets constructed from
             field termvectors. If the field has no termvectors or offsets
             are not included in the termvector, return null.  See 
             <see cref="M:Lucene.Net.Search.Highlight.TokenSources.GetTokenStream(Lucene.Net.Index.Terms)"/>
             for an explanation of what happens when positions aren't present.
             </summary>
             <param name="reader">the <see cref="T:Lucene.Net.Index.IndexReader"/> to retrieve term vectors from</param>
             <param name="docId">the document to retrieve term vectors for </param>
             <param name="field">the field to retrieve term vectors for</param>
             <returns>a <see cref="T:Lucene.Net.Analysis.TokenStream"/>, or null if offsets are not available</returns>
             <exception cref="T:System.IO.IOException"> If there is a low-level I/O error</exception>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.TokenStreamFromTermPositionVector">
            <summary>
            <see cref="T:Lucene.Net.Analysis.TokenStream"/> created from a term vector field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TokenStreamFromTermPositionVector.#ctor(Lucene.Net.Index.Terms)">
            <summary>Constructor</summary>
             <param name="vector">
             Terms that contains the data for
             creating the <see cref="T:Lucene.Net.Analysis.TokenStream"/>. Must have positions and offsets.
             </param>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.WeightedSpanTerm">
            <summary>
            Lightweight class to hold term, weight, and positions used for scoring this term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTerm.CheckPosition(System.Int32)">
            <summary>
            Checks to see if this term is valid at <paramref name="position"/>.
            </summary>
            <param name="position">to check against valid term postions</param>
            <returns>true iff this term is a hit at this position</returns>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor">
            <summary>
            Class used to extract <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s from a <see cref="T:Lucene.Net.Search.Query"/> based on whether 
            <see cref="T:Lucene.Net.Index.Term"/>s from the <see cref="T:Lucene.Net.Search.Query"/> are contained in a supplied <see cref="T:Lucene.Net.Analysis.TokenStream"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.Extract(Lucene.Net.Search.Query,System.Collections.Generic.IDictionary{System.String,Lucene.Net.Search.Highlight.WeightedSpanTerm})">
            <summary>
            Fills a <see cref="T:IDictionary{string, WeightedSpanTerm}"/> with <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s using the terms from the supplied <paramref name="query"/>.
            </summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> to extract Terms from</param>
            <param name="terms">Map to place created <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s in</param>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.ExtractWeightedSpanTerms(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Search.Highlight.WeightedSpanTerm},Lucene.Net.Search.Spans.SpanQuery)">
            <summary>
            Fills a <see cref="T:IDictionary{string, WeightedSpanTerm}"/> with <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s using the terms from the supplied <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/>.
            </summary>
            <param name="terms"><see cref="T:IDictionary{string, WeightedSpanTerm}"/> to place created <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s in</param>
            <param name="spanQuery"><see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> to extract Terms from</param>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.ExtractWeightedTerms(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Search.Highlight.WeightedSpanTerm},Lucene.Net.Search.Query)">
            <summary>
            Fills a <see cref="T:IDictionary{string, WeightedSpanTerm}"/> with <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s using the terms from 
            the supplied <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/>.
            </summary>
            <param name="terms"><see cref="T:IDictionary{string, WeightedSpanTerm}"/> to place created <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s in</param>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> to extract Terms from</param>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.FieldNameComparer(System.String)">
            <summary>
            Necessary to implement matches for queries against <see cref="F:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.defaultField"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.DelegatingAtomicReader">
            <summary>
            This reader will just delegate every call to a single field in the wrapped
            <see cref="T:Lucene.Net.Index.AtomicReader"/>. This way we only need to build this field once rather than
            N-Times
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.GetWeightedSpanTerms(Lucene.Net.Search.Query,Lucene.Net.Analysis.TokenStream)">
            <summary>
            Creates an <see cref="T:IDictionary{string, WeightedSpanTerm}"/> from the given <see cref="T:Lucene.Net.Search.Query"/> and <see cref="T:Lucene.Net.Analysis.TokenStream"/>.
            </summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> that caused hit</param>
            <param name="tokenStream"><see cref="T:Lucene.Net.Analysis.TokenStream"/> of text to be highlighted</param>
            <returns>Map containing <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s</returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.GetWeightedSpanTerms(Lucene.Net.Search.Query,Lucene.Net.Analysis.TokenStream,System.String)">
            <summary>
            Creates an <see cref="T:IDictionary{string, WeightedSpanTerm}"/> from the given <see cref="T:Lucene.Net.Search.Query"/> and <see cref="T:Lucene.Net.Analysis.TokenStream"/>.
            </summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> that caused hit</param>
            <param name="tokenStream"><see cref="T:Lucene.Net.Analysis.TokenStream"/> of text to be highlighted</param>
            <param name="fieldName">restricts Term's used based on field name</param>
            <returns>Map containing <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s</returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.GetWeightedSpanTermsWithScores(Lucene.Net.Search.Query,Lucene.Net.Analysis.TokenStream,System.String,Lucene.Net.Index.IndexReader)">
            <summary>
            Creates an <see cref="T:IDictionary{string, WeightedSpanTerm}"/> from the given <see cref="T:Lucene.Net.Search.Query"/> and <see cref="T:Lucene.Net.Analysis.TokenStream"/>. Uses a supplied
            <see cref="T:Lucene.Net.Index.IndexReader"/> to properly Weight terms (for gradient highlighting).
            </summary>
            <param name="query"><see cref="T:Lucene.Net.Search.Query"/> that caused hit</param>
            <param name="tokenStream"><see cref="T:Lucene.Net.Analysis.TokenStream"/> of text to be highlighted</param>
            <param name="fieldName">restricts Term's used based on field name</param>
            <param name="reader">to use for scoring</param>
            <returns>Map of <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s with quasi tf/idf scores</returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.PositionCheckingMap`1">
            <summary>
            This class makes sure that if both position sensitive and insensitive
            versions of the same term are added, the position insensitive one wins.
            </summary>
            <typeparam name="K"></typeparam>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.SetWrapIfNotCachingTokenFilter(System.Boolean)">
            <summary>
            By default, <see cref="T:Lucene.Net.Analysis.TokenStream"/>s that are not of the type
            <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/> are wrapped in a <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/> to
            <see cref="T:Lucene.Net.Analysis.TokenStream"/> impl and you don't want it to be wrapped, set this to
            false.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.WeightedTerm">
            <summary>
            Lightweight class to hold term and a Weight value used for scoring this term
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.WeightedTerm.Term">
            <summary>
            the term value (stemmed)
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.WeightedTerm.Weight">
            <summary>
            the Weight associated with this term
            </summary>
            <value> </value>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.BaseFragListBuilder">
            <summary>
            A abstract implementation of <see cref="T:Lucene.Net.Search.VectorHighlight.IFragListBuilder"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.BaseFragListBuilder.AcceptPhrase(Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo,System.Int32,System.Int32)">
            <summary>
            A predicate to decide if the given <see cref="T:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo"/> should be
            accepted as a highlighted phrase or if it should be discarded.
            <para/>
            The default implementation discards phrases that are composed of more than one term
            and where the matchLength exceeds the fragment character size.
            </summary>
            <param name="info">the phrase info to accept</param>
            <param name="matchLength">the match length of the current phrase</param>
            <param name="fragCharSize">the configured fragment character size</param>
            <returns><c>true</c> if this phrase info should be accepted as a highligh phrase</returns>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.BaseFragmentsBuilder">
            <summary>
            Base <see cref="T:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder"/> implementation that supports colored pre/post
            tags and multivalued fields.
            <para/>
            Uses <see cref="T:Lucene.Net.Search.VectorHighlight.IBoundaryScanner"/> to determine fragments.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.IBoundaryScanner">
            <summary>
            Finds fragment boundaries: pluggable into <see cref="T:Lucene.Net.Search.VectorHighlight.BaseFragmentsBuilder"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.IBoundaryScanner.FindStartOffset(System.Text.StringBuilder,System.Int32)">
            <summary>
            Scan backward to find end offset.
            </summary>
            <param name="buffer">scanned object</param>
            <param name="start">offset to begin</param>
            <returns>the found start offset</returns>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.IBoundaryScanner.FindEndOffset(System.Text.StringBuilder,System.Int32)">
            <summary>
            Scan forward to find start offset.
            </summary>
            <param name="buffer">scanned object</param>
            <param name="start">start offset to begin</param>
            <returns>the found end offset</returns>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter">
            <summary>
            Another highlighter implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.#ctor">
            <summary>
            the default constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.#ctor(System.Boolean,System.Boolean)">
            <summary>
            a constructor. Using <see cref="T:Lucene.Net.Search.VectorHighlight.SimpleFragListBuilder"/> and <see cref="T:Lucene.Net.Search.VectorHighlight.ScoreOrderFragmentsBuilder"/>.
            </summary>
            <param name="phraseHighlight">true or false for phrase highlighting</param>
            <param name="fieldMatch">true of false for field matching</param>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.#ctor(System.Boolean,System.Boolean,Lucene.Net.Search.VectorHighlight.IFragListBuilder,Lucene.Net.Search.VectorHighlight.IFragmentsBuilder)">
            <summary>
            a constructor. A <see cref="T:Lucene.Net.Search.VectorHighlight.IFragListBuilder"/> and a <see cref="T:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder"/> can be specified (plugins).
            </summary>
            <param name="phraseHighlight">true of false for phrase highlighting</param>
            <param name="fieldMatch">true of false for field matching</param>
            <param name="fragListBuilder">an instance of <see cref="T:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder"/></param>
            <param name="fragmentsBuilder">an instance of <see cref="T:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder"/></param>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.GetFieldQuery(Lucene.Net.Search.Query)">
            <summary>
            create a <see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> object.
            </summary>
            <param name="query">a query</param>
            <returns>the created <see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> object</returns>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.GetFieldQuery(Lucene.Net.Search.Query,Lucene.Net.Index.IndexReader)">
            <summary>
            create a <see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> object.
            </summary>
            <param name="query">a query</param>
            <param name="reader"></param>
            <returns>the created <see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> object</returns>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.GetBestFragment(Lucene.Net.Search.VectorHighlight.FieldQuery,Lucene.Net.Index.IndexReader,System.Int32,System.String,System.Int32)">
            <summary>
            return the best fragment.
            </summary>
            <param name="fieldQuery"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> object</param>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> of the index</param>
            <param name="docId">document id to be highlighted</param>
            <param name="fieldName">field of the document to be highlighted</param>
            <param name="fragCharSize">the length (number of chars) of a fragment</param>
            <returns>the best fragment (snippet) string</returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.GetBestFragments(Lucene.Net.Search.VectorHighlight.FieldQuery,Lucene.Net.Index.IndexReader,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            return the best fragments.
            </summary>
            <param name="fieldQuery"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> object</param>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> of the index</param>
            <param name="docId">document id to be highlighted</param>
            <param name="fieldName">field of the document to be highlighted</param>
            <param name="fragCharSize">the length (number of chars) of a fragment</param>
            <param name="maxNumFragments">maximum number of fragments</param>
            <returns>
            created fragments or null when no fragments created.
            size of the array can be less than maxNumFragments
            </returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.GetBestFragment(Lucene.Net.Search.VectorHighlight.FieldQuery,Lucene.Net.Index.IndexReader,System.Int32,System.String,System.Int32,Lucene.Net.Search.VectorHighlight.IFragListBuilder,Lucene.Net.Search.VectorHighlight.IFragmentsBuilder,System.String[],System.String[],Lucene.Net.Search.Highlight.IEncoder)">
            <summary>
            return the best fragment.
            </summary>
            <param name="fieldQuery"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> object</param>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> of the index</param>
            <param name="docId">document id to be highlighted</param>
            <param name="fieldName">field of the document to be highlighted</param>
            <param name="fragCharSize">the length (number of chars) of a fragment</param>
            <param name="fragListBuilder"><see cref="T:Lucene.Net.Search.VectorHighlight.IFragListBuilder"/> object</param>
            <param name="fragmentsBuilder"><see cref="T:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder"/> object</param>
            <param name="preTags">pre-tags to be used to highlight terms</param>
            <param name="postTags">post-tags to be used to highlight terms</param>
            <param name="encoder">an encoder that generates encoded text</param>
            <returns>the best fragment (snippet) string</returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.GetBestFragments(Lucene.Net.Search.VectorHighlight.FieldQuery,Lucene.Net.Index.IndexReader,System.Int32,System.String,System.Int32,System.Int32,Lucene.Net.Search.VectorHighlight.IFragListBuilder,Lucene.Net.Search.VectorHighlight.IFragmentsBuilder,System.String[],System.String[],Lucene.Net.Search.Highlight.IEncoder)">
            <summary>
            return the best fragments.
            </summary>
            <param name="fieldQuery"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> object</param>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> of the index</param>
            <param name="docId">document id to be highlighted</param>
            <param name="fieldName">field of the document to be highlighted</param>
            <param name="fragCharSize">the length (number of chars) of a fragment</param>
            <param name="maxNumFragments">maximum number of fragments</param>
            <param name="fragListBuilder"><see cref="T:Lucene.Net.Search.VectorHighlight.IFragListBuilder"/> object</param>
            <param name="fragmentsBuilder"><see cref="T:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder"/> object</param>
            <param name="preTags">pre-tags to be used to highlight terms</param>
            <param name="postTags">post-tags to be used to highlight terms</param>
            <param name="encoder">an encoder that generates encoded text</param>
            <returns>
            created fragments or null when no fragments created.
            size of the array can be less than maxNumFragments
            </returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.GetBestFragments(Lucene.Net.Search.VectorHighlight.FieldQuery,Lucene.Net.Index.IndexReader,System.Int32,System.String,System.Collections.Generic.ISet{System.String},System.Int32,System.Int32,Lucene.Net.Search.VectorHighlight.IFragListBuilder,Lucene.Net.Search.VectorHighlight.IFragmentsBuilder,System.String[],System.String[],Lucene.Net.Search.Highlight.IEncoder)">
            <summary>
            Return the best fragments.  Matches are scanned from <paramref name="matchedFields"/> and turned into fragments against
            <paramref name="storedField"/>.  The highlighting may not make sense if <paramref name="matchedFields"/> has matches with offsets that don't
            correspond features in <paramref name="storedField"/>.  It will outright throw a <see cref="T:System.IndexOutOfRangeException"/>
            if <paramref name="matchedFields"/> produces offsets outside of <paramref name="storedField"/>.  As such it is advisable that all
            <paramref name="matchedFields"/> share the same source as <paramref name="storedField"/> or are at least a prefix of it.
            </summary>
            <param name="fieldQuery"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> object</param>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> of the index</param>
            <param name="docId">document id to be highlighted</param>
            <param name="storedField">field of the document that stores the text</param>
            <param name="matchedFields">fields of the document to scan for matches</param>
            <param name="fragCharSize">the length (number of chars) of a fragment</param>
            <param name="maxNumFragments">maximum number of fragments</param>
            <param name="fragListBuilder"><see cref="T:Lucene.Net.Search.VectorHighlight.IFragListBuilder"/> object</param>
            <param name="fragmentsBuilder"><see cref="T:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder"/> object</param>
            <param name="preTags">pre-tags to be used to highlight terms</param>
            <param name="postTags">post-tags to be used to highlight terms</param>
            <param name="encoder">an encoder that generates encoded text</param>
            <returns>
            created fragments or null when no fragments created.
            size of the array can be less than <paramref name="maxNumFragments"/>
            </returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.GetFieldFragList(Lucene.Net.Search.VectorHighlight.IFragListBuilder,Lucene.Net.Search.VectorHighlight.FieldQuery,Lucene.Net.Index.IndexReader,System.Int32,System.String,System.Int32)">
            <summary>
            Build a <see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList"/> for one field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.GetFieldFragList(Lucene.Net.Search.VectorHighlight.IFragListBuilder,Lucene.Net.Search.VectorHighlight.FieldQuery,Lucene.Net.Index.IndexReader,System.Int32,System.Collections.Generic.ISet{System.String},System.Int32)">
            <summary>
            Build a <see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList"/> for more than one field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.IsPhraseHighlight">
            <summary>
            return whether phraseHighlight or not.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.IsFieldMatch">
            <summary>
            return whether fieldMatch or not.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter.PhraseLimit">
            <summary>
            Gets or Sets the maximum number of phrases to analyze when searching for the highest-scoring phrase.
            The default is unlimited (int.MaxValue).
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.FieldFragList">
            <summary>
            FieldFragList has a list of "frag info" that is used by <see cref="T:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder"/> class
            to create fragments (snippets).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldFragList.#ctor(System.Int32)">
            <summary>
            a constructor.
            </summary>
            <param name="fragCharSize">the length (number of chars) of a fragment</param>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldFragList.Add(System.Int32,System.Int32,System.Collections.Generic.IList{Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo})">
            <summary>
            convert the list of <see cref="T:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo"/> to <see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList.WeightedFragInfo"/>, then add it to the fragInfos
            </summary>
            <param name="startOffset">start offset of the fragment</param>
            <param name="endOffset">end offset of the fragment</param>
            <param name="phraseInfoList">list of <see cref="T:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo"/> objects</param>
        </member>
        <member name="P:Lucene.Net.Search.VectorHighlight.FieldFragList.FragInfos">
            <summary>
            return the list of <see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList.WeightedFragInfo"/>s.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.FieldFragList.WeightedFragInfo">
            <summary>
            List of term offsets + weight for a frag info
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.FieldFragList.WeightedFragInfo.SubInfo">
            <summary>
            Represents the list of term offsets for some text
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.FieldPhraseList">
            <summary>
            FieldPhraseList has a list of WeightedPhraseInfo that is used by FragListBuilder
            to create a FieldFragList object.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.VectorHighlight.FieldPhraseList.phraseList">
            <summary>
            List of non-overlapping <see cref="T:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo"/> objects.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldPhraseList.#ctor(Lucene.Net.Search.VectorHighlight.FieldTermStack,Lucene.Net.Search.VectorHighlight.FieldQuery)">
            <summary>
            create a <see cref="T:Lucene.Net.Search.VectorHighlight.FieldPhraseList"/> that has no limit on the number of phrases to analyze
            </summary>
            <param name="fieldTermStack"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldTermStack"/> object</param>
            <param name="fieldQuery"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> object</param>
        </member>
        <member name="P:Lucene.Net.Search.VectorHighlight.FieldPhraseList.PhraseList">
            <summary>
            return the list of <see cref="T:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldPhraseList.#ctor(Lucene.Net.Search.VectorHighlight.FieldTermStack,Lucene.Net.Search.VectorHighlight.FieldQuery,System.Int32)">
            <summary>
            a constructor.
            </summary>
            <param name="fieldTermStack"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldTermStack"/> object</param>
            <param name="fieldQuery"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> object</param>
            <param name="phraseLimit">maximum size of phraseList</param>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldPhraseList.#ctor(Lucene.Net.Search.VectorHighlight.FieldPhraseList[])">
            <summary>
            Merging constructor.
            </summary>
            <param name="toMerge"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldPhraseList"/>s to merge to build this one</param>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo">
            <summary>
            Represents the list of term offsets and boost for some text
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo.GetText">
            <summary>
            Text of the match, calculated on the fly.  Use for debugging only.
            </summary>
            <returns>the text</returns>
        </member>
        <member name="P:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo.TermsOffsets">
            <summary>
            the termsOffsets
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo.Boost">
            <summary>
            the boost
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo.TermsInfos">
            <summary>
            the termInfos 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo.#ctor(System.Collections.Generic.ICollection{Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo})">
            <summary>
            Merging constructor.  Note that this just grabs seqnum from the first info.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo.Seqnum">
            <summary>
            the seqnum
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo.Toffs">
            <summary>
            Term offsets (start + end)
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.FieldQuery">
            <summary>
            <see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> breaks down query object into terms/phrases and keeps
            them in a <see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery.QueryPhraseMap"/> structure.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldQuery.#ctor(Lucene.Net.Search.Query,System.Boolean,System.Boolean)">
            <summary>
            For backwards compatibility you can initialize <see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> without
            an <see cref="T:Lucene.Net.Index.IndexReader"/>, which is only required to support <see cref="T:Lucene.Net.Search.MultiTermQuery"/>
            </summary>
            <param name="query"></param>
            <param name="phraseHighlight"></param>
            <param name="fieldMatch"></param>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldQuery.ApplyParentBoost(Lucene.Net.Search.Query,Lucene.Net.Search.Query)">
            <summary>
            Push parent's boost into a clone of query if parent has a non 1 boost.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldQuery.Expand(System.Collections.Generic.ICollection{Lucene.Net.Search.Query})">
            <summary>
            Create expandQueries from <paramref name="flatQueries"/>.
            
            <code>
            expandQueries := flatQueries + overlapped phrase queries
            
            ex1) flatQueries={a,b,c}
                => expandQueries={a,b,c}
            ex2) flatQueries={a,"b c","c d"}
                => expandQueries={a,"b c","c d","b c d"}
            </code>
            </summary>
            <param name="flatQueries"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldQuery.CheckOverlap(System.Collections.Generic.ICollection{Lucene.Net.Search.Query},Lucene.Net.Search.PhraseQuery,Lucene.Net.Search.PhraseQuery)">
            <summary>
            Check if <see cref="T:Lucene.Net.Search.PhraseQuery"/> A and B have overlapped part.
            
            <code>
            ex1) A="a b", B="b c" => overlap; expandQueries={"a b c"}
            ex2) A="b c", B="a b" => overlap; expandQueries={"a b c"}
            ex3) A="a b", B="c d" => no overlap; expandQueries={}
            </code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldQuery.CheckOverlap(System.Collections.Generic.ICollection{Lucene.Net.Search.Query},Lucene.Net.Index.Term[],Lucene.Net.Index.Term[],System.Int32,System.Single)">
            <summary>
            Check if src and dest have overlapped part and if it is, create <see cref="T:Lucene.Net.Search.PhraseQuery"/>s and add <paramref name="expandQueries"/>.
            
            <code>
            ex1) src="a b", dest="c d"       => no overlap
            ex2) src="a b", dest="a b c"     => no overlap
            ex3) src="a b", dest="b c"       => overlap; expandQueries={"a b c"}
            ex4) src="a b c", dest="b c d"   => overlap; expandQueries={"a b c d"}
            ex5) src="a b c", dest="b c"     => no overlap
            ex6) src="a b c", dest="b"       => no overlap
            ex7) src="a a a a", dest="a a a" => overlap;
                                                expandQueries={"a a a a a","a a a a a a"}
            ex8) src="a b c d", dest="b c"   => no overlap
            </code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldQuery.GetKey(Lucene.Net.Search.Query)">
            <summary>
            Return 'key' string. 'key' is the field name of the <see cref="T:Lucene.Net.Search.Query"/>.
            If not fieldMatch, 'key' will be null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldQuery.SaveTerms(System.Collections.Generic.ICollection{Lucene.Net.Search.Query},Lucene.Net.Index.IndexReader)">
            <summary>
            Save the set of terms in the queries to <see cref="F:Lucene.Net.Search.VectorHighlight.FieldQuery.termSetMap"/>.
            
            <code>
            ex1) q=name:john
                 - fieldMatch==true
                     termSetMap=IDictionary&lt;"name",ISet&lt;"john"&gt;&gt;
                 - fieldMatch==false
                     termSetMap=IDictionary&lt;null,ISet&lt;"john"&gt;&gt;
            ex2) q=name:john title:manager
                 - fieldMatch==true
                     termSetMap=IDictionary&lt;"name",ISet&lt;"john"&gt;,
                                    "title",ISet&lt;"manager"&gt;&gt;
                 - fieldMatch==false
                     termSetMap=IDictionary&lt;null,ISet&lt;"john","manager"&gt;&gt;
            ex3) q=name:"john lennon"
                 - fieldMatch==true
                     termSetMap=IDictionary&lt;"name",ISet&lt;"john","lennon"&gt;&gt;
                 - fieldMatch==false
                     termSetMap=IDictionary&lt;null,ISet&lt;"john","lennon"&gt;&gt;
            </code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldQuery.GetFieldTermMap(System.String,System.String)">
            <returns>QueryPhraseMap</returns>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldQuery.SearchPhrase(System.String,System.Collections.Generic.IList{Lucene.Net.Search.VectorHighlight.FieldTermStack.TermInfo})">
            <returns>QueryPhraseMap</returns>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.FieldQuery.QueryPhraseMap">
            <summary>
            Internal structure of a query for highlighting: represents
            a nested query structure
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.FieldTermStack">
            <summary>
            <see cref="T:Lucene.Net.Search.VectorHighlight.FieldTermStack"/> is a stack that keeps query terms in the specified field
            of the document to be highlighted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldTermStack.#ctor(Lucene.Net.Index.IndexReader,System.Int32,System.String,Lucene.Net.Search.VectorHighlight.FieldQuery)">
            <summary>
            a constructor.
            </summary>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> of the index</param>
            <param name="docId">document id to be highlighted</param>
            <param name="fieldName">field of the document to be highlighted</param>
            <param name="fieldQuery"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldQuery"/> object</param>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="P:Lucene.Net.Search.VectorHighlight.FieldTermStack.FieldName">
            <summary>
            field name
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldTermStack.Pop">
            <summary>
            Returns the top <see cref="T:Lucene.Net.Search.VectorHighlight.FieldTermStack.TermInfo"/> object of the stack
            </summary>
            <returns>the top <see cref="T:Lucene.Net.Search.VectorHighlight.FieldTermStack.TermInfo"/> object of the stack</returns>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.FieldTermStack.Push(Lucene.Net.Search.VectorHighlight.FieldTermStack.TermInfo)">
            <summary>
            Puts a <see cref="T:Lucene.Net.Search.VectorHighlight.FieldTermStack.TermInfo"/> onto the top of the stack
            </summary>
            <param name="termInfo">the <see cref="T:Lucene.Net.Search.VectorHighlight.FieldTermStack.TermInfo"/> object to be put on the top of the stack</param>
        </member>
        <member name="P:Lucene.Net.Search.VectorHighlight.FieldTermStack.IsEmpty">
            <summary>
            to know whether the stack is empty. Returns true if the stack is empty, false if not
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.FieldTermStack.TermInfo">
            <summary>
            Single term with its position/offsets in the document and IDF weight.
            It is <see cref="T:System.IComparable`1"/> but considers only position.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.VectorHighlight.FieldTermStack.TermInfo.Next">
            <summary>
            Returns the next TermInfo at this same position. This is a circular list!
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.IFragListBuilder">
            <summary>
            <see cref="T:Lucene.Net.Search.VectorHighlight.IFragListBuilder"/> is an interface for <see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList"/> builder classes.
            A <see cref="T:Lucene.Net.Search.VectorHighlight.IFragListBuilder"/> class can be plugged in to <see cref="T:Lucene.Net.Search.Highlight.Highlighter"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.IFragListBuilder.CreateFieldFragList(Lucene.Net.Search.VectorHighlight.FieldPhraseList,System.Int32)">
            <summary>
            create a <see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList"/>.
            </summary>
            <param name="fieldPhraseList"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldPhraseList"/> object</param>
            <param name="fragCharSize">the length (number of chars) of a fragment</param>
            <returns>the created <see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList"/> object</returns>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder">
            <summary>
            <see cref="T:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder"/> is an interface for fragments (snippets) builder classes.
            A <see cref="T:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder"/> class can be plugged in to
            <see cref="T:Lucene.Net.Search.VectorHighlight.FastVectorHighlighter"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder.CreateFragment(Lucene.Net.Index.IndexReader,System.Int32,System.String,Lucene.Net.Search.VectorHighlight.FieldFragList)">
            <summary>
            create a fragment.
            </summary>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> of the index</param>
            <param name="docId">document id to be highlighted</param>
            <param name="fieldName">field of the document to be highlighted</param>
            <param name="fieldFragList"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList"/> object</param>
            <returns>a created fragment or null when no fragment created</returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder.CreateFragments(Lucene.Net.Index.IndexReader,System.Int32,System.String,Lucene.Net.Search.VectorHighlight.FieldFragList,System.Int32)">
            <summary>
            create multiple fragments.
            </summary>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> of the index</param>
            <param name="docId">document id to be highlighter</param>
            <param name="fieldName">field of the document to be highlighted</param>
            <param name="fieldFragList"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList"/> object</param>
            <param name="maxNumFragments">maximum number of fragments</param>
            <returns>
            created fragments or null when no fragments created.
            size of the array can be less than <paramref name="maxNumFragments"/>
            </returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder.CreateFragment(Lucene.Net.Index.IndexReader,System.Int32,System.String,Lucene.Net.Search.VectorHighlight.FieldFragList,System.String[],System.String[],Lucene.Net.Search.Highlight.IEncoder)">
            <summary>
            create a fragment.
            </summary>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> of the index</param>
            <param name="docId">document id to be highlighted</param>
            <param name="fieldName">field of the document to be highlighted</param>
            <param name="fieldFragList"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList"/> object</param>
            <param name="preTags">pre-tags to be used to highlight terms</param>
            <param name="postTags">post-tags to be used to highlight terms</param>
            <param name="encoder">an encoder that generates encoded text</param>
            <returns>a created fragment or null when no fragment created</returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.IFragmentsBuilder.CreateFragments(Lucene.Net.Index.IndexReader,System.Int32,System.String,Lucene.Net.Search.VectorHighlight.FieldFragList,System.Int32,System.String[],System.String[],Lucene.Net.Search.Highlight.IEncoder)">
            <summary>
            create multiple fragments.
            </summary>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> of the index</param>
            <param name="docId">document id to be highlighter</param>
            <param name="fieldName">field of the document to be highlighted</param>
            <param name="fieldFragList"><see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList"/> object</param>
            <param name="maxNumFragments">maximum number of fragments</param>
            <param name="preTags">pre-tags to be used to highlight terms</param>
            <param name="postTags">post-tags to be used to highlight terms</param>
            <param name="encoder">an encoder that generates encoded text</param>
            <returns>
            created fragments or null when no fragments created.
            size of the array can be less than <paramref name="maxNumFragments"/>
            </returns>
            <exception cref="T:System.IO.IOException">If there is a low-level I/O error</exception>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.ScoreOrderFragmentsBuilder">
            <summary>
            An implementation of FragmentsBuilder that outputs score-order fragments.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.ScoreOrderFragmentsBuilder.#ctor">
            <summary>
            a constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.ScoreOrderFragmentsBuilder.#ctor(System.String[],System.String[])">
            <summary>
            a constructor.
            </summary>
            <param name="preTags">array of pre-tags for markup terms.</param>
            <param name="postTags">array of post-tags for markup terms.</param>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.ScoreOrderFragmentsBuilder.GetWeightedFragInfoList(System.Collections.Generic.IList{Lucene.Net.Search.VectorHighlight.FieldFragList.WeightedFragInfo})">
            <summary>
            Sort by score the list of <see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList.WeightedFragInfo"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.ScoreOrderFragmentsBuilder.ScoreComparer">
            <summary>
            <see cref="T:System.Collections.Generic.IComparer`1"/> for <see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList.WeightedFragInfo"/> by boost, breaking ties 
            by offset.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.SimpleBoundaryScanner">
            <summary>
            Simple boundary scanner implementation that divides fragments
            based on a set of separator characters.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.SimpleFieldFragList">
            <summary>
            A simple implementation of <see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.SimpleFieldFragList.#ctor(System.Int32)">
            <summary>
            a constructor.
            </summary>
            <param name="fragCharSize">the length (number of chars) of a fragment</param>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.SimpleFieldFragList.Add(System.Int32,System.Int32,System.Collections.Generic.IList{Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo})">
            <summary>
            <seealso cref="M:Lucene.Net.Search.VectorHighlight.FieldFragList.Add(System.Int32,System.Int32,System.Collections.Generic.IList{Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo})"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.SimpleFragListBuilder">
            <summary>
            A simple implementation of <see cref="T:Lucene.Net.Search.VectorHighlight.IFragListBuilder"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.SimpleFragListBuilder.CreateFieldFragList(Lucene.Net.Search.VectorHighlight.FieldPhraseList,System.Int32)">
            <summary>
            <seealso cref="M:Lucene.Net.Search.VectorHighlight.BaseFragListBuilder.CreateFieldFragList(Lucene.Net.Search.VectorHighlight.FieldPhraseList,System.Int32)"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.SimpleFragmentsBuilder">
            <summary>
            A simple implementation of FragmentsBuilder.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.SimpleFragmentsBuilder.#ctor">
            <summary>
            a constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.SimpleFragmentsBuilder.#ctor(System.String[],System.String[])">
            <summary>
            a constructor.
            </summary>
            <param name="preTags">array of pre-tags for markup terms.</param>
            <param name="postTags">array of post-tags for markup terms.</param>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.SimpleFragmentsBuilder.GetWeightedFragInfoList(System.Collections.Generic.IList{Lucene.Net.Search.VectorHighlight.FieldFragList.WeightedFragInfo})">
            <summary>
            do nothing. return the source list.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.SingleFragListBuilder">
            <summary>
            An implementation class of <see cref="T:Lucene.Net.Search.VectorHighlight.IFragListBuilder"/> that generates one <see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList.WeightedFragInfo"/> object.
            Typical use case of this class is that you can get an entire field contents
            by using both of this class and <see cref="T:Lucene.Net.Search.VectorHighlight.SimpleFragmentsBuilder"/>.
            <para/>
            <code>
            FastVectorHighlighter h = new FastVectorHighlighter( true, true,
                new SingleFragListBuilder(), new SimpleFragmentsBuilder() );
            </code>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.WeightedFieldFragList">
            <summary>
            A weighted implementation of <see cref="T:Lucene.Net.Search.VectorHighlight.FieldFragList"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.WeightedFieldFragList.#ctor(System.Int32)">
            <summary>
            a constructor.
            </summary>
            <param name="fragCharSize">the length (number of chars) of a fragment</param>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.WeightedFieldFragList.Add(System.Int32,System.Int32,System.Collections.Generic.IList{Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo})">
            <summary>
            <seealso cref="M:Lucene.Net.Search.VectorHighlight.FieldFragList.Add(System.Int32,System.Int32,System.Collections.Generic.IList{Lucene.Net.Search.VectorHighlight.FieldPhraseList.WeightedPhraseInfo})"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.VectorHighlight.WeightedFragListBuilder">
            <summary>
            A weighted implementation of <see cref="T:Lucene.Net.Search.VectorHighlight.IFragListBuilder"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.VectorHighlight.WeightedFragListBuilder.CreateFieldFragList(Lucene.Net.Search.VectorHighlight.FieldPhraseList,System.Int32)">
            <summary>
            <seealso cref="M:Lucene.Net.Search.VectorHighlight.BaseFragListBuilder.CreateFieldFragList(Lucene.Net.Search.VectorHighlight.FieldPhraseList,System.Int32)"/>
            </summary>
        </member>
    </members>
</doc>
